/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui
'use strict';

var Promise = require('bluebird');
var apimClient = require('apiconnect-apim-client');
var authPlugin = require('apiconnect-cli-auth');
var runtimePublishPlugin = require('apiconnect-cli-apps');
var Util = require('apiconnect-cli-util');
var Config = require('apiconnect-config');
var Bluemix = require('./bluemix-handler');
var request = require('request');
var auth = require('./auth');


var projectConfig = Config.loadConfig();

function getServer() {
  return projectConfig.getOne('apim_server', Config.PROJECT_STORE);
}

function setServer(server) {
  projectConfig.set({ 'apim_server': server }, Config.PROJECT_STORE);
}

function getCreds() {
  return authPlugin.getCredentials({
    uri: 'https://' + getServer(),
    useDefaultRegion: false
  });
};

function isLoggedIn(server) {
  var isLoggedIn = auth.isLoggedIn({ host: server });

  if (isLoggedIn) {
    setServer(server);
  }

  return isLoggedIn;
}

function login(server, credentials) {
  var loginServerUri = 'apic-mgmt://' + server;
  return apim_login(loginServerUri, credentials, true)
    .then(function(res) {
      // Successful login, set server into config
      setServer(server);
      var s = getServer();
      return res;
    })
    .catch(function(err) {
      console.error('Error logging into API Connect: %s', err.message);
      if (err.message.indexOf('Invalid credentials') > -1) {
        err.statusCode = 401;
      }
      err.error = err.message;
      throw err;
    });
}

function apim_login(server, credentials, defaultOrg) {
  return authPlugin.login(credentials.login, credentials.password, {
    uri: server,
    useDefaultOrg: defaultOrg,
    useDefaultRegion: false,
    interactiveMode: false
  });
}

function listOrgs() {
  return apimClient.orgs.list({ creds: getCreds() })
    .catch(function(err) {
      console.error('exception thrown in listOrgs: %s', err.message);
      return Promise.reject({
        error: err.message
      });
    });
}

function listCatalogs(orgId, instance) {
  return apimClient.catalogs.listAll({
    organization: orgId,
    creds: getCreds(),
    server: instance
  })
    .catch(function(err) {
      err.error = err.message;
      return Promise.reject(err);
    });
}

function listApps(server, orgId) {
  return apimClient.apps.list({
    server: server,
    organization: orgId,
    creds: getCreds()
  }).catch(function(err) {
    err.error = err.message;
    throw err;
  });
}

function getMetadata(server) {
  return Util.serverMeta.getMetadata({
    host: server
  })
    .then(function(meta) {
      return {
        isBluemix: meta.isBluemix(),
        supportsTokenAuth: meta.supports('authTypes', 'token')
      };
    })
    .catch(function(err) {
      err.error = err.message;
      throw err;
    });
}

function publishRuntime(instance, options) {
  var type = options.type;
  var org_name = options.org.name;
  var app_name;
  if (type === 'onprem' || options.app.new) {
    app_name = options.app.name;
  } else {
    app_name = options.app.entity.name;
  }
  var path = options.workspaceDir.path;
  var publishOptions = {
    server: instance,
    organization: org_name,
    app: app_name,
    projectDir: path,
    fromUI: true,
    versionOptions: options.versionOptions
  };

  if (!options.catalog.none) {
    publishOptions.catalog = options.catalog.shortName;
    if (options.space && !options.space.none) {
      publishOptions.space = options.space.name;
    }
  }

  publishOptions.creds = getCreds();

  if (!publishOptions.creds) {
    return Promise.reject({
      statusCode: 401,
      error: {
        noLoginCredentials: 'No login credentials for API Connect were found. Please logout and try again.'
      }
    });
  }

  if (options.defaultTarget) {
    var orgGuid = options.org.externalNativeOrgId;
    var spaceGuid = options.org.externalSpaceId;
    return Promise.join(runtimePublishPlugin.deployProject(publishOptions), Bluemix.provision(instance, orgGuid, spaceGuid));
  }

  return runtimePublishPlugin.deployProject(publishOptions)
    .then(function(resp) {
      if (options.defaultTarget) {
        resp = resp[0];
      }
      if (options.type === 'bluemix') {
        return updateRuntimeTargetFile(options, resp);
      }
    })
    .catch(function(error) {
      console.error('Error publishing runtime: %s', error.message);
      if (error.message.indexOf('Invalid credentials') > -1) {
        error.statusCode = 401;
      }
      if (!error.error) {
        error.error = 'Error publishing runtime: ' + error.message;
      }
      throw error;
    });
}

function updateRuntimeTargetFile(targetDoc, runtimeResp) {
  targetDoc.app = {
    metadata: {
      guid: runtimeResp.runtimeAppId
    },
    entity: runtimeResp.extendedStatus.body
  };
  var opts = {
    url: {
      protocol: 'http:',
      hostname: process.env.HOST || '127.0.0.1',
      port: process.env.PORT || 9000,
      path: '/proxy/orgs/localhost/targets'
    },
    method: 'PUT',
    json: true,
    body: targetDoc
  };
  return new Promise(function(resolve, reject) {
    request(opts, function(err, response) {
      if (err) {
        console.error('Error updating target file: %s', err.message);
        err.error = 'Error updating target file: ' + err.message;
        reject(err);
      }

      resolve(response);
    });
  });
}

function publishProducts(instance, options) {
  var products = options.products;
  var org_name = options.org.name;
  var catalog_name = options.catalog.shortName;
  var publishOptions = {
    organization: org_name,
    catalog: catalog_name,
    server: instance
  };
  if (options.space) {
    publishOptions.space = options.space.name;
  }
  if (options.productStageOnly) {
    publishOptions.stage = true;
  }

  console.log('Found %d files to publish.', products.length);
  if (products.length === 0) {
    return Promise.reject({
      statusCode: 400,
      error: {
        noProducts: 'No products were found to publish'
      }
    });
  }

  var loginServerUri = 'apic-mgmt://' + instance + '/organizations/' + org_name;

  return getMetadata(instance)
    .then(function(meta) {
      var credentials = getCreds();

      publishOptions.creds = credentials;

      if (meta.isBluemix && meta.supportsTokenAuth) {
        return Promise.resolve();
      } else {
        if (!credentials) {
          return Promise.reject({
            statusCode: 401,
            error: {
              noLoginCredentials: 'No login credentials for API Connect were found. Please logout and try again.'
            }
          });
        }
        // why are we logging in again?
        return apim_login(loginServerUri, credentials, false)
      }
    })
    .then(function() {
      return Promise.mapSeries(products, function(product) {
        var action = publishOptions.stage ? 'stage' : 'publish';
        return apimClient.products[action](Object.assign({
          filename: product.file
        }, publishOptions));
      })
        .then(function(res) {
          // Do we want to continue to log stuff to console??
          console.log('Successfully published products');
          return res;
        })
        .catch(function(err) {
          console.error('Error during products publish: %s', err.message);
          err.error = err.message;
          throw err;
        });
    });
}

module.exports = {
  isLoggedIn: isLoggedIn,
  login: login,
  listOrgs: listOrgs,
  listCatalogs: listCatalogs,
  listApps: listApps,
  publishRuntime: publishRuntime,
  publishProducts: publishProducts,
  getMetadata: getMetadata
};
