/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui
'use strict';

var fs = require('fs');
var glob = require('glob');
var js2yaml = require('js-yaml');
var netrc = require('netrc');
var https = require('https');
var async = require('async');
var uuid = require('uuid');
var util = require('../common/util.js');
var request = require('request');
var configParser = require('apiconnect-config');
var Promise = require('bluebird');
var pathM = require('path');
var projectInspector = require('apiconnect-project');
var osenv = require('osenv');
var debug = require('debug')('apim-ui:registry');
var formidable = require('formidable');
var url = require('url');
var apicWsdl = require('apiconnect-wsdl');
var _ = require('lodash');
var refs = require('apiconnect-refs');
var auth = require('../common/auth');
var configToDP = require('apiconnect-config-to-datapower');

// this is used to store the host the server was started on for use in localRegistry handlers
var gatewayHost = 'localhost';
exports.setGatewayHost = function(addr) {
  gatewayHost = addr;
};

function getProjectArtifacts(){
  // TODO -- apiconnect-project glob needs to be updated to search for extensions other than just .yaml
  var workspaceDir = getWorkspaceDir();
  return projectInspector.loadProject(getWorkspaceDir());
}

function getDefinitionsDir(){
  var workspaceDir = getWorkspaceDir();
  var config = projectInspector.inspectPath(workspaceDir);
  var definitionsDir;

  if (config.type === 'project' ) {
    //is loopback project, look in ./definitions
    definitionsDir = config.basePath+'/definitions';
  } else {
    //non-loopback project, use basePath;
    definitionsDir = config.basePath;
  }

  return definitionsDir;
}

var getWorkspaceDir = function(){
  return process.env.WORKSPACE_DIR || process.cwd();
};

var getConfigDir = function(){
  return process.env.CONFIG_DIR || process.cwd();
};

var getSwaggerFileLocal = function(path, relative) {
  if (!relative) {
    relative = getWorkspaceDir();
  }

  var resolvePath = pathM.relative(relative, path);
  var baseName = pathM.basename(path);

  if (path === baseName || resolvePath === './' + path) {
    resolvePath = baseName;
  }

  return resolvePath;
};

var getMe = function (req, res) {
  auth.hasInternetConnectivity().then(function(isOnline) {

    auth.isLoggedIn({
      tokenOnly: true
    })
      .then(function(status) {
        var hostname = auth.getDefaultHost();

        getTokenData(hostname)
          .then(function(token){
            token = token || {};
            var email = token.emails && token.emails.length ? token.emails[0].value : '';
            var username = token.username || '';
            var displayName = token.displayName || '';
            var accountId = token.id || '';
            var provider = token.provider || '';
            var exp = token.exp || '';

            var data = {
              name: osenv.user(),
              username: username,
              displayName: displayName,
              email: email,
              accountId: accountId,
              provider: provider,
              exp: exp
            };

            if (isOnline && !status.loggedIn && !process.env.SKIP_LOGIN){
              return res.redirect('/login.html');
            }

            if (status.expiration){
              data.expiration = status.expiration;
            }

            res.statusCode = 200;
            res.setHeader('Content-Type', 'application/json');
            res.end(JSON.stringify(data));
          });
    });
  });
};

var getTokenData = function(hostname){
  var BluemixLogin = require('apiconnect-cli-login-bluemix');
  var bluemixLogin = new BluemixLogin(hostname);

  return bluemixLogin.decryptedToken();
};

var getPermissions = function (req, res) {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify({
    permissions: [
      {resource: 'org_members', actions: ['view', 'manage']},
      {resource: 'org_organizationManagement', actions: ['view', 'manage']},
      {resource: 'org_draftApis', actions: ['view', 'edit']},
      {resource: 'org_draftProducts', actions: ['view', 'edit']},
      {resource: 'org_catalogs', actions: ['view', 'manage']}
    ],
    environments: [{
      id: '5613bb29e4b0f1c02745a0dc',
      shortName: 'sb',
      name: 'Sandbox',
      sandbox: true,
      permissions: [
        {resource: 'catalog_catalogSettings', actions: ['view', 'manage'], type: 'environment'},
        {resource: 'catalog_productDeploymentApproval', actions: ['view', 'stage', 'publish', 'deprecate', 'retire', 'replace', 'supercede', 'setMigrationTarget'], type: 'environment'},
        {resource: 'catalog_environmentAnalytics', actions: ['view'], type: 'environment'},
        {resource: 'catalog_planSubscriptions', actions: ['view', 'manage'], type: 'environment'},
        {resource: 'catalog_developers', actions: ['view', 'manage'], type: 'environment'},
        {resource: 'catalog_members', actions: ['view', 'manage'], type: 'environment'},
        {resource: 'catalog_subscriptionApproval', actions: ['view', 'manage'], type: 'environment'},
        {resource: 'catalog_productDeployment', actions: ['stage', 'view', 'manage'], type: 'environment'},
        {resource: 'catalog_applications', actions: ['view', 'manage'], type: 'environment'}
      ]
    }]
  }));
};

var getEnvironments = function (req, res) {
  var environments = [];
  var myNetrc = netrc();
  async.each(Object.keys(myNetrc), function (hostname, outerCallback) {
    var details = myNetrc[hostname];
    var authHeader = ('Basic ' +
      new Buffer(details.login + ': ' + details.password).toString('base64'));
    https.get({
      host: hostname,
      path: '/v1/me/orgs',
      method: 'GET',
      headers: {Authorization: authHeader}
    }, function (response) {
      var orgsString = '';
      response.on('data', function (chunk) {
        orgsString += chunk;
      });
      response.on('end', function () {
        var orgs = JSON.parse(orgsString);
        async.each(orgs, function (org, innerCallback) {
          https.get({
            host: hostname,
            path: '/v1/orgs/' + org.id + '/environments',
            method: 'GET',
            headers: {Authorization: authHeader}
          }, function (response) {
            var envsString = '';
            response.on('data', function (chunk) {
              envsString += chunk;
            });
            response.on('end', function () {
              var envs = JSON.parse(envsString);
              environments = environments.concat(envs);
              innerCallback();
            });
          });
        }, function (err) {
          outerCallback(err);
        });
      });
    });
  }, function (err) {
    if (err) {
      res.statusCode = 500;
      res.end(err);
      return;
    }
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(environments));
  });
};

var getDeployedProducts = function (req, res) {
  var deployedProducts = [];
  var myNetrc = netrc();
  async.each(Object.keys(myNetrc), function (hostname, outerCallback) {
    var details = myNetrc[hostname];
    var authHeader = 'Basic ' +
      new Buffer(details.login + ': ' + details.password).toString('base64');
    https.get({
      host: hostname,
      path: '/v1/me/orgs',
      method: 'GET',
      headers: {Authorization: authHeader}
    }, function (response) {
      var orgsString = '';
      response.on('data', function (chunk) {
        orgsString += chunk;
      });
      response.on('end', function () {
        var orgs = JSON.parse(orgsString);
        async.each(orgs, function (org, innerCallback) {
          https.get({
            host: hostname,
            path: '/v1/orgs/' + org.id + '/environments/products',
            method: 'GET',
            headers: {Authorization: authHeader}
          }, function (response) {
            var deployedProductsString = '';
            response.on('data', function (chunk) {
              deployedProductsString += chunk;
            });
            response.on('end', function () {
              var deployedProds = JSON.parse(deployedProductsString);
              deployedProducts = deployedProducts.concat(deployedProds);
              innerCallback();
            });
          });
        }, function (err) {
          outerCallback(err);
        });
      });
    });
  }, function (err) {
    if (err) {
      res.statusCode = 500;
      res.end(err);
      return;
    }
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(deployedProducts));
  });
};

var getOrgs = function (req, res) {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify([{
    id: 'localhost',
    name: 'localhost',
    displayName: 'Local Organization'
  }]));
};

var getTemplates = function(req, res) {

  var workspaceDir = getWorkspaceDir();
  var projectInfo = projectInspector.inspectPath(workspaceDir);

  var config = configParser.loadConfig({
    projectDir: projectInfo.basePath,
    shouldParseUris: false
  });

  var templateInfo = {
    defaults: {},
    templates: {}
  };

  if (config.get('template-default-api')['template-default-api']) {
    templateInfo.defaults.api = config.get('template-default-api')['template-default-api'];
  }

  if (config.get('template-default-product')['template-default-product']) {
    templateInfo.defaults.product = config.get('template-default-product')['template-default-product'];
  }

  if (config.get('template-path')['template-path']) {
    glob(config.get('template-path')['template-path'] + '/*.hbs', function(er, files) {
        files = files.map(function(file) {
          return pathM.resolve(file);
        });
        files.forEach(function(file) {
          templateInfo.templates[file] = fs.readFileSync(file, "utf8");
        });
        res.statusCode = 200;
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(templateInfo));
    });
  } else {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(templateInfo));
  }

};

var getComponents = function(req, res) {
  var defsDir = getDefinitionsDir();
  getProjectArtifacts()
    .then(function(artifacts){
      var components = [];
      artifacts.forEach(function (artifact) {
        var doc = artifact.data;
        var filter = req.query.filter;
        if (filter) filter = filter.toLowerCase();
        if (doc && doc.component === '1.0.0') {
          if (filter && filter.length > 0) {
            if (doc.info.title.toLowerCase().indexOf(filter) < 0 &&
              (!doc.info.name || doc.info.name.toLowerCase().indexOf(filter) < 0) &&
              doc.info.version.toLowerCase().indexOf(filter) < 0) {
                return;
            }
          }
          components.push({
            info: doc.info,
            updatedAt: artifact.mtime,
            file: pathM.relative(defsDir, artifact.filePath)
          });
        }
      });
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('X-Total-Count', components.length);
      res.end(JSON.stringify(components));
    })
    .catch(function(err){
      res.statusCode = 500;
      res.end(JSON.stringify(err));
      return;
    });
};

var getComponent = function(req, res) {
  getProjectArtifacts()
    .then(function(artifacts){
      var component, file;
      var ref = localApiRegistry.getComponent.regex.exec(req.url)[1];
      // TODO - why are we double-encoding??
      ref = decodeURI(decodeURI(ref));
      artifacts.forEach(function (artifact) {
        var doc = artifact.data;
        if (doc &&
          doc.component === '1.0.0' &&
          doc.info &&
          (ref === doc.info.name + ":" + doc.info.version ||
          ref === doc.info.title + ":" + doc.info.version)) {
          component = doc;
          file = artifact.filePath;
        }
      });
      if (!component) {
        var fnfError = {
          error: {
            message: "Component not found: " + ref
          }
        };
        res.statusCode = 404;
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(fnfError));
        return;
      }
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.setHeader("X-IBM-Component-File", getSwaggerFileLocal(file));
      res.end(JSON.stringify(component));
    })
    .catch(function(err){
      res.statusCode = 500;
      res.end(JSON.stringify(err));
      return;
    });
};

var saveComponent = function (req, res) {
  var fileName = req.headers['x-ibm-component-file'];
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }
  var json = req.body;
  var yaml;
  try {
    yaml = js2yaml.safeDump(json);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!yaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, yaml);
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('X-IBM-Component-File', fileName);
  res.end(JSON.stringify(json));
};

var deleteComponent = function(req, res) {
  var fileName = pathM.resolve(pathM.join(
    getDefinitionsDir(), req.headers["x-ibm-component-file"]
  ));
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }

  // sanity check
  var workspaceDir = getWorkspaceDir();
  if (!fileName.startsWith(workspaceDir)) {
    res.statusCode = 404;
    res.end();
    return;
  }

  fs.unlink(fileName);
  res.statusCode = 200;
  res.end();
};

var createComponent = function(req, res) {
  var componentJson = req.body;
  var workspaceDir = getWorkspaceDir();
  var definitionsDir = getDefinitionsDir();
  var dir = definitionsDir;
  if (!fs.existsSync(dir)) {
  	fs.mkdirSync(dir);
  }
  var fileName = dir + "/" + componentJson.info.name + "_" + componentJson.info.version + ".yaml";
  var i = 1;
  while (fileExists(fileName)) {
    fileName = dir + "/" + componentJson.info.name + "_" + componentJson.info.version + "_" + i + ".yaml";
    i++;
  }
  var componentYaml;
  try {
    componentYaml = js2yaml.safeDump(componentJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!componentYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, componentYaml);
  res.statusCode = 200;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Component-File", fileName.replace(workspaceDir, "."));
  res.end(JSON.stringify(componentJson));
};

var getComponentReferences = function(req, res) {
  var properties = ["definitions", "parameters", "assemblies"];
  var defsDir = getDefinitionsDir();
  getProjectArtifacts()
    .then(function(artifacts){
      var items = {};
      artifacts.forEach(function (artifact) {
        var doc = artifact.data;
        if (doc && doc.component === '1.0.0') {
          var file = pathM.relative(defsDir, artifact.filePath);
          properties.forEach(function(property) {
            if (!doc[property]) return;
            Object.keys(doc[property]).forEach(function(itemName) {
              if (!items[property]) items[property] = {};
              items[property][file + "#/" + property + "/" + itemName] = doc[property][itemName];
            });
          });
        }
      });
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(items));
    })
    .catch(function(err){
      console.error(err);
      res.statusCode = 500;
      res.end(JSON.stringify(err));
      return;
    });
};

var getReferences = function(req, res) {
	var document = req.body;
  var defsDir = getDefinitionsDir();
  refs.findReferences(document, {
        includeInvalid: true,
        options: {
            relativeBase: defsDir
        }
    }).then(function(response) {
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(response));
  });
};

var getRunningApis = function(req, res) {
  // first up, look for the datastore port. If found, try that out.
  // else, fall back to draft APIs.
  // either way, set a header so the caller knows what content is coming back
  var configDir = getWorkspaceDir();

  fs.readFile(configDir + pathM.sep + '.datastore', 'utf8', function (err, data) {
    var config = null;
    if (err) {
      // ok, so no datastore then
      console.error(err);
      res.statusCode = 500;
      res.end(JSON.stringify({error: {message: "Unable to find the server to retrieve running APIs."}}));
      return;
    }
    try {
      config = JSON.parse(data);
    } catch(err) {
      console.error(err);
      res.statusCode = 500;
      res.end(JSON.stringify({error: {message: "Unable to read data from the server to retrieve running APIs."}}));
      return;
    }
    if (config.datapower) {
      gatewayHost = config.host;
    }
    request.get('http://' + gatewayHost + ':' + config.port + '/api/apis', function(err, res1, body) {
      if (err) {
        console.error(err);
        res.statusCode = 500;
        res.end(JSON.stringify({error: {message: "Received an error from the server while retrieving running APIs."}}));
      } else {
        var apis = [];
        if (typeof body == "string") body = JSON.parse(body);
        body.forEach(function(api) {
          if (api.document) apis.push(api.document);
        });
        res.statusCode = 200;
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('X-Total-Count', apis.length);
        res.setHeader('X-IBM-Datastore', true);
        res.end(JSON.stringify(apis));
      }
    });
  });
};

var getApis = function(req, res, fullContent) {
  var defsDir = getDefinitionsDir();
	getWorkspaceDir();
    getProjectArtifacts()
      .then(function(artifacts){
        var apis = [];
        artifacts.forEach(function (artifact) {
          var doc = artifact.data;
          var filter = req.query.filter;
          if (filter) filter = filter.toLowerCase();
          if (doc && (doc.swagger === '2.0' || doc.swagger === 2.0)) {
            if (filter && filter.length > 0) {
              if (doc.info.title.toLowerCase().indexOf(filter) < 0 &&
                (!doc.info['x-ibm-name'] || doc.info['x-ibm-name'].toLowerCase().indexOf(filter) < 0) &&
                doc.info.version.toLowerCase().indexOf(filter) < 0) {
                  return;
              }
            }
            if (fullContent) {
              apis.push(doc);
            } else {
              var protocol = (doc['x-ibm-configuration'] && doc['x-ibm-configuration'].type) ? doc['x-ibm-configuration'].type : "rest";
              if (protocol == "wsdl") {
            	  protocol = "soap";
              }
              apis.push({
                info: doc.info,
                updatedAt: artifact.mtime,
                protocol: protocol,
                file: pathM.relative(defsDir, artifact.filePath)
              });
            }
          }
        });
        res.statusCode = 200;
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('X-Total-Count', apis.length);
        res.end(JSON.stringify(apis));
      })
      .catch(function(err){
        res.statusCode = 500;
        res.end(err);
        return;
      });
};

var uploadApi = function(req, res) {
	if (req.body.url) {
		// fetch yaml from URL
	    var options = {
	    	url: req.body.url,
			method: 'GET'
	    };
	    if (req.body.headers && req.body.headers["Authorization"]) {
	    	// note: the auth header arrives as an array
	    	var authArray = req.body.headers["Authorization"];
	    	var authHeader = authArray[0];
	    	options.headers = {
	    		Authorization: authHeader
	    	};
	    }
		request(options, function (error, response, body) {
			if (error) {
				res.statusCode = 500;
			    res.setHeader('Content-Type', 'application/json');
	    	    res.end(JSON.stringify({error: {message: "Code: " + error.code}}));
			} else {
				try {
		            var doc = js2yaml.safeLoad(body);
		            // work out filename from the URL
		            var parsed = url.parse(req.body.url);
		            var slash = parsed.pathname.lastIndexOf('/');
		            var rawFile = parsed.pathname.substr(slash + 1);
		            if (!rawFile) {
		            	// unable to get file from URL - use a UUID to avoid clashes
		            	rawFile = uuid.v4();
		            }
		            var fileName = rawFile;
		            var dot = rawFile.lastIndexOf('.');
		            if (dot != -1) {
		            	var extension = rawFile.substr(dot + 1).toLowerCase();
		            	if (extension != "yaml" && extension != "yml") {
		            		// switch extension to yaml
		            		fileName = rawFile.substring(0, dot) + ".yaml";
		            	}
		            } else {
		            	// no extension of original file - just add yaml
		            	fileName = rawFile + ".yaml";
		            }
					var swaggerYaml;
					try {
						swaggerYaml = js2yaml.safeDump(doc);
					} catch (e) {
						console.log(e);
						res.statusCode = 400;
						res.end();
						return;
					}
					if (!swaggerYaml) {
						res.statusCode = 400;
						res.end();
						return;
          }
          var baseDir = getDefinitionsDir();
          fileName = pathM.join(baseDir, fileName)
					fs.writeFileSync(fileName, swaggerYaml);
		    	    res.statusCode = 201;
		    	    res.setHeader('Content-Type', 'application/json');
		    	    res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(fileName, getDefinitionsDir()));
		    	    res.end(JSON.stringify(doc));
				} catch (err) {
		        	res.status(err.statusCode || 500).send(util.packageError(err.error));
				}
			}
		});
	} else {
		// fetch yaml from supplied file upload
		var form = new formidable.IncomingForm();
		form.parse(req, function(err, fields, files) {
	        try {
	            var doc = js2yaml.safeLoad(fs.readFileSync(files.file.path, 'utf8'));
	            // work out filename from the one supplied
	            var rawFile = files.file.name;
	            var fileName = rawFile;
	            var dot = rawFile.lastIndexOf('.');
	            if (dot != -1) {
	            	var extension = rawFile.substr(dot + 1).toLowerCase();
	            	if (extension != "yaml" && extension != "yml") {
	            		// switch extension to yaml
	            		fileName = rawFile.substring(0, dot) + ".yaml";
	            	}
	            } else {
	            	// no extension of original file - just add yaml
	            	fileName = rawFile + ".yaml";
	            }
				var swaggerYaml;
				try {
					swaggerYaml = js2yaml.safeDump(doc);
				} catch (e) {
					console.log(e);
					res.statusCode = 400;
					res.end();
					return;
				}
				if (!swaggerYaml) {
					res.statusCode = 400;
					res.end();
					return;
        }
        var baseDir = getDefinitionsDir();
        fileName = pathM.join(baseDir, fileName)
				fs.writeFileSync(fileName, swaggerYaml);
	    	    res.statusCode = 201;
	    	    res.setHeader('Content-Type', 'application/json');
	    	    res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(fileName, getDefinitionsDir()));
	    	    res.end(JSON.stringify(doc));
	        } catch (error) {
	        	res.status(error.statusCode || 500).send(util.packageError(error.error));
	        }
		});
	}
};

var uploadWSDL = function(req, res) {
	if (req.body.wsdlUrl) {
		// fetch yaml from URL
		try {
      var location = req.body.wsdlUrl;
      var parsedUrl = url.parse(location);
      var filename = pathM.basename(parsedUrl.pathname);
      var def = apicWsdl.getJsonForWSDL(location, req.body.basicAuth)
        .then(function (allWSDLs) {
          var xml = allWSDLs[0].doc.xml;
          filename = pathM.join(getDefinitionsDir(), filename);
          fs.writeFileSync(filename, xml);
          handleWSDLUpload(filename, req, res);
        }, function (error) {
          var err = {
            error: {
              message: 'Unexpected error processing WSDL file: ' + location + ' Error: ' + error.message
            }
          };
          res.statusCode = 400;
          res.setHeader('Content-Type', 'application/json');
          res.end(JSON.stringify(err));
        });
		} catch (error) {
			var err = {
					error: {
						message: 'Unexpected error reading WSDL file: ' + req.body.wsdlUrl + ' Error: ' + error.message
					}
			};
			res.statusCode = 400;
			res.setHeader('Content-Type', 'application/json');
			res.end(JSON.stringify(err));
		}
  } else {
    // fetch WSDL from supplied file upload
    var fileName;
    try {
      var form = new formidable.IncomingForm();
      form.parse(req, function (err, fields, files) {
        fileName = files.file.name;
        var xml = fs.readFileSync(files.file.path);
        // immediately write out the WSDL file
        fs.writeFileSync(files.file.name, xml);
        handleWSDLUpload(files.file.name, req, res);
      });
    } catch (error) {
      var message = 'Unexpected error reading WSDL file: ';
      message += fileName ? ': ' + fileName : '';
      message += '. Error: ' + error.message;
      var wsdlErr = {
        error: {
          message: 'Unexpected error reading WSDL file. Error: ' + error.message
        }
      };
      res.statusCode = 400;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(wsdlErr));
    }
  }
};

var handleWSDLUpload = function(filename, req, res) {
  var xml = fs.readFileSync(filename);
  var wsdlId = util.base64EncodeURL(filename);
  var localUrl = req.url;
  var index = localUrl.indexOf('?');
  if (index != -1) {
    localUrl = localUrl.substring(0, index);
  }
  // generate response data
  var responseData = {
    name: filename,
    url: localUrl + '/' + wsdlId,
    wsdlId: wsdlId
  };
  res.statusCode = 201;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify(responseData));
}

/**
* Get the swagger.definitions for the xsd file(s) in the request
*/
var uploadXSDDefinitions = function(req, res) {

	if (req.body.xsdUrl) {
		try {
      // The request is from a url
      var location = req.body.xsdUrl;
      var parsedUrl = url.parse(location);
      var filename = pathM.basename(parsedUrl.pathname);

      apicWsdl.getDefinitionsForXSD(location, req.body.basicAuth).then (function (definitions) {
          res.statusCode = 200;
          res.setHeader('Content-Type', 'application/json');
          try {
            var defString = JSON.stringify(definitions);
            var responseData = {
              definitions: defString
            };
            res.end(JSON.stringify(responseData));
          }
          catch(e) {
            res.statusCode = 400;
            var wsdlErr = {
              error: {
                message: 'Unexpected error processing schema.  Error: ' + e.message
              }
            };
            res.end(JSON.stringify(wsdlErr));
          };
        }, function (error) {
          var err = {
            error: {
              message: 'Unexpected error processing XSD file: ' + location + ' Error: ' + error.message
            }
          };
          res.statusCode = 400;
          res.setHeader('Content-Type', 'application/json');
          res.end(JSON.stringify(err));
        });
		} catch (error) {

			var err = {
					error: {
						message: 'Unexpected error reading WSDL file. ' + req.body.wsdlUrl + ' Error: ' + error.message
					}
			};
			res.statusCode = 400;
			res.setHeader('Content-Type', 'application/json');
			res.end(JSON.stringify(err));
		}
  } else {
    // fetch XSD definitions from supplied file upload
    try {
      res.setHeader('Content-Type', 'application/json');
      var form = new formidable.IncomingForm();
      form.parse(req, function (err, fields, files) {
        // Read file and pass the xml object directly to the parser
        var xml;
        try {
          xml = fs.readFileSync(files.file.path);
        } catch (e) {
          res.statusCode = 400;
          var wsdlErr = {
            error: {
              message: 'Unexpected error reading file.  Error: ' + e.message
            }
          };
          res.end(JSON.stringify(wsdlErr));
        }
        apicWsdl.getDefinitionsForXSD("MEMORY", { "data": xml }).then (function (definitions) {
            res.statusCode = 200;
            try {
              var defString = JSON.stringify(definitions);
              var responseData = {
        					definitions: defString
        			};
              res.end(JSON.stringify(responseData));
            }
            catch(e) {
              res.statusCode = 400;
              var wsdlErr = {
                error: {
                  message: 'Unexpected error processing schema.  Error: ' + e.message
                }
              };
              res.end(JSON.stringify(wsdlErr));
            };
          }, function (error) {
            var wsdlErr = {
              error: {
                message: 'Unexpected error processing schema.  Error: ' + error.message
              }
            };
            res.statusCode = 400;
            res.end(JSON.stringify(wsdlErr));
          });
      });
    } catch (error) {
      res.statusCode = 400;
      var wsdlErr = {
        error: {
          message: 'Unexpected error processing schema.  Error: ' + error.message
        }
      };
      res.end(JSON.stringify(wsdlErr));
    }
  }

};


var getConnectionData = function(req, res) {
	var registryType = localApiRegistry.registryDiscovery.regex.exec(req.url)[1];
	registryType = registryType.toLowerCase();
	var responseData = {
		indentifier: "uri",
		label: "name",
		items: []
	};
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(responseData));
};

var getWSDL = function(req, res) {
	var localUrl = req.url;
	if (localUrl.endsWith("&preview=true")) {
		localUrl = localUrl.substr(0, localUrl.length - 13);
	}
	var wsdlId = localApiRegistry.getWSDL.regex.exec(localUrl)[1];
	var wsdlFilename = util.base64DecodeURL(wsdlId);
	try {
		var def = apicWsdl.getJsonForWSDL(wsdlFilename);
		def.then(function(allWSDLs) {
			var serviceData = apicWsdl.getWSDLServices(allWSDLs, wsdlFilename);
			var responseData = {
					services: serviceData.services,
					wsdlId: wsdlId
			};
			res.statusCode = 200;
			res.setHeader('Content-Type', 'application/json');
			res.end(JSON.stringify(responseData));
		}, function(error) {
			var err = {
					error: {
						message: "Unexpected error processing WSDL file: " + wsdlFilename + " Error: " + error.message
					}
			};
			res.statusCode = 400;
			res.setHeader('Content-Type', 'application/json');
			res.end(JSON.stringify(err));
		});
	} catch (error) {
		var err = {
				error: {
					message: "Unexpected error reading WSDL file: " + wsdlFilename + " Error: " + error.message
				}
		};
		res.statusCode = 400;
		res.setHeader('Content-Type', 'application/json');
		res.end(JSON.stringify(err));
	}
};

var createWSDLApi = function(req, res) {
	var requestJson = req.body;
	if (requestJson.protocol && requestJson.protocol == "SOAP" && requestJson.soapApiDefinition) {
		try {
			// fetch WSDL content from given ID
			var wsdlFilename = null;
			var wsdlId = requestJson.soapApiDefinition.wsdlId;
			if (!wsdlId) {
				// might well be a URL instead
				wsdlId = requestJson.soapApiDefinition.wsdlUrl;
				wsdlFilename = wsdlId;
			} else {
				wsdlFilename = util.base64DecodeURL(wsdlId);
			}
			var serviceName = requestJson.soapApiDefinition.services[0].service;
			var serviceFilename = requestJson.soapApiDefinition.services[0].filename;
			var auth = null;
			if (requestJson.soapApiDefinition.username) {
				auth = "Basic " + new Buffer(requestJson.soapApiDefinition.username + ":" + requestJson.soapApiDefinition.password).toString('base64');
			}
			var def = apicWsdl.getJsonForWSDL(wsdlFilename, auth);
			def.then(function(allWSDLs) {
				try {
					// generate the matching swagger
					var wsdlEntry = apicWsdl.findWSDLForServiceName(allWSDLs, serviceName, serviceFilename);
					var swagger = apicWsdl.getSwaggerForService(wsdlEntry, serviceName, wsdlFilename);
					var dir = getDefinitionsDir();
					if (!fs.existsSync(dir)) {
						fs.mkdirSync(dir);
					}
					var fileName = dir + "/" + swagger.info['x-ibm-name'] + "_" + swagger.info.version + ".yaml";
					var i = 1;
					while (fileExists(fileName)) {
						fileName = dir + "/" + swagger.info['x-ibm-name'] + "_" + swagger.info.version + "_" + i + ".yaml";
						i++;
					}
					if (req.url.indexOf("preview=true") == -1) {
						var apiYaml;
						apiYaml = js2yaml.safeDump(swagger);
						if (!apiYaml) {
							res.statusCode = 400;
							res.end();
							return;
						}
						fs.writeFileSync(fileName, apiYaml);
					}
					var responseData = {
						basePath: swagger.basePath,
						description: "",
						id: wsdlId,
						name: swagger.info["x-ibm-name"],
						protocol: "SOAP",
						swagger: JSON.stringify(swagger),
						title: swagger.info.title,
						url: getSwaggerFileLocal(fileName, dir),
						version: swagger.info.version
					};
					var response = [];
					response.push(responseData);
					res.statusCode = 200;
					res.setHeader("Content-Type", "application/json");
				    res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(fileName, dir));
					res.end(JSON.stringify(response));
				} catch (e2) {
					var err = {
						error: {
							message: e2.message
						}
					};
					res.statusCode = 400;
					res.setHeader('Content-Type', 'application/json');
					res.end(JSON.stringify(err));
					return;
				}
			}, function(error) {
				var err = {
					error: {
						message: error.message
					}
				};
				res.statusCode = 400;
				res.setHeader('Content-Type', 'application/json');
				res.end(JSON.stringify(err));
				return;
			});
		} catch (e) {
			var err = {
				error: {
					message: e.message ? e.message : "Unable to open file for processing."
				}
			};
			res.statusCode = 400;
			res.setHeader('Content-Type', 'application/json');
			res.end(JSON.stringify(err));
			return;
		}
	} else {
		var soapErr = {
			error: {
				message: "Not a valid SOAP request"
			}
		};
		res.statusCode = 400;
		res.setHeader('Content-Type', 'application/json');
		res.end(JSON.stringify(soapErr));
	}
};

var getApi = function(req, res) {
  getProjectArtifacts()
    .then(function(artifacts){
      var apiRef = localApiRegistry.api.regex.exec(req.url)[1];
      // TODO - why are we double-encoding??
      apiRef = decodeURI(decodeURI(apiRef));

      var api = null;
      var file = null;
      var i = 0;
      while (!api && i < artifacts.length) {
        var doc = artifacts[i].data;
        file = artifacts[0].filePath;
        if (
          doc && doc.info &&
          (doc.swagger === '2.0' || doc.swagger === 2.0) &&
          (
            apiRef === doc.info['x-ibm-name'] + ":" + doc.info.version ||
            apiRef === doc.info.title + ":" + doc.info.version
          )
        ) {
          api = doc;
          file = artifacts[i].filePath;
        }
        i++;
      }
      if (!api) {
        var fnfError = {
          error: {
            message: "API not found: " + apiRef
          }
        };
        res.statusCode = 404;
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(fnfError));
        return;
      }
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(file));
      res.end(JSON.stringify(api));
    })
    .catch(function(err){
      res.statusCode = 500;
      res.end(err);
      return;
    });
};

var saveApi = function (req, res) {
  var fileName = req.headers['x-ibm-swagger-file'];
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }
  var swaggerJson = req.body;
  var swaggerYaml;
  try {
    swaggerYaml = js2yaml.safeDump(swaggerJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!swaggerYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(pathM.join(getWorkspaceDir(), fileName), swaggerYaml);
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(fileName, getDefinitionsDir()));
  res.end(JSON.stringify(swaggerJson));
};

var saveApiVersion = function (req, res) {
  var fileName = req.headers['x-ibm-swagger-file'];
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }
  var swaggerJson = req.body;
  var swaggerYaml;
  try {
    swaggerYaml = js2yaml.safeDump(swaggerJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!swaggerYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(pathM.join(getWorkspaceDir(), fileName), swaggerYaml);
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(fileName, getDefinitionsDir()));
  res.end(JSON.stringify(swaggerJson));
};

var deleteApi = function(req, res) {
  var defDir = getDefinitionsDir();

  try {
    var fileName = req.headers['x-ibm-swagger-file'];
    if (!fileName) {
      throw new Error('filename must not be blank');
    }

    var filePath;
    if (
      fileName.replace(/^\//, '').split('/').shift() ===
      defDir.split('/').pop()
    ) {
      filePath = pathM.resolve(defDir.replace(defDir.split('/').pop(), fileName));
    }
    else {
      filePath = pathM.resolve(defDir, fileName);
    }

    if (!filePath || !filePath.startsWith(getWorkspaceDir())) {
      throw new Error(fileName + ': file is not in the workspace directory');
    }

    fs.unlinkSync(filePath);
    res.statusCode = 200;
    res.end();
  } catch (e) {
    debug('unable to delete API', e);

    res.statusCode = e.code === 'ENOENT' ? 404 : 400;
    res.send(JSON.stringify({
      error: e.message
    }));

    res.end();
  }
};

var createApi = function(req, res) {
  var apiJson = req.body;
  if (!apiJson.swagger) apiJson.swagger = "2.0";
  var dir = getDefinitionsDir();
  if (!fs.existsSync(dir)) {
  	fs.mkdirSync(dir);
  }
  var fileName = dir + "/" + apiJson.info['x-ibm-name'] + "_" + apiJson.info.version + ".yaml";
  var i = 1;
  while (fileExists(fileName)) {
    fileName = dir + "/" + apiJson.info['x-ibm-name'] + "_" + apiJson.info.version + "_" + i + ".yaml";
    i++;
  }
  var apiYaml;
  try {
    apiYaml = js2yaml.safeDump(apiJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!apiYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, apiYaml);
  res.statusCode = 200;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Swagger-File", getSwaggerFileLocal(fileName, getDefinitionsDir()));
  res.send(JSON.stringify(apiJson));
  res.end();
};

var getOauths = function(req, res, fullContent) {
  getWorkspaceDir();
  getProjectArtifacts()
    .then(function(artifacts){
      var oauths = [];
      artifacts.forEach(function (artifact) {
        var doc = artifact.data;
        if (!doc || !doc['provider-type']) {
          return;
        }
        oauths.push(doc);
      });
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(oauths));
      res.end();
    }).catch(function(err){
      res.statusCode = 500;
      return res.end();
    });
};

function getOauthArtifact (oauthRef, oauthJson, creating) {
   return new Promise(function(resolve, reject) {
      getProjectArtifacts()
      .then(function(artifacts){
        var basePathExists = false;
        var nameInvalid = false;
        var nameExists = false;
        var oauth = null;
        var file = null;
        var i = 0;
        while (i < artifacts.length) {
          var doc = artifacts[i].data;
          if (doc && doc['provider-type']) {
            if (oauthJson && (oauthRef !== doc.name) && (oauthJson.basePath === doc.basePath)) {
              basePathExists = true;
            }
            if (oauthRef === doc.name) {
              oauth = doc;
              file = artifacts[i].filePath;
              nameExists = true;
            }
            if (oauthJson && (oauthRef !== doc.name) && (doc.name === oauthJson.name)) {
              nameInvalid = true;
              nameExists = true;
            }
          }
          i++;
        }
        if (creating) {
          if (nameExists) {
            return reject(new Error(oauthRef + ': Found duplicate name, please use another name.'));
          } else if (basePathExists) {
            return reject(new Error(oauthRef + ': duplicate base path, please use another base path.'));
          } else {
            return resolve(oauthRef);
          }
        }

        if (oauth) {
          if (nameInvalid) {
            return reject(new Error(oauthRef + ': Found duplicate name, please use another name.'));
          } else if (basePathExists) {
            return reject(new Error(oauthRef + ': duplicate base path, please use another base path.'));
          } else {
            return resolve(
            {
              oauth: oauth,
              file: file
            });
          }
        } else {
          return reject(new Error(oauthRef + ': file is not in the workspace directory.'));
        }
      });
    });
}

var getOauth = function(req, res) {
  var oauthRef = localApiRegistry.oauth.regex.exec(req.url)[1];
  getOauthArtifact(oauthRef)
    .then(function(result) {
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(result.oauth));
      res.end();
    }, function(err){
      res.statusCode = 404;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(err.message));
      res.end();
    }).catch(function(err){
      res.statusCode = 500;
      return res.end();
    });
};

var saveOauth = function (req, res) {
  var oauthRef = localApiRegistry.oauth.regex.exec(req.url)[1];
  var oauthJson = req.body;
  getOauthArtifact(oauthRef, oauthJson)
    .then(function(result) {
      var oauthYaml;
      oauthYaml = js2yaml.safeDump(oauthJson);
      fs.writeFileSync(result.file, oauthYaml);
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(oauthJson));
      res.end();
    }, function(err){
      res.statusCode = 404;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(err.message));
      res.end();
    }).catch(function(err){
        res.statusCode = 500;
        return res.end();
    });
};

var deleteOauth = function(req, res) {
  var oauthRef = localApiRegistry.oauth.regex.exec(req.url)[1];
  getOauthArtifact(oauthRef)
    .then(function(result) {
      fs.unlinkSync(result.file);
      res.statusCode = 200;
      res.end();
    }, function(err){
      res.statusCode = 404;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(err.message));
      res.end();
    }).catch(function(err){
      res.statusCode = 500;
      return res.end();
    });
};

function oauthAutoFill(oauthJson) {
  if (!oauthJson) return;
  var template = {
    'provider-type': 'apiconnect',
    'apic-authorize-endpoint': '/oauth2/authorize',
    'apic-token-endpoint': '/oauth2/token',
    'apic-token-secret': {
      name: 'oauth-default-key'
    },
    scopes: {
      scope1: ''
    },
    grants: ['implicit', 'accessCode', 'application'],
    clients: ['confidential'],
    'apic-access-token-ttl': 3600,
    'apic-maximum-consent-ttl': 7200,
    'apic-enable-refresh-token': false,
    'apic-enable-introspection': false
  };
  template.name = oauthJson.name;
  template.title = oauthJson.title;
  template.basePath = oauthJson.basePath;
  template.description = oauthJson.description || '';
  return template;
}

var createOauth = function(req, res) {
  var oauthJson = _.cloneDeep(oauthAutoFill(req.body));
  getOauthArtifact(oauthJson.name, oauthJson, true)
    .then(function(result) {
      var definitionsDir = getDefinitionsDir();
      var dir = definitionsDir;
      var oauthYaml;
      oauthYaml = js2yaml.safeDump(oauthJson);
      var file = dir + '/' + oauthJson.name + '.yaml';
      fs.writeFileSync(file, oauthYaml);
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(oauthJson));
      res.end();
    }, function(err){
      res.statusCode = 400;
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(err.message));
      res.end();
    }).catch(function(err){
      res.statusCode = 500;
      return res.end();
    });
};

var getProducts = function(req, res) {
    getProjectArtifacts()
      .then(function(artifacts){
        var products = [];
        artifacts.forEach(function (artifact) {
          try {
            var doc = artifact.data;
            var filter = req.query.filter;
            if (filter) filter = filter.toLowerCase();
            if (doc.product === '1.0.0') {
              if (filter && filter.length > 0) {
                if (doc.info.title.toLowerCase().indexOf(filter) < 0 &&
                  doc.info.name.toLowerCase().indexOf(filter) < 0 &&
                  doc.info.version.toLowerCase().indexOf(filter) < 0) {
                    return;
                }
              }
              products.push({
                info: doc.info,
                updatedAt: artifact.mtime,
                file: artifact.filePath,
                apis: doc.apis
              });
            }
          } catch (e) {
            console.log('Error loading YAML: ' + artifact.filePath);
            console.log(e);
          }
        });
        res.statusCode = 200;
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('X-Total-Count', products.length);
        res.end(JSON.stringify(products));
      })
      .catch(function(err){
        res.statusCode = 500;
        res.end(err);
        return;
      });
};

var getProduct = function(req, res) {
  getProjectArtifacts()
    .then(function(artifacts){
      var productRef = localApiRegistry.product.regex.exec(req.url)[1];
      productRef = decodeURIComponent(productRef);

      var product = null;
      var file = null;
      var i = 0;
      while (!product && i < artifacts.length) {
        try {
          var doc = artifacts[i].data;
          if (doc.product === "1.0.0" &&
            (productRef === doc.info.name + ':' + doc.info.version ||
            productRef === doc.info.title + ":" + doc.info.version)) {
            product = doc;
            file = artifacts[i].filePath;
          }
        } catch (e) {
          // WTF?
          console.log('Error loading YAML: ' + file);
          console.log(e);
        }
        i++;
      }
      if (!product) {
        var fnfError = {
          error: {
            message: "Product not found: " + productRef
          }
        };
        res.statusCode = 404;
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(fnfError));
        return;
      }
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('X-IBM-Product-File', file);
      res.end(JSON.stringify(product));
    })
    .catch(function(err){
      res.statusCode = 500;
      res.end(err);
      return;
    });
};

var saveProduct = function (req, res) {
  var fileName = req.headers['x-ibm-product-file'];
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }
  var productJson = req.body;
  var productYaml;
  try {
    productYaml = js2yaml.safeDump(productJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!productYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, productYaml);
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('X-IBM-Product-File', fileName);
  res.end(JSON.stringify(productJson));
};

var deleteProduct = function(req, res) {
  var fileName = req.headers["x-ibm-product-file"];
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }

  // sanity check
  var workspaceDir = getWorkspaceDir(); //todo
  if (!fileName.startsWith(workspaceDir)) {
    res.statusCode = 404;
    res.end();
    return;
  }

  fs.unlink(fileName);
  res.statusCode = 200;
  res.end();
};

var createProduct = function(req, res) {
  var productJson = req.body;
  var workspaceDir = getWorkspaceDir();
  var definitionsDir = getDefinitionsDir();
  var dir = definitionsDir;
  if (!fs.existsSync(dir)) {
  	fs.mkdirSync(dir);
  }
  var fileName = dir + "/" + productJson.info.name + "_" + productJson.info.version + ".yaml";
  var i = 1;
  while (fileExists(fileName)) {
    fileName = dir + "/" + productJson.info.name + "_" + productJson.info.version + "_" + i + ".yaml";
    i++;
  }
  var productYaml;
  try {
    productYaml = js2yaml.safeDump(productJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!productYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, productYaml);
  res.statusCode = 200;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Product-File", fileName.replace(workspaceDir, "."));
  res.end(JSON.stringify(productJson));
};

var getAssemblies = function(req, res) {
    getProjectArtifacts()
      .then(function(artifacts){
        var assemblies = [];
        artifacts.forEach(function(artifact) {
          try {
            var doc = artifact.data;
            if (doc.assembly === "1.0.0") {
              assemblies.push({
                doc: doc,
                info: doc.info,
                updatedAt: artifact.mtime,
                file: artifact.filePath
              });
            }
          } catch (e) {
            console.log("Error loading YAML: " + artifact.filePath);
            console.log(e);
          }
        });
        res.statusCode = 200;
        res.setHeader("Content-Type", "application/json");
        res.setHeader("X-Total-Count", assemblies.length);
        res.end(JSON.stringify(assemblies));
      })
      .catch(function(err){
        res.statusCode = 500;
        res.end(err);
        return;
      });
};

var getAssembly = function(req, res) {
    getProjectArtifacts()
      .then(function(artifacts){
        var assemblyRef = localApiRegistry.assembly.regex.exec(req.url)[1];
        // TODO - why are we double-encoding??
        assemblyRef = decodeURI(decodeURI(assemblyRef));

        var assembly = null;
        var file = null;
        var i = 0;
        while (!assembly && i < artifacts.length) {
          try {
            var doc = artifacts[i].data;
            if (assemblyRef === doc.info.name + ":" + doc.info.version) {
              assembly = doc;
              file = artifacts[i].filePath;
            }
          } catch (e) {
            console.log("Error loading YAML: " + file);
            console.log(e);
          }
          i++;
        }
        if (!assembly) {
          res.statusCode = 404;
          res.end();
          return;
        }
        res.statusCode = 200;
        res.setHeader("Content-Type", "application/json");
        res.setHeader("X-IBM-Assembly-File", file);
        res.end(JSON.stringify(assembly));
      })
      .catch(function(err){
        res.statusCode = 500;
        res.end(err);
        return;
      });
};

var saveAssembly = function(req, res) {
  var fileName = req.headers["x-ibm-assembly-file"];
  if (!fileName) {
    res.statusCode = 404;
    res.end();
    return;
  }
  var assemblyJson = req.body;
  var assemblyYaml;
  try {
    assemblyYaml = js2yaml.safeDump(assemblyJson);
  } catch (e) {
    console.log(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!assemblyYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, assemblyYaml);
  res.statusCode = 200;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Assembly-File", fileName);
  res.end(JSON.stringify(assemblyJson));
};

var getUserPolicies = function () {

  // Loading procedures from MicroGateway's PolicyLoader:
  // 1. (Doesn't apply here?) always load policies in resolve(__dirname, '..', 'policies')
  // 2. check 'userPolicies' in (either one, project first):
  //    - 2.1: if cwd() is a loopback project, check .apiconnect.
  //       - if 'userPolicies' presents, add locations. if not, go
  //         to 2.2
  //    - 2.2: check home/.apiconnect/config
  //       - if 'userPolicies' presents, add locations
  var workspaceDir = getWorkspaceDir();
  var projectInfo = projectInspector.inspectPath(workspaceDir);

  var config = configParser.loadConfig({
    projectDir: projectInfo.basePath,
    shouldParseUris: false
  });

  // Are we in a loopback project dir?
  var projectName;
  if (projectInfo.type === 'project') {
    projectName = require(pathM.resolve(projectInfo.basePath, 'package.json')).name;
  } else {
    // non-lb dir
    projectName = pathM.basename(workspaceDir);
  }
  var gatewayName = projectName + '-gw';
  var microgw = config.get('microgateway') || config.get('micro-gateway');
  var gatewayDir = microgw['microgateway'] || microgw['micro-gateway'];
  var obj;
  var locations = [];

  // TODO(jtary): similar logic to this is done in apiconnect-cli-pm, which
  // will also default to it's microgateway module if this all fails. We can't
  // reliably get the microgateway module from here, so we should bubble the
  // gateway dir from the apiconnect-cli-pm module.
  if (gatewayDir) {
    locations.push(pathM.resolve(gatewayDir, 'userPolicies'));
  }

  var loadUserSettings = true;

  //2.1 load project specific settings
  obj = config.get('userPolicies', configParser.PROJECT_STORE);

  if (obj.userPolicies && Array.isArray(obj.userPolicies)) {
    //if the location is related path, prepend projectDir
    obj.userPolicies.forEach(function (location) {
      if (glob.hasMagic(location)) {
        console.warn('getUserPolicies(): ignoring invalid path', location);
        return;
      }
      location = location.replace(/^~/, osenv.home());
      if (pathM.isAbsolute(location)) {
        locations.push(location);
      }
      else {
        locations.push(pathM.resolve(projectInfo.basePath, location));
      }
    });
    //already load project specific settings, skip global one
    loadUserSettings = false;
  }

  //2.2 load global settings from home directory
  if (loadUserSettings) {
    obj = config.get('userPolicies', configParser.USER_STORE);
    if (obj.userPolicies && Array.isArray(obj.userPolicies)) {
      //if the location is related path, prepend APIC_CONFIG_PATH
      var configDir = process.env.APIC_CONFIG_PATH || pathM.resolve(osenv.home(), '.apiconnect');

      obj.userPolicies.forEach(function (location) {
        if (glob.hasMagic(location)) {
          console.warn('getUserPolicies(): ignoring invalid path', location);
          return;
        }
        location = location.replace(/^~/, osenv.home());
        if (pathM.isAbsolute(location)) {
          locations.push(location);
        }
        else {
          locations.push(pathM.resolve(configDir, location));
        }
      });
    }
  }

  var globbers = locations.map(function (loc) {
    return new Promise(function (resolve) {
      var yamlpath = loc + '/policy.+(yml|yaml|YML|YAML)';
      var globopt = { ignore: '**/node_modules/**' };
      var results = { searchPath: loc, files: [] };

      if (/policy\.(ya?ml|YA?ML)$/.test(loc)) {
        console.warn('getUserPolicies():', loc, 'appears to be a full path to a policy file.',
        'Please provide a path to the directory in which the policy exists instead.');
        return resolve(results);
      }

      glob(yamlpath, globopt, function (err, files) {
        if (err) {
          console.warn(err);
          return resolve([]);
        }

        if (files.length > 0) {
          results.files = files;
          return resolve(results);
        }

        var yamlpath = loc + '/*/policy.+(yml|yaml|YML|YAML)';
        glob(yamlpath, globopt, function (err, files) {
          if (err) {
            console.warn(err);
            return resolve([]);
          }

          results.files = files;
          return resolve(results);
        });

      });
    });
  });

  return Promise.all(globbers).then(function (fileArrays) {
    var files = [];
    var filemap = {};
    fileArrays.forEach(function (results) {
      if (results.files.length === 0) {
        console.warn('getUserPolicies(): No results found for', results.searchPath,
                     'Please be sure this is a valid directory containing a policy or directories of policies.');
      }
      results.files.forEach(function (fpath) {
        var fdir = fpath.slice(0, fpath.lastIndexOf('/'));
        if (!!filemap[fdir]) {
          console.warn('getUserPolicies(): Ignoring', fpath, '. Another policy from', fdir, 'already found.');
          return;
        }
        files.push(fpath);
        filemap[fdir] = fpath;
      });
    });
    return files;
  });
};

var getPolicies = function(req, res) {
    getUserPolicies()
      .then(function(files){
        var policies = [];
        files.forEach(function(file) {
          try {
            var doc = js2yaml.safeLoad(fs.readFileSync(file, "utf8"));
            if (typeof doc.policy === 'string' && typeof doc.info.name === 'string') {
              policies.push(doc);
            }
          } catch (e) {
            console.log("Error loading YAML: " + file);
            console.log(e);
          }
        });
        res.statusCode = 200;
        res.setHeader("Content-Type", "application/json");
        res.setHeader("X-Total-Count", policies.length);
        res.end(JSON.stringify(policies));
      })
      .catch(function(err){
        res.statusCode = 500;
        res.end(err);
      });
};

var getVendorExtensions = function(req, res) {
    getProjectArtifacts()
      .then(function(artifacts){
        var vendorExtensions = [];
        artifacts.forEach(function (artifact) {
          try {
            var doc = artifact.data;
            var filter = req.query.filter;
            if (filter) filter = filter.toLowerCase();
            if (doc['extension'] === '1.0.0') {
              if (filter && filter.length > 0) {
                if (doc.info.title.toLowerCase().indexOf(filter) < 0 &&
                  doc.info.name.toLowerCase().indexOf(filter) < 0 &&
                  doc.info.version.toLowerCase().indexOf(filter) < 0) {
                    return;
                }
              }
              vendorExtensions.push({
            	title: doc.info.title,
                name: doc.info.name,
                version: doc.info.version,
                portalVisible: doc.info.portalVisible,
                updatedAt: artifact.mtime,
                file: artifact.filePath,
                schema: doc
              });
            }
          } catch (e) {
            console.log('Error loading YAML: ' + artifact.filePath);
            console.log(e);
          }
        });
        res.statusCode = 200;
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('X-Total-Count', vendorExtensions.length);
        res.end(JSON.stringify(vendorExtensions));
      })
      .catch(function(err){
        res.statusCode = 500;
        res.end(err);
        return;
      });
};

var getTargets = function(req, res) {
  var workspaceDir = getWorkspaceDir();
  glob(workspaceDir+"/.targets/*.target", {}, function(err, files) {
    if (err) {
      res.statusCode = 500;
      res.end(err);
      return;
    }
    var targets = [];
    files.forEach(function (file) {
      try {
        var doc = js2yaml.safeLoad(fs.readFileSync(file, 'utf8'));
        if (doc.target === '1.0.0') {
          targets.push({
            info: doc,
            updatedAt: fs.statSync(file).mtime,
            file: file
          });
        }
      } catch (e) {
        console.error('Error loading YAML: ' + file);
        console.error(e);
      }
    });
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('X-Total-Count', targets.length);
    res.end(JSON.stringify(targets));
  });
};

var createTarget = function(req, res){
  var workspaceDir = getWorkspaceDir();
  var dir = workspaceDir + '/.targets';
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
  }
  var targetJson = req.body;
  targetJson.id = uuid.v4();
  targetJson.target = '1.0.0';
  var fileName = workspaceDir + "/.targets/" + targetJson.id+".target";
  var targetYaml;
  try {
    targetYaml = js2yaml.safeDump(targetJson);
  } catch (e) {
    console.error(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!targetYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, targetYaml);
  res.statusCode = 200;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Product-File", fileName);
  res.end(JSON.stringify(targetJson));
};

var updateTarget = function(req, res){
  var workspaceDir = getWorkspaceDir();
  var targetJson = req.body;
  var fileName = workspaceDir + "/.targets/" + targetJson.id+".target";
  var targetYaml;
  try {
    targetYaml = js2yaml.safeDump(targetJson);
  } catch (e) {
    console.error(e);
    res.statusCode = 400;
    res.end();
    return;
  }
  if (!targetYaml) {
    res.statusCode = 400;
    res.end();
    return;
  }
  fs.writeFileSync(fileName, targetYaml);
  res.statusCode = 200;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Product-File", fileName);
  res.end(JSON.stringify(targetJson));
};

var deleteTarget = function(req, res) {
  var workspaceDir = getWorkspaceDir();
  var targetRef = req.url.split('/')[req.url.split('/').length - 1];
  // TODO - why are we double-encoding??
  targetRef = decodeURI(decodeURI(targetRef));

  var fileName = workspaceDir + "/.targets/" + targetRef + ".target";
  if (!fileExists(fileName)) {
    res.statusCode = 404;
    res.end();
    return;
  }
  fs.unlinkSync(fileName);
  res.statusCode = 204;
  res.setHeader("Content-Type", "application/json");
  res.setHeader("X-IBM-Product-File", fileName);
  res.end();
};

var getAPIcServers = function(req, res) {
  var configDir = util.getConfigDir();
  glob(configDir+"/apicServers.yaml", {}, function(err, files) {
    if (err) {
      res.statusCode = 500;
      res.end(err);
      return;
    }
    var servers = null;
    var file = null;
    var i = 0;
    while (!servers && i < files.length) {
      try {
        var doc = js2yaml.safeLoad(fs.readFileSync(files[i], 'utf8'));
        if (doc.apiServers === '1.0.0') {
          servers = doc.servers;
          file = files[i];
        }
      } catch (e) {
        console.log('Error loading YAML: ' + file);
        console.log(e);
      }
      i++;
    }
    if (!servers) {
      var filename = configDir + "/apicServers.yaml";
      var defServers = util.getDefaultStacks();
      var saveYaml;
      try {
        saveYaml = js2yaml.safeDump(defServers);
      } catch (e) {
        console.log(e);
        res.statusCode = 400;
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(defServers.servers));
        return;
      }
      try{
        fs.writeFileSync(filename, saveYaml);
      } catch(e){
        console.error('error writing files');
        console.error(e);
        res.statusCode = 500;
        res.end();
        return;
      }
      res.statusCode = 201;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(defServers.servers));
      return;
    }
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(servers));
  });
};

var updateAPIcServers = function(req, res){
  var configDir = util.getConfigDir();
  glob(configDir+"/apicServers.yaml", {}, function(err, files) {
    if (err) {
      res.statusCode = 500;
      res.end(err);
      return;
    }
    var servers;
    var file;
    var i = 0;
    while (!servers && i < files.length) {
      try {
        var doc = js2yaml.safeLoad(fs.readFileSync(files[i], 'utf8'));
        if (doc.apiServers === '1.0.0') {
          servers = doc.servers;
          file = files[i];
        }
      } catch (e) {
        console.log('Error loading YAML: ' + file);
        console.log(e);
      }
      i++;
    }
    if (!servers) {
      console.log("Servers file not found.");
      var filename = configDir + "/apicServers.yaml";
      servers = util.getDefaultStacks();
    }
    var newServer = req.body;
    var found = false;
    for(var j = 0; j < servers.length; j++){
      if (servers[j].name === newServer.name) {
        servers[j] = newServer;
        found = true;
        break;
      }
    }
    if (!found) {
      servers.push(newServer);
    }
    var json = {
      apiServers: '1.0.0',
      servers: servers
    };
    var saveYaml;
    try {
      saveYaml = js2yaml.safeDump(json);
    } catch (e) {
      console.log(e);
      res.statusCode = 400;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(json.servers));
      return;
    }
    var serversFilename = configDir + "/apicServers.yaml";
    try{
      fs.writeFileSync(serversFilename, saveYaml);
    } catch(e){
      console.error('error writing files');
      console.error(e);
      res.statusCode = 500;
      res.end();
      return;
    }
    res.status(200).send();
  });
};

var getDefaultServer = function(req, res) {
  res.send(auth.getDefaultServer());
};

var setDefaultServer = function(req, res) {
  auth.setDefaultServer(req.body);
  res.status(200).send();
};

var getCatalogs = function(req, res){
  getProjectArtifacts()
    .then(function(artifacts){
      var catalogs = [];
      artifacts.forEach(function (artifact) {
        try {
          var doc = artifact.data;
          if (doc.catalog === '1.0.0') {
            catalogs.push({
              info: doc.info,
              updatedAt: artifact.mtime,
              file: artifact.filePath
            });
          }
        } catch (e) {
          console.log('Error loading YAML: ' + artifact.filePath);
          console.log(e);
        }
      });
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('X-Total-Count', catalogs.length);
      res.end(JSON.stringify(catalogs));
    })
    .catch(function(err){
      res.statusCode = 500;
      res.end(err);
      return;
    });
};

var resolveReference = function(req, res) {
  // TODO - why are we double-encoding??
  var ref = pathM.resolve(pathM.join(
    getDefinitionsDir(),
    decodeURIComponent(
      localApiRegistry.resolveReference.regex.exec(req.url)[1]
    )
  ));

  if (fileExists(ref)) {
    var doc = js2yaml.safeLoad(fs.readFileSync(ref, "utf8"));
    res.statusCode = 200;
    res.setHeader("Content-Type", "application/json");
    res.end(JSON.stringify(doc));
  } else {
    var fnfError = {
      error: {
        message: "Referenced file not found: " + ref
      }
    };
    res.statusCode = 404;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(fnfError));
  }

};

var referenceToFilename = function(req, res) {
  var ref = localApiRegistry.referenceToFilename.regex.exec(req.url)[1];
  getProjectArtifacts().then(function(artifacts){
    var filename = "";
    artifacts.forEach(function (artifact) {
      var doc = artifact.data;
      if (doc && doc.info) {
        if (ref === doc.info['x-ibm-name'] + ":" + doc.info.version ||
            ref === doc.info.name + ":" + doc.info.version) {
          filename = artifact.filePath;
        }
      }
    });
    if (filename !== "") {
      res.statusCode = 200;
      res.setHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        ref: ref,
        filename: filename
      }));
    } else {
      var fnfError = {
        error: {
          message: "Reference not found: " + ref
        }
      };
      res.statusCode = 404;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(fnfError));
    }
  });
};

var getDPConfigPolicies = function(req, res) {
  var dpActions;
  try {
    dpActions =configToDP.listActions()
  } catch (e) {
    res.statusCode = 500;
    res.end(JSON.stringify({error: {message: "Received an error from the server while retrieving v6 DataPower Gateway (experimental) supported policies."}}));
    return;
  }
  res.statusCode = 200;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify(dpActions));
};

var proxyService = function(req, res) {
  var targetUrl = url.parse(req.body.url);
  // Docker datapower GW is doing TLS on the flight, we need this agent to bypass the cert failure until we have TLS in docker datapower GW.
  var agentOptions = {
    host: targetUrl.hostname,
    port: targetUrl.port,
    path: '/',
    rejectUnauthorized: false
  };
  var agent = new https.Agent(agentOptions);

  var options = {
    url: req.body.url,
    headers: req.body.headers,
    method: req.body.method,
    agent: agent
  };

  if (req.body.data) {
    options.body = req.body.data;
  }
  if (req.body.skipErrorCheck !== undefined) {
    options.skipErrorCheck = req.body.skipErrorCheck;
  }
  // send and pipe response back
  var reqStream = request(options);
  reqStream.pipe(res);
};

var localApiRegistry = {
  "me": {
    regex: new RegExp('proxy/me$'),
    method: 'GET',
    impl: getMe
  },
  "orgs": {
    regex: new RegExp('proxy/me/orgs\\?orgType=apiProvider$'),
    method: 'GET',
    impl: getOrgs
  },
  "permissions": {
    regex: new RegExp('proxy/me/orgs/localhost/permissions(?:\\?.*)?'),
    method: 'GET',
    impl: getPermissions
  },
  "environments": {
    regex: new RegExp('proxy/orgs/localhost/environments$'),
    method: 'GET',
    impl: getEnvironments
  },
  "apis": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis\\?.*'),
    method: 'GET',
    impl: getApis
  },
  "api": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis/(.*)\\?.*'),
    method: 'GET',
    impl: getApi
  },
  "oauth": {
    regex: new RegExp('proxy/orgs/localhost/oauth/(.*)'),
    method: 'GET',
    impl: getOauth
  },
  "oauths": {
    regex: new RegExp('proxy/orgs/localhost/oauth'),
    method: 'GET',
    impl: getOauths
  },
  "saveApi": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis/(.*)\\?.*'),
    method: 'PUT',
    impl: saveApi
  },
  "saveOauth": {
    regex: new RegExp('proxy/orgs/localhost/oauth/(.*)'),
    method: 'PUT',
    impl: saveOauth
  },
  "saveApiVersion": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis/(.*)\\?.*'),
    method: 'POST',
    impl: saveApiVersion
  },
  "deleteApi": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis/(.*)\\?.*'),
    method: "DELETE",
    impl: deleteApi
  },
  "deleteOauth": {
    regex: new RegExp('proxy/orgs/localhost/oauth/(.*)'),
    method: 'DELETE',
    impl: deleteOauth
  },
  "createApi": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis\\?.*'),
    method: "POST",
    impl: createApi
  },
  "createOauth": {
    regex: new RegExp('proxy/orgs/localhost/oauth'),
    method: "POST",
    impl: createOauth
  },
  "uploadApi": {
    regex: new RegExp('proxy/apimanager/orgs/localhost/apis'),
    method: 'POST',
    impl: uploadApi
  },
  "uploadWSDL": {
    regex: new RegExp('proxy/orgs/localhost/apis/wsdl'),
    method: 'POST',
    impl: uploadWSDL
  },
  "getWSDL": {
    regex: new RegExp('proxy/orgs/localhost/apis/wsdl\\?wsdlId=(.*)'),
    method: 'GET',
    impl: getWSDL
  },
  "createWSDLApi": {
    regex: new RegExp('proxy/orgs/localhost/apis\\?.*'),
    method: 'POST',
    impl: createWSDLApi
  },
  "uploadXSDDefinitions": {
    regex: new RegExp('proxy/orgs/localhost/apis/uploadxsd'),
    method: 'POST',
    impl: uploadXSDDefinitions
  },
  "obtainXSDDefinitions": {
    regex: new RegExp('proxy/orgs/localhost/apis/xsd'),
    method: 'POST',
    impl: uploadXSDDefinitions
  },
  "registryDiscovery": {
    regex: new RegExp('proxy/orgs/localhost/registryDiscovery/instance/(.*)/connectionData'),
    method: 'GET',
    impl: getConnectionData
  },
  "products": {
    regex: new RegExp('proxy/orgs/localhost/products($|\\?.*)'),
    method: 'GET',
    impl: getProducts
  },
  "product": {
    regex: new RegExp('proxy/orgs/localhost/products/(.*)'),
    method: 'GET',
    impl: getProduct
  },
  "saveProduct": {
    regex: new RegExp('proxy/orgs/localhost/products/(.*)'),
    method: 'PUT',
    impl: saveProduct
  },
  "deleteProduct": {
    regex: new RegExp('proxy/orgs/localhost/products/(.*)'),
    method: "DELETE",
    impl: deleteProduct
  },
  "createProduct": {
    regex: new RegExp('proxy/orgs/localhost/products$'),
    method: "POST",
    impl: createProduct
  },
  "deployed-products": {
    regex: new RegExp('proxy/orgs/localhost/environments/products'),
    method: 'GET',
    impl: getDeployedProducts
  },
  "assemblies": {
    regex: new RegExp('proxy/orgs/localhost/assemblies\\?.*'),
    method: "GET",
    impl: getAssemblies
  },
  "assembly": {
    regex: new RegExp('proxy/orgs/localhost/assemblies/(.*)'),
    method: "GET",
    impl: getAssembly
  },
  "saveAssembly": {
    regex: new RegExp('proxy/orgs/localhost/assemblies/(.*)'),
    method: "PUT",
    impl: saveAssembly
  },
  "policies": {
    regex: new RegExp('proxy/orgs/localhost/policies$'),
    method: "GET",
    impl: getPolicies
  },
  "vendorExtensions": {
	regex: new RegExp('proxy/orgs/localhost/environments/extensions$'),
	method: "GET",
	impl: getVendorExtensions
  },
  "targets": {
    regex: new RegExp('proxy/orgs/localhost/targets$'),
    method: "GET",
    impl: getTargets
  },
  "createTarget": {
    regex: new RegExp('proxy/orgs/localhost/targets$'),
    method: "POST",
    impl: createTarget
  },
  "updateTarget": {
    regex: new RegExp('proxy/orgs/localhost/targets$'),
    method: "PUT",
    impl: updateTarget
  },
  "deleteTarget": {
    regex: new RegExp('proxy/orgs/localhost/targets/(.*)'),
    method: "DELETE",
    impl: deleteTarget
  },
  "apicServers": {
    regex: new RegExp('proxy/orgs/localhost/apicServers$'),
    method: "GET",
    impl: getAPIcServers
  },
  "updateAPIcServers": {
    regex: new RegExp('proxy/orgs/localhost/apicServers$'),
    method: "PUT",
    impl: updateAPIcServers
  },
  "getDefaultServer": {
    regex: new RegExp('proxy/orgs/localhost/defaultServer$'),
    method: "GET",
    impl: getDefaultServer
  },
  "setDefaultServer": {
    regex: new RegExp('proxy/orgs/localhost/defaultServer$'),
    method: "PUT",
    impl: setDefaultServer
  },
  "catalogs": {
    regex: new RegExp('proxy/orgs/localhost/catalogs'),
    method: "GET",
    impl: getCatalogs
  },
  "resolveReference": {
    regex: new RegExp('proxy/orgs/localhost/references/(.*)'),
    method: "GET",
    impl: resolveReference
  },
  "referenceToFilename": {
    regex: new RegExp('proxy/orgs/localhost/filenames/(.*)'),
    method: "GET",
    impl: referenceToFilename
  },
  "getRunningApis": {
    regex: new RegExp('proxy/orgs/localhost/runningApis'),
    method: "GET",
    impl: getRunningApis
  },
  "getTemplates": {
    regex: new RegExp('proxy/orgs/localhost/templates'),
    method: "GET",
    impl: getTemplates
  },
  "getComponents": {
    regex: new RegExp('proxy/orgs/localhost/components$'),
    method: "GET",
    impl: getComponents
  },
  "getComponentReferences": {
    regex: new RegExp('proxy/orgs/localhost/components/references$'),
    method: "GET",
    impl: getComponentReferences
  },
  "getComponent": {
    regex: new RegExp('proxy/orgs/localhost/components/(.*)'),
    method: "GET",
    impl: getComponent
  },
  "saveComponent": {
    regex: new RegExp('proxy/orgs/localhost/components/(.*)'),
    method: 'PUT',
    impl: saveComponent
  },
  "deleteComponent": {
    regex: new RegExp('proxy/orgs/localhost/components/(.*)'),
    method: 'DELETE',
    impl: deleteComponent
  },
  "createComponent": {
    regex: new RegExp('proxy/orgs/localhost/components$'),
    method: 'POST',
    impl: createComponent
  },
  "getReferences": {
    regex: new RegExp('proxy/orgs/localhost/references$'),
    method: "POST",
    impl: getReferences
  },
  "getDPConfigPolicies": {
    regex: new RegExp('proxy/orgs/localhost/DPConfigPolicies'),
    method: "GET",
    impl: getDPConfigPolicies
  },
  "proxyService": {
    regex: new RegExp('proxy/proxyService'),
    method: "POST",
    impl: proxyService
  }
};

exports.localListings = function () {
  return function (req, res, next) {
    var apiCalls = Object.keys(localApiRegistry).filter(function (key) {
      var definition = localApiRegistry[key];
      return definition.method === req.method && definition.regex.test(req.url);
    });
    if (apiCalls.length > 0) {
      localApiRegistry[apiCalls[0]].impl(req, res);
    } else {
      next();
    }
  };
};

var fileExists = function(filePath) {
  try {
    return fs.statSync(filePath).isFile();
  } catch (err) {
    return false;
  }
};
