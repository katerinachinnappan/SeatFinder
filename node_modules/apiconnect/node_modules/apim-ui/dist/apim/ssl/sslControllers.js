/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var sslProfiles = angular.module('apim.tls', ['ngResource']);

sslProfiles.controller('SSLProfilesCtrl', ['$scope', '$rootScope', '$q', '$modal', '$location', '$filter', 'SSLProfile', sslProfilesController]);

function sslProfilesController($scope, $rootScope, $q, $modal, $location, $filter, SSLProfile) {

  $scope.context = $rootScope.context;

  $scope.preSelectProfile = null;
  $scope.sslProfilesLoaded = false;
  $scope.saveDisabled = true;
  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.refreshProfiles();
  });

  $scope.refreshProfiles = function() {
    var params = {};
    if ($rootScope.context == "apim"){
      params.orgId = $scope.orgId;
    }
    $scope.sslProfiles = SSLProfile.query(params);
    $scope.sslProfiles.$promise.then(
      function() {
        $scope.sslProfilesLoaded = true;
        // pre-select a profile if needed
        var len = $scope.sslProfiles.length;
        if ($scope.preSelectProfile) {
          for (var i=0;i<len;i++) {
            if ($scope.sslProfiles[i].id == $scope.preSelectProfile) {
              $scope.selectedSSLProfile = $scope.sslProfiles[i];
              break;
            }
          } // end for
          $scope.preSelectProfile = null;
        }
        if (!$scope.selectedSSLProfile && len > 0) {
          $scope.selectedSSLProfile = $scope.sslProfiles[0];
        }
      }
    );
    return $scope.sslProfiles.$promise;
  };

  $scope.$on("$locationChangeStart", function (event, next, current) {
    if (!$scope.saveDisabled) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          $scope.saveDisabled = true;
          $location.path($location.url(next).hash());
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });

  $scope.onNavigateOut = function(oldValue) {
    var deferred = $q.defer();
    if (!$scope.saveDisabled) {
      $scope.confirmation = {
        titleKey: 'unsavedChanges',
        message: $filter('translate')('sslProfileUnsavedChanges', {tlsProfile: oldValue ? oldValue.title : $scope.selectedSSLProfile.title}),
        confirmed: function() {
          $scope.saveDisabled = true;
          deferred.resolve(true);
        },
        rejected: function() {
          deferred.reject();
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        scope: $scope,
        backdrop: 'static'
      });
    } else {
      deferred.resolve(true);
    }
    return deferred.promise;
  };

  $scope.getIdFromUrl = function(url) {
    return url.substring(url.lastIndexOf("/") + 1);
  };

  $scope.addSSLProfile = function() {
    if(!$scope.sslProfiles.$resolved) return;
    // perform a navigate check - cant have unsaved changes when we create a new profile
    $scope.onNavigateOut($scope.selectedSSLProfile).then(function(navigate) {
      // user wants to navigate
      if (navigate) {
        $scope.saveDisabled = true;
        $scope.$broadcast("SSL_discarded");
        $scope.refreshProfiles().then(function() {
          $scope.performAdd();
        });
      }
    }, function() {
      // user doesn't want to discard changes - nothing to do
    });
  };

  $scope.performAdd = function() {
    $scope.saveDisabled = true;

    // Work out a suitable default name and path
    var newSSLProfileName = null;
    var newSSLProfileNamePrefix = $filter('translate')('newIdentity') + " ";
    for(var i=1; newSSLProfileName == null; i++) {
      var testName = newSSLProfileNamePrefix + i;
      var nameAlreadyTaken = false;
      for(var j=0; j<$scope.sslProfiles.length; j++) {
        if($scope.sslProfiles[j].title == testName) {
          nameAlreadyTaken = true;
          break;
        }
      }
      if(!nameAlreadyTaken) {
        newSSLProfileName = testName;
      }
    }

    // Create environment object
    var newSSLProfile = new SSLProfile({
      title: newSSLProfileName,
      description: "",
      protocols: ["TLSv11", "TLSv12"],
      ciphers: [],
      mutualAuth: false,
      "public": false
    });

    var timestamp = (new Date()).getTime();
    var messageId = "savingSSLProfile-" + timestamp;
    $scope.$root.notifyUser('savingProfile', [], "BUSY", false, messageId);

    var params = {};
    if ($rootScope.context == "apim"){
      params.orgId = $scope.orgId;
    }
    newSSLProfile.$save(params).then(
      function(fullSSLProfile) {
        $scope.refreshPermissions();
        $scope.sslProfiles.unshift(fullSSLProfile); // Add to beginning of array
        $scope.selectedSSLProfile = fullSSLProfile;
        $scope.$root.notifyUser('savedProfile', [], "SUCCESS", true, messageId);
      },
      function(error) {
        $scope.$root.notifyUser('errorSavingProfile', [], "ERROR", false, messageId);
      }
    );
  };

  $scope.saveSSLProfile = function() {
    if ($scope.saveDisabled) return;
    var messageId = "savingSSLProfile";
    $scope.$root.notifyUser('savingProfile', [], "BUSY", false, messageId);
    $scope.saveDisabled = true;
    var params = {};
    if ($rootScope.context == "apim"){
      params.orgId = $scope.orgId;
    }
    params.objId = $scope.selectedSSLProfile.id;
    $scope.selectedSSLProfile.$update(params).then(
      function() {
        $scope.saveDisabled = true;
        $scope.$broadcast("SSL_saved");
        $scope.$root.notifyUser('savedProfile', [], "SUCCESS", true, messageId);
      },
      function(error) {
        $scope.saveDisabled = false;
        $scope.$root.notifyUser('errorSavingProfile', [], "ERROR", false, messageId);
      }
    );
  };

  $scope.confirmDeleteSSLProfile = function(index) {
    $scope.confirmation = {
      titleKey: 'confirmDeleteSSLIdentityTitle',
      messageKey: 'confirmDeleteSSLIdentity',
      confirmed: function() {
        $scope.deleteSSLProfile(index);
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope,
      backdrop: 'static'
    });
  };

  $scope.deleteSSLProfile = function(index) {
    var timestamp = (new Date()).getTime();
    var messageId = "deletingSSLProfile-" + timestamp;
    $scope.$root.notifyUser('deletingSSLProfile', [], "BUSY", false, messageId);

    $scope.beingDeleted = true;
    $scope.saveDisabled = true;
    var sslProfileToDelete = $scope.sslProfiles[index];
    if(!sslProfileToDelete.newSSLProfile) {
      var params = {};
      if ($rootScope.context == "apim"){
        params.orgId = $rootScope.orgId;
      }
      params.objId = sslProfileToDelete.id;
      sslProfileToDelete.$remove(params).then(
        function() {
          $scope.sslProfiles.splice(index, 1);
          if($scope.sslProfiles.length > 0) {
            $scope.selectedSSLProfile = $scope.sslProfiles[0];
          } else {
            $scope.selectedSSLProfile = null;
          }
          $scope.$emit('sslProfile_removed', sslProfileToDelete);
          $scope.beingDeleted = false;
          $scope.$root.notifyUser('deletedSSLProfile', [], "SUCCESS", true, messageId);
        },
        function(error) {
          $scope.beingDeleted = false;
          $scope.saveDisabled = false;
          $scope.$root.notifyUser('errorDeletingSSLProfile', [], "ERROR", false, messageId);
        });
    }
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave) {
    $scope.saveDisabled = !canSave;
  };

  // Called when a different profile is selected from the list
  $scope.sslChanged = function(newValue, oldValue) {
    if (!$scope.saveDisabled && newValue !== oldValue) {
      // perform a navigate check - send original value in case the user vetoes the operation
      $scope.onNavigateOut(oldValue).then(function(navigate) {
        // user wants to navigate
        if (navigate) {
          if (newValue) {
            $scope.preSelectProfile = newValue.id;
          }
          $scope.saveDisabled = true;
          $scope.$broadcast("SSL_discarded");
          $scope.refreshProfiles();
        }
      }, function() {
        // restore previous selection, user wants to stay - must switch off watch temporarily
        // otherwise we get stuck in a loop
        $scope.unwatchProfile();
        $scope.selectedSSLProfile = oldValue;
        $scope.unwatchProfile = $scope.$watch('selectedSSLProfile', $scope.sslChanged);
      });
    }
  };

  $scope.unwatchProfile = $scope.$watch('selectedSSLProfile', $scope.sslChanged);
  $scope.$on("SSL_canSave", $scope.handleSave);
};


sslProfiles.controller('SSLProfileCtrl', ['$scope', '$rootScope', '$q', '$modal', '$filter', '$mdDialog' , '$timeout', 'uiUploader', 'errorHandler', 'TruststoreCerts', 'SSLProfile', sslProfileController]);

function sslProfileController($scope, $rootScope, $q, $modal, $filter, $mdDialog, $timeout, uiUploader, errorHandler, TruststoreCerts, SSLProfile) {

  $scope.clicked = {};

  $scope.uploadKeyCert = function(dialogScope, data, hideOnSuccess) {
    if (typeof hideOnSuccess === "undefined") hideOnSuccess = true;
    var url = "";
    if ($rootScope.context == "apim") {
      url = 'proxy/orgs/' + $rootScope.orgId + '/ssl-profiles/' + $scope.selectedSSLProfile.id + '/keystore/upload';
    } else {
      url = 'proxy/cloud/ssl-profiles/' + $scope.selectedSSLProfile.id + '/keystore/upload';
    }
    // Grab the password and submit it with the form.
      var jsonData = {};
    jsonData.password = "{\"keyStorePassword\":\"" + data.password + "\"}";
    // make sure any previous upload file list is cleared
    uiUploader.removeAll();
    $rootScope.markFilesInactive(data.selectedFiles);
    uiUploader.addFiles(data.selectedFiles);
    uiUploader.startUpload({
      url: url,
      data: jsonData,
      onProgress: function(file) {

      },
      onCompleted: function(file, responseText, responseCode) {
        dialogScope.performingUpload = false;
        dialogScope.$apply();
        delete dialogScope.showUploadForm;
        if (responseCode == 200) {
          if (hideOnSuccess) {
            $mdDialog.hide();
            $scope.refreshView();
          }
        } else {
          var response = {
            data: responseText,
            status: responseCode,
            config: {url: url}
          };
          errorHandler.checkResponse(response);
        }
        $scope.$emit('file_upload_completed');
      },
      onCompletedAll: function(fileList) {
        // not used as we only have one file uploading
      }
    });
  };

  $scope.uploadTrustCert = function(dialogScope, data, hideOnSuccess) {
    if (typeof hideOnSuccess === "undefined") hideOnSuccess = true;
    var url = "";
    if ($rootScope.context == "apim") {
      url = 'proxy/orgs/' + $rootScope.orgId + '/ssl-profiles/' + $scope.selectedSSLProfile.id + '/truststore/upload';
    } else {
      url = 'proxy/cloud/ssl-profiles/' + $scope.selectedSSLProfile.id + '/truststore/upload';
    }
    // Grab the password and submit it with the form.
      var jsonData = {};
    jsonData.password = "{\"keyStorePassword\":\"" + data.password + "\"}";
    // make sure any previous upload file list is cleared
    uiUploader.removeAll();
    $rootScope.markFilesInactive(data.selectedFiles);
    uiUploader.addFiles(data.selectedFiles);
    uiUploader.startUpload({
      url: url,
      data: jsonData,
      onProgress: function(file) {

      },
      onCompleted: function(file, responseText, responseCode) {
        dialogScope.performingUpload = false;
        delete dialogScope.showUploadForm;
        dialogScope.$apply();
        if (responseCode == 200) {
          if (hideOnSuccess) {
            $mdDialog.hide();
            $scope.refreshView();
          }
        } else {
          var response = {
            data: responseText,
            status: responseCode,
            config: {url: url}
          };
          errorHandler.checkResponse(response);
        }
        $scope.$emit('file_upload_completed');
      },
      onCompletedAll: function(fileList) {
        // not used as we only have one file uploading
      }
    });
  };

  $scope.renderCertIssuer = function(cert, isIssuedTo) {
    var ret = $filter('translate')('unknown');
    var mode = "issuedBy";
    if (isIssuedTo) {
      mode = "issuedTo";
    }
    if (cert.details && cert.details[mode]) {
      ret = cert.details[mode].commonName || cert.details[mode].organizationalUnit || cert.details[mode].organization || $filter('translate')('unknown');
    }
    return (ret);
  };

  $scope.confirmDeleteCert = function(certId) {
    $scope.confirmation = {
      titleKey: 'confirmDeleteSSLCertificateTitle',
      messageKey: 'confirmDeleteSSLCertificate',
      confirmed: function() {
        $scope.deleteCert(certId);
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope,
      backdrop: 'static'
    });
  };

  $scope.deleteCert = function(certId) {
    var certToDelete = new TruststoreCerts({});
    var params = {};
    if ($rootScope.context == "apim"){
      params.orgId = $rootScope.orgId;
    }
    params.objId = $scope.selectedSSLProfile.id;
    params.certId = certId;
    certToDelete.$remove(params).then(
      function() {
        $scope.refreshView();
      },
      function(error) {
      });
  };

  $scope.toggleProtocol = function(protocol) {
    var index = $scope.selectedSSLProfile.protocols.indexOf(protocol);
    if (index != -1) {
      $scope.selectedSSLProfile.protocols.splice(index,1);
    } else {
      $scope.selectedSSLProfile.protocols.push(protocol);
    }
    $scope.sslProfileForm.$setDirty();
  };

  $scope.toggleFeature = function(feature) {
    var index = $scope.selectedSSLProfile.features.indexOf(feature);
    if (index > -1) {
      $scope.selectedSSLProfile.features.splice(index, 1);
    } else {
      $scope.selectedSSLProfile.features.push(feature);
    }
    $scope.sslProfileForm.$setDirty();
  };

  $scope.refreshView = function() {
    var params = {};
    if ($rootScope.context == "apim"){
      params.orgId = $rootScope.orgId;
    }
    params.objId = $scope.selectedSSLProfile.id;
    var currentProfile = SSLProfile.get(params);
    currentProfile.$promise.then(function(data) {
      $scope.selectedSSLProfile = data;
    });
  };

  $scope.showKeyUpload = function(evt) {
    // perform a navigate check - cant have unsaved changes when we upload a cert
    $scope.onNavigateOut($scope.selectedSSLProfile).then(function(navigate) {
      // user wants to navigate
      if (navigate) {
        $scope.saveDisabled = true;
        $scope.$broadcast("SSL_discarded");
        $mdDialog.show({
          controller: 'CertDialogController',
          templateUrl: 'apim/ssl/partials/uploadCert.html',
          parent: angular.element(document.body),
          targetEvent: evt,
          locals: {
            keyCert: true,
            outerScope: $scope
          }
        }).then(function() {
        }, function() {
          // cancelled upload, but we still must refresh view as we discarded changes
          $scope.$parent.preSelectProfile = $scope.selectedSSLProfile.id;
          $scope.refreshProfiles();
        });
      }
    }, function() {
      // user doesn't want to discard changes - nothing to do
    });
  };

  $scope.showTrustUpload = function(evt) {
    // perform a navigate check - cant have unsaved changes when we upload a cert
    $scope.onNavigateOut($scope.selectedSSLProfile).then(function(navigate) {
      // user wants to navigate
      if (navigate) {
        $scope.saveDisabled = true;
        $scope.$broadcast("SSL_discarded");
        $mdDialog.show({
          controller: 'CertDialogController',
          templateUrl: 'apim/ssl/partials/uploadCert.html',
          parent: angular.element(document.body),
          targetEvent: evt,
          locals: {
            keyCert: false,
            outerScope: $scope
          }
        }).then(function() {
        }, function() {
          // cancelled upload, but we still must refresh view as we discarded changes
          $scope.$parent.preSelectProfile = $scope.selectedSSLProfile.id;
          $scope.refreshProfiles();
        });
      }
    }, function() {
      // user doesn't want to discard changes - nothing to do
    });
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.sslProfileForm || $scope.sslProfileForm.$invalid || $scope.sslProfileForm.$pristine) {
      canSave = false;
    }
    $scope.$emit("SSL_canSave", canSave);
  };

  // called from parent scope when the IDP has been successfully saved
  $scope.sslSaved = function() {
    // mark the form as clean again
    $scope.sslProfileForm.$setPristine();
  };

  // set name when title has the value changed by the user (and not when the data is loaded)
  $scope.titleKeyPressed = function() {
    // timeout so $digest can happen and value is what was typed
    $timeout(function() {
      $scope.selectedSSLProfile.name = $rootScope.generateName($scope.selectedSSLProfile.title);
    });
  };

  $scope.$watch('sslProfileForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('sslProfileForm.$pristine', $scope.handleFormUpdate);
  $scope.$on("SSL_saved", $scope.sslSaved);
  $scope.$on("SSL_discarded", $scope.sslSaved);
};

sslProfiles.controller('CertDialogController', ['$scope', '$mdDialog', 'keyCert', 'outerScope', certDialogController]);

function certDialogController($scope, $mdDialog, keyCert, outerScope) {
  $scope.performingUpload = false;
  $scope.cancel = function() {
    $mdDialog.cancel();
  };
  $scope.upload = function() {
    var data = {
      password: $scope.password,
      selectedFiles: $scope.certFiles
    };
    $scope.performingUpload = true;
    if (keyCert) {
      outerScope.uploadKeyCert($scope, data);
    } else {
      outerScope.uploadTrustCert($scope, data);
    }
  };
};

sslProfiles.controller('KeyCertUploadController', ['$scope', KeyCertUploadController]);

function KeyCertUploadController($scope) {
  $scope.performingUpload = false;
  $scope.upload = function() {
    var data = {
      password: $scope.password,
      selectedFiles: $scope.certFiles
    };
    $scope.performingUpload = true;
    $scope.uploadKeyCert($scope, data, false);
  };
};

sslProfiles.controller('TrustCertUploadController', ['$scope', TrustCertUploadController]);

function TrustCertUploadController($scope) {
  $scope.performingUpload = false;
  $scope.upload = function() {
    var data = {
      password: $scope.password,
      selectedFiles: $scope.certFiles
    };
    $scope.$emit('file_upload_started');
    $scope.uploadTrustCert($scope, data, false);
  };
};

