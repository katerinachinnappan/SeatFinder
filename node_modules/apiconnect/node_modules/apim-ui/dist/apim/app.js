/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

  /* global networkMode */
'use strict';

// application Constants
var CONST = {
  UNTRACKED_MODULES: [], // modules we do not want to track in intercom
  APIM_SEGMENTIO_WRITE_KEY: 'TpI4UgkwYM2gmXwMTXLDaqobQILIwCvr'
};

var apimDependencies = [
  'apim.core',
  'apim.account',
  'apim.errors',
  'apim.analytics',
  'apim.apis',
  'apim.components',
  'apim.apps',
  'apiconnect-assembly',
  'apiconnect-assembly-test',
  'apim.catalogs',
  'apim.community',
  'apim.deployment',
  'apim.developers',
  'apim.environments',
  'apim.explorer',
  'apim.idps',
  'apim.log',
  'apim.notifications',
  'apim.objects',
  'apim.products',
  'apic.projects',
  'apim.styleguide',
  'apim.subscriptions',
  'apim.templates',
  'apim.tls',
  'apim.users',
  'apim.models',
  'apim.datasources',
  'apim.runner',
  'apim.common',
  'apim.securegateways',
  'apic.amp',
  'apic.uiSelectList',
  'bluemix.components',
  'pascalprecht.translate',
  'ui.bootstrap',
  'ui.uploader',
  'ui.router',
  'ngMaterial',
  'ngAnimate',
  'angular-clipboard',
  'ngMessages',
  'angular-inview',
  'localization',
  'ngResource',
  'ngSanitize',
  'mohsen1.schema-form',
  'mohsen1.json-schema-view',
  'hc.marked',
  'hljs',
  'ui.ace',
  'infinite-scroll',
  'luegg.directives',
  'apim.drafts',
  'apim.dashboard',
  'apim.admin',
  'apim.billing',
  'apim.favourites'
];

if (window.isExplorer) {
  apimDependencies.push('apiconnect-explorer');
}

angular.module('apim', apimDependencies)
  .constant("moment", moment)
  .run([
    '$rootScope',
    '$mdDialog',
    '$http',
    '$modal',
    '$log',
    '$state',
    'translateMultipleFilter',
    'sinceFilter',
    'CurrentUser',
    'ProjectsServices',
    'SlugService',
    '$translate',
    '$timeout',
    '$localStorage',
    '$mdComponentRegistry',
    'TrackingServices',
    '$window',
    function(
      $rootScope,
      $mdDialog,
      $http,
      $modal,
      $log,
      $state,
      translateMultipleFilter,
      sinceFilter,
      CurrentUser,
      ProjectsServices,
      SlugService,
      $translate,
      $timeout,
      $localStorage,
      $mdComponentRegistry,
      TrackingServices,
      $window
    ) {
      // queue up XHRs that happen while we're out of session
      $rootScope.queuedXhrs = [];
      $rootScope.loginOpen = false;
      $rootScope.context = "apim";

      var locale = $translate.preferredLanguage();
      var langMap = {
        "zh": "zh-cn"
      };
      // need to promote the most-specific supported locale into moment to get regional variants
      var specificLang = null;
      if (angular.isArray(navigator.languages)) {
        var len = navigator.languages.length;
        for (var i = 0; i < len; i++) {
          var language = navigator.languages[i];
          if (language && language.length) {
            specificLang = language;
            break;
          }
        } // end for
      } else if (typeof(localStorage) !== "undefined") {
        var userLocale = localStorage.getItem("apim-client-locale");
        if (userLocale) {
          specificLang = userLocale;
        }
      }
      if (specificLang) {
        if (specificLang.substr(0,locale.length) == locale) {
          langMap[locale] = specificLang;
        }
      }
      if (locale) moment.locale(langMap[locale] || locale);

      $rootScope.offlineMode = networkMode === 'offline';
      $rootScope.disableLeftNav = false;


      if ($rootScope.offlineMode === true) {
        document.title = "API Designer - IBM API Connect";
      } else {
        document.title = "API Manager - IBM API Connect";
      }


      $rootScope.isOffline = function() {
        return $rootScope.offlineMode;
      };

      $rootScope.$on('event:showLogin', function() {
        if (!$rootScope.loginOpen) {
          $rootScope.loginOpen = true;
          $mdDialog.show({
            controller: 'LoginDialogController',
            templateUrl: 'apim/partials/login.html',
            parent: angular.element(document.body),
            focusOnOpen: false,
            escapeToClose: false,
            locals: {
              outerScope: $rootScope
            }
          });
        }
      });

      $rootScope.$on('event:getProjects', function (){
        if (!$rootScope.offlineMode) return;

        ProjectsServices.getProjects()
          .then(function(data){
            $rootScope.projects = data.data;
            $timeout($state.reload);
          });
      });


      $rootScope.$on('event:loginSuccess', function() {
        // replay any queued requests
        var len = $rootScope.queuedXhrs.length;
        for (var i=0;i<len;i++) {
          var item = $rootScope.queuedXhrs[i];
          (function() {
            var request = item;
            $http(request.config).then(function(response) {
              request.def.resolve(response);
            });
          })();
        } // end for
        $rootScope.queuedXhrs = [];
        $rootScope.$emit('event:getProjects');
        $rootScope.$emit('event:sessionTimeout');
      });


      var displayingError = false;
      $rootScope.$on('event:showError', function(event, error, reload) {
        var scope = $rootScope.$new(true);

        scope.errorInfo = {
          titleKey: 'error',
          error: error,
          okPressed: function() {
            displayingError = false;
            if (reload == true) {
              window.location.reload();
            }
          }
        };

        if (typeof error === 'string') {
          scope.errorInfo.error = error;
        } else if (angular.isObject(error)) {
          scope.errorInfo = angular.extend(scope.errorInfo, error);
        }

        if (!displayingError) {
          displayingError = true;
          $modal.open({
            templateUrl: 'apim/partials/error-message.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'ErrorMessageController',
            scope: scope,
            backdrop: 'static'
          });
        }
      });

      $rootScope.$on('$stateChangeStart', function (event, next, nextParams, from, fromParams) {
        // track state changes
        var i = location.href.indexOf('#');
        var baseUrl = i === -1 ? location.href : location.href.slice(0, i);
        $rootScope.previousUrl = baseUrl + $state.href(from.name, fromParams);
        $rootScope.nextState = next;
        trackRouteChange(event, next);
      });

      $rootScope.backLinkHref = '/';
      $rootScope.$on('$stateChangeSuccess', function (
        evt, to, toParams, from, fromParams
      ) {
        $mdComponentRegistry.when('mainNav').then(function(nav){
          nav.close();
        });

        if (from.name && from.name !== to.name) {
          $rootScope.backLinkHref = $state.href(from, fromParams) || '/';
        }

        if ($rootScope.isOffline()) {
          $timeout(function(){
            var bottomMargin = angular.element(document.getElementsByTagName('apic-amp')).css('height');
            angular.element(document.getElementsByClassName('amp-margin')).css('margin-bottom', bottomMargin);
          });
        }
      });


      $rootScope.notificationArray = [];
      $rootScope.messages = [];
      $rootScope.notifyUser = function(messageKey, substitutions, type, autohide, replaceId, link, timer) {
        var latest = $rootScope.latestMessage
        if (latest && latest.id !== replaceId) {
          $rootScope.messages.unshift(latest);
        }

        var timestamp = Date.now();
        $rootScope.latestMessage = {
          text: translateMultipleFilter(messageKey, substitutions),
          type: type,
          timer: timer,
          timestamp: timestamp,
          time: sinceFilter(timestamp),
          id: replaceId,
          link: link
        };
        $rootScope.notificationArray.unshift($rootScope.latestMessage);
        // if (autohide == true) {
          //     setTimeout(function() {
            //         if (!$rootScope.latestMessage) return;
            //         $rootScope.messages.push($rootScope.latestMessage);
            //         delete $rootScope.latestMessage;
            //         $rootScope.$apply();
            //     }, 5000);
          // }
      };

      // converts strings to safe x-ibm-name values
      $rootScope.generateName = function(title) {
        var name = SlugService.createName(title);
        return name;
      };

      $rootScope.generateProjectName = function(displayName){
        var name = displayName.toLowerCase().replace(/[\s\\\/]+/gi, '-');
        name = name.replace(/[^A-Za-z0-9_\\-]/gi, '');
        name = name.replace(/^-|-$/gi, '');
        return name;
      };

      // This is a validation function for hostnames
      // Returns a boolean natch.
        // Any updates should also be reflected in cmc app.js as well as here
      $rootScope.validateHost = function(value) {
        if (!value) return true; // Null should return true incase it's an optional field
        // We need to allow local network names eg mymachine123.
          if (value.indexOf(".") < 0) {
            // Could be IPv6 or a local name
            return window.validator.isFQDN(value, {require_tld:false}) || window.validator.isIP(value, "6");
          } else {
            // Could be IPv4 or a FQDN
            return window.validator.isFQDN(value) || window.validator.isIP(value, "4");
          }
      };

      // =================================================================
        // Monkey patch JSYAML to fix line folding

      var common = {
        repeat: function(string, count) {
          var result = '', cycle;

          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }

          return result;
        },
        isNothing: function(subject) {
          return (typeof subject === 'undefined') || (null === subject);
        },
        extend: function(target, source) {
          var index, length, key, sourceKeys;

          if (source) {
            sourceKeys = Object.keys(source);

            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }

          return target;
        }
      };

      var _toString       = Object.prototype.toString;
      var _hasOwnProperty = Object.prototype.hasOwnProperty;

      var CHAR_TAB                  = 0x09; /* Tab */
        var CHAR_LINE_FEED            = 0x0A; /* LF */
        var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
        var CHAR_SPACE                = 0x20; /* Space */
        var CHAR_EXCLAMATION          = 0x21; /* ! */
        var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
        var CHAR_SHARP                = 0x23; /* # */
        var CHAR_PERCENT              = 0x25; /* % */
        var CHAR_AMPERSAND            = 0x26; /* & */
        var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
        var CHAR_ASTERISK             = 0x2A; /* * */
        var CHAR_COMMA                = 0x2C; /* , */
        var CHAR_MINUS                = 0x2D; /* - */
        var CHAR_COLON                = 0x3A; /* : */
        var CHAR_GREATER_THAN         = 0x3E; /* > */
        var CHAR_QUESTION             = 0x3F; /* ? */
        var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
        var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
          var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
        var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
        var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
          var CHAR_VERTICAL_LINE        = 0x7C; /* | */
          var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

        var ESCAPE_SEQUENCES = {};

      ESCAPE_SEQUENCES[0x00]   = '\\0';
      ESCAPE_SEQUENCES[0x07]   = '\\a';
      ESCAPE_SEQUENCES[0x08]   = '\\b';
      ESCAPE_SEQUENCES[0x09]   = '\\t';
      ESCAPE_SEQUENCES[0x0A]   = '\\n';
      ESCAPE_SEQUENCES[0x0B]   = '\\v';
      ESCAPE_SEQUENCES[0x0C]   = '\\f';
      ESCAPE_SEQUENCES[0x0D]   = '\\r';
      ESCAPE_SEQUENCES[0x1B]   = '\\e';
      ESCAPE_SEQUENCES[0x22]   = '\\"';
      ESCAPE_SEQUENCES[0x5C]   = '\\\\';
      ESCAPE_SEQUENCES[0x85]   = '\\N';
      ESCAPE_SEQUENCES[0xA0]   = '\\_';
      ESCAPE_SEQUENCES[0x2028] = '\\L';
      ESCAPE_SEQUENCES[0x2029] = '\\P';

      var DEPRECATED_BOOLEANS_SYNTAX = [
        'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
        'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
      ];

      function compileStyleMap(schema, map) {
        var result, keys, index, length, tag, style, type;

        if (null === map) {
          return {};
        }

        result = {};
        keys = Object.keys(map);

        for (index = 0, length = keys.length; index < length; index += 1) {
          tag = keys[index];
          style = String(map[tag]);

          if ('!!' === tag.slice(0, 2)) {
            tag = 'tag:yaml.org,2002:' + tag.slice(2);
          }

          type = schema.compiledTypeMap[tag];

          if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
          }

          result[tag] = style;
        }

        return result;
      }

      function encodeHex(character) {
        var string, handle, length;

        string = character.toString(16).toUpperCase();

        if (character <= 0xFF) {
          handle = 'x';
          length = 2;
        } else if (character <= 0xFFFF) {
          handle = 'u';
          length = 4;
        } else if (character <= 0xFFFFFFFF) {
          handle = 'U';
          length = 8;
        } else {
          throw new jsyaml.YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
        }

        return '\\' + handle + common.repeat('0', length - string.length) + string;
      }

      function State(options) {
        this.schema      = options['schema'] || jsyaml.DEFAULT_FULL_SCHEMA;
        this.indent      = Math.max(1, (options['indent'] || 2));
        this.skipInvalid = options['skipInvalid'] || false;
        this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
        this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);
        this.sortKeys    = options['sortKeys'] || false;
        this.lineWidth    = options['lineWidth'] || 80;

        this.implicitTypes = this.schema.compiledImplicit;
        this.explicitTypes = this.schema.compiledExplicit;

        this.tag = null;
        this.result = '';

        this.duplicates = [];
        this.usedDuplicates = null;
      }

      function indentString(string, spaces) {
        var ind = common.repeat(' ', spaces),
          position = 0,
          next = -1,
          result = '',
          line,
          length = string.length;

        while (position < length) {
          next = string.indexOf('\n', position);
          if (next === -1) {
            line = string.slice(position);
            position = length;
          } else {
            line = string.slice(position, next + 1);
            position = next + 1;
          }
          if (line.length && line !== '\n') {
            result += ind;
          }
          result += line;
        }

        return result;
      }

      function generateNextLine(state, level) {
        return '\n' + common.repeat(' ', state.indent * level);
      }

      function testImplicitResolving(state, str) {
        var index, length, type;

        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
          type = state.implicitTypes[index];

          if (type.resolve(str)) {
            return true;
          }
        }

        return false;
      }

      function StringBuilder(source) {
        this.source = source;
        this.result = '';
        this.checkpoint = 0;
      }

      StringBuilder.prototype.takeUpTo = function (position) {
        var er;

        if (position < this.checkpoint) {
          er = new Error('position should be > checkpoint');
          er.position = position;
          er.checkpoint = this.checkpoint;
          throw er;
        }

        this.result += this.source.slice(this.checkpoint, position);
        this.checkpoint = position;
        return this;
      };

      StringBuilder.prototype.escapeChar = function () {
        var character, esc;

        character = this.source.charCodeAt(this.checkpoint);
        esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
        this.result += esc;
        this.checkpoint += 1;

        return this;
      };

      StringBuilder.prototype.finish = function () {
        if (this.source.length > this.checkpoint) {
          this.takeUpTo(this.source.length);
        }
      };

      function writeScalar(state, object, level, iskey) {
        var simple, first, spaceWrap, folded, literal, single, double,
          sawLineFeed, linePosition, longestLine, indent, max, character,
          position, escapeSeq, hexEsc, previous, lineLength, modifier,
          trailingLineBreaks, result;

        if (0 === object.length) {
          state.dump = "''";
          return;
        }

        if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
          state.dump = "'" + object + "'";
          return;
        }

        simple = true;
        first = object.length ? object.charCodeAt(0) : 0;
        spaceWrap = (CHAR_SPACE === first ||
          CHAR_SPACE === object.charCodeAt(object.length - 1));

        // Simplified check for restricted first characters
        // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
        if (CHAR_MINUS         === first ||
          CHAR_QUESTION      === first ||
          CHAR_COMMERCIAL_AT === first ||
          CHAR_GRAVE_ACCENT  === first) {
            simple = false;
        }

        // can only use > and | if not wrapped in spaces or is not a key.
          if (spaceWrap) {
            simple = false;
            folded = false;
            literal = false;
          } else {
            folded = !iskey;
            literal = !iskey;
          }

        single = true;
        double = new StringBuilder(object);

        sawLineFeed = false;
        linePosition = 0;
        longestLine = 0;

        indent = state.indent * level;
        max = state.lineWidth;
        if (max === -1) {
          // Replace -1 with biggest ingeger number according to
          // http://ecma262-5.com/ELS5_HTML.htm#Section_8.5
          max = 9007199254740991;
        }

        if (indent < 40) {
          max -= indent;
        } else {
          max = 40;
        }

        for (position = 0; position < object.length; position++) {
          character = object.charCodeAt(position);
          if (simple) {
            // Characters that can never appear in the simple scalar
            if (!simpleChar(character)) {
              simple = false;
            } else {
              // Still simple.  If we make it all the way through like
              // this, then we can just dump the string as-is.
                continue;
            }
          }

          if (single && character === CHAR_SINGLE_QUOTE) {
            single = false;
          }

          escapeSeq = ESCAPE_SEQUENCES[character];
          hexEsc = needsHexEscape(character);

          if (!escapeSeq && !hexEsc) {
            continue;
          }

          if (character !== CHAR_LINE_FEED &&
            character !== CHAR_DOUBLE_QUOTE &&
            character !== CHAR_SINGLE_QUOTE) {
              folded = false;
              literal = false;
          } else if (character === CHAR_LINE_FEED) {
            sawLineFeed = true;
            single = false;
            if (position > 0) {
              previous = object.charCodeAt(position - 1);
              if (previous === CHAR_SPACE) {
                literal = false;
                folded = false;
              }
            }
            if (folded) {
              lineLength = position - linePosition;
              linePosition = position;
              if (lineLength > longestLine) {
                longestLine = lineLength;
              }
            }
          }

          if (character !== CHAR_DOUBLE_QUOTE) {
            single = false;
          }

          double.takeUpTo(position);
          double.escapeChar();
        }

        if (simple && testImplicitResolving(state, object)) {
          simple = false;
        }

        modifier = '';
        if (folded || literal) {
          trailingLineBreaks = 0;
          if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
            trailingLineBreaks += 1;
            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
              trailingLineBreaks += 1;
            }
          }

          if (trailingLineBreaks === 0) {
            modifier = '-';
          } else if (trailingLineBreaks === 2) {
            modifier = '+';
          }
        }

        if (literal && longestLine < max) {
          folded = false;
        }

        // If it's literally one line, then don't bother with the literal.
          // We may still want to do a fold, though, if it's a super long line.
          if (!sawLineFeed) {
            literal = false;
          }

        if (simple) {
          state.dump = object;
        } else if (single) {
          state.dump = '\'' + object + '\'';
        } else if (folded) {
          result = fold(object, max);
          state.dump = '>' + modifier + '\n' + indentString(result, indent);
        } else if (literal) {
          if (!modifier) {
            object = object.replace(/\n$/, '');
          }
          state.dump = '|' + modifier + '\n' + indentString(object, indent);
        } else if (double) {
          double.finish();
          state.dump = '"' + double.result + '"';
        } else {
          throw new Error('Failed to dump scalar value');
        }

        return;
      }

      // ********** Fixed fold function ****************
        function fold(object, max) {
          var result = '', position = 0, length = object.length, trailing = /\n+$/.exec(object), newLine;

          if (trailing) {
            length = trailing.index + 1;
          }

          var extraIndent = false;
          while (position < length) {
            newLine = object.indexOf('\n', position);
            if (newLine > length || newLine === -1) {
              if (result) {
                result += '\n\n';
              }
              result += foldLine(object.slice(position, length), max);
              position = length;
            } else {
              var line = object.slice(position, newLine);
              if (result.length == 0) {
                result = foldLine(line, max);
              } else {
                if (line.length == 0) {
                  result += '\n';
                } else {
                  var folded = foldLine(line, max);
                  var lineStart = line.charAt(0);
                  if (lineStart == ' ' || lineStart == '\t') {
                    result += '\n';
                    extraIndent = true;
                  } else {
                    if (extraIndent) {
                      result += '\n';
                      extraIndent = false;
                    } else {
                      result += '\n\n';
                    }
                  }
                  result += folded;
                }
              }
              position = newLine + 1;
            }
          }
          if (trailing && trailing[0] !== '\n') {
            result += trailing[0];
          }

          return result;
        }

      function foldLine(line, max) {
        if (line === '') {
          return line;
        }

        var foldRe = /[^\s] [^\s]/g,
          result = '',
          prevMatch = 0,
          foldStart = 0,
          match = foldRe.exec(line),
          index,
          foldEnd,
          folded;

        while (match) {
          index = match.index;

          // when we cross the max len, if the previous match would've
          // been ok, use that one, and carry on.  If there was no previous
          // match on this fold section, then just have a long line.
            if (index - foldStart > max) {
              if (prevMatch !== foldStart) {
                foldEnd = prevMatch;
              } else {
                foldEnd = index;
              }

              if (result) {
                result += '\n';
              }
              folded = line.slice(foldStart, foldEnd);
              result += folded;
              foldStart = foldEnd + 1;
            }
          prevMatch = index + 1;
          match = foldRe.exec(line);
        }

        if (result) {
          result += '\n';
        }

        // if we end up with one last word at the end, then the last bit might
        // be slightly bigger than we wanted, because we exited out of the loop.
          if (foldStart !== prevMatch && line.length - foldStart > max) {
            result += line.slice(foldStart, prevMatch) + '\n' +
              line.slice(prevMatch + 1);
          } else {
            result += line.slice(foldStart);
          }

        return result;
      }

      // Returns true if character can be found in a simple scalar
      function simpleChar(character) {
        return CHAR_TAB                  !== character &&
          CHAR_LINE_FEED            !== character &&
          CHAR_CARRIAGE_RETURN      !== character &&
          CHAR_COMMA                !== character &&
          CHAR_LEFT_SQUARE_BRACKET  !== character &&
          CHAR_RIGHT_SQUARE_BRACKET !== character &&
          CHAR_LEFT_CURLY_BRACKET   !== character &&
          CHAR_RIGHT_CURLY_BRACKET  !== character &&
          CHAR_SHARP                !== character &&
          CHAR_AMPERSAND            !== character &&
          CHAR_ASTERISK             !== character &&
          CHAR_EXCLAMATION          !== character &&
          CHAR_VERTICAL_LINE        !== character &&
          CHAR_GREATER_THAN         !== character &&
          CHAR_SINGLE_QUOTE         !== character &&
          CHAR_DOUBLE_QUOTE         !== character &&
          CHAR_PERCENT              !== character &&
          CHAR_COLON                !== character &&
          !ESCAPE_SEQUENCES[character]            &&
          !needsHexEscape(character);
      }

      // Returns true if the character code needs to be escaped.
        function needsHexEscape(character) {
          return !((0x00020 <= character && character <= 0x00007E) ||
            (0x00085 === character)                         ||
            (0x000A0 <= character && character <= 0x00D7FF) ||
            (0x0E000 <= character && character <= 0x00FFFD) ||
            (0x10000 <= character && character <= 0x10FFFF));
        }

      function writeFlowSequence(state, level, object) {
        var _result = '',
          _tag    = state.tag,
          index,
          length;

        for (index = 0, length = object.length; index < length; index += 1) {
          // Write only valid elements.
            if (writeNode(state, level, object[index], false, false)) {
              if (0 !== index) {
                _result += ', ';
              }
              _result += state.dump;
            }
        }

        state.tag = _tag;
        state.dump = '[' + _result + ']';
      }

      function writeBlockSequence(state, level, object, compact) {
        var _result = '',
          _tag    = state.tag,
          index,
          length;

        for (index = 0, length = object.length; index < length; index += 1) {
          // Write only valid elements.
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || 0 !== index) {
                _result += generateNextLine(state, level);
              }
              _result += '- ' + state.dump;
            }
        }

        state.tag = _tag;
        state.dump = _result || '[]'; // Empty sequence if no valid values.
      }

      function writeFlowMapping(state, level, object) {
        var _result       = '',
          _tag          = state.tag,
          objectKeyList = Object.keys(object),
          index,
          length,
          objectKey,
          objectValue,
          pairBuffer;

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          pairBuffer = '';

          if (0 !== index) {
            pairBuffer += ', ';
          }

          objectKey = objectKeyList[index];
          objectValue = object[objectKey];

          if (!writeNode(state, level, objectKey, false, false)) {
            continue; // Skip this pair because of invalid key;
          }

          if (state.dump.length > 1024) {
            pairBuffer += '? ';
          }

          pairBuffer += state.dump + ': ';

          if (!writeNode(state, level, objectValue, false, false)) {
            continue; // Skip this pair because of invalid value.
          }

          pairBuffer += state.dump;

          // Both key and value are valid.
            _result += pairBuffer;
        }

        state.tag = _tag;
        state.dump = '{' + _result + '}';
      }

      function writeBlockMapping(state, level, object, compact) {
        var _result       = '',
          _tag          = state.tag,
          objectKeyList = Object.keys(object),
          index,
          length,
          objectKey,
          objectValue,
          explicitPair,
          pairBuffer;

        // Allow sorting keys so that the output file is deterministic
        if (state.sortKeys === true) {
          // Default sorting
          objectKeyList.sort();
        } else if (typeof state.sortKeys === 'function') {
          // Custom sort function
          objectKeyList.sort(state.sortKeys);
        } else if (state.sortKeys) {
          // Something is wrong
          throw new jsyaml.YAMLException('sortKeys must be a boolean or a function');
        }

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          pairBuffer = '';

          if (!compact || 0 !== index) {
            pairBuffer += generateNextLine(state, level);
          }

          objectKey = objectKeyList[index];
          objectValue = object[objectKey];

          if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue; // Skip this pair because of invalid key.
          }

          explicitPair = (null !== state.tag && '?' !== state.tag) ||
            (state.dump && state.dump.length > 1024);

          if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += '?';
            } else {
              pairBuffer += '? ';
            }
          }

          pairBuffer += state.dump;

          if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
          }

          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue; // Skip this pair because of invalid value.
          }

          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ':';
          } else {
            pairBuffer += ': ';
          }

          pairBuffer += state.dump;

          // Both key and value are valid.
            _result += pairBuffer;
        }

        state.tag = _tag;
        state.dump = _result || '{}'; // Empty mapping if no valid pairs.
      }

      function detectType(state, object, explicit) {
        var _result, typeList, index, length, type, style;

        typeList = explicit ? state.explicitTypes : state.implicitTypes;

        for (index = 0, length = typeList.length; index < length; index += 1) {
          type = typeList[index];

          if ((type.instanceOf  || type.predicate) &&
            (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
            (!type.predicate  || type.predicate(object))) {

              state.tag = explicit ? type.tag : '?';

              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;

                if ('[object Function]' === _toString.call(type.represent)) {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new jsyaml.YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }

                state.dump = _result;
              }

              return true;
          }
        }

        return false;
      }

      // Serializes `object` and writes it to global `result`.
        // Returns true on success, or false on invalid object.
        //
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;

          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }

          var type = _toString.call(state.dump);

          if (block) {
            block = (0 > state.flowLevel || state.flowLevel > level);
          }

          var objectOrArray = '[object Object]' === type || '[object Array]' === type,
            duplicateIndex = 0,
            duplicate = 0;

          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }

          if ((null !== state.tag && '?' !== state.tag) || duplicate || (2 !== state.indent && level > 0)) {
            compact = false;
          }

          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = '*ref_' + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if ('[object Object]' === type) {
              if (block && (0 !== Object.keys(state.dump).length)) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if ('[object Array]' === type) {
              if (block && (0 !== state.dump.length)) {
                writeBlockSequence(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if ('[object String]' === type) {
              if ('?' !== state.tag) {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid) {
                return false;
              }
              throw new jsyaml.YAMLException('unacceptable kind of an object to dump ' + type);
            }
            if (null !== state.tag && '?' !== state.tag) {
              state.dump = '!<' + state.tag + '> ' + state.dump;
            }
          }
          return true;
        }

      function getDuplicateReferences(object, state) {
        var objects = [],
          duplicatesIndexes = [],
          index,
          length;

        inspectNode(object, objects, duplicatesIndexes);

        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
          state.duplicates.push(objects[duplicatesIndexes[index]]);
        }
        state.usedDuplicates = new Array(length);
      }

      function inspectNode(object, objects, duplicatesIndexes) {
        var objectKeyList,
          index,
          length;

        if (null !== object && 'object' === typeof object) {
          index = objects.indexOf(object);
          if (-1 !== index) {
            if (-1 === duplicatesIndexes.indexOf(index)) {
              duplicatesIndexes.push(index);
            }
          } else {
            objects.push(object);

            if (Array.isArray(object)) {
              for (index = 0, length = object.length; index < length; index += 1) {
                inspectNode(object[index], objects, duplicatesIndexes);
              }
            } else {
              objectKeyList = Object.keys(object);

              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
              }
            }
          }
        }
      }

      function dump(input, options) {
        options = options || {};

        var state = new State(options);

        getDuplicateReferences(input, state);

        if (writeNode(state, 0, input, true, true)) {
          return state.dump + '\n';
        }
        return '';
      }

      function safeDump(input, options) {
        return dump(input, common.extend({ schema: jsyaml.DEFAULT_SAFE_SCHEMA }, options));
      }

      // Now patch the original function
      jsyaml.safeDump = safeDump;


      // =================================================================

        // restore any hash that was supplied in the initial login URL
      try {
        var urlhash = localStorage.getItem("urlhash");
        if (urlhash) {
          window.location.hash = urlhash;
          localStorage.removeItem("urlhash");
        }
      } catch(e) {
      }

      function trackUser (writeKey){
        TrackingServices.load(writeKey)
          .then(function(){
            return CurrentUser.query().$promise;
          })
          .then(function(currentUser){
            $rootScope.currentUser = currentUser;
            if (currentUser) {
              return TrackingServices.identify(currentUser);
            }
          })
          .catch(function(err){
            $log.log('tracking disabled', err);
          });
      }

      function startTracking(){
        // force get analytics flag and installation id when app loads
        if ($rootScope.isOffline()){
          TrackingServices.getEnableAnalytics(true)
            .then(function(enabled){
              $rootScope.analytics = Boolean(enabled);
            })
            .then(function(){
              return TrackingServices.getAnalyticsKey()
                .then(function(key){
                  CONST.SEGMENTIO_WRITE_KEY = key;
                })
            })
            .then(function(){
              return TrackingServices.getId(true)
                .then(function(data){
                  $rootScope.installationId = data;
                });
            })
            .then(function(){
              trackUser(CONST.SEGMENTIO_WRITE_KEY)
            })
            .catch(function(err){
              $localStorage.setItem('enable-analytics', false);
            });
        }
        else if ($window.isSaaS){
           TrackingServices.setEnableAnalytics(true)
             .then(function(){
               return new Promise(function(resolve, reject) {
                 $rootScope.$watch('bluemixExternalSpaceId', function(newVal) {
                   if (newVal){
                     resolve();
                   }
                 })
              })
            }).then(function(){
                trackUser(CONST.APIM_SEGMENTIO_WRITE_KEY);
              });
        }
      }

      function trackRouteChange(event, next){
        if ($rootScope.isOffline() || $window.isSaaS){
          TrackingServices.getEnableAnalytics()
            .then(function(enabled){
              $rootScope.analytics = Boolean(enabled);
            })
            .then(function(){
              return TrackingServices.getId()
                .then(function(data){
                  $rootScope.installationId = data;
                });
            })
            .then(function(){
              return TrackingServices.page('route', next.name);
            });
        }
      }

      startTracking();

    }]).config(['$httpProvider', '$locationProvider', function($httpProvider, $locationProvider) {
      // disable link rewriting as it will cause a digest conflict with the API explorer on
      // navigation clicks.
        $locationProvider.html5Mode({
          rewriteLinks: false
        });

      $httpProvider.interceptors.push(['$q', 'errorHandler', function($q, errorHandler) {
        return {
          'response': function(response) {
            return errorHandler.checkResponse(response);
          },
          'responseError': function(rejection) {
            if (rejection && rejection.config && rejection.config.skipErrorCheck == true) {
              return $q.reject(rejection);
            }
            return errorHandler.checkResponse(rejection);
          }
        };
      }]);
    }]);
