/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apim.core').filter('messageType', ['translateFilter', function (translateFilter) {
  return function(messageType) {
    var ret = null;
    if (messageType) {
      switch (messageType) {
        case "ERROR":
          ret = translateFilter("message_error");
          break;
        case "SUCCESS":
          ret = translateFilter("message_success");
          break;
        case "INFO":
          ret = translateFilter("message_info");
          break;
      } // end switch
    }
    return ret;
  };
}]).filter('filterIcon', function () {
  return function(filtered) {
    if (filtered) return 'close';
    return'filter_list';
  };
}).filter('addTempId', function () {
  return function(objects){
    if (!objects) return objects;
    var idObjects = {};
    angular.forEach(objects, function(theObject, name) {
      if (typeof theObject == "object") {
        idObjects[name] = theObject;
        if (!idObjects[name]["$$apim-temp-id"]) idObjects[name]["$$apim-temp-id"] = name + new Date().getTime();
      }
    });
    return idObjects;
  };
}).filter('checkmark', function() {
  return function(input) {
    return input ? '\u2713' : '\u2718';
  };
}).filter('orgToTag', function() {
  return function (orgs) {
    var tags = [];
    orgs.forEach(function(org) {
      tags.push({
        value: org.id,
        deletable: true,
        className: "orgTag smallTag",
        label: org.displayName,
        org: org
      });
    });
    return tags;
  };
}).filter('unique', function() {
  return function (items, field, count) {
    if(!items) return items;
    // Stick items in an object to make them unique
    var map = {};
    var undefinedCounter = 0;
    var item;
    for(var i=0; i<items.length; i++) {
      item = items[i];
      var split = field.split('.');
      var j = 0;
      var key = item;
      while (j < split.length) {
        key = key[split[j]];
        j++;
      }
      // ensure something unique is set if undefined
      if (!key) key = undefinedCounter++;
      if(!map[key]) {
        items[i].count = 1;
        map[key] = items[i];
      } else {
        map[key].count++;
      }
    }
    // Then stick back in an array
    var result = [];
    for(item in map) {
      result.push(map[item]);
    }
    return result;
  };
}).filter('urlEncode', function() {
  return window.encodeURIComponent;
}).filter('findInArray', function() {
  return function(items, property, value) {
    var filtered = items.filter(function(item) {
      return (item[property] == value);
    });
    if (filtered.length == 1) return filtered[0];
    return null;
  };
}).filter('getPropertyFromId', function() {
  return function(id, items, idPropertyName, propertyName, altPropertyName) {
    if(!items) return id;
    var filtered = items.filter(function(item) {
      return (item[idPropertyName] == id);
    });
    if (filtered.length == 1) {
      var ret = filtered[0][propertyName];
      // if the primary property resolves as empty then try the alternate property
      if (!ret && altPropertyName && filtered[0][altPropertyName]) {
        ret = filtered[0][altPropertyName];
      }
      return ret;
    }
    return null;
  };
}).filter('equalOrNull', function() {
  return function (items, propertyName, propertyValue) {
    if(!items || !propertyValue) return items;
    var result = [];
    for(var i=0; i<items.length; i++) {
      var item = items[i];
      if (items[i][propertyName] == propertyValue) result.push(items[i]);
    }
    return result;
  };
}).filter('withinDateRange', function() {
  return function (items, startDate, endDate) {
    if(!items || !startDate || !endDate) return items;
    // Stick items in an object to make them unique
    var result = [];
    for(var i=0; i<items.length; i++) {
      var itemDate = new Date(items[i].datetime);
      if(itemDate >= startDate && itemDate <= endDate) {
        result.push(items[i]);
      }
    }
    return result;
  };
}).filter('notInArray', function() {
  return function (items, existing) {
    if (!items) return;
    if (!existing) return items;
    return items.filter(function(item) {
      return (existing.indexOf(item) == -1);
    });
  };
}).filter('notInArrayByField', function() {
  return function (items, existing, property) {
    if (!items) return;
    if (!existing) return items;
    return items.filter(function(item) {
      for (var i = 0; i < existing.length; i++) {
        if (existing[i][property] == item[property]) return false;
      }
      return true;
    });
  };
}).filter('since', ['moment', function(moment) {
  return function (value) {
    // prevent future dates due to minor clock differences
    var theDate = new moment(value);
    var nowDate = new moment();
    if (theDate.isAfter(nowDate)) {
      return nowDate.fromNow();
    } else {
      return theDate.fromNow();
    }
  };
}]).filter('dateformat', ['moment', function(moment) {
  return function (value, formatString, utcTime) {
    if(utcTime) return moment.utc(value).format(formatString);
    return moment(value).format(formatString);
  };
}]).filter('utcDate', ['moment', function(moment) {
  return function (value) {
    return moment.utc(value);
  };
}]).filter('paginate', function() {
  return function(items, page, itemsPerPage) {
    if(!items) return items;
    if(!itemsPerPage) itemsPerPage = 5;
    var firstItem = page * itemsPerPage;
    var lastItem = firstItem + itemsPerPage;
    var slicedArray = items.slice(firstItem, lastItem);
    return slicedArray;
  };
}).filter('prettify', ['nls', function(nls) {
  return function (text) {
    //text = "<?xml version=\”1.0\” encoding=\”UTF-8\”?><CATALOG><PLANT><COMMON>Bloodroot</COMMON><BOTANICAL>Sanguinaria canadensis</BOTANICAL><ZONE>4</ZONE><LIGHT>Mostly Shady</LIGHT><PRICE>$2.44</PRICE><AVAILABILITY>031599</AVAILABILITY></PLANT><PLANT><COMMON>Bloodroot</COMMON><BOTANICAL>Sanguinaria canadensis</BOTANICAL><ZONE>4</ZONE><LIGHT>Mostly Shady</LIGHT><PRICE>$2.44</PRICE><AVAILABILITY>031599</AVAILABILITY></PLANT></CATALOG>";
    if(!text || text.length == 0) return text;
    if (text.trim().indexOf("<") == 0) {
      // XML
      var formattedXml = '';
      var reg = /(>)(<)(\/*)/g;
      var xml = text.replace(reg, '$1\r\n$2$3');
      var pad = 0;
      var splitXml = xml.split('\r\n');
      splitXml.forEach(function(element) {
        var indent = 0;
        if (element.match( /.+<\/\w[^>]*>$/ )) {
          indent = 0;
        } else if (element.match( /^<\/\w/ )) {
          if (pad != 0) pad -= 1;
        } else if (element.match( /^<\w[^>]*[^\/]>.*$/ )) {
          indent = 1;
        } else {
          indent = 0;
        }

        var padding = '';
        for (var i=0; i<pad; i++) {
          padding += '    ';
        }

        formattedXml += padding + element + '\r\n';
        pad += indent;
      });

      return formattedXml;
    } else {
      // JSON
      var object = JSON.parse(text);
      return JSON.stringify(object, null, 4);
    }
  };
}]).filter('notEmpty', function() {
  return function(obj) {
    if(!obj) return obj;
    return Object.keys(obj).length > 0;
  };
});

var tagClasses = [
  "tag1", "tag2", "tag3", "tag4", "tag5", "tag6", "tag7",
  "tag8", "tag9", "tag10", "tag11", "tag12", "tag13", "tag14",
  "tag15", "tag16", "tag17", "tag18", "tag19"
];

var favouriteTag = {
  name: "favourite",
  label: "favourite",
  className: "favouriteTag"
};

var stringToInt = function(asString) {
  var asInt = 0;
  for (var a = 0; a < asString.length; a = a + 1) {
    asInt += asString.charCodeAt(a);
  }
  return asInt;
};

var getClassForTag = function(tagName, translateFilter) {
  if (tagName == translateFilter(favouriteTag.name)) return favouriteTag.className;
  return tagClasses[stringToInt(tagName) % tagClasses.length];
};

angular.module('apim').filter('convertPlansToTags', function() {
  return function (plans) {
    var tags = [];
    plans.forEach(function(plan) {
      tags.push({
        value: plan.planId,
        className: "smallTag " + getClassForTag(plan.name),
        label: plan.name,
        deletable: true,
        plan: plan
      });
    });
    return tags;
  };
}).filter('communityToTag', ['translateFilter', function(translateFilter) {
  return function (communities, appendFavourite) {
    var tags = [];
    var favouriteTags = communities.filter(function(tag) {
      return (tag.name == translateFilter(favouriteTag.name));
    });
    if (favouriteTags.length == 0 && appendFavourite != false) {
      // push on a favourite tag
      tags.push({
        value: favouriteTag.name,
        label: translateFilter(favouriteTag.label),
        className: "smallTag " + favouriteTag.className,
        deletable: true,
        community: {
          value: favouriteTag.name,
          label: translateFilter(favouriteTag.label),
          className: "smallTag " + favouriteTag.className
        }
      });
    }
    communities.forEach(function(community) {
      tags.push({
        value: community.name,
        deletable: true,
        className: "smallTag " + getClassForTag(community.name, translateFilter),
        label: community.name,
        community: community
      });
    });
    return tags;
  };
}]).filter('constructTags', ['translateFilter', function(translateFilter) {
  return function (tagObjects, showCount, rootClass, noFavourite) {
    var tags = [];
    if (!rootClass) rootClass = "fixedWidthTag";
    if (!noFavourite) {
      // push on a favourite tag
      tags.push({
        value: favouriteTag.name,
        label: translateFilter(favouriteTag.label),
        className: rootClass + " " + favouriteTag.className
      });
    }
    tagObjects.forEach(function(tagObject) {
      tags.push({
        value: tagObject.name,
        className: rootClass + " " + getClassForTag(tagObject.name, translateFilter),
        label: tagObject.name,
        showCount: showCount,
        count: tagObject.count
      });
    });
    tags.push({
      value: "untagged",
      label: translateFilter('tagsUntagged'),
      className: rootClass + " untagged"
    });
    return tags;
  };
}]).filter('excludeUntagged', function() {
  return function (tags) {
    if (!tags) return [];
    return tags.filter(function(tag) {
      return (tag.value != "untagged");
    });
  };
}).filter('convertTags', ['translateFilter', function(translateFilter) {
  return function (tagObjects, favourites, itemId) {
    var tags = [];
    if (!tagObjects) return tags;
    // check if this item is a favourite
    if (favourites && favourites.developer && favourites.developer[itemId]) {
      tags.push({
        value: favouriteTag.name,
        className: "smallTag " + getClassForTag(favouriteTag.name, translateFilter),
        label: translateFilter(favouriteTag.label),
        deletable: true
      });
    }
    tagObjects.forEach(function(tagObject) {
      tags.push({
        value: tagObject.name,
        className: "smallTag " + getClassForTag(tagObject.name, translateFilter),
        label: (tagObject.name == favouriteTag.name) ? translateFilter(favouriteTag.label) : tagObject.name,
        deletable: true
      });
    });
    return tags;
  };
}]).filter('highlight', function() {
  var cleanAmp = new RegExp("&", "ig");
  var cleanLt = new RegExp("<", "ig");
  return function(input, matching) {
    if (!input || typeof input !== 'string') return;
    input = input.replace(cleanAmp, "&amp;");
    input = input.replace(cleanLt, "&lt;");
    if (!input || !matching || matching == "") return input;
    var reg = new RegExp(matching, "ig");
    return input.replace(reg, function(match, $1, $2, offset, original) { return '<span class="ui-match">' + match + '</span>';});
  };
}).filter('infiniteScroll', function() {
  return function(items, limit) {
    if (!items) return;
    if (items.length === 0) return items;
    if (limit >= items.length) return items;
    return items.splice(0, limit);
  };
});

