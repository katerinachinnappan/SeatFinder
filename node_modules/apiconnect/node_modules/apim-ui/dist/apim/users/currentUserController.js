/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var users = angular.module('apim.users');

users.controller('CurrentUserController', [
  '$scope',
  '$rootScope',
  '$window',
  '$modal',
  '$mdSidenav',
  '$log',
  '$state',
  '$q',
  '$timeout',
  '$localStorage',
  '$interval',
  '$http',
  'CurrentUser',
  'Permission',
  'Environment',
  'BluemixURLs',
  'SBSToken',
  'translateFilter',
  'translateMultipleFilter',
  'ProjectsServices',
  'ConfigServices',
  'FormFactor',
  'DirtyService',
  'RoleService',
  'TrackingServices',
  'currentUsersServices',
  'Bluemix',
  currentUserController]);

function currentUserController(
  $scope,
  $rootScope,
  $window,
  $modal,
  $mdSidenav,
  $log,
  $state,
  $q,
  $timeout,
  $localStorage,
  $interval,
  $http,
  CurrentUser,
  Permission,
  Environment,
  BluemixURLs,
  SBSToken,
  translateFilter,
  translateMultipleFilter,
  ProjectsServices,
  ConfigServices,
  FormFactor,
  DirtyService,
  RoleService,
  TrackingServices,
  currentUsersServices,
  Bluemix
) {
  $scope.location = $window.location;

  // automatically open chat if user has just clicked "Enable Live Chat"
  if ($localStorage.getItem('triggerChat')) {
    $localStorage.removeItem('triggerChat');
    $timeout(function(){
      if($window.Intercom) {
        $window.Intercom('show');
      }
    }, 2000);
  }

 //  check to see if there any pending http requests before reload
  $rootScope.$watch('analytics', function(newVal, oldVal){
    if(!isSaaS) {
      $scope.enableIntercom = newVal;
    }

    // skip reload if no change
    if (oldVal == null) return;

    pendingReqs().then(function() {
        $window.location.reload();
    });

    function pendingReqs() {
      return $q(function(resolve, reject) {
        setTimeout(function() {
          if ($http.pendingRequests.length === 0) {
            resolve();
          } else {
            reject();
          }
        }, 1000);
      });
    }
  });

  $scope.isMobile = function() {
    return $window.mobile;
  };

  $scope.getURLParameter = function getURLParameter(param) {
    var regexString = "[\\#&\\?]" + param + "=([^&#\\?]*)",
      regex = new RegExp(regexString),
      results = regex.exec(window.location.href);

    return ((results == null) ? "" : results[1]);
  };

  // master value of current space ID - blank if we're only viewing at the catalog or org level
  $rootScope.spaceId = "";
  $scope.setSpace = function(spaceId, dontRedirect) {
    $rootScope.spaceId = spaceId;
    var hashArray = window.location.hash.split("/");
    var envId = hashArray[2];
    if (!spaceId) {
      $rootScope.spaceName = "";
      delete $rootScope.selectedSpace;
    } else {
      if ($scope.environment && $scope.environment.spaces) {
        var len = $scope.environment.spaces.length;
        for (var i=0;i<len;i++) {
          var space = $scope.environment.spaces[i];
          if (space.id == spaceId) {
            $rootScope.spaceName = space.title;
            break;
          }
        } // end for
      }
    }
    if (!dontRedirect) {
      // maintain previous hash
      if (spaceId && hashArray[3] === 'spaces') {
        hashArray[4] = spaceId;
      } else if (spaceId) {
        hashArray.splice(3, 0, 'spaces', spaceId);
      } else if (hashArray[3] === 'spaces') {
        hashArray.splice(3, 2);
      }
      window.location.hash = hashArray.join('/');
    }
  };

  $scope.setOrganization = function(org, reload) {
    if ($rootScope.currentOrg === org) {
      return;
    }
    if(reload) {
      org.loading = true
    }

    function setOrg() {
      if ($scope.orgName == org.displayName && $scope.orgId == org.id) return;
      localStorage.setItem($scope.currentUser.id + "_organization", org.displayName);
      localStorage.setItem($scope.currentUser.id + "_organizationId", org.id);
      $rootScope.orgName = org.displayName;
      $rootScope.orgId = org.id;
      $rootScope.currentOrg = org;
    }

    function refreshEnv() {
      try {
        $rootScope.permissions = {}
        if (!$scope.offlineMode) {
          return Promise.all([
            $scope.refreshPermissions(),
            $scope.refreshEnvironments()
          ])
        }
        return $scope.refreshPermissions()
      }
      catch(e) {
        console.error('ERROR: ', e);
      }
    }

    setOrg();
    refreshEnv().then(function() {
      if(reload) {
        $rootScope.currentOrg.loading = false
        $window.location.hash = '';
      }
    });
  };

  $scope.setWorkspace = function(workspace){
    $scope.$parent.navigate('design/apis');
  };

  $scope.track = TrackingServices.track;

  $scope.openAddExistingProject = function(){
    $rootScope.$emit('event:projects:openAddExistingProject', $scope);
  };

  $scope.openAddNewOpenApiProject = function(){
    $rootScope.$emit('event:projects:addNewOpenApiProject', $scope);
  };

  $scope.openAddNewLoopbackProject = function(){
    $rootScope.$emit('event:projects:openAddNewLoopbackProject', $scope);
  };


  $scope.setFavourite = function(type, item, forceDelete, id) {
    if (!id) id = item.id;
    var favouriteSection = $scope.favourites[type];
    if(!favouriteSection) {
      favouriteSection = {};
    }
    if(forceDelete || favouriteSection[id]) delete favouriteSection[id];
    else favouriteSection[id] = item;
    $scope.favourites[type] = favouriteSection;
    if(typeof(Storage) !== "undefined") {
      localStorage.setItem($scope.currentUser.id + "-apim-favourites", JSON.stringify($scope.favourites));
    }
  };
  $scope.isFavourite = function(type, item, id) {
    if (!id) id = item.id;
    var favouriteSection = $scope.favourites[type];
    if(!favouriteSection) return false;
    return favouriteSection[id];
  };

  $scope.toggleGettingStartedMenu = function toggleGettingStartedMenu() {
    $localStorage.removeItem('onboarded');
    if ($scope.currentUser) {
      if ($window.location.hash.indexOf('#/admin/securegateways') === 0) {
        $scope.$broadcast('toggleCloseTourEvent');
      } else {
        $rootScope.experiencedUser = !$rootScope.experiencedUser;
        $window.localStorage['experiencedUser_' + $scope.currentUser.id] = $rootScope.experiencedUser;
        if ($rootScope.experiencedUser) {
          $timeout(function () {
            angular.element(document.getElementById('helpbtn')).triggerHandler('click');
            angular.element(document.getElementById('reopenGettingStartedBtn')).triggerHandler('closeGettingStartedEvent');
          }, 500);
        }
      }
    }
  };

  $scope.toggleMinimizeGettingStartedMenu = function toggleMinimizeGettingStartedMenu() {
    if($scope.currentUser) {
      $rootScope.gsMinimized = !$rootScope.gsMinimized;
      $window.localStorage['gsMinimized_' + $scope.currentUser.id] = $rootScope.gsMinimized;
    }
  };


  $rootScope.projects = [];
  $rootScope.workspaceDir = null;
  $rootScope.currentUser = $scope.currentUser = CurrentUser.query();

  var stopWatchUserData = $scope.$watch( 'userData', function(newValue, oldValue) {
    if ($rootScope.userData) {
      stopWatchUserData();
      // populating $window.IBM_Meta and triggering NPS serveys just for online mode and
      // when the feature is turned on
      if ($scope.features.NPS  && !$scope.isOffline()) {
        $rootScope.currentUser.$promise.then(function(userData) {
          $window.IBM_Meta = {};
          $window.IBM_Meta.offeringId = "​5725-Z63";
          $window.IBM_Meta.offeringName = "​API Connect";
          $window.IBM_Meta.highLevelOfferingName = "Bluemix";
          $window.IBM_Meta.userFirstName = userData.firstName;
          $window.IBM_Meta.userLastName = userData.lastName;
          $window.IBM_Meta.userEmail = userData.email;
          $window.IBM_Meta.userId = userData.id;
          $window.IBM_Meta.language = currentUsersServices.getUsersLanguage();
          $window.IBM_Meta.iuid = $rootScope.userData.uniqueSecurityName;
          $window.IBM_Meta.noQuarantine = "yes";
          $window.IBM_Meta.testData = true;
          $window.IBM_Meta.triggerIntercept = "heavy";
          $window.IBM_Meta.trigger2 = true;

          // Dynamically append medallia Digital embeded code for the NPS surveys.
          // Please note the script needs to be loaded after populating $Window.IBM_Meta data,
          // otherwise IBM_Meta will not be available to the script, also in case injecting after 1 second.
          $timeout(function(){
            $('<script type="text/javascript" src="https://nebula-cdn.kampyle.com/we/28600/onsite/embed.js" async></script>').appendTo('body');
          }, 1000);
        });
      }
    }
  });

  $scope.currentUser.$promise.then(function() {
    $scope.isSaaS = typeof isSaaS != "undefined" && isSaaS;

    $rootScope.$emit('event:showWhatsNewifApplicable');

    if ($scope.currentUser.id) {
      $rootScope.experiencedUser = $window.localStorage['experiencedUser_'+$scope.currentUser.id]=='true'? true: false;// casts localstorage var to boolean
      $rootScope.gsMinimized = $window.localStorage['gsMinimized_' + $scope.currentUser.id]=='true' ? true : false;
      $rootScope.sgTourTextOff = $window.localStorage['sgTourClosed_' + $scope.currentUser.id]=='true' ? true : false;
    }

    if ($scope.currentUser.formFactor) {
      $scope.isSaaS = FormFactor.isBluemix($scope.currentUser.formFactor);
      $scope.isPublicSaaS = FormFactor.isBluemixPublic($scope.currentUser.formFactor);
      if ($scope.features) {
        $scope.features.customPolicies = !$scope.isPublicSaaS;
        $scope.features.applicationLifecycle = !$scope.isPublicSaaS;
      }
    }

    if ($rootScope.offlineMode) {
      ProjectsServices.getWorkspaceEnvironment()
        .then(function(result){
          $rootScope.workspaceDir = result;
        })
        .catch(function(err){
          $log.log('getWorkspace error: ', err);
        });

      $rootScope.$emit('event:getProjects');
      $rootScope.$emit('event:sessionTimeout');
    }

    $scope.userProviderOrgs = CurrentUser.listProviderOrgs();
    $scope.userProviderOrgs.$promise.then(function() {

      // #1 is the zero orgs page, if there are no pOrgs at all.
        if ($scope.userProviderOrgs.length == 0) {
          $scope.orgsView = "zero";
          return;
        }

      var orgParameter = $scope.getURLParameter("org");
      // #2 - if we're given an org on the URL, we use that if it is valid
      var org;
      if (orgParameter) {
        // ok, we have org on the URL, but is it still valid?
          org = $scope.userProviderOrgs.filter(function(thisOrg) {
            return (thisOrg.id == orgParameter);
          });
        if (org.length > 0) {
          $scope.setOrganization(org[0], false);
        }
      } else {
        // #3 is local storage (i.e. whatever we used last time, if it is there, and if it is still a valid org
          var storedCurrentOrgId = localStorage.getItem($scope.currentUser.id + "_organizationId");
          if(storedCurrentOrgId) {
            org = $scope.userProviderOrgs.filter(function(thisOrg) {
              return (thisOrg.id == storedCurrentOrgId);
            });
            if (org.length > 0) {
              $scope.setOrganization(org[0], false);
            }
          }
      }

        // #4 is the first org in the pOrg array
        if (!$scope.orgName || !$scope.orgId) {
          $scope.setOrganization($scope.userProviderOrgs[0], false);
        }

        // If SaaS get sbsToken data for this org
        if ($scope.isSaaS) {
          SBSToken.query({orgId: $scope.orgId}).$promise.then(
            function(sbsToken) {
              $scope.sbsToken = sbsToken;
              $scope.advancePortalConfirmed = false;
              if ($scope.sbsToken.billedEnvironment && $scope.sbsToken.billedEnvironment == "Bluemix") {
                $scope.isSCX = false;
                $scope.isbluemix = true;
                $scope.isNonIBMID = false;
              } else if ($scope.sbsToken.billedEnvironment && $scope.sbsToken.billedEnvironment == "SCX" ) {
                $scope.isSCX = true;
                $scope.isbluemix = false;
                $scope.isNonIBMID = false;
              } else {
                $scope.isNonIBMID = true;
                $scope.isSCX = false;
                $scope.isbluemix = false;
              }
            });

        }

        // ok, we have orgs, and we have an org name, but is it still valid?
          org = $scope.userProviderOrgs.filter(function(thisOrg) {
            return (thisOrg.id == $scope.orgId);
          });
        if (org.length == 0) {
          // no, it isn't
          $scope.setOrganization($scope.userProviderOrgs[0], false);
        }
        // yes, it is
        $scope.orgsView = "valid";

        if ($scope.isSaaS) {
          for(var i = 0; i < $scope.userProviderOrgs.length; i++) {
            var userProviderOrgsID = $scope.userProviderOrgs[i].id;
            var externalNativeOrgId = $scope.userProviderOrgs[i].externalNativeOrgId;
            var externalSpaceId = $scope.userProviderOrgs[i].externalSpaceId;

            if(userProviderOrgsID == $scope.orgId && externalNativeOrgId && externalSpaceId) {
              window.document.body.className += " bluemix";
              $rootScope.bluemixExternalOrgId = externalNativeOrgId;
              $rootScope.bluemixExternalSpaceId = externalSpaceId;
              break;
            }
            else {
              $rootScope.bluemixExternalSpaceId = null;
            }
          }
        }
    });

      $scope.confirmLogout = function() {
        $scope.confirmation = {
          titleKey: 'unsaved_changes_title',
          messageKey: 'signout_unsaved_changes',
          confirmed: function() {
            $scope.logOutPage();
          },
          rejected: function() {
            return;
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          scope: $scope
        });
      };


      $scope.signOut = function() {
        if (DirtyService.isDirty()) {
          $scope.confirmLogout();
        } else {
          $scope.logOutPage();
        }
      };

      // expose a global signout event
      $rootScope.$on('event:signOut', $scope.signOut);

      $scope.logOutPage = function() {
        if ($scope.isOffline()) {
          //todo this doesn't actually log a user out

          $window.location = '/auth/logout';
          return;
        }

        $scope.currentUser.$logout().then(function() {
          window.location.reload();
        });
      }
      $scope.changePassword = function() {
        var PasswordDialog = dojo.require("base/PasswordDialog");
        var passwordDialog = new PasswordDialog({
          endpoint: "proxy/me",
          publishTopic: "WA_MESSAGE"
        });
        passwordDialog.show();
      };
      $scope.manageProfile = function() {
        var ProfileDialog = dojo.require("webapi/widgets/view/ProfileDialog");
        var profileDialog = new ProfileDialog({
          endpoint: "proxy/me",
          publishTopic: "WA_MESSAGE",
          updateProfile: $scope.currentUser.idpSummary.capabilities.updateProfile,
          updateEmail: $scope.currentUser.idpSummary.capabilities.updateEmail
        });
        profileDialog.show();
      };

      $scope.refreshPermissions = function() {
        // we need awareness of new permission has been fetched, so we
        // dont run into 403 with old org's permission
        return new Promise(function(resolve, reject) {
          RoleService.getPermissions();
          var unregister = $rootScope.$watch('permissions', function() {
            if (Object.keys($rootScope.permissions).length) {
              unregister();
              resolve();
            }
          })
        });
      }

      $scope.refreshEnvironments = function() {
        return new Promise(function (resolve, reject) {
          var unregister = $scope.$watch('permissions', function() {
            if (!$scope.permissions) return;
            unregister();
            Environment.query({orgId: $scope.orgId}).$promise.then(function(environments) {
              $rootScope.environments = environments;
              resolve()
            });
          });
        })
      };

      $scope.$watch('environments', function(){
        if (!$scope.environments) return;
        $scope.setPublishableTargets();
      });

      $scope.setPublishableTargets = function() {
        // publishTargets is an array of palces you can publish to - spaces or catalogs without spaces enabled, each object has following properties
        // type = "SPACE" or "CATALOG"
        // environmentId
        // environmentTitle
        // spaceId
        // spaceTitle
        // displayAs: The text to display it in the UI i.e. "environmentTitle - spaceTitle"
        // invokeUrl: The URL that the APIs will be invokable at
        var publishTargets = [];
        for (var j = 0; j < $scope.environments.length; j++) {
          var environment = $scope.environments[j];
          if (!environment.spaceEnabled) {
            var target = {"type":"CATALOG","environmentId":environment.id, "environmentTitle":environment.name,
              "spaceId":null, "spaceTitle":null, "displayAs":environment.name, "invokeUrl":environment.baseUrl}
            publishTargets.push(target);
            continue;
          } else if (environment.spaces){
            for (var k = 0; k < environment.spaces.length; k++) {
              var space = environment.spaces[k];
              var spaceTarget = {"type":"SPACE","environmentId":environment.id, "environmentTitle":environment.name,
                "spaceId":space.id, "spaceTitle":space.title, "displayAs":environment.name + " - " + space.title,
                "invokeUrl":environment.baseUrl}
                var spacePermId = environment.spaces[k].id + '/space_productDeployment/stage';
                  if ($scope.permissions[spacePermId]) {
                    publishTargets.push(spaceTarget);
                  }
            }
          }

        }
        $rootScope.publishTargets = publishTargets;
      }

      if(typeof(Storage) !== "undefined") {
        var favs = localStorage.getItem($scope.currentUser.id + "-apim-favourites");
        if (favs) $scope.favourites = JSON.parse(favs);
      }
      if (!$scope.favourites) $scope.favourites = {};
    });

    $scope.validatePassword = function(value) {
      if (!value) return;
      if (value.length < 6) {
        return false;
      }

      // No more than two identical letters in a row.
        for (var i = 0; i < value.length - 3; i++) {
          if (value.charAt(i) == value.charAt(i + 1) && value.charAt(i + 1) == value.charAt(i + 2)) {
            return false;
          }
        }

      // 3 sets of characters required
      var charsets = 0;
      if (/[a-z]/.test(value)) {
        charsets++;
      }

      if (/[A-Z]/.test(value)) {
        charsets++;
      }

      if (/[0-9]/.test(value)) {
        charsets++;
      }

      if (/[^A-Za-z0-9]/.test(value)) {
        charsets++;
      }

      return charsets >= 3;

    };


    var sessionHeartBeat = 5; // minutes

    // handle session timeout heartbeat
    $rootScope.$on('event:sessionTimeout', function(){
      var user = $scope.currentUser;

      if (!user || $rootScope.sessionTimeout) return;

      if (user.expiration){
        $rootScope.sessionTimeout = $interval(startSessionTimeout, sessionHeartBeat*60000);
      }
    });

    function startSessionTimeout(){
      if (!$scope.currentUser) {
        return $interval.cancel($rootScope.sessionTimeout);
      }

      var expiration = $scope.currentUser.expiration;
      var now = moment();

      if (expiration && expiration < now.subtract(sessionHeartBeat, 'minutes').unix()){
        $interval.cancel($rootScope.sessionTimeout);
        $scope.signOut();
        $timeout(function(){
          window.location.href = '/login.html';
        }, 10000);
      }
    }
};
