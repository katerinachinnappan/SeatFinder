/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Directives */

var users = angular.module('apim.users');

users.directive('apimUser', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/users/partials/user.html'
  };
});

users.directive('apimRole', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/users/partials/role.html'
  };
});

users.directive('apimAddUser', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/users/partials/add-user.html',
    link: function(scope, element, attrs) {
      scope.$watch(attrs.takeFocus, function(value) {
        scope.takeFocus = value;
      });
    }
  };
});

users.directive('gettingStartedPerUser', function(){
  return {
    restrict: 'E',
    templateUrl: 'apim/users/partials/gettingStarted.html'
  };
});

users.directive('apimSlidingColumn', ['$window', '$timeout', '$compile', function($window, $timeout, $compile) {
  return {
    restrict: 'A',
    scope: {
      columnRows: "="
    },
    link: function(scope, element, attrs) {
      scope.scrollHandlers = [];
      scope.$watch("columnRows", function(rows) {
        if (!rows) return;
        $timeout(function() {
          // clear old handlers first
          var i;
          var scLen = scope.scrollHandlers.length;
          if (scLen) {
            for (i=0;i<scLen;i++) {
              var elem = scope.scrollHandlers[i].element;
              elem.removeEventListener("scroll", scope.scrollHandlers[i].func);
            } // end for
            scope.scrollHandlers.length = 0;
          }
          var roleScrolls = element.context.getElementsByClassName(attrs.columnClass);
          if (roleScrolls.length > 0) {
            // first scroller will always be the table header - we must reset it's scroll position
            // every time since the table rows will auto-reset to zero scroll when the browser
            // redraws them
            roleScrolls[0].scrollLeft = 0;
            var syncScroll = function(evt) {
              var len = roleScrolls.length;
              var newOffset = evt.target.scrollLeft;
              for (i=0;i<len;i++) {
                var roleScroll = roleScrolls[i];
                roleScroll.scrollLeft = newOffset;
              } // end for
              if (newOffset > 0) {
                element.context.classList.add("overSizeLeft");
              }
              if (newOffset >= (roleScrolls[0].scrollWidth - roleScrolls[0].offsetWidth)) {
                element.context.classList.remove("overSizeRight");
              } else if ((roleScrolls[0].offsetWidth + newOffset) < roleScrolls[0].scrollWidth) {
                element.context.classList.add("overSizeRight");
              }
            };
            var scrLen = roleScrolls.length;
            for (i=0;i<scrLen;i++) {
              var roleScroll = roleScrolls[i];
              roleScroll.addEventListener("scroll", syncScroll);
              scope.scrollHandlers.push({element: roleScroll, func: syncScroll});
            } // end for
            var handleResize = function(evt) {
              var testScroll = roleScrolls[0];
              if (testScroll.scrollLeft == 0) {
                element.context.classList.remove("overSizeLeft");
              } else {
                element.context.classList.add("overSizeLeft");
              }
              if (testScroll.offsetWidth >= testScroll.scrollWidth) {
                element.context.classList.remove("overSizeRight");
              } else {
                element.context.classList.add("overSizeRight");
              }
            };
            // always call the resize check once
            $timeout(function() {
              handleResize();
            }, 0, false);
            if (!scope.boundResize) {
              angular.element($window).bind("resize", handleResize);
              scope.boundResize = true;
            }
            // set up the left and right arrows
            if (!scope.arrowsCreated) {
              scope.arrowsCreated = true;
              var leftArrow = angular.element("<div class=\"leftArrow material-icons bxLeftArrow\" tabindex=\"0\" title=\"{{::'apiScrollLeft' | translate}}\">chevron_left</div>");
              angular.element(leftArrow).appendTo(element.context);
              $compile(leftArrow)(scope);
              var handleLeft = function(evt) {
                var len = roleScrolls.length;
                var newOffset = roleScrolls[0].scrollLeft - 150;
                if (newOffset < 0) {
                  newOffset = 0;
                }
                for (i=0;i<len;i++) {
                  var roleScroll = roleScrolls[i];
                  roleScroll.scrollLeft = newOffset;
                } // end for
                if (newOffset == 0) {
                  element.context.classList.remove("overSizeLeft");
                }
                if (newOffset < roleScrolls[0].offsetWidth) {
                  element.context.classList.add("overSizeRight");
                }
              };
              leftArrow.on("click", handleLeft);
              leftArrow.on("keypress", handleLeft);
              var rightArrow = angular.element("<div class=\"rightArrow material-icons bxRightArrow\" tabindex=\"0\" title=\"{{::'apiScrollRight' | translate}}\">chevron_right</div>");
              angular.element(rightArrow).appendTo(element.context);
              $compile(rightArrow)(scope);
              var handleRight = function(evt) {
                var len = roleScrolls.length;
                var newOffset = roleScrolls[0].scrollLeft + 150;
                for (i=0;i<len;i++) {
                  var roleScroll = roleScrolls[i];
                  roleScroll.scrollLeft = newOffset;
                } // end for
                if (newOffset > 0) {
                  element.context.classList.add("overSizeLeft");
                }
                if (newOffset >= (roleScrolls[0].scrollWidth - roleScrolls[0].offsetWidth)) {
                  element.context.classList.remove("overSizeRight");
                }
              };
              rightArrow.on("click", handleRight);
              rightArrow.on("keypress", handleRight);
            }
          }
        }, 500);
      });
    }
  };
}]);

