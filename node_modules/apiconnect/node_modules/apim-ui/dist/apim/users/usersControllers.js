/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var users = angular.module('apim.users', ['ngResource']);


users.controller('UsersController', ['$scope', '$rootScope', '$window', '$modal', '$q', '$filter', '$timeout', '$animate', 'Role', 'Member', 'IdentityProvider', 'IDPForContext', 'uniqueFilter', 'constructTagsFilter', 'translateFilter', usersController]);

function usersController($scope, $rootScope, $window, $modal, $q, $filter, $timeout, $animate, Role, Member, IdentityProvider, IDPForContext, uniqueFilter, constructTagsFilter, translateFilter) {
  $scope.isCatalogUsers = window.location.hash.indexOf('catalogs') >= 0;
  $scope.usersScope = "org";
  if ($scope.isCatalogUsers) {
    $scope.usersScope = "catalog";
  }
  $scope.roleMessages = {};

  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    var orgId = null;
    if ($rootScope.context == "cmc") {
      orgId = "defaultIBMOrg";
    } else {
      orgId = $scope.orgId;
    }
    var unregister = $scope.$watch('permissions', function() {
      if (!$scope.permissions || Object.keys($scope.permissions).length === 0) return;
      unregister();
      // edit permission differs depending on where the users panel appears
      if (!$scope.isCatalogUsers && $scope.permissions['org_members/manage']) {
        $scope.canEdit = true;
      }
      if ($rootScope.context == "cmc") {
        if ($scope.permissions['org_members/manage']) {
          $scope.canEdit = true;
        }
        if ($scope.permissions['org_members/view']) {
          $scope.canViewRoles = true;
        }
        $scope.getRoles(orgId);
      } else {
        var unwatch = $scope.$watch('environments', function() {
          if (!$scope.environments) return;
          unwatch();
          if ($scope.isCatalogUsers) {
            var hashArray = window.location.hash.split("/");
            var envId = hashArray[2];
            if (envId != "environments" && (!$scope.environment || $scope.environment.id != envId)) {
              var filtered = $scope.environments.filter(function(env) {
                return env.id == envId;
              });
              if (filtered.length > 0) {
                $scope.setEnvironment(filtered[0]);
              }
            }
            if ($scope.permissions[$scope.spaceId ? $scope.spaceId + '/space_members/manage' : $scope.environment.id + '/catalog_members/manage']) {
              $scope.canEdit = true;
            }
            // make sure we setup the correct space if we land directly on this page
            if (hashArray[3] == "spaces") {
              var spaceId = hashArray[4];
              if (spaceId != $scope.spaceId) {
                $scope.setSpace(spaceId, true);
              }
            } else if ($scope.spaceId) {
              $scope.setSpace("", true);
            }
            if ($scope.spaceId) {
              $scope.usersScope = "space";
            }
          } else {
            // must reset spaceId if we're at org-level users
            if ($scope.spaceId) {
              $scope.setSpace("", true);
            }
          }
          if ($scope.permissions['org_members/view'] || $scope.permissions[$scope.spaceId ? $scope.spaceId + '/space_members/view' : $scope.environment.id + '/catalog_members/view']) {
            $scope.canViewRoles = true;
          }
          $scope.getRoles(orgId);
        });
      }
    });
  });

  $scope.getRoles = function(orgId) {
    if ($scope.permissions['org_members/view'] || $scope.permissions[$scope.spaceId ? $scope.spaceId + '/space_members/view' : $scope.environment.id + '/catalog_members/view']) {
      $scope.roles = Role.query({orgId: orgId});
      $scope.roles.$promise.then(
        function() {
          var len = $scope.roles.length;
          if ($rootScope.context == "cmc") {
            // special check for CMC - need to add system role as some roles dont get it back on the response
            var foundSystem = false;
            for (var i=0;i<len;i++) {
              var role = $scope.roles[i];
              if (role.name == "system") {
                foundSystem = true;
              }
            } // end for
            if (!foundSystem) {
              $scope.roles.push({
                description: $filter('translate')('userRoleSystemDesc'),
                displayName: $filter('translate')('userRoleSystem'),
                modifiable: false,
                name: "system",
                removable: false
              });
            }
          }
          // pre-calculate translations for roles
          for (var j=0;j<len;j++) {
            var roleItem = $scope.roles[j];
            $scope.roleMessages[roleItem.id] = $filter('translate')('apiAddRoleSpecific', roleItem);
          } // end for
          $scope.getUsers();
        }
      );
    } else {
      $scope.getUsers();
    }
  };

  $scope.getUsers = function() {
    var queryArgs = {
      orgId: $scope.orgId
    };
    if ($rootScope.context == "cmc") {
      queryArgs.orgId = "defaultIBMOrg";
    }
    if ($scope.isCatalogUsers) {
      queryArgs.environments = "environments";
      queryArgs.envId = $scope.environment.id;
      if ($scope.spaceId) {
        queryArgs.spaces = "spaces";
        queryArgs.spaceId = $scope.spaceId;
      }
    }
    $animate.enabled(false);
    $scope.users = Member.query(queryArgs);
    $scope.users.$promise.then(
      function() {
        // work out logged in user
        var len = $scope.users.length;
        for (var i=0;i<len;i++) {
          var user = $scope.users[i];
          if (user.user.name == $scope.currentUser.name) {
            $scope.loggedInUser = user;
            break;
          }
        } // end for
        $scope.usersLoaded = true;
        $scope.finishedDrawing = false;
        $timeout(function() {
          $scope.finishedDrawing = true;
          $animate.enabled(true);
        }, 0, false);
      }
    );
  };

  $scope.newUser = function(evt) {
    var idpConfig = {};
    var idpConfigDeferred = $q.defer();

    // When adding in CMC users the IDP to use may not be the current users
    // as admin is always LUR, but other users may not be
    if ($rootScope.context == "cmc") {
      IDPForContext.query({context: "cmc"}).$promise.then(function(data){
        IdentityProvider.query({idpId: data.id}).$promise.then(function(idp){
          idpConfig.id = idp.id;
          idpConfig.type = idp.type;
          idpConfig.context = "cmc";
          idpConfigDeferred.resolve(idpConfig);
        });
      });
    } else {
      idpConfig.id = $scope.currentUser.idpSummary.id;
      idpConfig.type = $scope.currentUser.idpSummary.type;
      idpConfig.context = $scope.currentUser.context;
      idpConfigDeferred.resolve(idpConfig);
    }

    $scope.idpConfig = idpConfig;
    idpConfigDeferred.promise.then(function(idpConfig) {
      $modal.open({
        controller: 'AddUserDialogController',
        templateUrl: 'apim/users/partials/addUserDialog.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        scope: $scope,
        resolve: {
          addOwner: function() { return false },
          changeOwner: function() { return false },
          idpConfig: function() { return idpConfig },
          roleList: function() { return $scope.roles },
          orgId: function() { return $scope.orgId },
          envId: function() { return $scope.environment ? $scope.environment.id : '' },
          isCatalogUsers: function() { return $scope.isCatalogUsers },
          spaceId: function() { return $scope.spaceId },
        },
      }).result.then(function() {
        $scope.getUsers();
      });
    });
  };

  $scope.processRoles = function() {
    var roles = [];
    $scope.users.forEach(function(user) {
      if (user.roles) {
        roles = roles.concat(user.roles);
      }
    });
    roles = uniqueFilter(roles, "name");
    $scope.roles = constructTagsFilter(roles);
    var selectedTags = {};
    $scope.roles.forEach(function(role) {
      selectedTags[role.value] = true;
    });
    $scope.selectedTags = selectedTags;
  };
};

users.controller('UserController', ['$scope', '$rootScope', '$window', '$modal', 'Member', 'Role', 'CurrentUser', 'ApimUser', 'translateFilter', userController]);

function userController($scope, $rootScope, $window, $modal, Member, Role, CurrentUser, ApimUser, translateFilter) {
  $scope.remove = function(){
    var messageKey = "deletingUserConfirm";
    if ($scope.isCatalogUsers) {
      messageKey = "deletingUserCatalogConfirm";
      if ($scope.spaceId) {
        messageKey = "deletingUserSpaceConfirm";
      }
    }
    $scope.confirmation = {
      titleKey: 'deletingUser',
      messageKey: messageKey,
      confirmed: function() {
        $scope.beingDeleted = true;
        var removeArgs = {
          orgId: $scope.orgId,
          userId: $scope.user.user.id
        };
        if ($rootScope.context == "cmc") {
          removeArgs.orgId = "defaultIBMOrg";
        }
        if ($scope.isCatalogUsers) {
          removeArgs.environments = "environments";
          removeArgs.envId = $scope.environment.id;
          removeArgs.userId = $scope.user.id;
          if ($scope.spaceId) {
            removeArgs.spaces = "spaces";
            removeArgs.spaceId = $scope.spaceId;
          }
        }
        var deletedUser = Member.remove(removeArgs);
        deletedUser.$promise.then(
          function() {
            $scope.beingDeleted = false;
            $scope.getUsers();
          }, function(error) {
            $scope.beingDeleted = false;
          }
        );
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope
    });
  };

  $scope.$userRole = function() {
    if (arguments.length) {
      // Setter
      $scope.toggleRole(this.role);
    } else {
      // Getter
      var ret = false;
      if ($rootScope.context == "cmc") {
        // special case for CMC owner - must show user as in all regular roles
        var isOwner = $scope.isInRole({name: "cloudowner"});
        if (isOwner && this.role.name != "system") {
          ret = true;
        } else {
          ret = $scope.isInRole(this.role);
        }
      } else {
        var childMember = this.subchildMember ? this.subchildMember : this.childMember;
        if (childMember) {
          var catOwner = $scope.isInAnyOfChildRoles(childMember, ['catalogowner', 'spaceowner']);
          if (catOwner) {
            ret = true;
          } else {
            ret = $scope.isInChildRole(childMember, this.role);
          }
        } else {
          var owner = $scope.isInAnyOfRoles(['owner', 'catalogowner', 'spaceowner']);
          if (owner) {
            ret = true;
          } else {
            ret = $scope.isInRole(this.role);
          }
        }
      }
      return ret;
    }
  };

  $scope.toggleRole = function(role) {
    if ($scope.isInRole(role)) {
      $scope.removeRole(role);
    } else {
      $scope.assignRole(role);
    }
  };

  $scope.assignRole = function(role) {
    var roles = {
      roles: []
    };
    // put the existing roles in the list
    var len = $scope.user.roles.length;
    for (var j=0;j<len;j++) {
      roles.roles.push($scope.user.roles[j].name);
    } // end for
    // add the new role
    roles.roles.push(role.name);
    var updateArgs = {
      orgId: $scope.orgId,
      userId: $scope.user.user.id
    };
    if ($scope.isCatalogUsers) {
      updateArgs.environments = "environments";
      updateArgs.envId = $scope.environment.id;
      if ($scope.user.id) {
        updateArgs.userId = $scope.user.id;
      }
      if ($scope.spaceId) {
        updateArgs.spaces = "spaces";
        updateArgs.spaceId = $scope.spaceId;
      }
    }
    var updateRole = Member.updateRoles(updateArgs, roles);
    updateRole.$promise.then(
      function(data) {
        for (var i=0; i<$scope.users.length; i++) {
          if ($scope.user.user.id === $scope.users[i].user.id) {
            $scope.user.roles.push(role);
            // must also refresh the member ID and child membership as they can change ...
              $scope.user.id = data.id;
            $scope.user.childMembership = data.childMembership;
            break;
          }
        }
      }
    );
  };

  $scope.removeRole = function(role) {
    var roles = {
      roles: []
    };
    // put the existing roles in the list, minus the one we're removing
    var len = $scope.user.roles.length;
    for (var j=0;j<len;j++) {
      var roleName = $scope.user.roles[j].name;
      if (roleName != role.name) {
        roles.roles.push(roleName);
      }
    } // end for
    var updateArgs = {
      orgId: $scope.orgId,
      userId: $scope.user.user.id
    };
    if ($scope.isCatalogUsers) {
      updateArgs.environments = "environments";
      updateArgs.envId = $scope.environment.id;
      if ($scope.user.id) {
        updateArgs.userId = $scope.user.id;
      }
      if ($scope.spaceId) {
        updateArgs.spaces = "spaces";
        updateArgs.spaceId = $scope.spaceId;
      }
    }
    var updateRole = Member.updateRoles(updateArgs, roles);
    updateRole.$promise.then(
      function(data) {
        for (var i=0; i<$scope.users.length; i++) {
          if ($scope.user.user.id === $scope.users[i].user.id) {
            for (var j=0; j<$scope.users[i].roles.length; j++) {
              if($scope.users[i].roles[j].name == role.name) {
                $scope.user.roles.splice(j, 1);
                break;
              }
            }
            // must also refresh the member ID and child membership as they can change ...
              $scope.user.id = data.id;
            $scope.user.childMembership = data.childMembership;
            break;
          }
        }
      }
    );
  };

  $scope.isInRole = function(role) {
    var ret = false;
    var len = $scope.user.roles.length;
    for (var i=0;i<len;i++) {
      if ($scope.user.roles[i].name == role.name) {
        ret = true;
        break;
      }
    } // end for
    return ret;
  };

  $scope.isInChildRole = function(childMember, role) {
    var ret = false;
    if (childMember && childMember.roles) {
      var len = childMember.roles.length;
      for (var i=0;i<len;i++) {
        if (childMember.roles[i].name == role.name) {
          ret = true;
          break;
        }
      } // end for
    }
    return ret;
  };

  $scope.isInAnyOfRoles = function(roles) {
    var ret = false;
    var len = $scope.user.roles.length;
    for (var i=0;i<len;i++) {
      var roleName = $scope.user.roles[i].name;
      if (roles.indexOf(roleName) != -1) {
        ret = true;
        break;
      }
    } // end for
    return ret;
  };

  $scope.isInAnyOfChildRoles = function(childMember, roles) {
    var ret = false;
    if (childMember && childMember.roles) {
      var len = childMember.roles.length;
      for (var i=0;i<len;i++) {
        var roleName = childMember.roles[i].name;
        if (roles.indexOf(roleName) != -1) {
          ret = true;
          break;
        }
      } // end for
    }
    return ret;
  };

  $scope.hasModifiableRoles = function() {
    var ret = false;
    var len = $scope.user.roles.length;
    for (var i=0;i<len;i++) {
      if ($scope.user.roles[i].modifiable) {
        ret = true;
        break;
      }
    } // end for
    return ret;
  };

  $scope.isModifiable = function(role) {
    var ret = true;
    var len = $scope.user.roles.length;
    for (var i=0;i<len;i++) {
      if ($scope.user.roles[i].name == role.name) {
        if (!$scope.user.roles[i].modifiable) {
          ret = false;
        }
        break;
      }
    } // end for
    return ret;
  };

  $scope.isLoggedInUserInRole = function(role) {
    var ret = false;
    if ($scope.loggedInUser) {
      var len = $scope.loggedInUser.roles.length;
      for (var i=0;i<len;i++) {
        if ($scope.loggedInUser.roles[i].name == role.name) {
          ret = true;
          break;
        }
      } // end for
    }
    return ret;
  };

  $scope.resendInvite = function(user) {
    var timestamp = (new Date()).getTime();
    var messageId = "User_resend_" + timestamp;
    var resend = ApimUser.resendInvite({userId: user.id, idpOrganization: $scope.orgId});
    resend.$promise.then(function(data) {
      $scope.notifyUser('resendingInvitations', [], "SUCCESS", true, messageId);
    }, function(err) {
      // user will see standard error dialog here
    });
  };

  // work out whether the role checkbox should be disabled for the current user
  $scope.isDisabled = function(role) {
    var ret = false;
    if (!$scope.canEdit || role.name=="owner" || role.name=="cloudowner" || $scope.isInAnyOfRoles(['owner', 'catalogowner', 'spaceowner'])) {
      ret = true;
    } else if (!$scope.isModifiable(role)) {
      ret = true;
    } else if (role.name != "system" && $scope.isInRole({name: "cloudowner"})) {
      ret = true;
    } else if (role.name == "system" && !$scope.isLoggedInUserInRole({name: "cloudowner"})) {
      ret = true;
    }
    return ret;
  };
};

users.controller('AddUserController', ['$scope', '$q', 'UserSearch', addUserController]);

function addUserController($scope, $q, UserSearch) {
  $scope.takeFocus = false;

  $scope.toggleRole = function(role) {
    if ($scope.isInRole(role)) {
      $scope.removeRole(role);
    } else {
      $scope.assignRole(role);
    }
  };

  $scope.assignRole = function(role) {
    $scope.roles.push(role);
  };

  $scope.removeRole = function(role) {
    var len = $scope.roles.length;
    for (var i=0; i<len; i++) {
      if ($scope.roles[i].name == role.name) {
        $scope.roles.splice(i, 1);
        break;
      }
    } // end for
  };

  $scope.isInRole = function(role) {
    var ret = false;
    var len = $scope.roles.length;
    for (var i=0;i<len;i++) {
      if ($scope.roles[i].name == role.name) {
        ret = true;
        break;
      }
    } // end for
    return ret;
  };

  $scope.renderUserName = function(user) {
    var ret = "";
    if (user.firstName && user.firstName.toLowerCase() == 'admin') {
      ret = 'admin';
    } else {
      if (user.firstName) {
        ret = user.firstName;
      }
      if (user.lastName) {
        ret = ret + " " + user.lastName;
      }
    }
    // only need separator if we have a name
    if (ret) {
      ret = ret + " - ";
    }
    return (ret);
  };

  $scope.searchUsers = function(searchString) {
    $scope.searchingForUsers = true;
    searchString = $scope.searchString || searchString;
    UserSearch.query({idpId: $scope.idpId, searchFilter: searchString}).$promise.then(function(users) {
      $scope.searchingForUsers = false;
      $scope.selectedUser = null;
      $scope.searchResults = users;
    }, function(err) {
      $scope.searchingForUsers = false;
      $scope.selectedUser = null;
      // show any specific errors (from LDAP only)
      if (err && err.response && err.response.data && err.response.data.errors) {
        var msg = null;
        for (var key in err.response.data.errors[0]) {
          msg = err.response.data.errors[0][key];
          break;
        } // end for
        if (msg) {
          $scope.searchError = msg;
        }
      }
    });
  };
};

users.controller('AddUserDialogController', ['$scope', '$rootScope', '$filter', '$modalInstance', '$q', 'UserSearch', 'ApimUser', 'UserContext', 'IDPForContext', 'IdentityProvider', 'Member', 'addOwner', 'changeOwner', 'idpConfig', 'roleList', 'orgId', 'envId', 'isCatalogUsers', 'spaceId', 'TrackingServices', addUserDialogController]);

function addUserDialogController($scope, $rootScope, $filter, $modalInstance, $q, UserSearch, User, UserContext, IDPForContext, IdentityProvider, Member, addOwner, changeOwner, idpConfig, roleList, orgId, envId, isCatalogUsers, spaceId, TrackingServices) {

  $scope.saveDisabled = true;
  $scope.performingAdd = false;
  // Below has to be explicitly defined because of material design to carbon.
    $scope.addOwner = addOwner || $scope.addOwner;
  $scope.changeOwner = changeOwner || $scope.changeOwner;
  $scope.isCatalogUsers = isCatalogUsers || $scope.isCatalogUsers;
  $scope.spaceId = spaceId || $scope.spaceId;
  // idpConfig is the information about the IDP you wish to search for users in
    // e.g. {"id":"abc123", "type":"ldap", "context":"cmc|apimanager|catalog.id"}
  // This used to be called currentUser but that name is very VERY misleading as
  // only one of the four cases actually use the IDP information of the current user.
    $scope.idpConfig = idpConfig || $scope.idpConfig;
  $scope.idpId = idpConfig.id || $scope.idpConfig.id;
  $scope.provider = idpConfig.type || $scope.idpConfig.type;
  $scope.roleList = roleList || $scope.roleList;
  $scope.orgId = orgId || $scope.orgId;
  $scope.envId = envId || ($scope.environment ? $scope.environment.id : '');
  $scope.roleList = $scope.roles;
  $scope.selectedUser = null;
  $scope.tab = 1;
  $scope.roles = [];
  if ($scope.addOwner) {
    $scope.roles.push('owner');
  }
  $scope.userData = {
    email: ""
  };

  $scope.cancel = function() {
    $modalInstance.dismiss();
  };

  $scope.addUser = function() {
    $scope.performingAdd = true;
    var timestamp = (new Date()).getTime();
    var messageId = "User_Create_" + timestamp;
    $scope.$root.notifyUser($scope.isCatalogUsers ? $scope.spaceId ? 'spaceAddingUser' : 'catalogAddingUser' : 'creatingUser', [], "BUSY", false, messageId);
    // make the request using the local data
    var promise = null;
    var localData = null;
    if ($scope.tab == 1 && $scope.selectedUser != null) {
      localData = angular.copy($scope.selectedUser);
    } else {
      localData = {
        email: $scope.userData.email
      };
    }
    localData.context = $scope.idpConfig.context;
    localData.idpId = $scope.idpId;
    if ($scope.changeOwner) {
      localData.environment = $scope.idpConfig.context;
      localData.providerOrg = $scope.orgId;
    }
    // cannot get existing user on authurl
    if ($scope.provider == "authUrl") {
      promise = $scope.createUser(localData);
    } else {
      promise = $scope.getCreateUser(localData, $scope.idpConfig.context);
    }
    if (promise) {
      promise.then(function(response) {
        if (!$scope.addOwner) {
          $scope.addAdditionalUser(response).then(function(data) {
            var message = $scope.isCatalogUsers ? ($scope.spaceId ? 'spaceAddedUser' : 'catalogAddedUser') : 'sendingInvitations';
            $scope.$root.notifyUser(message, [], "SUCCESS", true, messageId);
            TrackingServices.track('userAdded', message);
            $modalInstance.close(data);
          }, function(err) {
            $scope.performingAdd = false;
            $scope.$root.notifyUser($scope.isCatalogUsers ? $scope.spaceId ? 'spaceAddUserFailed' : 'catalogAddUserFailed' : 'createUserFailed', [], "ERROR", false, messageId);
          });
        } else {
          $scope.$root.notifyUser('createdUser', [], "SUCCESS", true, messageId);
          return $modalInstance.close(response);
        }
      }, function(err) {
        $scope.performingAdd = false;
        $scope.$root.notifyUser($scope.isCatalogUsers ? $scope.spaceId ? 'spaceAddUserFailed' : 'catalogAddUserFailed' : 'createUserFailed', [], "ERROR", false, messageId);
      });
    }
  };

  $scope.createUser = function(user) {
    var newUser = new User(user);
    var ret = newUser.$create();
    return (ret);
  };

  $scope.getUserInContext = function(userId, context) {
    var ret = UserContext.query({
      context: context,
      userId: userId
    });
    return (ret.$promise);
  };

  $scope.getCreateUser = function(user, context) {
    var ret = $q.defer();
    // Try to get the user
    $scope.getUserInContext(user.username ? user.username : user.email, context).then(function(data) {
      ret.resolve(data);
    }, function(err) {
      if (err && err.status == 404) {
        $scope.createUser(user).then(function(data) {
          ret.resolve(data);
        }, function(err) {
          ret.reject(err);
        });
      } else {
        ret.reject(err);
      }
    });
    return (ret.promise ? ret.promise : ret);
  };

  $scope.addAdditionalUser = function(user) {
    var userData = { user:user.id ? user.id : user };
    var roleNames = [];
    var len = $scope.roles.length;
    for (var i=0;i<len;i++) {
      roleNames.push($scope.roles[i].name);
    } // end for
    userData.roles = roleNames;
    var newMember = new Member(userData);
    var addArgs = {
      orgId: $scope.orgId
    };
    if ($scope.idpConfig.context == "cmc") {
      addArgs.orgId = "defaultIBMOrg";
    }
    if ($scope.isCatalogUsers) {
      addArgs.environments = "environments";
      addArgs.envId = $scope.envId;
      if ($scope.spaceId) {
        addArgs.spaces = "spaces";
        addArgs.spaceId = $scope.spaceId;
      }
    }
    var ret = newMember.$add(addArgs);
    return (ret);
  };

  // Called when the form is invalid
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.addUserForm || $scope.addUserForm.$invalid) {
      canSave = false;
    }
    if (($scope.provider == 'apim' || $scope.provider == 'scim') && $scope.tab == 1 && !$scope.selectedUser) {
      canSave = false;
    }
    if ($scope.roles.length < 1) {
      canSave = false;
    }
    $scope.saveDisabled = !canSave;
  };

  $scope.$watch('addUserForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('selectedUser', $scope.handleFormUpdate);
  $scope.$watchCollection('roles', $scope.handleFormUpdate);
};

users.controller('RolesController', ['$scope', '$window', '$filter', '$modal', '$location', '$q', '$state', 'Member', 'Role', 'CurrentUser', 'translateFilter', '$interval', rolesController]);

function rolesController($scope, $window, $filter, $modal, $location, $q, $state, Member, Role, CurrentUser, translateFilter, $interval) {

  $scope.dirtyRoles = {};
  $scope.rolesCache = {};
  $scope.saveDisabled = true;
  $scope.unsavedChangesDialogOpened = false;
  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.roles = Role.query({orgId: $scope.orgId});
    $scope.roles.$promise.then(
      function() {
        $scope.rolesLoaded = true;
        if($scope.roles.length > 0 && !$scope.selectedRoleDetails) $scope.selectRole($scope.roles[0]);
      }
    );
  });

  $scope.$on("$locationChangeStart", function (event, next, current) {
    if (!$scope.saveDisabled && !$scope.unsavedChangesDialogOpened) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          $scope.saveDisabled = true;
          $scope.unsavedChangesDialogOpened = false;
          $location.path($location.url(next).hash());
        },
        rejected: function() {
          $scope.unsavedChangesDialogOpened = false;
        }
      };
      $scope.unsavedChangesDialogOpened = true;
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });

  $scope.$on("$stateChangeStart", function (event, toState, toParams, fromState, fromParams) {
    if (!$scope.saveDisabled && !$scope.unsavedChangesDialogOpened) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          $scope.saveDisabled = true;
          $scope.unsavedChangesDialogOpened = false;
          $state.go(toState, toParams);
        },
        rejected: function() {
          $scope.unsavedChangesDialogOpened = false;
        }
      };
      $scope.unsavedChangesDialogOpened = true;
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });

  $scope.selectRole = function(role) {
    $scope.selectedRole = role;
    if (!$scope.rolesCache[role.id]) {
      $scope.selectedRoleDetails = Role.get({orgId: $scope.orgId, roleId: role.id});
      $scope.rolesCache[role.id] = $scope.selectedRoleDetails;
    } else {
      $scope.selectedRoleDetails = $scope.rolesCache[role.id];
    }
  };

  var isAddRoleLocked = false;
  $scope.addRole = function() {
    var stopCheckAddRole = $interval(function() {
      if (isAddRoleLocked === false) {
        isAddRoleLocked = true;
        if(!$scope.roles.$resolved) return;
        $scope.saveDisabled = true;

        // Work out a suitable default name
        var newRoleName = null;
        var newRoleNamePrefix = $filter('translate')('newRoleName') + " ";
        for(var i=1; newRoleName == null; i++) {
          var testName = newRoleNamePrefix + i;
          var nameAlreadyTaken = false;
          for(var j=0; j<$scope.roles.length; j++) {
            if($scope.roles[j].displayName == testName) {
              nameAlreadyTaken = true;
              break;
            }
          }
          if(!nameAlreadyTaken) {
            newRoleName = testName;
          }
        }

        // Create environment object
        var newRole = new Role({
          displayName: newRoleName,
          description: "",
          permissions: []
        });

        var timestamp = (new Date()).getTime();
        var messageId = "savingRole-" + timestamp;
        $scope.notifyUser('creatingRole', [], "BUSY", false, messageId);
        newRole.$save({orgId: $scope.orgId}).then(
          function(role) {
            $scope.roles.unshift(newRole);    // Add to beginning of array
            $scope.selectRole(role);
            $scope.notifyUser('createdRole', [], "SUCCESS", true, messageId);
            isAddRoleLocked = false;
            $interval.cancel(stopCheckAddRole);
          },
          function(error) {
            $scope.notifyUser('createRoleFailed', [], "ERROR", false, messageId);
            isAddRoleLocked = false;
            $interval.cancel(stopCheckAddRole);
          }
        );
      }
    },500);

  };

  $scope.confirmDeleteRole = function(index) {
    $scope.confirmation = {
      titleKey: 'deletingRole',
      messageKey: 'deleteRoleConfirm',
      confirmed: function() {
        $scope.deleteRole(index);
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope
    });
  };

  $scope.deleteRole = function(index) {
    var timestamp = (new Date()).getTime();
    var messageId = "deletingRole-" + timestamp;
    $scope.notifyUser('deletingRole', [], "BUSY", false, messageId);
    var removedRole = Role.remove({orgId: $scope.orgId, roleId: $scope.roles[index].id});
    removedRole.$promise.then(
      function() {
        $scope.notifyUser('deletedRole', [], "SUCCESS", true, messageId);
        var oldRoleId = $scope.roles[index].id;
        delete $scope.dirtyRoles[oldRoleId];
        delete $scope.rolesCache[oldRoleId];
        $scope.roles.splice(index, 1);
        if ($scope.roles.length > 0) {
          $scope.selectRole($scope.roles[0]);
        }
      },
      function(err) {
        $scope.notifyUser('errorDeletingRole', [], "ERROR", false, messageId);
      }
    );
  };

  var saveRole = function(roleId) {
    var deferred = $q.defer();
    var ret = deferred.promise;
    if (roleId) {
      var roleToSave = $scope.rolesCache[roleId];
      if (roleToSave) {
        ret = roleToSave.$update({orgId: $scope.orgId, roleId: roleId});
      } else {
        deferred.resolve();
      }
    } else {
      deferred.resolve();
    }
    return ret;
  };

  var chainPromises = function(masterDeferred, promises) {
    if (promises.length === 0) {
      masterDeferred.resolve();
      return;
    }
    promises[0]().then(function() {
      chainPromises(masterDeferred, promises.slice(1));
    }, function(error) {
      masterDeferred.reject(error);
    });
  };

  $scope.saveRoles = function() {
    if ($scope.saveDisabled) return;
    var timestamp = (new Date()).getTime();
    var messageId = "savingRoles-" + timestamp;
    $scope.notifyUser('savingRoles', [], "BUSY", false, messageId);
    $scope.saveDisabled = true;
    var masterDeferred = $q.defer();
    var saveFunctions = [];
    // add each dirty role to the list of save functions
    for (var key in $scope.dirtyRoles) {
      var saveFn = (function() {
        var roleId = key;
        return function() {
          return saveRole(roleId);
        };
      })();
      saveFunctions.push(saveFn);
    } // end for
    // masterDeferred will get triggered when all saves are good or when the first one fails
    masterDeferred.promise.then(function() {
      $scope.saveDisabled = true;
      $scope.dirtyRoles = {};
      $scope.rolesCache = {};
      $scope.notifyUser('savedRoles', [], "SUCCESS", true, messageId);
      $scope.$broadcast("Role_saved");
      // refresh list of roles
      $scope.rolesLoaded = false;
      $scope.roles = Role.query({orgId: $scope.orgId});
      $scope.roles.$promise.then(
        function() {
          $scope.rolesLoaded = true;
          if ($scope.roles.length > 0) {
            $scope.selectRole($scope.roles[0]);
          }
        }
      );
    }, function(error) {
      $scope.saveDisabled = false;
      $scope.notifyUser('errorSavingRoles', [], "ERROR", false, messageId);
    });
    // make the actual save
    chainPromises(masterDeferred, saveFunctions);
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave, changedRoleId) {
    if (Object.keys($scope.dirtyRoles).length > 0) {
      // already have some dirty roles - make sure we always show the save button
      $scope.saveDisabled = false;
    } else {
      $scope.saveDisabled = !canSave;
    }
    if (canSave && changedRoleId) {
      $scope.dirtyRoles[changedRoleId] = true;
    }
  };

  $scope.$on("Role_canSave", $scope.handleSave);
};


users.controller('RoleController', ['$scope', '$window', 'Member', 'Role', 'CurrentUser', 'translateFilter', 'Permissions', roleController]);

function roleController($scope, $window, Member, Role, CurrentUser, translateFilter, Permissions) {

  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;

    $scope.rolesPermissions = Permissions;
    $scope.metadataLoaded = true;
  });

  // called from parent scope when the role has been successfully saved
  $scope.roleSaved = function() {
    // mark the form as clean again
    $scope.userRoleForm.$setPristine();
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.userRoleForm || $scope.userRoleForm.$invalid || $scope.userRoleForm.$pristine) {
      canSave = false;
    }
    $scope.$emit("Role_canSave", canSave, $scope.selectedRole ? $scope.selectedRole.id : "");
  };

  $scope.handleRoleChange = function() {
    if (!$scope.selectedRole) return;
    // put the form back into its previous state
    if ($scope.dirtyRoles[$scope.selectedRole.id]) {
      $scope.userRoleForm.$setDirty();
    } else {
      $scope.userRoleForm.$setPristine();
    }
  };

  $scope.$watch('userRoleForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('userRoleForm.$pristine', $scope.handleFormUpdate);
  $scope.$watch('selectedRole', $scope.handleRoleChange);
  $scope.$on("Role_saved", $scope.roleSaved);
};


users.controller('ActionController', ['$scope', '$window', 'Member', 'Role', 'CurrentUser', 'translateFilter', actionController]);

function actionController($scope, $window, Member, Role, CurrentUser, translateFilter) {

  $scope.$action = function() {
    if(!$scope.selectedRoleDetails || !$scope.selectedRoleDetails.permissions) return;

    var permission = $scope.selectedRoleDetails.permissions[$scope.getResourceIndex($scope.permission.resource)];
    var actionIndex = $scope.getActionIndex(permission, $scope.action.name);

    if(arguments.length) {
      // Setter
      if(actionIndex >= 0) {
        permission.actions.splice(actionIndex, 1);
      } else {
        if(!permission) {
          permission = {resource: $scope.permission.resource, actions: []};
          if ($scope.permission.type && $scope.permission.type == "environment") {
            permission.type = "environment";
          }
          if ($scope.permission.type && $scope.permission.type == "space") {
            permission.type = "space";
          }
          $scope.selectedRoleDetails.permissions.push(permission);
        }
        permission.actions.push($scope.action.name);
        if($scope.action.impliedActions.length > 0) {
          // check and disabled implied actions
          for(var i=0; i<$scope.action.impliedActions.length; i++) {
            var actionName = $scope.action.impliedActions[i];
            if (permission.actions.indexOf(actionName) == -1) {
              permission.actions.push(actionName);
            }
          }
        }
      }
    } else {
      // Getter
      if(actionIndex >= 0) {
        return true;
      } else {
        return false;
      }
    }
  };

  // Does another action in the same permission imply this action?
    $scope.amIImplied = function() {
      if(!$scope.selectedRoleDetails) return false;
      for(var i=0; i<$scope.permission.actions.length; i++) {
        if($scope.permission.actions[i] == $scope.action.name) continue;	// skip self
        for(var j=0; j<$scope.permission.actions[i].impliedActions.length; j++) {
          if($scope.permission.actions[i].impliedActions[j] == $scope.action.name) {
            // I'm implied, but is the implicator checked?
              if($scope.selectedRoleDetails.permissions) {
                var permission = $scope.selectedRoleDetails.permissions[$scope.getResourceIndex($scope.permission.resource)];
                var actionIndex = $scope.getActionIndex(permission, $scope.permission.actions[i].name);
                if(actionIndex >= 0) return true;
              }
          }
        }
      }
      return false;
    };

  $scope.getActionIndex = function(permission, actionName) {
    if(!permission) return -1;
    for(var i=0; i<permission.actions.length; i++) {
      if(permission.actions[i] == actionName) {
        return i;
      }
    }
    return -1;
  };

  $scope.getResourceIndex = function(resource) {
    if(!$scope.selectedRoleDetails || !$scope.selectedRoleDetails.permissions) return -1;
    for(var i=0; i<$scope.selectedRoleDetails.permissions.length; i++) {
      if($scope.selectedRoleDetails.permissions[i].resource == resource) {
        return i;
      }
    }
    return -1;
  };

};

