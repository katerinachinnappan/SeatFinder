/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var deployment = angular.module('apim.deployment');

deployment.controller('DeployedProductsController', [
  '$scope',
  '$timeout',
  '$filter',
  'orderByFilter',
  'DeployedProduct',
  'DeveloperOrganization',
  'Environment',
  'orgToTagFilter',
  'communityToTagFilter',
  'translateMultipleFilter',
  'translatePluralityFilter',
  'uniqueFilter',
  deployedProductsController,
]);

function deployedProductsController(
  $scope,
  $timeout,
  $filter,
  orderBy,
  DeployedProduct,
  DeveloperOrganization,
  Environment,
  orgToTagFilter,
  communityToTagFilter,
  translateMultipleFilter,
  translatePluralityFilter,
  uniqueFilter
) {
  $scope.addNextProducts = function($el) {
    var table = $el.currentTarget;
    var l = $scope.visibleProductVersions.length;

    if (l >= $scope.productVersions.length) {
      return;
    }

    if ((table.offsetHeight + table.scrollTop) >= table.scrollHeight) {
      $scope.visibleProductVersions = $scope.visibleProductVersions.concat(
        $scope.productVersions.slice(l, l + 30)
      );
      $scope.$digest()
    }
  };
  $scope.queryChange = function() {
    $scope.xhrProcessing = true;
    var query = ($scope.query || '').toLowerCase();
    if (!query) {
      $scope.productVersions = angular.copy($scope.fullProductVersions);
    } else {
      $scope.productVersions = $filter('filter')($scope.fullProductVersions, {
        $: query,
      });
    }
    $scope.visibleProductVersions = $scope.productVersions.slice(0, 30);
    $scope.xhrProcessing = false;
  };
  // expand full width by default
  $scope.panelExpanded = true;
  $scope.xhrProcessing = true;
  var orgUnwatch = $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    orgUnwatch();
    var envWatch = $scope.$watch('environments', function() {
      if (!$scope.environments) return;
      envWatch();
      var hashArray = window.location.hash.split("/");
      var envId = hashArray[2];
      if(!$scope.environment || $scope.environment.id != envId) {
        var filtered = $scope.environments.filter(function(env) {
          return env.id == envId;
        });
        if (filtered.length > 0) {
          $scope.setEnvironment(filtered[0]);
        }
      }
      // make sure we setup the correct space if we land directly on this page
      if (hashArray[3] == "spaces") {
        var spaceId = hashArray[4];
        if (spaceId != $scope.spaceId) {
          $scope.setSpace(spaceId, true);
        }
      } else if ($scope.spaceId) {
        $scope.setSpace("", true);
      }
    });
  });

  var unwatch = $scope.$watch('environment', function() {
    if (!$scope.environment) return;

    unwatch();

    unwatch = $scope.$watch('permissions', function() {
      if (!$scope.permissions) return;

      unwatch();

      if($scope.permissions[$scope.spaceId ? $scope.spaceId + '/space_productDeployment/view' : $scope.environment.id + '/catalog_productDeployment/view']) {
        $scope.xhrProcessing = true;
        var deployedQueryArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id,
          expand: false,
        };
        if ($scope.spaceId) {
          deployedQueryArgs.spaces = "spaces";
          deployedQueryArgs.spaceId = $scope.spaceId;
        }
        $scope.productVersions = DeployedProduct.query(deployedQueryArgs);
        $scope.productVersions.$promise.then(function(res) {
          $scope.fullProductVersions = orderBy(res, $scope.orderProp);
          $scope.fullProductVersions.$resolved = res.$resolved;

          angular.copy($scope.fullProductVersions, $scope.productVersions);

          $scope.visibleProductVersions = $scope.productVersions.filter(function(el) {
            return $scope.status[el.deploymentState];
          }).slice(0, 30);
          $scope.xhrProcessing = false;
        });
      }
      if ($scope.permissions[$scope.spaceId ? $scope.spaceId + '/space_developers/view' : $scope.environment.id + '/catalog_developers/view']) {
        var devOrgsArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id
        };
        if ($scope.spaceId) {
          devOrgsArgs.spaces = "spaces";
          devOrgsArgs.spaceId = $scope.spaceId;
        }
        $scope.developerOrgs = DeveloperOrganization.query(devOrgsArgs);
        $scope.developerOrgs.$promise.then(function() {
          var organizationTags = orgToTagFilter($scope.developerOrgs);
          var communityTags = [];
          $scope.developerOrgs.forEach(function(org) {
            if (org.tags) {
              communityTags = communityTags.concat(org.tags);
            }
          });
          communityTags = uniqueFilter(communityTags, "name");
          communityTags = communityToTagFilter(communityTags, false);
          $scope.organizationTags = organizationTags;
          $scope.communityTags = communityTags;
          $scope.tags = organizationTags.concat(communityTags);
        });
      }
    });
  });
  $scope.$on('descriptorChanged', function() {
    var deployedQueryArgs = {
      orgId: $scope.orgId,
      envId: $scope.environment.id
    };
    if ($scope.spaceId) {
      deployedQueryArgs.spaces = "spaces";
      deployedQueryArgs.spaceId = $scope.spaceId;
    }
    $scope.productVersions = DeployedProduct.query(deployedQueryArgs);
  });
  $scope.refreshSubscriptionsForPlan = function(productVersion, planName) {
    $scope.$broadcast('deployedProductVersionSubscriptions_' + productVersion.productName + '/' +
      productVersion.productVersion + '/' + planName);
  };
  $scope.refreshProduct = function(name, version) {
    $scope.productVersions.forEach(function(productVersion) {
      if (productVersion.productName == name && productVersion.productVersion == version) {
        $scope._refreshProduct(productVersion);
      }
    });

  };
  $scope._refreshPlan = function() {};
  $scope._refreshProduct = function(productVersion) {
    var docId = productVersion.productName;
    var docVersion = productVersion.productVersion;
    var productVersionArgs = {
      orgId: $scope.orgId,
      envId: $scope.environment.id,
      productId: docId + ":" + docVersion
    };
    if ($scope.spaceId) {
      productVersionArgs.spaces = "spaces";
      productVersionArgs.spaceId = $scope.spaceId;
    }
    productVersion = productVersion.$get(productVersionArgs).then(function() {
      $scope.$broadcast('deployedProductVersionSubscriptions_' + docId + "/" + docVersion);
    });
  };
  $scope.checkForTask = function(response) {
    return response &&
      response.operationStatusSummary &&
      response.operationStatusSummary.messages &&
      response.operationStatusSummary.messages.CREATED_WORKFLOW_TASK;
  };
  $scope.handleMessages = function(operationSummary) {
    if (!operationSummary.messages) return;
    var message = "";
    var removedPlanIds = [];
    if (operationSummary.messages['REMOVED_FROM_ENVIRONMENT']) {
      for (var i = 0; i < operationSummary.messages['REMOVED_FROM_ENVIRONMENT'].length; i++) {
        var url = operationSummary.messages['REMOVED_FROM_ENVIRONMENT'][i];
        removedPlanIds.push(url.substring(url.indexOf("/plans/") + 7));
      }
    }
    if (removedPlanIds.length > 0) {
      message = translatePluralityFilter(removedPlanIds.length, 'lifecycleEffects_REMOVED_FROM_ENVIRONMENT_digest') + ":<br/><br/>";
    }
    $scope.productVersions.forEach(function(productVersion) {
      if (removedPlanIds.indexOf(productVersion.productName + "/v" + productVersion.productVersion) >= 0) {
        $scope.productVersions.splice($scope.productVersions.indexOf(productVersion), 1);
        message += translateMultipleFilter('lifecycleEffects_REMOVED_FROM_ENVIRONMENT_message', {name: productVersion.productName, version: productVersion.productVersion}) + "<br/>";
      }
    });
    if (message != "") {
      var topic = dojo.require("dojo/topic");
      topic.publish('WA_MESSAGE', {
        type: "SUCCESS",
        text: message,
        autohide: true
      });
    }
  };
  $scope.receievedProductVersions = [];
  $scope.setExpanded = function(productVersion, expanded) {
    var documentId = productVersion.documentId;
    if ($scope.receievedProductVersions.indexOf(documentId) >= 0) {
      return handleExpanded();
    }
    $scope.getFullProduct(productVersion);
    handleExpanded();
    function handleExpanded(argument) {
      if (expanded && !$scope.isExpanded(documentId)) {
        $scope.expandedDeployments.push($scope.environment.id + '/' + documentId);
      } else if (!expanded && $scope.isExpanded(documentId)) {
        $scope.expandedDeployments.splice($scope.expandedDeployments.indexOf($scope.environment.id + '/' + documentId), 1);
      }
    }
  };

  $scope.getFullProduct = function(productVersion) {
    if ($scope.receievedProductVersions.indexOf(productVersion.documentId) >= 0) {
      return;
    }
    var productArgs = {
      orgId: productVersion.orgId,
      envId: productVersion.envId,
      productId: productVersion.documentId,
    }
    if(productVersion.spaceId) {
      productArgs.spaces = 'spaces'
      productArgs.spaceId = productVersion.spaceId
    }
    DeployedProduct.get(productArgs, function(product) {
      $scope.fullProductVersions.forEach(function(productVersion, index) {
        if (productVersion.id === product.id) {
          productVersion.getProductsSuccess = true;
          for (var i in product) {
            productVersion[i] = product[i];
          }
          $scope.receievedProductVersions.push(productVersion.documentId);
          syncProductVersion(productVersion);
        }
      });
    });
  };

  function syncProductVersion(productVersion) {
    $scope.visibleProductVersions.forEach(function(visibleProductVersion, index) {
      if(visibleProductVersion.id === productVersion.id) {
        angular.copy(productVersion, visibleProductVersion);
      }
    });
  }

  $scope.orderProp = 'productName';
  $scope.query = '';
  if (localStorage) {
    var storedStatus = localStorage.getItem("deployed-product-status");
    if (storedStatus) {
      $scope.status = JSON.parse(storedStatus);
    } else {
      $scope.status = {pending: true, staged: true, deployed: true, published: true, deprecated: true, retired: true, archived: false};
    }
  } else {
    $scope.status = {pending: true, staged: true, deployed: true, published: true, deprecated: true, retired: true, archived: false};
  }
  $scope.$watchCollection('status', function() {
    localStorage.setItem("deployed-product-status", JSON.stringify($scope.status));
    $scope.visibleProductVersions = $scope.productVersions.filter(function(el) {
      return $scope.status[el.deploymentState];
    }).slice(0, 30);
  });
  // need to attach a transition listener to handle slide effect properly
  var mainColumn = angular.element(document.getElementsByClassName("majorColumnLeft"));
  if (mainColumn) {
    mainColumn.on("transitionend", function() {
      var container = mainColumn.parent().parent();
      var parentContainer = container.parent();
      if (container.hasClass("expanded")) {
        parentContainer.addClass("slideOverflow");
      } else {
        parentContainer.removeClass("slideOverflow");
      }
    });
  }
};

deployment.controller('DeployedProductController', ['$scope', '$location', deployedProductController]);

function deployedProductController($scope, $location) {
  $scope.showDetails = true;
};

deployment.controller('DeployedProductVersionController', ['$scope', '$modal', 'translateMultipleFilter', 'otherPublishedProductVersionsFilter', 'otherPublishedOrDeprecatedProductVersionsFilter', '$state', deployedProductVersionController]);

function deployedProductVersionController($scope, $modal, translateMultipleFilter, otherPublishedProductVersionsFilter, otherPublishedOrDeprecatedProductVersionsFilter, $state) {
  // override any expansion variable
  $scope.showVersionDetails = false;
  $scope.getProductsSuccess = false;

  $scope.$watch('productVersions', function() {
    // check for suitable other product versions for replace or supersede function
    $scope.otherPublishedProducts = otherPublishedProductVersionsFilter($scope.productVersions, $scope.productVersion);
    $scope.otherPublishedOrDeprecatedProducts = otherPublishedOrDeprecatedProductVersionsFilter($scope.productVersions, $scope.productVersion);
  });

  $scope.visibility = $scope.productVersion.visibility;
  $scope.$watch('organizationTags', function() {
    $scope.$watch('communityTags', $scope.updateSelectedTags);
  });

  $scope.updateSelectedTags = function() {
    if (!$scope.organizationTags) return;
    if (!$scope.communityTags) return;
    $scope.selectedOrgsVisible = [];
    $scope.selectedCommunitiesVisible = [];
    $scope.selectedOrgsSubscribable = [];
    $scope.selectedCommunitiesSubscribable = [];
    if (!$scope.productVersion.deploymentVisibility) return;
    if ($scope.productVersion.deploymentVisibility.view.orgs) {
      $scope.productVersion.deploymentVisibility.view.orgs.forEach(function(orgTag) {
        var thisOrgTag = $scope.organizationTags.filter(function(tag) {
          return (tag.value == orgTag);
        });
        if (thisOrgTag.length == 1) {
          $scope.selectedOrgsVisible.push(thisOrgTag[0]);
        }
      });
    }
    if ($scope.productVersion.deploymentVisibility.subscribe.orgs) {
      $scope.productVersion.deploymentVisibility.subscribe.orgs.forEach(function(orgTag) {
        var thisOrgTag = $scope.organizationTags.filter(function(tag) {
          return (tag.value == orgTag);
        });
        if (thisOrgTag.length == 1) {
          $scope.selectedOrgsSubscribable.push(thisOrgTag[0]);
        }
      });
    }
    if ($scope.productVersion.deploymentVisibility.view.tags) {
      $scope.productVersion.deploymentVisibility.view.tags.forEach(function(communityTag) {
        var thisCommunityTag = $scope.communityTags.filter(function(tag) {
          return (tag.value == communityTag);
        });
        if (thisCommunityTag.length == 1) {
          $scope.selectedCommunitiesVisible.push(thisCommunityTag[0]);
        }
      });
    }
    if ($scope.productVersion.deploymentVisibility.subscribe.tags) {
      $scope.productVersion.deploymentVisibility.subscribe.tags.forEach(function(communityTag) {
        var thisCommunityTag = $scope.communityTags.filter(function(tag) {
          return (tag.value == communityTag);
        });
        if (thisCommunityTag.length == 1) {
          $scope.selectedCommunitiesSubscribable.push(thisCommunityTag[0]);
        }
      });
    }
  };
  $scope.handleModalResponse = function(modalInstance) {
    modalInstance.result.then(function(promise) {
      delete $scope.doingReplace;
      delete $scope.publishOnCommit;
      if (promise.$resolved) {
        $scope.xhrProcessing = false;
        $scope.updateSelectedTags();
      } else {
        promise.$promise.then(function() {
          $scope.xhrProcessing = false;
          $scope.updateSelectedTags();
        }, function() {
          $scope.xhrProcessing = false;
          $scope.updateSelectedTags();
        });
      }
    }, function() {
      delete $scope.doingReplace;
      delete $scope.publishOnCommit;
      $scope.xhrProcessing = false;
      $scope._refreshProduct($scope.productVersion);
      $scope.updateSelectedTags();
    });
  };
  $scope.availability = function(commit) {
    $scope.publishOnCommit = commit;
    $scope.getFullProduct($scope.productVersion);
    var modalInstance = $modal.open({
      templateUrl: 'apim/deployment/partials/visibility.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductPublishController',
      size: ($scope.productVersion) ? 'lg' : 'md',
      scope: $scope
    });
    $scope.handleModalResponse(modalInstance);
  };
  $scope.replace = function() {
    $scope.doingReplace = true;
    $scope.noAnimate = true;
    $scope.getFullProduct($scope.productVersion);
    var modalInstance = $modal.open({
      templateUrl: 'apim/deployment/partials/product-replace.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductPublishController',
      size: 'xlg',
      scope: $scope
    });
    $scope.handleModalResponse(modalInstance);
  };
  $scope.approvals = function() {
    $modal.open({
      templateUrl: 'apim/deployment/partials/approval-history.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductApprovalController',
      size: 'lg',
      scope: $scope
    });
  };
  $scope.supersede = function() {
    $scope.getFullProduct($scope.productVersion);
    var modalInstance = $modal.open({
      templateUrl: 'apim/deployment/partials/product-supersede.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductPublishController',
      size: 'lg',
      scope: $scope
    });
    $scope.handleModalResponse(modalInstance);
  };
  $scope.setMigrationTargets = function() {
    var modalInstance = $modal.open({
      templateUrl: 'apim/deployment/partials/product-migration-targets.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductPublishController',
      size: 'lg',
      scope: $scope
    });
    $scope.handleModalResponse(modalInstance);
  };
  $scope.deprecate = function() {

    console.log('trying to deprecate', $scope.productVersion)
    $scope.confirmation = {
      title: translateMultipleFilter('product_deprecate_title', {
        name: $scope.productVersion.productName,
        version: $scope.productVersion.productVersion
      }),
      messageKey: 'product_deprecate_description',
      confirmed: function() {
        $scope.xhrProcessing = true;
        var messageId = $scope.notifyUser('publishBeingDeprecated', {
          name: $scope.productVersion.productName,
          version: $scope.productVersion.productVersion,
          environment: $scope.environment.name
        }, 'BUSY');
        console.log('trying to deprecate', $scope.productVersion)
        var postArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id,
          productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
        };
        if ($scope.spaceId) {
          postArgs.spaces = "spaces";
          postArgs.spaceId = $scope.spaceId;
        }
        var promise = $scope.productVersion.$deprecate(postArgs, function(data) {
          $scope.xhrProcessing = false;
          var key = 'publishDoneBeingDeprecated';
          if ($scope.checkForTask(data)) key += 'PendingApproval';
          $scope.notifyUser(key, {
            name: $scope.productVersion.productName,
            version: $scope.productVersion.productVersion,
            environment: $scope.environment.name
          }, 'SUCCESS', true, messageId);
          if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
        },
          function() {
            $scope.xhrProcessing = false;
            $scope.notifyUser('publishFailedToDeprecate', {
              name: $scope.productVersion.productName,
              version: $scope.productVersion.productVersion,
              environment: $scope.environment.name
            }, 'ERROR', false, messageId);
          });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  $scope.stage = function() {
    $scope.confirmation = {
      title: translateMultipleFilter('product_stage_title', {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion}),
      messageKey: 'product_stage_description',
      confirmed: function() {
        $scope.xhrProcessing = true;
        var messageId = $scope.notifyUser('publishBeingStaged',
          {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
          'BUSY');
        var postArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id,
          productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
        };
        if ($scope.spaceId) {
          postArgs.spaces = "spaces";
          postArgs.spaceId = $scope.spaceId;
        }
        $scope.productVersion.$stage(postArgs, function(data) {
          $scope.xhrProcessing = false;
          var key = 'publishDoneBeingStaged';
          if ($scope.checkForTask(data)) key += 'PendingApproval';
          $scope.notifyUser(key,
            {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
            'SUCCESS', true, messageId);
        },
          function() {
            $scope.xhrProcessing = false;
            $scope.notifyUser('publishFailedToStage',
              {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
              'ERROR', false, messageId);
          });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  $scope.archive = function() {
    $scope.confirmation = {
      title: translateMultipleFilter('product_archive_title', {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion}),
      messageKey: 'product_archive_description',
      confirmed: function() {
        $scope.xhrProcessing = true;
        var messageId = $scope.notifyUser('publishBeingArchived',
          {name: $scope.productVersion.planName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
          'BUSY');
        var postArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id,
          productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
        };
        if ($scope.spaceId) {
          postArgs.spaces = "spaces";
          postArgs.spaceId = $scope.spaceId;
        }
        $scope.productVersion.$archive(postArgs, function(data) {
          $scope.xhrProcessing = false;
          var key = 'publishDoneBeingArchived';
          if ($scope.checkForTask(data)) key += 'PendingApproval';
          $scope.notifyUser(key,
            {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
            'SUCCESS', true, messageId);
        },
          function() {
            $scope.xhrProcessing = false;
            $scope.notifyUser('publishFailedToArchive',
              {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
              'ERROR', false, messageId);
          });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  $scope.retire = function() {
    $scope.confirmation = {
      title: translateMultipleFilter('product_retire_title', {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion}),
      messageKey: 'product_retire_description',
      confirmed: $scope.retireHelper,
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  $scope.retireHelper = function(unarchiving) {
    $scope.xhrProcessing = true;
    var messageId = $scope.notifyUser((unarchiving) ? 'publishBeingUnarchived' : 'publishBeingRetired',
      {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
      'BUSY');
    var postArgs = {
      orgId: $scope.orgId,
      envId: $scope.environment.id,
      productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
    };
    if ($scope.spaceId) {
      postArgs.spaces = "spaces";
      postArgs.spaceId = $scope.spaceId;
    }
    $scope.productVersion.$retire(postArgs, function(data) {
      $scope.xhrProcessing = false;
      var key = (unarchiving) ? 'publishDoneBeingUnarchived' : 'publishDoneBeingRetired';
      if ($scope.checkForTask(data)) key += 'PendingApproval';
      $scope.notifyUser(key,
        {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
        'SUCCESS', true, messageId);
    },
      function() {
        $scope.xhrProcessing = false;
        $scope.notifyUser((unarchiving) ? 'publishFailedToUnarchive' : 'publishFailedToRetire',
          {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
          'ERROR', false, messageId);
      });
  };
  $scope.remove = function() {
    $scope.confirmation = {
      title: translateMultipleFilter('product_remove_title', {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion}),
      messageKey: 'product_remove_description',
      confirmed: function() {
        $scope.xhrProcessing = true;
        var messageId = $scope.notifyUser('publishBeingRemoved',
          {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
          'BUSY');
        var postArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id,
          productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
        };
        var productName = $scope.productVersion.productName;
        var productVersion = $scope.productVersion.productVersion;
        var environmentName = $scope.environment.name;
        if ($scope.spaceId) {
          postArgs.spaces = "spaces";
          postArgs.spaceId = $scope.spaceId;
        }
        $scope.productVersion.$remove(postArgs, function(data) {
          $scope.xhrProcessing = false;
          var key = 'publishDoneBeingRemoved';
          if ($scope.checkForTask(data)) key += 'PendingApproval';
          $scope.notifyUser(key,
            {name: productName, version: productVersion, environment: environmentName},
            'SUCCESS', true, messageId);

          var product = $scope.productVersion;
          // Delete the item from the visible product list
          var visibleIndex = $scope.visibleProductVersions.indexOf(product);
          if (visibleIndex > -1) {
            $scope.visibleProductVersions.splice(visibleIndex, 1);
          }
          // Delete the item from the real product list
          var productIndex = $scope.productVersions.indexOf(product);
          if (productIndex > -1) {
            $scope.productVersions.splice(productIndex, 1);
          }
        },
          function() {
            $scope.xhrProcessing = false;
            $scope.notifyUser('publishFailedToRemove',
              {name: productName, version: productVersion, environment: environmentName},
              'ERROR', false, messageId);
          });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  $scope.displayAnalytics = function() {
    if ($scope.spaceId) {
      // TODO add additional args to fulfill the state
      $state.go('spaces_analytics', {
        type: 'product',
        id: $scope.productVersion.productName + ':' + $scope.productVersion.productVersion,
        name: $scope.productVersion.productName
      });
    } else {
      $state.go('catalogs_analytics', {
        type: 'product',
        id: $scope.productVersion.productName + ':' + $scope.productVersion.productVersion,
        name: $scope.productVersion.productName
      });
    }
  };
};

deployment.controller('ProductPlanController', ['$scope', '$modal', 'AppSubscription', 'supersededByObjectFilter', productPlanController]);

function productPlanController($scope, $modal, AppSubscription, supersededByObjectFilter) {
  $scope.refreshSubscriptions = function() {
    if($scope.permissions[$scope.environment.id + '/catalog_planSubscriptions/view']) {
      // get plan subscriptions
      $scope.refreshingSubscriptions = true;
      $scope.subscriptions = AppSubscription.query({
        orgId: $scope.orgId,
        envId: $scope.environment.id,
        planId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion + ":" + $scope.planVersion.planName
      });
      $scope.subscriptions.$promise.then(function() {
        $scope.refreshingSubscriptions = false;
      });
    }
  };
  $scope.migrateSubscriptions = function() {
    $scope.refreshSubscriptions();
    var modalInstance = $modal.open({
      templateUrl: 'apim/deployment/partials/product-migrate.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductPublishController',
      size: 'lg',
      scope: $scope
    });
    modalInstance.result.then(function() {
      $scope.xhrProcessing = false;
    }, function() {
      $scope.xhrProcessing = false;
    });
  };
  $scope.setTarget = function() {
    var modalInstance = $modal.open({
      templateUrl: 'apim/deployment/partials/product-target.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ProductPublishController',
      size: 'lg',
      scope: $scope
    });
    modalInstance.result.then(function() {
      $scope.xhrProcessing = false;
    }, function() {
      $scope.xhrProcessing = false;
    });
  };
  $scope.$watch('productVersion.supersededByResponse', function() {
    var supersededByObject = supersededByObjectFilter($scope.planVersion, $scope.productVersion, $scope.productVersions);
    if (!_.isEmpty(supersededByObject)) {
      $scope.supersededByObject = supersededByObject;
    } else {
      delete $scope.supersededByObject;
    }
  });
};


deployment.controller('ProductPublishController', ['$scope', '$http', '$modalInstance', 'otherPublishedProductVersionsFilter', 'deploymentSubscriberCountFilter', 'translateFilter', 'TrackingServices', 'DeployedProduct', productPublishController]);

function productPublishController($scope, $http, $modalInstance, otherPublishedProductVersionsFilter, deploymentSubscriberCountFilter, translateFilter, TrackingServices, DeployedProduct) {

  // flag the fact that we are within a modal in this scope
  $scope.modalContent = true;

  // override any expansion variable
  $scope.showVersionDetails = false;

  $scope.needSecureGatewayAssignment = false;

  $scope.$on("needSecureGatewayAssignment", function(evt, needSecureGatewayAssignment) {
    $scope.needSecureGatewayAssignment = needSecureGatewayAssignment;
  });

  $scope.planVersionQuery = "";

  if (!$scope.selectedVisibility) $scope.selectedVisibility = $scope.productVersion;

  // create lookup tables for options
  $scope.visibleOptions = [
    {id: "public", name: translateFilter("product_visibility_public")},
    {id: "authenticated", name: translateFilter("product_visibility_authenticated")},
    {id: "custom", name: translateFilter("planCustom")}
  ];

  $scope.subscribeOptions = [
    {id: "authenticated", name: translateFilter("product_visibility_authenticated")},
    {id: "custom", name: translateFilter("planCustom")}
  ];

  // watch out for a selectedProductVersion to set up auto-plan maps
  $scope.$watch('selectedProductVersion', function() {
    if (!$scope.selectedProductVersion) return;
    var planTargets = {};

    // if we're doing a replace, look for plan mappings in selectedProductVersion
    // otherwise, we're migrating and so we look in productVersion
    var supersededByResponse = ($scope.doingReplace) ? $scope.selectedProductVersion.supersededByResponse : $scope.productVersion.supersededByResponse;
    var selectedProductString = ($scope.doingReplace) ?
      $scope.productVersion.productName + ":" + $scope.productVersion.productVersion :
      $scope.selectedProductVersion.productName + ":" + $scope.selectedProductVersion.productVersion;
    // do we already have some plan targets?
      if (supersededByResponse) {
        if (supersededByResponse[selectedProductString]) {
          // honour them
          planTargets = angular.copy(supersededByResponse[selectedProductString]);
        }
      }
    $scope.planTargets = planTargets;
  });

  // set up defaults for migrate
  $scope.currentPage = 1;
  $scope.pageCount = 2;
  $scope.selectAll = true;
  $scope.$watch('subscriptions', function() {
    if (!$scope.subscriptions) return;
    $scope.subscriptions.$promise.then(function() {
      $scope.subscriptionsSelected = $scope.subscriptions.length > 0;
    });
  });

  if ($scope.supersededByObject) {
    $scope.selectedProductVersion = $scope.supersededByObject.object;
    $scope.selectedPlanName = $scope.supersededByObject.planShortName;
  }
  // end of defaults for migrate

  // set up defaults for deprecate
  $scope.availableProductVersions = otherPublishedProductVersionsFilter($scope.productVersions, $scope.productVersion);
  $scope.referenceProduct = false;
  // end of defaults for deprecate

  $scope.selectVisibility = function(selected) {
    $scope.selectedVisibility = selected;
    $scope.visibility = selected.visibility;
  };

  $scope.next = function() {
    if ($scope.migratingSubscription) {
      $scope.loadingPlanVersions = true;
      $scope.productVersions = DeployedProduct.query({
        orgId: $scope.orgId,
        envId: $scope.environment.id
      });
      $scope.productVersions.$promise.then(function() {
        $scope.loadingPlanVersions = false;
      });
    }
    $scope.currentPage++;
  };

  $scope.back = function() {
    $scope.currentPage--;
    // clear out any previously selected plan version
    $scope.selectedPlanVersion = null;
  };

  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };

  $scope.publish = function() {
    $scope.isPublishing = true;
    $scope.$broadcast('commitVisibility', $scope.productVersion);
    $scope.$parent.xhrProcessing = true;
    var promise = null;
    var messageId;
    if ($scope.productVersion.deploymentState != "published" && $scope.publishOnCommit === true) {
      // not in publish, so publish
      // make sure visibility settings are enabled
      $scope.productVersion.deploymentVisibility.view.enabled = true;
      $scope.productVersion.deploymentVisibility.subscribe.enabled = true;
      messageId = $scope.notifyUser('publishBeingPublished',
        {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
        'BUSY');
      var postArgs = {
        orgId: $scope.orgId,
        envId: $scope.environment.id,
        productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
      };
      if ($scope.spaceId) {
        postArgs.spaces = "spaces";
        postArgs.spaceId = $scope.spaceId;
      }
      promise = $scope.productVersion.$publish(postArgs, function(data) {
        var key = 'publishDoneBeingPublished';
        if ($scope.checkForTask(data)) key += 'PendingApproval';
        $scope.notifyUser(key,
          {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
          'SUCCESS', true, messageId);
        TrackingServices.track('product', 'publishProductApi' );
        if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
      },
        function() {
          $scope.notifyUser('publishFailedToPublish',
            {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
            'ERROR', false, messageId);
        });
    } else {
      // already published, so update
      messageId = $scope.notifyUser('publishEditingVisibility',
        {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
        'BUSY');
      var updateArgs = {
        orgId: $scope.orgId,
        envId: $scope.environment.id,
        productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
      };
      if ($scope.spaceId) {
        updateArgs.spaces = "spaces";
        updateArgs.spaceId = $scope.spaceId;
      }
      promise = $scope.productVersion.$update(updateArgs, function(data) {
        var key = 'publishDoneEditingVisibility';
        if ($scope.checkForTask(data)) key += 'PendingApproval';
        $scope.notifyUser(key,
          {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
          'SUCCESS', true, messageId);
        if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
        $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
      },
        function() {
          $scope.notifyUser('publishFailedEditingVisibility',
            {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name},
            'ERROR', false, messageId);
        });
    }
    $modalInstance.close(promise);
  };

  $scope.replaceVersion = function(productVersionToReplace) {
    $scope.$parent.xhrProcessing = true;
    var messageId = $scope.notifyUser('publishBeingReplaced',
      {newName: $scope.productVersion.productName, newVersion: $scope.productVersion.productVersion, environment: $scope.environment.name,
        name: productVersionToReplace.productName, version: productVersionToReplace.productVersion},
      'BUSY');
    var body = {
      oldProduct: {
        name: productVersionToReplace.productName,
        id: productVersionToReplace.productId,
        version: productVersionToReplace.productVersion
      },
      planMappings: []
    };
    Object.keys($scope.planTargets).forEach(function(fromPlan) {
      body.planMappings.push({
        from: fromPlan,
        to: $scope.planTargets[fromPlan]
      });
    });
    $scope.productVersion.$body = body;
    var postArgs = {
      orgId: $scope.orgId,
      envId: $scope.environment.id,
      productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
    };
    if ($scope.spaceId) {
      postArgs.spaces = "spaces";
      postArgs.spaceId = $scope.spaceId;
    }
    var promise = $scope.productVersion.$replace(postArgs, function(data) {
      delete $scope.productVersion.$body;
      var key = 'publishDoneBeingReplaced';
      if ($scope.checkForTask(data)) key += 'PendingApproval';
      $scope.notifyUser(key,
        {newName: $scope.productVersion.productName, newVersion: $scope.productVersion.productVersion, environment: $scope.environment.name,
          name: productVersionToReplace.productName, version: productVersionToReplace.productVersion},
        'SUCCESS', true, messageId);
      if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
      $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
      $scope.refreshProduct(productVersionToReplace.productName, productVersionToReplace.productVersion);
    },
      function() {
        delete $scope.productVersion.$body;
        $scope.notifyUser('publishFailedToReplace',
          {newName: $scope.productVersion.productName, newVersion: $scope.productVersion.productVersion, environment: $scope.environment.name,
            name: productVersionToReplace.productName, version: productVersionToReplace.productVersion},
          'ERROR', false, messageId);
        $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
        $scope.refreshProduct(productVersionToReplace.productName, productVersionToReplace.productVersion);
      });
    $modalInstance.close(promise);
  };

  $scope.migrateVersion = function(planNameToMigrateTo, productVersionToMigrateTo) {
    $scope.$parent.xhrProcessing = true;
    var subscriptions = [];
    $scope.filteredVersionSubscriptions.forEach(function(subscription) {
      if (subscription.selected) subscriptions.push(subscription.id);
    });
      var spaceUrl = "";
      if ($scope.spaceId) {
        spaceUrl = "/spaces/" + $scope.spaceId;
      }
      var promise = $http.post('proxy/orgs/' + $scope.orgId + '/environments/' + $scope.environment.id + spaceUrl +
        '/products/' + productVersionToMigrateTo.productName + ':' + productVersionToMigrateTo.productVersion +
        '/' + planNameToMigrateTo + '/migrate-subscription', {
          subscriptions: subscriptions
        });
      promise.then(function(data) {
        $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
        $scope.refreshProduct(productVersionToMigrateTo.productName, productVersionToMigrateTo.productVersion);
        $scope.refreshSubscriptions();
        if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
      },
        function() {
          $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
          $scope.refreshProduct(productVersionToMigrateTo.productName, productVersionToMigrateTo.productVersion);
        });
      $modalInstance.close(promise);
    };

          $scope.targetVersion = function(planNameToMigrateTo, productVersionToMigrateTo) {
              $modalInstance.close();
            };

              $scope.supersedeVersion = function(productVersionToReplace) {
                $scope.$parent.xhrProcessing = true;
                var messageId = $scope.notifyUser('publishBeingSuperseded',
                  {newName: $scope.productVersion.productName, newVersion: $scope.productVersion.productVersion, environment: $scope.environment.name,
                    name: productVersionToReplace.productName, version: productVersionToReplace.productVersion},
                  'BUSY');
                var body = {
                  oldProduct: {
                    name: productVersionToReplace.productName,
                    id: productVersionToReplace.docuement,
                    version: productVersionToReplace.productVersion
                  },
                  planMappings: []
                };
                Object.keys($scope.planTargets).forEach(function(fromPlan) {
                  body.planMappings.push({
                    from: fromPlan,
                    to: $scope.planTargets[fromPlan]
                  });
                });
                $scope.productVersion.$body = body;
                var postArgs = {
                  orgId: $scope.orgId,
                  envId: $scope.environment.id,
                  productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
                };
                if ($scope.spaceId) {
                  postArgs.spaces = "spaces";
                  postArgs.spaceId = $scope.spaceId;
                }
                var promise = $scope.productVersion.$supersede(postArgs, function(data) {
                  delete $scope.productVersion.$body;
                  var key = 'publishDoneBeingSuperseded';
                  if ($scope.checkForTask(data)) key += 'PendingApproval';
                  $scope.notifyUser(key,
                    {newName: $scope.productVersion.productName, newVersion: $scope.productVersion.productVersion, environment: $scope.environment.name,
                      name: productVersionToReplace.productName, version: productVersionToReplace.productVersion},
                    'SUCCESS', true, messageId);
                  if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
                  $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
                  $scope.refreshProduct(productVersionToReplace.productName, productVersionToReplace.productVersion);
                },
                  function() {
                    delete $scope.productVersion.$body;
                    $scope.notifyUser('publishFailedToSupersede',
                      {newName: $scope.productVersion.productName, newVersion: $scope.productVersion.productVersion, environment: $scope.environment.name,
                        name: productVersionToReplace.productName, version: productVersionToReplace.productVersion},
                      'ERROR', false, messageId);
                    $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
                    $scope.refreshProduct(productVersionToReplace.productName, productVersionToReplace.productVersion);
                  });
                $modalInstance.close(promise);
              };

              $scope.setMigrationTargetsForVersion = function(productVersionToMigrateTo) {
                $scope.$parent.xhrProcessing = true;
                var messageId = $scope.notifyUser('publishSettingMigrateTargets',
                  {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name,
                    newName: productVersionToMigrateTo.productName, newVersion: productVersionToMigrateTo.productVersion},
                  'BUSY');
                var body = {
                  newProduct: {
                    name: productVersionToMigrateTo.productName,
                    version: productVersionToMigrateTo.productVersion
                  },
                  planMappings: []
                };
                Object.keys($scope.planTargets).forEach(function(fromPlan) {
                  var mapping = {
                    from: fromPlan,
                    to: $scope.planTargets[fromPlan]
                  };
                  if (mapping.to === "__none__") mapping.to = null;
                  body.planMappings.push(mapping);
                });
                $scope.productVersion.$body = body;
                var postArgs = {
                  orgId: $scope.orgId,
                  envId: $scope.environment.id,
                  productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
                };
                if ($scope.spaceId) {
                  postArgs.spaces = "spaces";
                  postArgs.spaceId = $scope.spaceId;
                }
                var promise = $scope.productVersion.$migration(postArgs, function(data) {
                  delete $scope.productVersion.$body;
                  var key = 'publishDoneSettingMigrateTargets';
                  if ($scope.checkForTask(data)) key += 'PendingApproval';
                  $scope.notifyUser(key,
                    {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name,
                      newName: productVersionToMigrateTo.productName, newVersion: productVersionToMigrateTo.productVersion},
                    'SUCCESS', true, messageId);
                  if (data.operationStatusSummary) $scope.handleMessages(data.operationStatusSummary);
                  $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
                  $scope.refreshProduct(productVersionToMigrateTo.productName, productVersionToMigrateTo.productVersion);
                },
                  function() {
                    delete $scope.productVersion.$body;
                    $scope.notifyUser('publishFailedToSetMigrateTargets',
                      {name: $scope.productVersion.productName, version: $scope.productVersion.productVersion, environment: $scope.environment.name,
                        newName: productVersionToMigrateTo.productName, newVersion: productVersionToMigrateTo.productVersion},
                      'ERROR', false, messageId);
                    $scope.refreshProduct($scope.productVersion.productName, $scope.productVersion.productVersion);
                    $scope.refreshProduct(productVersionToMigrateTo.productName, productVersionToMigrateTo.productVersion);
                  });
                $modalInstance.close(promise);
              };

              $scope.productVersionSelected = function(selectedProductVersion) {
                $scope.getFullProduct(selectedProductVersion);
                $scope.selectedProductVersion = selectedProductVersion;
              };

              $scope.planVersionSelected = function(planName, otherProductVersion) {
                $scope.selectedPlanName = planName;
                $scope.selectedProductVersion = otherProductVersion;
              };

              $scope.selectAllSubscriptions = function() {
                $scope.filteredVersionSubscriptions.forEach(function(subscription) {
                  subscription.selected = $scope.selectAll;
                });
                $scope.subscriptionsSelected = $scope.selectAll;
              };

              $scope.subscriptionSelected = function(subscription) {
                if (!subscription.selected) $scope.selectAll = false;
                var selected = $scope.filteredVersionSubscriptions.filter(function(subscription) {
                  return subscription.selected;
                });
                $scope.selectAll = (selected.length == $scope.filteredVersionSubscriptions.length);
                $scope.subscriptionsSelected = (selected.length > 0);
              };
          };

            deployment.controller('VisibilitySettingsController', ['$scope', 'otherPublishedProductVersionsFilter', 'deploymentSubscriberCountFilter', 'translateFilter', visibilitySettingsController]);

            function visibilitySettingsController($scope, otherPublishedProductVersionsFilter, deploymentSubscriberCountFilter, translateFilter) {
              $scope.updateSelectedTags = function() {
                if (!$scope.organizationTags) return;
                if (!$scope.communityTags) return;
                if (!$scope.visibility) return;
                $scope.selectedOrgsVisible = [];
                $scope.selectedCommunitiesVisible = [];
                $scope.selectedOrgsSubscribable = [];
                $scope.selectedCommunitiesSubscribable = [];
                if ($scope.visibility.view.orgs) {
                  $scope.visibility.view.orgs.forEach(function(orgTag) {
                    var thisOrgTag = $scope.organizationTags.filter(function(tag) {
                      return (tag.value == orgTag);
                    });
                    if (thisOrgTag.length == 1) {
                      $scope.selectedOrgsVisible.push(thisOrgTag[0]);
                    }
                  });
                }
                if ($scope.visibility.subscribe.orgs) {
                  $scope.visibility.subscribe.orgs.forEach(function(orgTag) {
                    var thisOrgTag = $scope.organizationTags.filter(function(tag) {
                      return (tag.value == orgTag);
                    });
                    if (thisOrgTag.length == 1) {
                      $scope.selectedOrgsSubscribable.push(thisOrgTag[0]);
                    }
                  });
                }
                if ($scope.visibility.view.tags) {
                  $scope.visibility.view.tags.forEach(function(communityTag) {
                    var thisCommunityTag = $scope.communityTags.filter(function(tag) {
                      return (tag.value == communityTag);
                    });
                    if (thisCommunityTag.length == 1) {
                      $scope.selectedCommunitiesVisible.push(thisCommunityTag[0]);
                    }
                  });
                }
                if ($scope.visibility.subscribe.tags) {
                  $scope.visibility.subscribe.tags.forEach(function(communityTag) {
                    var thisCommunityTag = $scope.communityTags.filter(function(tag) {
                      return (tag.value == communityTag);
                    });
                    if (thisCommunityTag.length == 1) {
                      $scope.selectedCommunitiesSubscribable.push(thisCommunityTag[0]);
                    }
                  });
                }
              };
              var defaultVisibility = {
                view: {
                  enabled: true,
                  type: "public"
                },
                subscribe: {
                  enabled: true,
                  type: "authenticated"
                }
              };
              if ($scope.plan) {
                //$scope.deploymentVisibility = $scope.plan.visibility;
                if (!$scope.plan.visibility) $scope.plan.visibility = defaultVisibility;
                $scope.visibility = $scope.plan.visibility;
              } else {
                if (!$scope.productVersion.deploymentVisibility) $scope.productVersion.deploymentVisibility = defaultVisibility;
                $scope.visibility = $scope.productVersion.deploymentVisibility;
              }
              $scope.visibleTo = $scope.visibility.view.type;
              $scope.subscribableBy = $scope.visibility.subscribe.type;
              $scope.disableVisibility = !$scope.visibility.view.enabled;
              $scope.disableSubscribability = !$scope.visibility.subscribe.enabled;
              $scope.updateSelectedTags();
              // end of defaults for availability

              $scope.$on('commitVisibility', function(event, productVersion) {
                // commit user changes to the model
                $scope.visibility = productVersion.deploymentVisibility;

                var orgsVisible = [];
                if($scope.selectedOrgsVisible) {
                  $scope.selectedOrgsVisible.forEach(function(org) {
                    orgsVisible.push(org.value);
                  });
                }
                var orgsSubscribable = [];
                if($scope.selectedOrgsSubscribable) {
                  $scope.selectedOrgsSubscribable.forEach(function(org) {
                    orgsSubscribable.push(org.value);
                  });
                }
                var communitiesVisible = [];
                if($scope.selectedCommunitiesVisible) {
                  $scope.selectedCommunitiesVisible.forEach(function(community) {
                    communitiesVisible.push(community.value);
                  });
                }
                var communitiesSubscribable = [];
                if($scope.selectedCommunitiesSubscribable) {
                  $scope.selectedCommunitiesSubscribable.forEach(function(community) {
                    communitiesSubscribable.push(community.value);
                  });
                }
                $scope.visibility.view.type = $scope.visibleTo;
                if ($scope.visibleTo == "custom") {
                  $scope.visibility.view.orgs = orgsVisible;
                  $scope.visibility.view.tags = communitiesVisible;
                } else {
                  delete $scope.visibility.view.orgs;
                  delete $scope.visibility.view.tags;
                }
                $scope.visibility.view.enabled = !$scope.disableVisibility;
                $scope.visibility.subscribe.type = $scope.subscribableBy;
                if ($scope.subscribableBy == "custom") {
                  $scope.visibility.subscribe.orgs = orgsSubscribable;
                  $scope.visibility.subscribe.tags = communitiesSubscribable;
                } else {
                  delete $scope.visibility.subscribe.orgs;
                  delete $scope.visibility.subscribe.tags;
                }
                $scope.visibility.subscribe.enabled = !$scope.disableSubscribability;
              });

              // tie together related variables
              $scope.$watch('visibleTo', function() {
                if ($scope.visibleTo == "custom") $scope.subscribableBy = "custom";
              });
              $scope.$watch('subscribableBy', function() {
                if ($scope.subscribableBy != "custom" && $scope.visibleTo == "custom") $scope.visibleTo = "authenticated";
              });
              $scope.$watchCollection('selectedOrgsSubscribable', function() {
                $scope.selectedOrgsSubscribable.forEach(function(org) {
                  if ($scope.selectedOrgsVisible.indexOf(org) < 0) $scope.selectedOrgsVisible.push(org);
                });
              });
              $scope.$watchCollection('selectedCommunitiesSubscribable', function() {
                $scope.selectedCommunitiesSubscribable.forEach(function(org) {
                  if ($scope.selectedCommunitiesVisible.indexOf(org) < 0) $scope.selectedCommunitiesVisible.push(org);
                });
              });
              // end related variables
              $scope.deleteTagVisible = function(tag) {
                if (tag.org) {
                  $scope.selectedOrgsVisible = $scope.selectedOrgsVisible.filter(function(orgTag) {
                    return (orgTag.value != tag.value);
                  });
                } else if (tag.community) {
                  $scope.selectedCommunitiesVisible = $scope.selectedCommunitiesVisible.filter(function(communityTag) {
                    return (communityTag.value != tag.value);
                  });
                }
              };
              $scope.deleteTagSubscribable = function(tag) {
                if (tag.org) {
                  $scope.selectedOrgsSubscribable = $scope.selectedOrgsSubscribable.filter(function(orgTag) {
                    return (orgTag.value != tag.value);
                  });
                } else if (tag.community) {
                  $scope.selectedCommunitiesSubscribable = $scope.selectedCommunitiesSubscribable.filter(function(communityTag) {
                    return (communityTag.value != tag.value);
                  });
                }
              };
              $scope.orgsTagsVisibleSelected = function(item) {
                if (item.org) {
                  $scope.selectedOrgsVisible.push(item);
                } else if (item.community) {
                  $scope.selectedCommunitiesVisible.push(item);
                }
                $scope.userInputVisible = null;
              };
              $scope.orgsTagsSubscribableSelected = function(item) {
                if (item.org) {
                  $scope.selectedOrgsSubscribable.push(item);
                } else if (item.community) {
                  $scope.selectedCommunitiesSubscribable.push(item);
                }
                $scope.userInputSubscribable = null;
              };
            };

            deployment.controller('ProductApprovalController', ['$scope', '$modalInstance', 'ProductApproval', productApprovalController]);

            function productApprovalController($scope, $modalInstance, ProductApproval) {
              $scope.retrievingApprovals = true;
              var queryArgs = {
                orgId: $scope.orgId,
                envId: $scope.environment.id,
                productId: $scope.productVersion.productName + ':' + $scope.productVersion.productVersion
              };
              if ($scope.spaceId) {
                queryArgs.spaces = "spaces";
                queryArgs.spaceId = $scope.spaceId;
              }
              $scope.approvals = ProductApproval.query(queryArgs);
              $scope.approvals.$promise.then(function() {
                $scope.retrievingApprovals = false;
              });
              $scope.cancel = function() {
                $modalInstance.dismiss('cancel');
              };
            };

            deployment.controller('SecureGatewayAssignmentController', ['$scope', '$q', 'Gateway', 'Swagger', secureGatewayAssignmentController]);

            function secureGatewayAssignmentController($scope, $q, Gateway, Swagger) {
              $scope.secureGatewayAssignmentLoaded = false;

              $scope.$emit("needSecureGatewayAssignment", true);

              $scope.secureGatewayDeploymentInfo = Swagger.query({
                orgId: $scope.orgId,
                envId: $scope.environment.id,
                productId: $scope.productVersion.productName + ":" + $scope.productVersion.productVersion
              });

              $scope.secureGatewayDeploymentInfo.$promise.then(function() {
                if($scope.secureGatewayDeploymentInfo.length === 0) {
                  $scope.$emit("needSecureGatewayAssignment", false);
                  return;
                }

                for(var i = 0; i < $scope.secureGatewayDeploymentInfo.length; i++) {
                  $scope.secureGatewayDeploymentInfo[i].spaceGUID = $scope.bluemixExternalSpaceId;
                  $scope.secureGatewayDeploymentInfo[i].orgGUID = $scope.bluemixExternalOrgId;
                }

                $scope.secureGateways = Gateway.query({
                  orgId: $scope.orgId
                });

                return $scope.secureGateways.$promise;
              }).then(function() {
                $scope.secureGatewayAssignmentLoaded = true;
              });

              $scope.secureGatewayDeploymentInfoChange = function() {
                var numberOfGatewaysNotAssigned = 0;

                for(var i = 0; i < $scope.secureGatewayDeploymentInfo.length; i++) {
                  if($scope.secureGatewayDeploymentInfo[i].gateway.length === 0) {
                    numberOfGatewaysNotAssigned++
                  }
                }

                if(numberOfGatewaysNotAssigned === 0) {
                  $scope.$emit("needSecureGatewayAssignment", false);
                }

                $scope.productVersion.secureGatewayDeploymentInfo = $scope.secureGatewayDeploymentInfo;
              };
            };

            deployment.controller('DeployedProductApiController', ['$scope', '$modal', '$http', deployedProductApiController]);

            function deployedProductApiController($scope, $modal, $http) {
              $scope.apiToggled = $scope.apiVersion && $scope.apiVersion.deploymentState === 'running';
              $scope.refreshApiDescriptorState = function(apiVersion, newState) {
                $scope.products.forEach(function(product) {
                  if (!product.dependents.APIVERSION) return;
                  product.dependents.APIVERSION.forEach(function(api) {
                    if (api.apiId == apiVersion.apiId && api.documentVersion == apiVersion.documentVersion) {
                      api.deploymentState = newState;
                    }
                  });
                });
              };
              $scope.toggleApi = function() {
                if ($scope.apiVersion.deploymentState === 'suspended') {
                  start();
                  $scope.apiVersion.deploymentState = 'running';
                } else if ($scope.apiVersion.deploymentState === 'running') {
                  stop();
                }
              };
              function start() {
                $scope.changingState = true;
                var addedSpace = "";
                if ($scope.spaceId) {
                  addedSpace = "/spaces/" + $scope.spaceId;
                }
                $http.post('proxy/orgs/' + $scope.orgId + '/environments/' + $scope.environment.id + addedSpace +
                  '/apis/' + $scope.apiVersion.id + '/start'
                ).then(function(response) {
                  if (response.data && response.data.deploymentState) $scope.refreshApiDescriptorState($scope.apiVersion, response.data.deploymentState);
                  $scope.apiVersion.deploymentState = response.data.deploymentState;
                  $scope.changingState = false;
                }, function() {
                  $scope.changingState = false;
                })
                .finally(function() {
                  $scope.apiToggled = $scope.apiVersion && $scope.apiVersion.deploymentState === 'running';
                });
              };
              function stop() {
                $scope.confirmation = {
                  titleKey: 'apiSuspendTitle',
                  messageKey: 'apiTakeOfflineDetail',
                  confirmed: function() {
                    $scope.changingState = true;
                    var addedSpace = "";
                    if ($scope.spaceId) {
                      addedSpace = "/spaces/" + $scope.spaceId;
                    }
                    $http.post('proxy/orgs/' + $scope.orgId + '/environments/' + $scope.environment.id + addedSpace +
                      '/apis/' + $scope.apiVersion.id + '/stop'
                    ).then(function(response) {
                      if (response.data && response.data.deploymentState) $scope.refreshApiDescriptorState($scope.apiVersion, response.data.deploymentState);
                      $scope.apiVersion.deploymentState = response.data.deploymentState;
                      $scope.changingState = false;
                    }, function() {
                      $scope.changingState = false;
                    })
                    .finally(function () {
                      $scope.apiToggled = $scope.apiVersion && $scope.apiVersion.deploymentState === 'running';
                    });
                  },
                  rejected: function() {
                    $scope.apiToggled = $scope.apiVersion && $scope.apiVersion.deploymentState === 'running';
                  }
                };
                $modal.open({
                  templateUrl: 'apim/partials/confirmation.html',
                  windowTemplateUrl: 'apim/partials/main-template.html',
                  controller: 'ConfirmationController',
                  size: 'sm',
                  scope: $scope
                });
              };
            };
