/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/**
  * Use this directive to create bluemix type notification
  *
  * Usage:
  * <bx-notification-container notification-model></bx-notification-container>
  * where notification-model is expect to be a collection of message
  * var notificationModel = [
    *   {
      *     type: 'info', // success, warning, error
      *     text: 'string',
      *     timestamp: Javascript date that works with angular date filter
      *   }
    * ]
  *
  * Directive container will create childs based on messages in notificationModel
  */

  angular.module('bluemix.components')
  .directive('bxNotificationContainer', function() {
    return {
      restrict: 'E',
      templateUrl: 'apim/bluemix/components/notification/notification-container-generic.html',
      controller: function($scope) {
        this.removeNotification = function(index) {
          // XXX(Phong): This is weird to me. If user gets trigger-happy or
          // somehow the closeNotification method triggers twice (this is
            // actually happening if you put some console.log()'s), if the index
          // is less than the length of the array by 2, it can actually splice
          // two elements per single invoke. There doesn't seem to be any side
          // effects by I'm skeptical of this code; there should be more
          // protection in place.
            $scope.notificationModel.splice(index , 1);
        };
      },
      scope: {
        notificationModel: '='
      }
    }
  })

  .directive('bxNotificationGeneric', ['$timeout', function($timeout) {
    return {
      restrict: 'E',
      templateUrl: 'apim/bluemix/components/notification/notification-generic.html',
      scope: {
        title: '@bxNotificationTitle',
        url: '@bxNotificationUrl',
        subtitle: '@bxNotificationSubtitle',
        timestamp: '@bxNotificationTimestamp',
        type: '@bxNotificationType',
        timer: '@bxNotificationTimer',
        msgIndex: '@'
      },
      require: '^^bxNotificationContainer',
      link: function(scope, iElement, iAttrs, containerController) {
        var closeNotificationTimer;

        // TODO: this is potentially a integration logic that should be moved to app itself
        scope.getNotificationClassName = function() {
          var validTypes = ['info', 'error', 'success', 'warning'];
          var typeLowerCase = scope.type.toLowerCase();
          if (validTypes.indexOf(typeLowerCase) >= 0) {
            scope.typeClass = typeLowerCase;
          } else {
            // hide any not supported notification types
            iElement.toggleClass('cloak');
          }
        };

        scope.closeNotification = function(index){
          if (closeNotificationTimer.$$state.value !== 'canceled') {
            // This deals with the situation where user clicks the X button when
            // the timeout is about to trigger so you don't have a smooth
            // close animation, but part of one and then suddenly disappearing.
              $timeout.cancel(closeNotificationTimer);
          }
          iElement.addClass('bx-notification-pre-slide-in');
          setTimeout(function(){
            containerController.removeNotification(index);
          }, 750);
        }

        scope.init = function() {
          // Set to 5 seconds, but we have 1 second of animation time so about
          // so 6s total. This is a pretty hacky way of doing things.
          var timeout = scope.timer || 6000;
          scope.getNotificationClassName();
          setTimeout(function(){
            iElement.removeClass('bx-notification-pre-slide-in');
            closeNotificationTimer = $timeout(scope.closeNotification.bind(scope, scope.msgIndex), timeout);
          }, 1000)
        }

        scope.init();
      }
    };
  }]);
