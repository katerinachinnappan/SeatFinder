/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apim.errors', []).factory('errorHandler', [
  '$q', '$rootScope', '$filter',
  function($q, $rootScope, $filter) {

    var loginEyecatcher = '<!-- Login Page Eyecatcher 5765625370686572652e6d647566 -->';

    var ignorePatterns = [
      // new RegExp("rest/monitoring/activity"),
      // new RegExp(".*/orgs/.*/notifications"),
      // new RegExp(".*/orgs/.*/apps/.*/image"),
      // new RegExp(".*/orgs/.*/apps/.*/secret"),
      // new RegExp(".*/servers/.*/health"),
      // new RegExp(".*/orgs/.*/environments/.*/configuration"),
      // new RegExp(".*/orgs/.*/environments/.*/theme"),
      // new RegExp(".*/orgs/.*/environments/.*/theme/logo"),
      // new RegExp(".*/orgs/.*/environments/.*/theme/herospot"),
      // new RegExp(".*/orgs/.*/environments/.*/theme/browsericon"),
      new RegExp(".*/users/context/.*"),
      new RegExp(".*/orgs/.*/environments/.*/consumerApps/.*/image"),
      // new RegExp(".*/orgs/.*/apps/.*/credentials/verify-secret"),
      // new RegExp(".*/ssl-profiles/.*/keystore/cert"),
      // new RegExp(".*/orgs/.*/analytics/topApis"),
      // new RegExp(".*/orgs/.*/analytics/topApps"),
      // new RegExp(".*/orgs/.*/analytics/usage")
    ];

    // 503 Service Unavailable. Expected from health and analytics APIs in certain circumstances.
      // We only want to swallow these URLs in 503 situation, in case there's a different error
    var serviceUnavailablePatterns = [
      // new RegExp(".*/.*Clusters/.*/health.*"),
      // new RegExp(".*/servers/.*/health.*"),
      // new RegExp(".*/orgs/.*/analytics.*")
    ];

    var alwaysIgnorePatterns = [
      // new RegExp(".*/orgs/.*/environments/.*/theme"),
      // new RegExp(".*/orgs/.*/environments/.*/theme/logo"),
      // new RegExp(".*/orgs/.*/environments/.*/theme/herospot"),
      // new RegExp(".*/orgs/.*/environments/.*/theme/browsericon"),
      // new RegExp(".*/orgs/.*/permissions")
      new RegExp(".*/ProcessManagers/*"),
      new RegExp(".*/iamid.*")
    ];

    var falseSessionTimeoutPatterns = [
      new RegExp(".*/me/logout")
    ];

    // The intent for this array is to track URLs we poll for
    // So that we can suppress the polling after some inactivity
    var notificationsPatterns = [
      // new RegExp(".*/count"),
      // new RegExp(".*/activity"),
      // new RegExp(".*/.*Clusters/.*/health.*"),
      new RegExp(".*/servers/.*/health"),
      new RegExp(".*/servers/.*")
    ];

    var lastXhrDone = 0;

    // private functions
    // Queue the original request and show the inline login panel
    function handleInlineLogin(response) {
      var def = $q.defer();
      var queuedXhr = {
        config: response.config,
        def: def
      };
      $rootScope.queuedXhrs.push(queuedXhr);
      showLoginPanel();
      return (def.promise);
    };

    function showLoginPanel() {
      $rootScope.$broadcast('event:showLogin');
    };

    function checkSession() {
      var $injector = angular.injector();
      var $http = $injector.get('$http');
      var def = $q.defer();
      // if the response is valid, and isn't the login page, return success
      // otherwise, return failure
      var config = {
        method: "GET",
        url: "proxy/me",
        ignoreHttpCheck: true
      };
      $http(config).success(function(data) {
        if (data && data.indexOf(loginEyecatcher) > -1) {
          def.reject();
        } else {
          def.resolve();
        }
      }).error(function(err) {
        def.reject();
      });
      return (def.promise);
    };

    function serviceUnavailableIgnore(url) {
      for (var i = 0; i < serviceUnavailablePatterns.length; i++) {
        if (serviceUnavailablePatterns[i].test(url)) {
          return true;
        }
      }
      return false;
    };

    function shouldIgnore(url) {
      for (var i = 0; i < ignorePatterns.length; i++) {
        if (ignorePatterns[i].test(url)) {
          return true;
        }
      }
      return false;
    };

    function alwaysIgnore(url) {
      for (var i = 0; i < alwaysIgnorePatterns.length; i++) {
        if (alwaysIgnorePatterns[i].test(url)) {
          return true;
        }
      }
      return false;
    };

    function falseSessionTimeout(url) {
      for (var i = 0; i < falseSessionTimeoutPatterns.length; i++) {
        if (falseSessionTimeoutPatterns[i].test(url)) {
          return true;
        }
      }
      return false;
    };

    function isNotificationsCall(url) {
      for (var i = 0; i < notificationsPatterns.length; i++) {
        if (notificationsPatterns[i].test(url)) {
          return true;
        }
      }
      return false;
    };

    function handleError(error, xhrArgs, deferred, quiet, reload) {
      if (quiet != true) {
        $rootScope.$broadcast('event:showError', error, reload);
      }
      if (deferred)
        deferred.reject(error);
    };

    // return the public functions
    return {
      isUserActive: function() {
        return (lastXhrDone == 0 || (new Date().getTime() - lastXhrDone) < 300000);
      },

      checkResponse: function(response) {
        var ret = response;
        // currently used by the angular interceptor
        if (response && response.config && response.config.url && !isNotificationsCall(response.config.url)) {
          // track this as an active call
          lastXhrDone = new Date().getTime();
        }
        if (response.status < 200 || response.status >= 400) {
          if (!alwaysIgnore(response.config.url) && !shouldIgnore(response.config.url)) {
            // We may have had a login page returned causing a JSON parsing error. Check for eyecatcher
            // or for a zero return code
            if (typeof response.data == "string" && response.data.indexOf(loginEyecatcher) > -1) {
              // hang on, did we just log out?
                if (response.config.url != "proxy/me/logout") {
                  // The eyecatcher was found. Show appropriate error message, instead of the original
                  ret = handleInlineLogin(response);
                }
            } else if (response.status === 0) {
              // an api call timed out. Is this possibly expected?
                if (!falseSessionTimeout(response.config.url)) {
                  // It wasn't expected. We should run a session check to check if our session is still valid
                  // checkSession().then(
                    //   function() {
                      //     // we passed a session check... so the api call just timed out
                      //     // This happens on SaaS regularly especially with
                      //     // e.g. bluemix/ibmID/SCX related calls,
                        //     // where the browser may give up before the backend call does.
                        //     // There won't be any response text here so we shall provide our own
                      //       handleError({
                        //         responseText: $filter('translate')("apiCallTimeoutTitle"),
                        //         message: $filter('translate')("apiCallTimeoutMessage")
                        //       }, null, null, null, false);
                      //   },
                    //   function() {
                      //     // we failed a session check
                      //     ret = handleInlineLogin(response);
                      //   }
                    // );
                  handleError({
                    responseText: $filter('translate')("apiCallTimeoutTitle"),
                    message: $filter('translate')("apiCallTimeoutMessage")
                  }, null, null, null, false);
                }

            } else if (response.status === 403 || response.status === 412) {
              // *perhaps* our session is down... let's do a quick check
              // TODO checkSession does not work from here - cycle on $http - suspect we dont even need this check
              // checkSession().then(
                //   function() {
                  //     // we passed a session check... treat the error as genuine
                  //     handleError({response: response});
                  //   },
                //   function() {
                  //     // we failed a session check
                  //     ret = handleInlineLogin(response);
                  //   }
                // );
              handleError({response: response});
            } else if (response.status === 503) {
              if (!serviceUnavailableIgnore(response.config.url)) {
                handleError({response: response});
              }

            } else {
              // It wasn't a login page, continue handling the error
              handleError({response: response});
            }
          }
          // default in error case is to return bad
          ret = $q.reject(response);
        } else {
          var massagedErrors;
          // perhaps the session ended
          if (typeof response.data == 'string' && response.data.indexOf(loginEyecatcher) > -1) {
            if (!response.config.ignoreHttpCheck && !falseSessionTimeout(response.config.url)) {
              ret = handleInlineLogin(response);
            }
          }
          // Perhaps it was a fileUpload response - responseOrError is not an instance of Error in this case
          else if (response.data && typeof response.data == 'object' && response.data.body) {
            var decodedJson;
            try {
              decodedJson = response.data.body.innerText;
              if (!decodedJson) decodedJson = response.data.body.textContent;
              if (typeof decodedJson == "string") decodedJson = JSON.parse(decodedJson);
              // It was JSON in an HTML wrapper.
                if (decodedJson.errors){
                  // It's an error response from a file upload.
                    // Massage this into the right format so our ErrorMessage can handle it.
                    massagedErrors = {response: {
                      data: {
                        errors: decodedJson.errors
                      }
                    }};
                  handleError(massagedErrors, null, null, null, false);
                }

            } catch(e){
              // Not JSON, swallow
            }
            // Response has errors
          } else if(response.errors) {
            massagedErrors = {response: {
              data: {
                errors: response.errors
              }
            }};
            handleError(massagedErrors, null, null, null, false);
          }
        }
        return (ret);
      }
    };
  }
]);

