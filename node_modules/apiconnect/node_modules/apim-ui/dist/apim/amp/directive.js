/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apic.amp').directive('apicAmp', [
  '$window',
  function($window) {
    return {
      restrict: 'E',
      templateUrl: 'apim/amp/partials/amp.main.html',
      scope: {
        logProcesses: '=',
        processes: '='
      },
      link: function($scope, $elem) {
        $elem.find('.amp-process-list').on('click', function(e) {
          e.stopPropagation();
        });

        function changeHeight (e, state) {
          var maximized = state === 'maximize';
          var maxHeight = $($window).innerHeight() - $('.mainBanner').height();
          var height = maximized ? maxHeight : 'auto';
          var ampMarginElement = angular.element(document.getElementsByClassName('amp-margin'));
          if (state === 'minimize') {
            height = maxHeight / 4;
            height = height < 150 ? 150 : height;
            ampMarginElement.css('margin-bottom', height);
          }
          else {
            ampMarginElement.css('margin-bottom', "3rem");
          }
          $elem.height(height);
        }

        $scope.$on('stateChange', changeHeight);
      },
      controller: [
        '$filter',
        '$scope',
        '$rootScope',
        '$log',
        'AppRunnerStates',
        'ProcessManager',
        'MicroGatewayService',
        'TrackingServices',
        '$modal',
        '$http',
        '$q',
        function($filter, $scope, $rootScope, $log, AppRunnerStates,
          ProcessManager, MicroGatewayService, TrackingServices, $modal, $http, $q) {
            $scope.disableControls = false;
            $scope.state = 'normalize';
            $scope.statusMessage = '';
            var failToStart = false;
            $scope.startedProcess = false;

            $scope.$watch('processes', function(newVal) {
              var isGw = function(process) {
                return !!process.gw || MicroGatewayService.isGateway(process);
              };

              if (newVal && newVal.some(isGw)) {
                MicroGatewayService.refreshGateway()
                  .then(function (gateways) {
                    if (gateways && gateways.length) {
                      $scope.gatewayUrl = gateways[0].url;
                    }
                  });
              }
            }, true);

            function processStartError(error) {
              error.responseText = $filter('translate')('unableToStartApp');
              error.collapseMessage = true;
              return error;
            }

            function handleStartError(result) {
              failToStart = true;
              $rootScope.$broadcast('event:showError', {
                titleKey: 'applicationStartFail',
                error: processStartError(result.data.error)
              });
            }

            ['start', 'restart', 'stop'].map(function(cmd) {
              $scope[cmd] = function(e) {
                e.stopPropagation();

                if ($scope.disableControls) {
                  return;
                }

                $scope.disableControls = true;
                TrackingServices.track('amp', cmd);

                var statusMsg = cmd + 'StatusMessage';
                $scope.statusMessage = $filter('translate')(statusMsg);

                $scope.continueProcess = function() {
                  var pm = ProcessManager[cmd]();
                  pm.$promise
                    .then(function(result) {
                      $log.log('application successfully started');
                      $scope.startedProcess = true;
                      failToStart = false;
                    }, handleStartError)
                    .finally(function() {
                      $scope.statusMessage = '';
                      $scope.disableControls = false;
                    });
                }

                if (cmd === 'start') {
                  // Get the name and version of the api
                  var baseURL = 'proxy/apimanager/orgs/localhost/apis';
                  var swaggerAPIParts = [
                    baseURL,
                    '?mode=swagger'
                  ]
                  var swaggerAPI = swaggerAPIParts.join('');
                  $http.get(swaggerAPI).then(function(response) {
                    var apis = response.data;
                    if (apis) {
                      var promises = [];
                      var idx = -1;
                      angular.forEach(apis, function(api, index) {
                        var DpGwApiParts = [
                          baseURL,
                          '/' + api.info.title,
                          ':' + api.info.version,
                          '?mode=swagger'
                        ]
                        var DpGwApi = DpGwApiParts.join('');
                        promises.push(
                          $http({ method: 'GET', url: DpGwApi }).then(function(response) {
                            if (response.data['x-ibm-configuration'].gateway === 'datapower-gateway') {
                              if (idx === -1) {
                                idx = index;
                              }
                            }
                          })
                        );
                      });

                      $q.all(promises).then(function() {
                        if ( idx === -1)
                          return $scope.continueProcess();
                        else {
                          $modal.open({
                            templateUrl: 'apim/partials/showGatewayProgress.html',
                            windowTemplateUrl: 'apim/partials/main-template.html',
                            controller: 'ToolkitProgressController',
                            size: 'sm',
                            scope: $scope
                          });
                        }
                      })
                    }
                  }, handleStartError);
                } else if (cmd === 'restart') {
                  $scope.startedProcess = false;
                  $scope.continueProcess();
                } else if (cmd === 'stop') {
                  var pm = ProcessManager[cmd]();
                  var watcher = $scope.$watch('processes', function(newVal) {
                    if (newVal && newVal.length < 1) {
                      // clear the watcher
                      watcher();
                      $scope.startedProcess = false;
                      $scope.statusMessage = '';
                      $scope.disableControls = false;
                    }
                  });
                }
              }
            });

            ['minimize', 'maximize', 'normalize'].forEach(function(fn) {
              $scope[fn] = function(e) {
                e.stopPropagation();
                $scope.changeState(fn);
              };
            });

            $scope.changeState = function(state) {
              $scope.$broadcast('stateChange', $scope.state = state);
            };

            var appStarting = false;
            $scope.$on('starting', function(e, status){
              appStarting = status;
            });

            $scope.isRunning = function() {
              return $scope.status() === AppRunnerStates.running;
            };

            $scope.isStarting = function () {
              if ($scope.logProcesses.length === 1) {
                return !$scope.isRunning();
              } else {
                return appStarting && !failToStart;
              }
            };

            $scope.status = function() {
              if ($scope.processes && $scope.processes.length > 0) {
                return AppRunnerStates.running;
              }

              return AppRunnerStates.stopped;
            };
        }
      ]
    };
  }
]);

angular.module('apic.amp')
  .controller('ToolkitProgressController', [
    '$filter',
    '$scope',
    '$rootScope',
    '$modalInstance',
    '$http',
    '$interval',
    ToolkitProgressController
  ]);

function ToolkitProgressController(
  $filter,
  $scope,
  $rootScope,
  $modalInstance,
  $http,
  $interval
) {
  $scope.options = {
    selectorInit: '[data-progress]',
    selectorStepElement: '.bx--progress-indicator__step',
    selectorCurrent: '.bx--progress-indicator__step--active',
    selectorIncomplete: '.bx--progress-indicator__step--incomplete',
    selectorComplete: '.bx--progress-step--complete',
    classStep: 'bx--progress-indicator__step',
    classComplete: 'bx--progress-indicator__step--complete',
    classCurrent: 'bx--progress-indicator__step--active',
    classIncomplete: 'bx--progress-indicator__step--incomplete',
  };

  $scope.initToolkitScript = function () {
    $scope.initProgressBar();
    setCurrentStep(0);
    $scope.errorText = '';
    $scope.onDockerstep = false;
    if ($scope.statusMessage === '') {
      var statusMsg = 'startStatusMessage';
      $scope.$parent.statusMessage = $filter('translate')(statusMsg);
      $scope.$parent.disableControls = true;
    }

    var config;
    if ($rootScope.features.experimental) {
      $scope.gateway = 'Experimental';
      config = {
        BUILD_V5: false,
        BUILD_EXPERIMENTAL: true,
        VALIDATE: true
      }
    } else {
      $scope.gateway = 'v5';
      config = {
        BUILD_V5: true,
        BUILD_EXPERIMENTAL: false,
        VALIDATE: true
      }
    }

    $http({
      url: '/dp/startScript',
      method: 'GET',
      params: config
    }).then(function(response){
      var id = response.data.id;
      var stopCount = $interval(function () {
        $http({
          url: '/dp/logs/' + id,
          method: 'GET'
        }).then(function(response) {
          var isDetectedPlatform = response.data.some(function(res) {
            if (res.indexOf('Detected platform:') >=0 ) {
              $scope.platform = res.slice(18);
              return res;
            }
          });

          if (isDetectedPlatform) {
            setCurrentStep(1);
          }

          var isError = response.data.some(function(err) {
            if (err.indexOf('Error') >=0 ) {
              $scope.errorText = err;
              return err;
            }
          });

          if (isError) {
            $scope.errorBlock = true;
            $scope.stopCounter();
            $scope.$parent.startedProcess = false;
            $scope.$parent.statusMessage = '';
            $scope.$parent.disableControls = false;
          }

          if (response.data.includes('\nPassed system validation\n')) {
            $scope.onDockerstep = true;
            setCurrentStep(2);
          } else if (response.data.includes('\nFinished Building v5 gateway')) {
            $scope.onDockerstep = false;
            setCurrentStep(3);
          } else if (response.data.includes('\nFinished Building experimental gateway')) {
            $scope.onDockerstep = false;
            setCurrentStep(3);
          }

          if (!isError && $scope.initProgressBar().currentIndex === 3 ) {
            $scope.stopCounter();
            $scope.continueProcess();
            var watchStarted = $scope.$watch('startedProcess', function(newValue) {
              if (newValue){
                watchStarted();
                $scope.cancel();
              }
            });
          }
        }, function handleScriptStartError(err) {
          $scope.errorText = err;
        });
      }, 500);

      $scope.stopCounter = function() {
        if (angular.isDefined(stopCount)) {
          $interval.cancel(stopCount);
          stopCount = undefined;
        }
      };
    }, function errorCallback(err) {
      $scope.errorText = err;
    });
}

  $scope.initProgressBar = function () {
    return {
      totalSteps: getAllSteps().length,
      currentIndex: getCurrentStep().index
    }
  };

  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };

  function getAllSteps () {
    return Array.prototype.slice.call(document.querySelectorAll($scope.options.selectorStepElement))
      .map(function (element, index) {
        return {
          element: element,
          index: index
        };
      });
  }

  function getCurrentStep() {
    var currentElement = document.querySelector($scope.options.selectorCurrent);

    return getAllSteps().filter(function (step) {
      return step.element === currentElement;
    })[0];

  }

  function setCurrentStep (newCurrentStep) {
    $scope.isChanged = false;

    if (newCurrentStep !== $scope.initProgressBar().currentIndex) {
      $scope.initProgressBar().currentIndex = newCurrentStep;
      $scope.isChanged = true;
    }

    if ($scope.isChanged) {
      getAllSteps().forEach(function (step) {
        if (step.index < newCurrentStep) {
          _updateStep({
            element: step.element,
            className: $scope.options.classComplete,
            html: _getCompleteSVG(),
          });
        } else if (step.index === newCurrentStep) {
          _updateStep({
            element: step.element,
            className: $scope.options.classCurrent,
            html: _getCurrentSVG(),
          });
        } else if (step.index > newCurrentStep) {
          _updateStep({
            element: step.element,
            className: $scope.options.classIncomplete,
            html: _getIncompleteSVG(),
          })
        }
      });
    }
  }

  function _updateStep(args) {
    var element = args.element,
      className = args.className,
      html = args.html;

    if (element.firstElementChild) {
      element.removeChild(element.firstElementChild);
    }

    if (!element.classList.contains(className)) {
      element.setAttribute('class', $scope.options.classStep);
      element.classList.add(className);
    }

    element.insertAdjacentHTML('afterbegin', html);
  }

  function _getCompleteSVG() {
    return "<svg>\n\t<circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n\t<circle cx=\"12\" cy=\"12\" r=\"6\"></circle>\n</svg>";
  }

  function _getCurrentSVG() {
    return "<svg>\n\t<circle cx='12' cy='12' r='12'></circle>\n\t<circle cx='12' cy='12' r='6'></circle>\n</svg>";
  }

  function _getIncompleteSVG() {
    return "<svg>\n\t<circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n</svg>";
  }
}
