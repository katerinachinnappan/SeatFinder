/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Directives used by both APIM-UI and CMC-UI */

var common = angular.module('apim.common');

common.directive('onScroll', function() {
  return {
    restrict: 'A',
    scope: {
      getScrollHandler: '&onScroll',
    },
    link: function(scope, element) {
      element.on('scroll', scope.getScrollHandler());
    },
  };
});

common.directive('selectTextOnClick', function () {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      element.on('click', function () {
        var range = document.createRange();
        range.selectNode(this.firstChild);
        window.getSelection().addRange(range);
      });
    }
  };
});

common.directive('apimTag', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/partials/tag.html'
  };
});

common.directive('apimSwitch', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/partials/switch.html',
    scope: {
      property: "=property",
      isDisabled: "=isDisabled"
    }
  };
});

common.directive('apimAutoFocus', ['$timeout', function($timeout) {
  return {
    restrict: 'AC',
    link: function(scope, element, attrs) {
      var target = element[0];
      var waitForVisible = function() {
        $timeout(function() {
          // element will be visible when offsetParent is not null
          if (target.offsetParent === null) {
            waitForVisible();
          } else {
            target.focus();
          }
        },100);
      };
      waitForVisible();
    }
  };
}]);

common.directive('apimFileSelector',['translateFilter', function(translate) {
  return {
    restrict: 'E',
    templateUrl: 'apim/partials/fileSelector.html',
    scope: {
      property: "@property",
      selectedFiles: "=selectedFiles",
      fileChosen: "=chosen",
      showAsIcon: "=showAsIcon"
    },
    controller: function($scope) {
      $scope.fileChanged = function() {
        var element = document.getElementById($scope.$id + "_uploadInput");
        var filename = element.value;
        if (filename) {
          $scope.fileChosen = true;
          $scope.selectedFiles = element.files;
          $scope.filename = element.files[0].name;
          element.title = translate('changeFile');
        } else {
          $scope.fileChosen = false;
          $scope.selectedFiles = [];
          element.title = translate('selectFile');
        }
        $scope.$apply();
      };
    }
  };
}]);

common.directive('apimCombobox', ['$timeout', '$parse', function($timeout, $parse) {
  return {
    restrict: 'E',
    templateUrl: 'apim/partials/comboBox.html',
    require: '?ngModel',
    scope: {
      items: "=itemList",
      apimComboboxDisabled: "=apimComboboxDisabled",
      mySelection: "=?selection",
      inputId: "=?id"
    },
    link: function(scope, element, attrs, ngModelCtrl) {
      // switch the input ID for the one supplied
      var elems = element.find('input');
      if (elems.length > 0) {
        scope.inputField = elems[0];
        if (elems[0] && scope.inputId) {
          elems[0].setAttribute("id", scope.inputId);
        }
      }
      scope.$watch('mySelection', function() {
        if (ngModelCtrl) {
          ngModelCtrl.$setViewValue(scope.mySelection);
        }
      });
      if (ngModelCtrl) {
        ngModelCtrl.$render = function() {
          scope.mySelection = ngModelCtrl.$viewValue;
        };
      }
    },
    controller: function($scope) {
      $scope.changeSelection = function(event, item) {
        event.preventDefault();
        $scope.mySelection = (item.value) ? item.value : item.name;
        // attempt to set the field dirty flag
        if ($scope.inputField && $scope.inputField.form) {
          var formName = $scope.inputField.form.name;
          if ($scope.$parent[formName]) {
            $scope.$parent[formName][$scope.$id + "_comboName"].$setDirty();
          }
        }
        $timeout(function() {
          if ($scope.inputField) {
            $scope.inputField.focus();
          }
        },0);
      };
    }
  };
}]);

common.directive('apimFileChange', function() {
  return {
    restrict: 'A',
    scope: {
      fileChangeFunc: "&apimFileChange"
    },
    link: function(scope, element, attrs, ctrl) {
      element.on('change', onChange);

      scope.$on('destroy', function () {
        element.off('change', onChange);
      });

      function onChange() {
        //        ctrl.$setViewValue(element[0].files[0]);
        scope.fileChangeFunc(element[0]);
      }
    }
  };
});

common.directive('apimFeedback', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/partials/feedback.html',
    controller: function($scope) {
      $scope.showFeedback = function() {
        $scope.feedbackVisible = true;
      };
    }
  };
});

common.directive('apimFeedbackBox', function() {
  return {
    restrict: 'E',
    templateUrl: 'apim/partials/feedbackBox.html'
  };
});

common.directive('apimBreadcrumbs', function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      crumbs: '=',
      separator: '@',
      onClick: '&'
    },
    templateUrl: 'apim/partials/breadcrumbs.html',
    controller: function($scope) {
      $scope.separator = $scope.separator || '/';

      // add default link property as true
      // set to false to hide link and use span
      $scope.$watch('crumbs', function(newCrumbs){
        if (!newCrumbs) return;

        newCrumbs.map(function(crumb){
          if ( typeof crumb.link === 'undefined' ) {
            crumb.link = true;
          }
        });
      });

      $scope._onClick = function($index, crumb){
        var len = $scope.crumbs.length-1;
        var i = $index;

        //skip if clicking on last breadcrumb
        if ( i === len ) return;

        //remove crumbs after clicked crumb
        $scope.crumbs.splice(i+1, len);
        $scope.onClick({ i: i, crumb: crumb, len: len });
      };
    }
  };
});

common.directive('apicFixOnClick', ['$timeout', function ($timeout) {
  return function (scope, element, attrs) {
    var top, left, right, bottom;
    var fixed = false;
    element.bind("click", function ($event) {
      if (!$($event.target).hasClass('maximizeHandle')) return;
      var node = $($event.currentTarget);
      if (fixed) {
        $timeout(function() {
          node.css({
            top: top,
            bottom: bottom,
            left: left,
            right: right
          });
        }, 0);
        $timeout(function() {
          node.css({
            position: ''
          });
        }, 500);
      } else {
        top = node.offset().top + 52;
        left = node.offset().left;
        bottom = window.screen.height - node.height() - top;
        right = window.screen.width - node.width() - left;
        node.css({
          position: 'fixed',
          top: top,
          bottom: bottom,
          left: left,
          right: right
        });
        $timeout(function() {
          node.css({
            top: 0,
            left: 0,
            right: 0,
            bottom: 0
          });
        }, 0);
      }
      fixed = !fixed;
    });
  };
}]);

common.directive('apicSaveKey', function () {
  return function (scope, element, attrs) {
    // ensure the element has a tabindex in order to receive the key events
    if (!element.attr("tabindex")) element.attr("tabindex", 0);
    element.bind("keydown keypress", function ($event) {
      if (!$event.metaKey && !$event.ctrlKey) return;
      if($event.which === 83) { // s
        scope.$apply(function () {
          scope.$eval(attrs.apicSaveKey);
        });
        event.preventDefault();
      }
    });
  };
});

common.component('selectList', {
  bindings: {
    items: '<',
    onSelect: '&'
  },
  templateUrl: 'apim/partials/selectList.html',
  controller: [
    '$scope',
    function ($scope) {
      var $ctrl = this;

      $scope.$watch('selectList', function(newVal) {
        if (newVal == null) {
          return;
        }

        $ctrl.onSelect({
          changeSet: newVal
        });
      });

      this.$onChanges = function(changeSet) {
        if (changeSet.items) {
          $scope.listItems = changeSet.items.currentValue;
        }
      };

      this.$onInit = function() {
        $scope.listItems = this.items;
        $scope.selectList = [];
        $scope.clearFilter();
      };

      $scope.updateSelectList = function() {
        $scope.selectList = $scope.listItems.filter(
          function(item) {
            return item.selected;
          }
        );
      };

      $scope.clearFilter = function() {
        $scope.query = '';
      };
    }
  ]
});

common.directive('ngEnter', [
  function() {
    return function (scope, element, attrs) {
      element.bind('keyup', function (event) {
        if (event.which === 13) {
          scope.$apply(function (){
            scope.$eval(attrs.ngEnter);
          });

          event.preventDefault();
        }
      });
    };
  }
]);

/*
  * Directive for an input field. Ensures that an
  * empty string equates to null in the model.
  */
  common.directive('apicExcludeEmpty', function () {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elem, attrs, ctrl) {
        ctrl.$parsers.push(function(viewValue) {
          if(viewValue === "") {
            return null;
          }
          return viewValue;
        });
      }
    };
  });

/**
 * A direcitve to compare re-typed new password to new password
 * to support form validation flag userForm.$invalid
 */
common.directive('compareTo', compareTo);

function compareTo() {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      otherValue: '=compareTo'
    },
    link: function(scope, e, a, ngModel) {
      ngModel.$validators.compareTo = function(value) {
        return value === scope.otherValue;
      };

      var unwatch = scope.$watch('otherValue', function() {
        ngModel.$validate();
      });

      scope.$onDestroy = function() {
        unwatch();
      };
    }
  };
}
