/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var idps = angular.module('apim.idps', ['ngResource']);

idps.controller('NewLocalRegistryController', ['$scope', '$filter', '$modalInstance', 'outerScope', 'object', 'UserRegistry', newLocalRegistryController]);

function newLocalRegistryController($scope, $filter, $modalInstance, outerScope, object, UserRegistry) {

  $scope.orgId = outerScope.orgId;
  $scope.permissions = outerScope.permissions;
  $scope.saveDisabled = true;
  $scope.isDialog = true;
  if (object) {
    $scope.selectedIDP = object;
  } else {
    $scope.selectedIDP = {
      description: $filter('translate')('dbForEnvironment'),
      title: "",
      name: "",
      scope: ["portal"],
      type: "apim",
      caseSensitive: false
    };
  }

  $scope.saveIDP = outerScope.saveIDP;

  if(!$scope.selectedIDP.title) {
    $scope.$watch('selectedIDP.title', function() {
      $scope.selectedIDP.name = $scope.$root.generateName($scope.selectedIDP.title);
    });
  }

  $scope.performingCreate = false;
  $scope.cancel = function() {
    $modalInstance.dismiss();
  };
  $scope.create = function() {
    $scope.performingCreate = true;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_CREATE_" + timestamp;
    $scope.$root.notifyUser('creatingIDP', [], "BUSY", false, messageId);
    // make the request using the local data
    var newRegistry = new UserRegistry($scope.selectedIDP);
    newRegistry.$save({orgId: $scope.orgId}).then(function(response) {
      $scope.$root.notifyUser('createdIDP', [], "SUCCESS", true, messageId);
      $modalInstance.close(response);
    }, function(err) {
      $scope.performingCreate = false;
      $scope.$root.notifyUser('failedCreateIDP', [], "ERROR", false, messageId);
    });
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave) {
    $scope.saveDisabled = !canSave;
  };

  $scope.$on("IDP_canSave", $scope.handleSave);
};

idps.controller('IDPsCtrl', ['$scope', '$rootScope', '$modal', '$filter', '$mdDialog', '$location', 'IDP', 'CmcIDP', 'CmcIDPScopes', IDPsController]);
function IDPsController($scope, $rootScope, $modal, $filter, $mdDialog, $location, IDP, CmcIDP, CmcIDPScopes) {

  $scope.saveDisabled = true;

  $scope.$on("$locationChangeStart", function (event, next, current) {
    if (!$scope.saveDisabled) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          $scope.saveDisabled = true;
          // $scope.$broadcast('api_is_dirty', $scope.isDirty);
          $location.path($location.url(next).hash());
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });

  $scope.isCMC = false;
  $scope.isAPIM = true;
  if ($rootScope.context == "cmc") {
    $scope.isCMC = true;
    $scope.isAPIM = false;
    // force editable always
    $scope.isDialog = true;
  }

  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.updateIDPs();
  });
  $scope.updateIDPs = function() {
    $scope.idpsLoaded = false;
    if ($rootScope.context == "cmc") {
      $scope.idps = CmcIDP.query({});
    } else {
      $scope.idps = IDP.query({orgId: $scope.orgId});
    }
    $scope.idps.$promise.then(
      function() {
        $scope.idpsLoaded = true;
      }
    );
  };

  $scope.beingDeleted = false;

  $scope.confirmDeleteIDP = function(index) {
    $scope.confirmation = {
      titleKey: 'confirmDelete',
      message: $filter('translate')('confirmDeleteIDP'),
      confirmed: function() {
        var timestamp = (new Date()).getTime();
        var messageId = "REGISTRY_DELETE_" + timestamp;
        $scope.$root.notifyUser('deletingIDP', [], "BUSY", false, messageId);
        var idpId = $scope.idps[index].id;
        var removeHandler = function() {
          $scope.$root.notifyUser('deletedIDP', [], "SUCCESS", true, messageId);
          $scope.beingDeleted = false;
          // delete was successful now refresh the list of user registries
          if($rootScope.context == "cmc") {
            $scope.idps = CmcIDP.query({});
          } else {
            $scope.idps = IDP.query({orgId: $scope.orgId});
          }
        };
        var removeErrorHandler = function(err) {
          $scope.$root.notifyUser('failedDeleteIDP', [], "ERROR", false, messageId);
          $scope.beingDeleted = false;
        };
        if($rootScope.context == "cmc") {
          CmcIDP.remove({orgId: $scope.orgId, idpId: idpId}).$promise.then(removeHandler, removeErrorHandler);
        } else {
          IDP.remove({orgId: $scope.orgId, idpId: idpId}).$promise.then(removeHandler, removeErrorHandler);
        }
      },
      rejected: function() {
        $scope.beingDeleted = false;
      }
    };
    $scope.beingDeleted = true;
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope
    });
  };

  $scope.saveIDP = function(theIDP) {
    if ($scope.saveDisabled) return;
    var idp = theIDP || $scope.selectedIDP;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_UPDATE_" + timestamp;
    $scope.$root.notifyUser('updatingIDP', [], "BUSY", false, messageId);
    // must filter out redacted passwords
    if (idp.ldapConfig && idp.ldapConfig.authenticatedBindPassword == "*****") {
      idp = angular.copy(idp);
      delete idp.ldapConfig.authenticatedBindPassword;
    }
    else if (idp.scimConfig && idp.scimConfig.scimAdminPassword == "*****") {
      idp = angular.copy(idp);
      delete idp.scimConfig.scimAdminPassword;
    }
    var saveHandler = function() {
      $scope.$root.notifyUser('updatedIDP', [], "SUCCESS", true, messageId);
      // reset save button on success
      $scope.saveDisabled = true;
      $scope.$broadcast('IDP_saved');
    };
    var saveErrorHandler = function(err) {
      $scope.$root.notifyUser('failedUpdateIDP', [], "ERROR", false, messageId);
    };

    if ($rootScope.context == "cmc") {
      // need to update scope first
      if($scope.selectedIDP.scope.indexOf("portal") != -1) {
        var newScope = new CmcIDPScopes({scopes: ["portal"]});
        newScope.$update({idpId: $scope.selectedIDP.id}).then(function(){
          // then save idp and the return data will have the correct scope
          CmcIDP.update({idpId: $scope.selectedIDP.id}, idp).$promise.then(saveHandler, saveErrorHandler);
        }, saveErrorHandler);
      } else {
        CmcIDPScopes.remove({idpId: idp.id, scope: "portal"}).$promise.then(function() {
          // then save idp and the return data will have the correct scope
          CmcIDP.update({idpId: $scope.selectedIDP.id}, idp).$promise.then(saveHandler, saveErrorHandler);
        }, saveErrorHandler);
      }

    } else {
      IDP.update({orgId: $scope.orgId, idpId: $scope.selectedIDP.id}, idp).$promise.then(saveHandler, saveErrorHandler);
    }
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave) {
    $scope.saveDisabled = !canSave;
  };

  $scope.$on("IDP_canSave", $scope.handleSave);

  // refresh IDPs for the CMC
  $scope.refreshIDPs = function(evt, idpName) {
    if ($rootScope.context == "cmc") {
      $scope.idps = CmcIDP.query({});
      $scope.idps.$promise.then(function() {
        for (var i = 0; i < $scope.idps.length; i++) {
          if ($scope.idps[i].name == idpName) {
            $scope.selectedIDP = $scope.idps[i];
            break;
          }
        }
      });
    }
  };

  $scope.$on("RefreshIDPs", $scope.refreshIDPs);

  $scope.newLdapProfile = function(evt) {
    $modal.open({
      controller: 'CreateLDAPCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createLdapDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["portal"]
        },
        object: function () {
          return null;
        }
      }
    }).result.then(function (idp) {
      return $scope.updateIDPs();
    });
  };

  $scope.editLdapProfile = function(evt, object) {
    $modal.open({
      controller: 'CreateLDAPCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/editLdapDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["portal"]
        },
        object: function () {
          return null;
        }
      }
    }).result.then(function (idp) {
      return $scope.updateIDPs();
    });
  };

  $scope.newLdapProfileAPIOnly = function(evt) {
    $modal.open({
      controller: 'CreateLDAPCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createLdapDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["api"]
        },
        object: function () {
          return null;
        }
      }
    }).result.then(function (idp) {
      return $scope.updateIDPs();
    });
  };

  $scope.newAuthUrlProfile = function(evt) {
    $modal.open({
      controller: 'CreateAuthUrlCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createAuthUrlDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["portal"]
        },
        object: function () {
          return null;
        }
      }
    }).result.then(function (idp) {
      return 	$scope.updateIDPs();
    });
  };

  $scope.editAuthUrlProfile = function(evt, object) {
    $modal.open({
      controller: 'CreateAuthUrlCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/editAuthUrlDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["portal"]
        },
        object: function () {
          return object;
        }
      }
    }).result.then(function (idp) {
      return 	$scope.updateIDPs();
    });
  };

  $scope.newLocalProfile = function(evt) {
    $modal.open({
      controller: 'NewLocalRegistryController',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/new-local-registry.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        object: function () {
          return null;
        }
      }
    }).result.then(function (idp) {
      return 	$scope.updateIDPs();
    });
  };

  $scope.newScimProfile = function(evt) {
    $modal.open({
      controller: 'CreateSCIMCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createScimDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["portal"]
        },
        object: function () {
          return null;
        }
      }
    }).result.then(function (idp) {
      return 	$scope.updateIDPs();
    });
  };

  $scope.editScimProfile = function(evt, object) {
    $modal.open({
      controller: 'CreateSCIMCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/editScimDialog.html',
      resolve: {
        outerScope: function () {
          return $scope
        },
        source: function () {
          return ["portal"]
        },
        object: function () {
          return object;
        }
      }
    }).result.then(function (idp) {
      return 	$scope.updateIDPs();
    });
  };
};

idps.controller('IDPCtrl', ['$scope', '$filter', 'IDP', idpController]);

function idpController($scope, $filter, IDP) {

  $scope.idpTypeLookup = {
    "apim": $filter('translate')('idpTypeLocal'),
    "ldap": $filter('translate')('idpTypeLdap'),
    "scim": $filter('translate')('idpTypeScim'),
    "authUrl": $filter('translate')('idpTypeAuthUrl')
  };

  $scope.idpChanged = function() {
    if(!$scope.selectedIDP) return;
    if($scope.previousSelectedIDP && $scope.previousSelectedIDP.id == $scope.selectedIDP.id) {
      $scope.saveDisabled = false;
    } else {
      $scope.saveDisabled = true;
    }
    $scope.previousSelectedIDP = $scope.selectedIDP;
  };

  $scope.$watch('selectedIDP', $scope.idpChanged);
}

idps.controller('LDAPCtrl', ['$scope', '$rootScope', '$filter', '$mdDialog', 'IDP', 'UserRegistry', 'SSLProfiles', 'BaseDN', 'IDPBaseDN', 'RegistryTest', 'IDPTest', 'CmcSSLProfiles', 'CmcUserRegistry', ldapController]);

function ldapController($scope, $rootScope, $filter, $mdDialog, IDP, UserRegistry, SSLProfiles, BaseDN, IDPBaseDN, RegistryTest, IDPTest, CmcSSLProfiles, CmcUserRegistry) {

  $scope.ldapVersions = [
    {name: $filter('translate')('ldapVersion3'), value: "3"},
    {name: $filter('translate')('ldapVersion2'), value: "2"}
  ];
  $scope.sslProfiles = [];
  $scope.baseDNList = [];
  $scope.testDetails = {
    testUsername: "",
    testPassword: ""
  };

  function hasScope(list) {
    var ret = false;
    var scopesToFind = list.split(" ");
    var len = scopesToFind.length;
    for (var i=0;i<len;i++) {
      var scope = scopesToFind[i];
      if ($scope.selectedIDP.scope.indexOf(scope) != -1) {
        ret = true;
        break;
      }
    } // end for
    return ret;
  };

  $scope.idpChanged = function() {
    if(!$scope.selectedIDP) return;
    // watch for changes to LDAP bind mode
    if ($scope.selectedIDP.type == "ldap") {
      $scope.$watch('selectedIDP.ldapConfig.authenticatedBind', $scope.setAnonBind);
    }
    // tag if we need to use the lite edition
    $scope.lite = true;
    if (hasScope("api")) {
      $scope.lite = false;
    }
    $scope.isLdapUsed = false;
    $scope.revealTest = false;
    // use a local scope var to control static/dynamic LDAP group radio buttons
    $scope.staticAuth = true;
    if ($scope.selectedIDP.ldapConfig.groupAuthMethod == "dynamicAuth") {
      $scope.staticAuth = false;
    }
    // query registries for warning boxout
    var handleUserRegistry = function(idps) {
      var len = idps.length;
      for (var i = 0; i < len; i++) {
        var id = idps[i].id;
        if (id == idpId) {
          $scope.isLdapUsed = true;
        }
      } // end for
    };
    if (hasScope("apimanager portal api")) {
      var idpId = $scope.selectedIDP.id;
      // do not need to do this check for CMC
      if ($rootScope.context != "cmc") {
        // TODO change this check once apim#1412 is fixed.
          //                UserRegistry.query({orgId: $scope.orgId, scope: $scope.selectedIDP.scope[0]}).$promise.then(handleUserRegistry);
      }
    }
    // fetch the SSL profile list for the dropdown
    var handleSSLProfiles = function(profiles) {
      var sslProfiles = [];
      var len = profiles.length;
      // To avoid confusion we shall only show the "Do not use a custom ssl profile" option
      // if the defaultSystemProfile is not in the list e.g. in apimanager
      // As semantically they have exactly the same meaning.
        var defaultIdentity = false;
      var i;
      for (i = 0; i < len; i++) {
        if (profiles[i].defaultSystemProfile == true) {
          defaultIdentity = profiles[i];
          break;
        }
      } // end for
      // default identity or our replacement value must be first in the list
      if (!defaultIdentity) {
        sslProfiles.push({id: "", title: $filter('translate')('ldapEmptyProfile'), selected: true});
      } else {
        sslProfiles.push(defaultIdentity);
      }
      // Having disabled the implicit sorting on the Select we need to sort the rest.
        profiles.sort(function(a,b){
          if (a.name < b.name) return -1;
          if (b.name < a.name) return 1;
          return 0;
        });
      var foundMatch = false;
      for (i = 0; i < len; i++) {
        // Already put default in the list earlier
        if (!profiles[i].defaultSystemProfile) {
          sslProfiles.push(profiles[i]);
        }
        // check for match on ssl Profile
        if ($scope.selectedIDP.ldapConfig.sslProfile == profiles[i].id) {
          foundMatch = true;
        }
      } // end for
      if (!foundMatch && $scope.selectedIDP.ldapConfig.sslProfile) {
        // no ssl profile match - must be private
        sslProfiles.push({id: $scope.selectedIDP.ldapConfig.sslProfile, title: $filter('translate')('ldapPrivateProfile'), selected: true});
      }
      // if CMC and nothing is selected, select our default profile so the drop down does not have an empty option
      if ($rootScope.context == "cmc" && !foundMatch && defaultIdentity) {
        $scope.selectedIDP.ldapConfig.sslProfile = defaultIdentity.id;
      }
      // finally set the new list
      $scope.sslProfiles = sslProfiles;
    };
    if ($rootScope.context == "cmc") {
      CmcSSLProfiles.query({}).$promise.then(handleSSLProfiles);
    } else {
      SSLProfiles.query({orgId: $scope.orgId}).$promise.then(handleSSLProfiles);
    }
  };


  $scope.validatePort = function(value) {
    var ret = false;
    var num = parseInt(value);
    if (num >= 1 && num <= 65535) {
      ret = true;
    }
    return (ret);
  };

  $scope.testLdapAuth = function() {
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_BASEDN_" + timestamp;
    $scope.$root.notifyUser('connectingIDP', [], "BUSY", false, messageId);
    // prepare the data ready to send
    var idp = {
      name: $scope.selectedIDP.name,
      title: $scope.selectedIDP.title,
      type: $scope.selectedIDP.type,
      scope: $scope.selectedIDP.scope,
      description: $scope.selectedIDP.description,
      caseSensitive: $scope.selectedIDP.caseSensitive,
      ldapConfig: $scope.selectedIDP.ldapConfig
    };
    // now make the request using the cloned data
    var promise = null;
    if ($rootScope.context == "cmc") {
      promise = IDPBaseDN.test({idpId: $scope.selectedIDP.id}, idp).$promise;
    } else if ($scope.orgId) {
      promise = BaseDN.test({orgId: $scope.orgId, idpId: $scope.selectedIDP.id}, idp).$promise;
    } else {
      promise = IDPBaseDN.test({idpId: $scope.selectedIDP.id}, idp).$promise;
    }
    if (promise) {
      promise.then(function(baseDNs) {
        $scope.$root.notifyUser('connectedIDP', [], "SUCCESS", true, messageId);
        // clear existing list first
        $scope.baseDNList.length = 0;
        // now fill in new values
        // first value is always the one currently showing if one is set
        if ($scope.selectedIDP.ldapConfig.searchDNBase) {
          $scope.baseDNList.push({name: $scope.selectedIDP.ldapConfig.searchDNBase});
        }
        var len = baseDNs.length;
        for (var i = 0; i < len; i++) {
          $scope.baseDNList.push({name: baseDNs[i].baseDN});
        } // end for
      }, function(err) {
        $scope.$root.notifyUser('failedConnectIDP', [], "ERROR", false, messageId);
      });
    }
  };

  // Triggered by clicking on the anonymous bind radio - must clear the username and password
  $scope.setAnonBind = function() {
    if (!$scope.selectedIDP.ldapConfig.authenticatedBind) {
      $scope.selectedIDP.ldapConfig.authenticatedBindAdminDN = "";
      $scope.selectedIDP.ldapConfig.authenticatedBindPassword = "";
    }
  };

  // Setter/getter triggered from auth group check box
  $scope.handleAuthGroup = function(newCheckState) {
    if (arguments.length > 0) {
      // setter
      if (newCheckState) {
        if ($scope.selectedIDP.ldapConfig.authMethod == 'bindUPN') {
          $scope.selectedIDP.ldapConfig.groupAuthMethod = "dynamicAuth";
        } else {
          if ($scope.staticAuth) {
            $scope.selectedIDP.ldapConfig.groupAuthMethod = "staticAuth";
          } else {
            $scope.selectedIDP.ldapConfig.groupAuthMethod = "dynamicAuth";
          }
        }
      } else {
        $scope.selectedIDP.ldapConfig.groupAuthMethod = "none";
      }
    } else {
      // getter
      if ($scope.selectedIDP.ldapConfig.groupAuthMethod == "none") {
        return false;
      } else {
        return true;
      }
    }
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.ldapForm || $scope.ldapForm.$invalid || $scope.ldapForm.$pristine) {
      canSave = false;
    }
    $scope.$emit("IDP_canSave", canSave);
  };

  $scope.openTest = function() {
    $scope.revealTest = true;
    setTimeout(function() {
      var element = document.getElementById($scope.$id + "_ldapCloseTest");
      if (element) {
        element.scrollIntoView();
      }
    },100);
  };

  $scope.closeTest = function() {
    $scope.revealTest = false;
    $scope.testFailed = false;
  };

  $scope.performTest = function(otherScope) {
    var outerScope = $scope;
    if (otherScope) {
      outerScope = otherScope;
    }
    outerScope.testFailed = false;
    outerScope.performingTest = true;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_TEST_" + timestamp;
    $scope.$root.notifyUser('testingIDP', [], "BUSY", false, messageId);
    // prepare the data ready to send
    var idp = {
      name: $scope.selectedIDP.name,
      title: $scope.selectedIDP.title,
      type: $scope.selectedIDP.type,
      scope: $scope.selectedIDP.scope,
      description: $scope.selectedIDP.description,
      caseSensitive: $scope.selectedIDP.caseSensitive,
      ldapConfig: $scope.selectedIDP.ldapConfig
    };
    var data = {
      identityProvider: idp,
      userCredential: {
        username: outerScope.testUsername ? outerScope.testUsername : outerScope.testDetails.testUsername,
        password: outerScope.testPassword ? outerScope.testPassword : outerScope.testDetails.testPassword
      }
    };
    // now make the request using the cloned data
    var promise = null;
    if ($rootScope.context == "cmc") {
      promise = IDPTest.test({idpId: $scope.selectedIDP.id}, data).$promise;
    } else if ($scope.orgId) {
      promise = RegistryTest.test({orgId: $scope.orgId, idpId: $scope.selectedIDP.id}, data).$promise;
    } else {
      promise = IDPTest.test({idpId: $scope.selectedIDP.id}, data).$promise;
    }
    if (promise) {
      promise.then(function() {
        $scope.$root.notifyUser('testedIDP', [], "SUCCESS", true, messageId);
        // we dont want the test connection to close the main dialog
        if (!$scope.isDialog) {
          $mdDialog.cancel();
        }
        outerScope.performingTest = false;
      }, function(err) {
        $scope.$root.notifyUser('failedTestIDP', [], "ERROR", false, messageId);
        outerScope.testFailed = true;
        outerScope.performingTest = false;
      });
    }
  };

  $scope.showTestConnection = function(evt) {
    $mdDialog.show({
      controller: 'TestConnectionController',
      templateUrl: 'apim/idps/partials/testConnection.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      focusOnOpen: false,
      locals: {
        outerScope: $scope
      }
    }).then(function() {
    }, function() {
    });
  };

  $scope.valueChanged = function(newValue, oldValue) {
    if (newValue !== oldValue) {
      $scope.ldapForm.$setDirty();
    }
  };

  // public checkbox clicked for the idp (in the CMC only)
  $scope.handlePublicClick = function(idp) {
    // get current state
    var pos = idp.scope.indexOf("portal");
    if(pos == -1) {
      // add
      idp.scope.push("portal");
    } else {
      // remove
      idp.scope.splice(pos, 1);
    }
    $scope.ldapForm.$setDirty();
  };

  // called from parent scope when the IDP has been successfully saved
  $scope.idpSaved = function() {
    // mark the form as clean again
    $scope.ldapForm.$setPristine();
  };

  $scope.$watch('selectedIDP', $scope.idpChanged);
  $scope.$watch('ldapForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('ldapForm.$pristine', $scope.handleFormUpdate);
  $scope.$watch('selectedIDP.ldapConfig.authMethod', $scope.valueChanged);
  $scope.$watch('selectedIDP.ldapConfig.authenticatedBind', $scope.valueChanged);
  $scope.$watch('selectedIDP.ldapConfig.groupAuthMethod', $scope.valueChanged);
  $scope.$on("IDP_saved", $scope.idpSaved);
}

idps.controller('TestConnectionController', ['$scope', '$mdDialog', 'outerScope', testConnectionController]);

function testConnectionController($scope, $mdDialog, outerScope) {
  $scope.performingTest = false;
  $scope.testFailed = false;
  $scope.cancel = function() {
    $mdDialog.cancel();
  };
  $scope.performTest = function() {
    outerScope.performTest($scope);
  };
}

idps.controller('CreateLDAPCtrl', ['$scope', '$rootScope', '$filter', '$modalInstance', 'outerScope', 'source', 'object', 'IDP', 'IdentityProvider', createLdapController]);

function createLdapController($scope, $rootScope, $filter, $modalInstance, outerScope, source, object, IDP, IdentityProvider) {

  $scope.orgId = outerScope.orgId;
  $scope.permissions = outerScope.permissions;
  $scope.saveDisabled = true;
  $scope.isDialog = true;
  $scope.ldapVersions = [
    {name: $filter('translate')('ldapVersion3'), value: "3"},
    {name: $filter('translate')('ldapVersion2'), value: "2"}
  ];
  if (object) {
    $scope.selectedIDP = object;
    // Monkey patching data
    // Converting authenticatedBind to string boolean,
    // Bluemix carbon components doesnt handle
    if ($scope.selectedIDP.ldapConfig &&
      typeof $scope.selectedIDP.ldapConfig.authenticatedBind === 'boolean') {
        $scope.selectedIDP.ldapConfig.authenticatedBind = $scope.selectedIDP.ldapConfig.authenticatedBind ? "true" : "false"
    }
  } else {
    $scope.selectedIDP = {
      title: "",
      type: "ldap",
      scope: source,
      description: "",
      caseSensitive: false,
      ldapConfig:  {
        host: "",
        port: 389,
        authMethod: "searchDN",
        groupAuthMethod: "none",
        authenticatedBind: false,
        authenticatedBindAdminDN: "",
        ssl: false,
        sslProfile: "",
        protocolVersion: "3",
        searchDNFilterPrefix: "",
        searchDNFilterSuffix: "",
        searchDNBase: "",
        bindSuffix: "",
        bindPrefix: "",
        staticGroupDN: "",
        staticGroupFilterPrefix: "",
        staticGroupFilterSuffix: "",
        dynamicGroupFilter: ""
      }
    };
  }

  $scope.saveIDP = outerScope.saveIDP;

  if(!$scope.selectedIDP.title) {
    $scope.$watch('selectedIDP.title', function() {
      $scope.selectedIDP.name = $scope.$root.generateName($scope.selectedIDP.title);
    });
  }

  $scope.performingCreate = false;
  $scope.cancel = function() {
    $modalInstance.dismiss();
  };
  $scope.create = function() {
    $scope.performingCreate = true;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_CREATE_" + timestamp;
    $scope.$root.notifyUser('creatingIDP', [], "BUSY", false, messageId);
    // make the request using the local data
    var promise = null;
    var newIDP;
    if ($rootScope.context == "cmc") {
      newIDP = new IdentityProvider($scope.selectedIDP);
      promise = newIDP.$save();
    } else if ($scope.orgId) {
      newIDP = new IDP($scope.selectedIDP);
      promise = newIDP.$save({orgId: $scope.orgId});
    } else {
      newIDP = new IdentityProvider($scope.selectedIDP);
      promise = newIDP.$save();
    }
    if (promise) {
      promise.then(function(response) {
        $scope.$root.notifyUser('createdIDP', [], "SUCCESS", true, messageId);
        $modalInstance.close(response);
      }, function(err) {
        $scope.performingCreate = false;
        $scope.$root.notifyUser('failedCreateIDP', [], "ERROR", false, messageId);
      });
    }
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave) {
    $scope.saveDisabled = !canSave;
  };

  $scope.$on("IDP_canSave", $scope.handleSave);
}

idps.controller('AuthUrlCtrl', ['$scope', '$rootScope', '$filter', '$mdDialog', 'SSLProfiles', 'CmcSSLProfiles', authUrlController]);

function authUrlController($scope, $rootScope, $filter, $mdDialog, SSLProfiles, CmcSSLProfiles) {

  $scope.sslProfiles = [];
  $scope.ssl = false;

  $scope.idpChanged = function() {
    if(!$scope.selectedIDP) return;
    // match local ssl flag to real data
    if ($scope.selectedIDP.authUrlConfig.sslProfile) {
      $scope.ssl = true;
    }
    // fetch the SSL profile list for the dropdown
    var handleSSLProfiles = function(profiles) {
      var sslProfiles = [];
      var len = profiles.length;
      // To avoid confusion we shall only show the "Do not use a custom ssl profile" option
      // if the defaultSystemProfile is not in the list e.g. in apimanager
      // As semantically they have exactly the same meaning.
        var defaultIdentity = false;
      var i;
      for (i = 0; i < len; i++) {
        if (profiles[i].defaultSystemProfile == true) {
          defaultIdentity = profiles[i];
          break;
        }
      } // end for
      // default identity or our replacement value must be first in the list
      if (!defaultIdentity) {
        sslProfiles.push({id: "", name: $filter('translate')('ldapEmptyProfile'), selected: true});
        $scope.selectedIDP.authUrlConfig.sslProfile = "";
      } else {
        sslProfiles.push(defaultIdentity);
      }
      // Having disabled the implicit sorting on the Select we need to sort the rest.
        profiles.sort(function(a,b){
          if (a.name < b.name) return -1;
          if (b.name < a.name) return 1;
          return 0;
        });
      for (i = 0; i < len; i++) {
        // Already put default in the list earlier
        if (!profiles[i].defaultSystemProfile) {
          sslProfiles.push(profiles[i]);
        }
      } // end for
      // finally set the new list
      $scope.sslProfiles = sslProfiles;
    };
    if ($rootScope.context == "cmc") {
      CmcSSLProfiles.query({}).$promise.then(handleSSLProfiles);
    } else {
      SSLProfiles.query({orgId: $scope.orgId}).$promise.then(handleSSLProfiles);
    }
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.authUrlForm || $scope.authUrlForm.$invalid || $scope.authUrlForm.$pristine) {
      canSave = false;
    }
    $scope.$emit("IDP_canSave", canSave);
  };

  // public checkbox clicked for the idp (in the CMC only)
  $scope.handlePublicClick = function(idp) {
    // get current state
    var pos = idp.scope.indexOf("portal");
    if(pos == -1) {
      // add
      idp.scope.push("portal");
    } else {
      // remove
      idp.scope.splice(pos, 1);
    }
    $scope.authUrlForm.$setDirty();
  };

  // called from parent scope when the IDP has been successfully saved
  $scope.idpSaved = function() {
    // mark the form as clean again
    $scope.authUrlForm.$setPristine();
  };

  $scope.$watch('selectedIDP', $scope.idpChanged);
  $scope.$watch('authUrlForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('authUrlForm.$pristine', $scope.handleFormUpdate);
  $scope.$on("IDP_saved", $scope.idpSaved);
}

idps.controller('CreateAuthUrlCtrl', ['$scope', '$rootScope', '$filter', '$modalInstance', 'outerScope', 'source', 'object', 'IDP', 'IdentityProvider', createAuthUrlController]);

function createAuthUrlController($scope, $rootScope, $filter, $modalInstance, outerScope, source, object, IDP, IdentityProvider) {
  $scope.orgId = outerScope.orgId;
  $scope.permissions = outerScope.permissions;
  $scope.saveDisabled = true;
  $scope.isDialog = true;
  if (object) {
    $scope.selectedIDP = object;
  } else {
    $scope.selectedIDP = {
      name: "",
      title: "",
      type: "authUrl",
      scope: source,
      description: "",
      caseSensitive: false,
      authUrlConfig:  {
        authenticationUrl: "",
        sslProfile: ""
      }
    };
  }

  $scope.saveIDP = outerScope.saveIDP;

  if(!$scope.selectedIDP.title) {
    $scope.$watch('selectedIDP.title', function() {
      $scope.selectedIDP.name = $scope.$root.generateName($scope.selectedIDP.title);
    });
  }

  $scope.performingCreate = false;
  $scope.cancel = function() {
    $modalInstance.dismiss();
  };
  $scope.create = function() {
    $scope.performingCreate = true;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_CREATE_" + timestamp;
    $scope.$root.notifyUser('creatingIDP', [], "BUSY", false, messageId);
    // make the request using the local data
    var promise = null;
    var newIDP;
    if ($rootScope.context == "cmc") {
      newIDP = new IdentityProvider($scope.selectedIDP);
      promise = newIDP.$save();
    } else if ($scope.orgId) {
      newIDP = new IDP($scope.selectedIDP);
      promise = newIDP.$save({orgId: $scope.orgId});
    } else {
      newIDP = new IdentityProvider($scope.selectedIDP);
      promise = newIDP.$save();
    }
    if (promise) {
      promise.then(function(response) {
        $scope.$root.notifyUser('createdIDP', [], "SUCCESS", true, messageId);
        $modalInstance.close(response);
      }, function(err) {
        $scope.performingCreate = false;
        $scope.$root.notifyUser('failedCreateIDP', [], "ERROR", false, messageId);
      });
    }
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave) {
    $scope.saveDisabled = !canSave;
  };

  $scope.$on("IDP_canSave", $scope.handleSave);
}

idps.controller('LocalAuthCtrl', ['$scope', localAuthController]);

function localAuthController($scope) {

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.localAuthForm || $scope.localAuthForm.$invalid || $scope.localAuthForm.$pristine) {
      canSave = false;
    }
    $scope.$emit("IDP_canSave", canSave);
  };

  // called from parent scope when the IDP has been successfully saved
  $scope.idpSaved = function() {
    // mark the form as clean again
    $scope.localAuthForm.$setPristine();
  };

  $scope.$watch('localAuthForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('localAuthForm.$pristine', $scope.handleFormUpdate);
  $scope.$on("IDP_saved", $scope.idpSaved);
}

idps.controller('SCIMCtrl', ['$scope', '$mdDialog', '$filter', 'RegistryTest', 'IDPTest', scimController]);

function scimController($scope, $mdDialog, $filter, RegistryTest, IDPTest) {

  $scope.testDetails = {
    testUsername: "",
    testPassword: ""
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.scimForm || $scope.scimForm.$invalid || $scope.scimForm.$pristine) {
      canSave = false;
    }
    $scope.$emit("IDP_canSave", canSave);
  };

  // called from parent scope when the IDP has been successfully saved
  $scope.idpSaved = function() {
    // mark the form as clean again
    $scope.scimForm.$setPristine();
  };

  $scope.validatePort = function(value) {
    var ret = false;
    var num = parseInt(value);
    if (num >= 1 && num <= 65535) {
      ret = true;
    }
    return (ret);
  };

  $scope.openTest = function() {
    $scope.revealTest = true;
    setTimeout(function() {
      var element = document.getElementById($scope.$id + "_ldapCloseTest");
      if (element) {
        element.scrollIntoView();
      }
    },100);
  };

  $scope.closeTest = function() {
    $scope.revealTest = false;
    $scope.testFailed = false;
  };

  $scope.performTest = function(otherScope) {
    var outerScope = $scope;
    if (otherScope) {
      outerScope = otherScope;
    }
    outerScope.testFailed = false;
    outerScope.performingTest = true;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_TEST_" + timestamp;
    $scope.$root.notifyUser('testingIDP', [], "BUSY", false, messageId);
    // prepare the data ready to send
    var idp = {
      name: $scope.selectedIDP.name,
      title: $scope.selectedIDP.title,
      type: $scope.selectedIDP.type,
      scope: $scope.selectedIDP.scope,
      description: $scope.selectedIDP.description,
      caseSensitive: $scope.selectedIDP.caseSensitive,
      scimConfig: $scope.selectedIDP.scimConfig
    };
    var data = {
      identityProvider: idp,
      userCredential: {
        username: outerScope.testUsername ? outerScope.testUsername : outerScope.testDetails.testUsername,
        password: outerScope.testPassword ? outerScope.testPassword : outerScope.testDetails.testPassword
      }
    };
    // now make the request using the cloned data
    var promise = null;
    if ($scope.orgId) {
      promise = RegistryTest.test({orgId: $scope.orgId, idpId: $scope.selectedIDP.id}, data).$promise;
    } else {
      promise = IDPTest.test({idpId: $scope.selectedIDP.id}, data).$promise;
    }
    if (promise) {
      promise.then(function() {
        $scope.$root.notifyUser('testedIDP', [], "SUCCESS", true, messageId);
        // we dont want the test connection to close the main dialog
        if (!$scope.isDialog) {
          $mdDialog.cancel();
        }
        outerScope.performingTest = false;
      }, function(err) {
        $scope.$root.notifyUser('failedTestIDP', [], "ERROR", false, messageId);
        outerScope.testFailed = true;
        outerScope.performingTest = false;
      });
    }
  };

  $scope.showTestConnection = function(evt) {
    $mdDialog.show({
      controller: 'TestSCIMConnectionController',
      templateUrl: 'apim/idps/partials/testConnection.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      focusOnOpen: false,
      locals: {
        outerScope: $scope
      }
    }).then(function() {
    }, function() {
    });
  };

  $scope.$watch('scimForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('scimForm.$pristine', $scope.handleFormUpdate);
  $scope.$on("IDP_saved", $scope.idpSaved);
}

idps.controller('TestSCIMConnectionController', ['$scope', '$mdDialog', 'outerScope', testSCIMConnectionController]);

function testSCIMConnectionController($scope, $mdDialog, outerScope) {
  $scope.performingTest = false;
  $scope.testFailed = false;
  $scope.cancel = function() {
    $mdDialog.cancel();
  };
  $scope.performTest = function() {
    outerScope.performTest($scope);
  };
}

idps.controller('CreateSCIMCtrl', ['$scope', '$filter', '$mdDialog', '$modalInstance', 'outerScope', 'source', 'object', 'IDP', 'IdentityProvider', createScimController]);

function createScimController($scope, $filter, $mdDialog, $modalInstance, outerScope, source, object, IDP, IdentityProvider) {

  $scope.orgId = outerScope.orgId;
  $scope.permissions = outerScope.permissions;
  $scope.saveDisabled = true;
  $scope.isDialog = true;
  if (object) {
    $scope.selectedIDP = object;
  } else {
    $scope.selectedIDP = {
      name: "",
      title: "",
      type: "scim",
      scope: source,
      description: "",
      caseSensitive: false,
      scimConfig:  {
        host: "",
        port: 0,
        contextRoot: "",
        scimAdminPassword: "",
        scimAdminUser: "",
        ssl: false,
        authenticationUrl: ""
      }
    };
  }

  $scope.saveIDP = outerScope.saveIDP;

  if(!$scope.selectedIDP.title) {
    $scope.$watch('selectedIDP.title', function() {
      $scope.selectedIDP.name = $scope.$root.generateName($scope.selectedIDP.title);
    });
  }

  $scope.performingCreate = false;
  $scope.cancel = function() {
    $modalInstance.dismiss();
  };
  $scope.create = function() {
    $scope.performingCreate = true;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_CREATE_" + timestamp;
    $scope.$root.notifyUser('creatingIDP', [], "BUSY", false, messageId);
    // make the request using the local data
    var promise = null;
    var newIDP;
    if ($scope.orgId) {
      newIDP = new IDP($scope.selectedIDP);
      promise = newIDP.$save({orgId: $scope.orgId});
    } else {
      newIDP = new IdentityProvider($scope.selectedIDP);
      promise = newIDP.$save();
    }
    if (promise) {
      promise.then(function(response) {
        $scope.$root.notifyUser('createdIDP', [], "SUCCESS", true, messageId);
        $modalInstance.close(response);
      }, function(err) {
        $scope.performingCreate = false;
        $scope.$root.notifyUser('failedCreateIDP', [], "ERROR", false, messageId);
      });
    }
  };

  // Called when event is raised from contained form
  $scope.handleSave = function(evt, canSave) {
    $scope.saveDisabled = !canSave;
  };

  $scope.$on("IDP_canSave", $scope.handleSave);
}
