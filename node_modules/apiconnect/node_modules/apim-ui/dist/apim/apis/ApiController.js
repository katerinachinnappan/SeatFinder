/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apim.apis').controller('ApiEditorController', ['$scope', '$rootScope', '$http', '$stateParams', '$location', '$timeout', '$state', '$modal', '$filter', '$window', 'Api', 'UserRegistry', 'Product', 'SSLProfile', 'Oauth', 'SchemaForm', 'VendorExtension', 'ApiValidators', 'DirtyService', 'ComponentRegistry', 'SlugService', 'validateWorkerFunctionFactory', 'validateWorkerFactory', 'LocationService', 'TrackingServices', ApiEditorController]);

function ApiEditorController($scope, $rootScope, $http, $stateParams, $location, $timeout, $state, $modal, $filter, $window, Api, UserRegistry, Product, SSLProfile, Oauth, SchemaForm, VendorExtension, ApiValidators, DirtyService, ComponentRegistry, SlugService, validateWorkerFunctionFactory, validateWorkerFactory, LocationService, TrackingServices) {

  var self = this;
  var validationWorker;

  $scope.animate = false;
  $scope.setMainTab("editor");  // make sure we initialise the correct menu

  $scope.propertyTypes = {
    "integer-int32": {
      name: "integer",
      type: "integer",
      format: "int32"
    },
    "integer-int64": {
      name: "long",
      type: "integer",
      format: "int64"
    },
    "number-float": {
      name: "float",
      type: "number",
      format: "float"
    },
    "number-double": {
      name: "double",
      type: "number",
      format: "double"
    },
    "string": {
      name: "string",
      type: "string"
    },
    "string-byte": {
      name: "byte",
      type: "string",
      format: "byte"
    },
    "string-binary": {
      name: "binary",
      type: "string",
      format: "binary"
    },
    "boolean": {
      name: "boolean",
      type: "boolean"
    },
    "string-date": {
      name: "date",
      type: "string",
      format: "date"
    },
    "string-date-time": {
      name: "dateTime",
      type: "string",
      format: "date-time"
    },
    "string-password": {
      name: "password",
      type: "string",
      format: "password"
    },
    "array": {
      name: "array",
      type: "array",
      items: {
        "type": "string"
      }
    },
    "object": {
      name: "object",
      type: "object"
    }
  };

  $scope.allTypes = angular.copy($scope.propertyTypes);

  $scope.objectNames = function(collection) {
    if (collection == null) {
      return [];
    }

    return Object.keys(collection);
  };

  $scope.$watch('documentReferences', function() {
    if (!$scope.documentReferences) return;
    Object.keys($scope.documentReferences).forEach(function(reference) {
      var name = reference.substring(reference.lastIndexOf('/')+1);
      $scope.allTypes[name] = {type: name, name: name, $ref: reference};
    });
  }, true);

  $scope.$watch('swaggerDocument.definitions', function(newVal) {
    if (newVal == null || typeof newVal !== 'object') {
      return;
    }

    Object.keys(newVal).forEach(function (definitionName) {
      $scope.allTypes[definitionName] = {
        type: definitionName,
        name: definitionName,
        $ref: '#/definitions/' + definitionName
      };
    });
  });

  if ($scope.features.components) {
    $scope.components = ComponentRegistry.getComponents();

    $scope.componentReferences = ComponentRegistry.getComponentReferences();
    $scope.componentReferences.$promise.then(function() {
      $scope.externalAssemblies = $scope.componentReferences.assemblies;
    });
  }

  $scope.checkDirtyApi = function() {
    if ($scope.swaggerDocument && !angular.equals(oldSwagger, $scope.swaggerDocument) || oldApiValue && oldApiValue !== $rootScope.apiValue) {
      DirtyService.setDirty(ApiEditorController);
      $scope.$broadcast('api_is_dirty', true);
      return true;
    }
    DirtyService.clearDirty(ApiEditorController);
    $scope.$broadcast('api_is_dirty', false);
    return false;
  };

  $scope.clearDirtyApi = function() {
    oldSwagger = angular.copy($scope.swaggerDocument);
    oldApiValue = $rootScope.apiValue;
    DirtyService.clearDirty(ApiEditorController);
    $scope.$broadcast('api_is_dirty', false);
  };

  $scope.$on("$locationChangeStart", function (event, next, current) {
    var isDirty = $scope.checkDirtyApi();
    if (isDirty) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          $scope.clearDirtyApi();
          $location.path($location.url(next).hash());
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });

  $scope.xhrProcessing = true;
  $scope.apiId = $stateParams.id;
  if ($stateParams.section) $scope.setMainTab($stateParams.section);

  var selectedPath = 'info';
  var selectedPathIndex = 1;
  var selectedPathGone = false;
  $scope.setSelectedPath = _.debounce(function(inview, path, index) {
    if (navigatedByTocClick) {
      navigatedByTocClick = false;
      return;
    }
    if (!inview && selectedPath == path) {
      selectedPathGone = true;
    } else if (inview || selectedPathGone) {
      selectedPathGone = false;
      selectedPath = path;
      selectedPathIndex = index;
      $('.toc .tocItem .selected').removeClass('selected');
      var tocItem = $('.toc .tocItem .toc-navigate-' + selectedPath);
      if(tocItem[0]) {
        tocItem.addClass('selected');
        tocItem[0].scrollIntoView(true);
        document.querySelector('.toc').scrollTop += -50;
      }
    }
  }, 200);
  $scope.setSelectedPathFromCode = function(path) {
    // map a few literal YAML sections to logical design sections
    if (path == "swagger") path = "info";
    if (path == "x-ibm-configuration") path = "lifecycle";
    selectedPath = path;
    // defer this to allow angular time to digest...
      setTimeout(function() {
        $('.toc .tocItem .selected').removeClass('selected');
        var tocItem = $('.toc .tocItem .toc-navigate-' + selectedPath);
        if(tocItem[0]) {
          tocItem.addClass('selected');
          tocItem[0].scrollIntoView(true);
          document.querySelector('.toc').scrollTop += -50;
        }
      }, 0);
  };

  $scope.validationErrors = [];
  $scope.validationWarnings = [];
  $scope.clearErrorsAndWarnings = function() {
    $scope.validationErrors = [];
    $scope.validationWarnings = [];
    $rootScope.$broadcast('update.bannerItems');
  };

  $scope.addError = function(error) {
    $scope.validationErrors.push(error);
    $rootScope.$broadcast('update.bannerItems');
  };
  $scope.addWarning = function(warning) {
    $scope.validationWarnings.push(warning);
    $rootScope.$broadcast('update.bannerItems');
  };

  $scope.convertApi = function(toSwagger) {
    if(toSwagger) {
      // convert object to swagger
      $rootScope.apiValue = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.swaggerDocument)), {lineWidth: -1});
    } else {
      // convert swagger to object
      var id = $scope.swaggerDocument.$$id;
      $scope.swaggerDocument = new Api(jsyaml.safeLoad($rootScope.apiValue));
      $scope.swaggerDocument.$$id = id;
    }
  };

  $scope.$watch('mainTab', function(newValue, oldValue) {
    if (!$scope.mainTab) return;
    // If we are moving from/to the code view we need to convert the API
    if(newValue == 'code' || oldValue == 'code' || !oldValue) {
      $scope.firstWatchHitCode = false;
      // $scope.firstWatchHit = false;
      $scope.convertApi($scope.mainTab == "code");
    }
    if (!$scope.swaggerDocument || !$scope.swaggerDocument.info) return;
    if(selectedPath) setTimeout(function(){$scope.navigate(selectedPath);},0);
  });

  $scope.$watch('permissions', function() {
    if (!$scope.permissions) return;
    $scope.editable = !!$scope.permissions['org_draftApis/edit'];
  });

  $scope.$watch('currentOrg', function(newValue, oldValue) {
    if (!$scope.currentOrg) return;
    if (newValue.id != oldValue.id) return;
    if (!$scope.offlineMode) {
      $scope.userRegistries = UserRegistry.query({orgId: $scope.orgId, scope: 'api'});
      $scope.sslProfiles = SSLProfile.query({orgId: $scope.orgId});
    }
    if ($scope.offlineMode && $rootScope.features.experimental) {
      $scope.oauthProviders = Oauth.query({orgId: $scope.orgId});
    }

    $scope.xhrProcessing = true;
    Api.get({orgId: $scope.orgId, apiId: $scope.apiId},
      function(api, headers) {
        $scope.xhrProcessing = false;
        $scope.swaggerHeaders = headers();
        $scope.swaggerDocument = api;
        var id = $scope.apiId;
        if (headers("id")) id = headers("id");
        $scope.swaggerDocument.$$id = id;

        // let anyone watching know we have an open document
        $scope.$watch("swaggerDocument['x-ibm-configuration']", function() {
          if (!$scope.swaggerDocument['x-ibm-configuration']) return;
          $scope.$emit('menu-configuration', {assembly: !!$scope.swaggerDocument['x-ibm-configuration'].assembly});
        });

        $scope.convertApi(true);
        $scope.vendorExtensions = [];
        VendorExtension.queryAll({
          orgId: $scope.orgId,
        }).$promise.then(function(extensions) {
          var ves = [];
          // For each extension in the swagger
          $scope.extensions = extensions;
          for (var key in $scope.swaggerDocument) {
            if (key.indexOf("x-") != 0 || key == "x-ibm-configuration") continue;

            // We've found a swagger extension
            var extName = key.slice(2);

            // Is it one that is in our dictionary?
              var dictionaryMatch = false;
            if ($scope.swaggerDocument["x-ibm-configuration"] &&
              $scope.swaggerDocument["x-ibm-configuration"].extensions &&
              $scope.swaggerDocument["x-ibm-configuration"].extensions[extName]) {
                for (var i = 0; i < extensions.length; i++) {
                  var extension = extensions[i];
                  if (extension.name == extName &&
                    extension.version == $scope.swaggerDocument["x-ibm-configuration"].extensions[extName]) {
                      dictionaryMatch = true;
                      ves.push({
                        "schema":extension.schema.properties,
                        "name":extension.name,
                        "version": extension.version,
                        "title":extension.title});
                      break;
                  }
                }
            }

            // If it wasn't in our dictionary
            // then we need to guess
            if (!dictionaryMatch) {
              for (var j = 0; j < extensions.length; j++) {
                var serverExtension = extensions[j];

                if (serverExtension.name === extName) {
                  ves.push({
                    schema: serverExtension.schema.properties,
                    name: serverExtension.name,
                    version: serverExtension.version,
                    title: serverExtension.title
                  });

                  break;
                }
              }
            }

          }
          $scope.vendorExtensions = ves;
        });
      }
    );
  });

  $scope.$basePath = function(value) {
    // if the swagger doc is not yet initialized, do nothing
    if (!$scope.swaggerDocument) return;
    if (typeof value !== "undefined") {
      // setter
      if (value === "") {
        delete $scope.swaggerDocument.basePath;
      } else {
        $scope.swaggerDocument.basePath = value;
      }
    } else {
      $scope.convertApi(true);
      return $scope.swaggerDocument.basePath;
    }
  };

  self.createAssembly = function() {
    if (!$scope.swaggerDocument['x-ibm-configuration']) $scope.swaggerDocument['x-ibm-configuration'] = {};
    $scope.swaggerDocument['x-ibm-configuration'].assembly = {execute: []};
    $scope.$emit('menu-configuration', {assembly: true});
    $scope.setMainTab('assembly');
  };

  self.openAssembly = function() {

  };

  $scope.setApi = function(api) {
    $scope.swaggerDocument = new Api(api);
    $scope.convertApi(true);
    $scope.firstWatchHitCode = false;
    $scope.firstWatchHit = false;
    $scope.$apply();
  };

  var isLargeSwagger = function() {
    if ($scope.swaggerDocument == null) {
      return false;
    }
    var moreThanEnough = 0;
    if ($scope.swaggerDocument.definitions) {
      moreThanEnough = Object.keys($scope.swaggerDocument.definitions).length;
    }
    if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].targets) {
      for (var targetName in $scope.swaggerDocument['x-ibm-configuration'].targets) {
        var target = $scope.swaggerDocument['x-ibm-configuration'].targets[targetName];
        if (target.definitions) {
          var targetLen = Object.keys(target.definitions).length;
          if (targetLen > moreThanEnough) {
            moreThanEnough = targetLen;
          }
        }
      } // end for
    }
    return (moreThanEnough > 50);
  };

  $scope.checkIfLargeSwagger = function() {
    self.largeSwagger = isLargeSwagger();
  };

  var validateFn = function(apiSwagger) {
    if ($scope.mainTab == 'assembly') return;

    // are we dealing with a large swagger?
      if (self.largeSwagger) {
        // large number of definitions?
          $scope.confirmation = {
            titleKey: 'confirmValidateLargeSwaggerTitle',
            messageKey: 'confirmValidateLargeSwagger',
            negativeAction: 'confirmValidateLargeSwaggerAnyway',
            confirmed: function() {
              $scope.validateDisabled = false;
            },
            rejected: function() {
              validateHelper(apiSwagger);
            }
          };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          scope: $scope
        });
      } else if (self.largeSwagger == false) {
        validateHelper(apiSwagger);
      }
  };

  var processValidationErrors = function(err) {
    $scope.addError(err);
    $scope.$apply();
    $scope.notifyUser($filter('translate')('api_validation_errors_notificationSingular'), [], 'ERROR', false);
    $scope.validateDisabled = false;
    $scope.apiInFlux = false;
  };

  var processValidationResults = function(results) {
    var errors = [];
    var warnings = [];
    var notificationMsg = $filter('translate')('api_validation_complete');
    var notificationType = 'SUCCESS';

    results.forEach(function(thisResult) {
      if (thisResult.error) {
        errors = errors.concat(thisResult.error);
      }
      if (thisResult.warning) {
        warnings = warnings.concat(thisResult.warning);
      }
    });

    var path;
    var plural;
    if(errors.length > 0) {
      for(var i=0; i<errors.length; i++) {
        if(errors[i].path && errors[i].path.length > 0) {
          path = errors[i].path[0];
          for(var j=1; j<errors[i].path.length; j++) {
            path += " -> " + errors[i].path[j];
          }
        }
        $scope.addError(errors[i]);
      }

      notificationMsg = errors.length > 1 ? $filter('translate')('api_validation_errors_notification', errors) : $filter('translate')('api_validation_errors_notificationSingular');
      notificationType = 'ERROR';
    }

    var notifyWarnings = [];
    if(warnings.length > 0) {
      for (var k = 0; k < warnings.length; k++) {
        var warning = warnings[k];

        // skip some known warning scenarios which aren't helpful
        var ignoreWarning = false;

        // #1: definition used only in assembly or is used for polymorphism
        if (warning.code == "UNUSED_DEFINITION" && _.isArray(warning.path)) {
          path = "#/" + warning.path.join("/");

          // 1a. detect usage in assembly
          var assemblyJson = "";
          if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].assembly) {
            assemblyJson = angular.toJson($scope.swaggerDocument['x-ibm-configuration'].assembly);
          }

          if (assemblyJson.indexOf(path) > -1) {
            // this definition is used in assembly - ignore the warning
            ignoreWarning = true;
          }
          // 1b. detect polymorphism
          if (!ignoreWarning) {
            // Locate the definition
            var def = $scope.swaggerDocument;
            for (var p = 0; p < warning.path.length; p++) {
              if (def[warning.path[p]]) {
                def = def[warning.path[p]];
              }
            }
            // If the definition has an allOf, this is an indication that it is the extension of a base type;
            // thus it is a polymorphism candidate and the warning should be ignored.
            if (def && def['allOf']) {
              ignoreWarning = true;
            }
          }
        }
        // #2: allow extra description and example on ref since it is supported within UI
        else if (warning.code == 'EXTRA_REFERENCE_PROPERTIES') {
          var inserts = warning.message.substring(warning.message.indexOf(':') + 1).split(',');

          // Get the inserts that are neither description nor example
          var newInserts = [];
          for (var w = 0; w < inserts.length; w++) {
            var insert = inserts[w].trim();
            if (insert != 'description' && insert != 'example') {
              newInserts.push(insert);
            }
          }

          // Ignore if no bad properties found, else generate a new message with new inserts
          if (newInserts.length == 0) {
            ignoreWarning = true;
          } else {
            warning.message = warning.message.substring(0, warning.message.indexOf(':'));
            var separator = ': ';
            for (w = 0; w < newInserts.length; w++) {
              warning.message += separator + newInserts[w];
              separator = ', ';
            }
          }
        }
        if (!ignoreWarning) {
          $scope.addWarning(warnings[k]);
          notifyWarnings.push(warnings[k]);
        }
      }
      if(notificationType === 'SUCCESS' && notifyWarnings.length>0) {
        notificationMsg = notifyWarnings.length > 1 ? $filter('translate')('api_validation_warnings_notification', notifyWarnings) : $filter('translate')('api_validation_warnings_notificationSingular');
        notificationType = 'WARNING';
      }
    }

    $scope.notifyUser(notificationMsg, [], notificationType, false);
    $scope.$apply();
    $scope.apiInFlux = false;
  };

  var validateHelper = function(apiSwagger) {
    try {
      $scope.clearErrorsAndWarnings();
      var apiToValidate = jsyaml.safeLoad(apiSwagger);

      var info = {
        api: apiToValidate,
        url: LocationService.getOrigin() + $window.location.pathname,
        vendorExtensions: $scope.vendorExtensions,
      };

      setupValidationWorker();
      notifyValidationStatus('apiValidating');
      validationWorker.postMessage(info);

    } catch(error) {
      processValidationErrors(error);
    }
  };

  function setupValidationWorker() {

    if (validationWorker != null) {
      validationWorker.terminate();
    }

    validationWorker = validateWorkerFactory.createWorker(
      validateWorkerFunctionFactory.getWebworkerFunction()
    );

    validationWorker.onmessage = function (message) {
      $scope.validateDisabled = false;
      $timeout(function () {
        if (message.data.type == 'RESULT') {
          processValidationResults(message.data.results);
        } else {
          processValidationErrors(message.data.results);
        }
      });
    }
  }

  var validate = _.debounce(validateFn, 1000);

  var validationStatus = function(message) {
    if (self.largeSwagger) {
      var messageId = new Date().getTime();
      $scope.$root.notifyUser(message, [], "INFO", false, messageId);
    }
  }

  var notifyValidationStatus = _.debounce(validationStatus, 2000);

  $scope.documentReferences = {};

  if ($scope.features.components) {
    $scope.getDocumentReferences = function() {
      var promise = ComponentRegistry.getDocumentReferences($scope.swaggerDocument);
      promise.then(function(response) {
        $scope.documentReferences = response.data;
      });
      return promise;
    };

    $scope.$on('reference_created', function(event, referenceDetails) {
      $scope.documentReferences[referenceDetails.reference] = referenceDetails.resolved;
    });
  }

  var startDocumentUpdate = function() {
    $scope.apiInFlux = true;
  };

  var endDocumentUpdate = function() {
    $scope.convertApi(true);
    $scope.checkIfLargeSwagger();
    $scope.apiInFlux = false;
  };

  $scope.updateSwagger = function(mutator) {
    startDocumentUpdate();

    if (typeof mutator === 'function') {
      $scope.swaggerDocument = mutator($scope.swaggerDocument);
    }

    endDocumentUpdate();
  }

  $scope.$watch('swaggerDocument', function(swaggerDoc) {
    $scope.missingRequiredFields = true;
    if(swaggerDoc &&
      swaggerDoc['x-ibm-configuration'] &&
      swaggerDoc['x-ibm-configuration'].assembly &&
      swaggerDoc['x-ibm-configuration'].assembly.execute) {
        var exec = swaggerDoc['x-ibm-configuration'].assembly.execute
        var missingFieldIdentified = false
        for (var i=0; i< exec.length; i++) {
          // Check required fields on invoke abd proxy
          if ((exec[i].invoke && !exec[i].invoke['target-url']) || (exec[i].proxy && !exec[i].proxy['target-url'])) {
            missingFieldIdentified = true
            break;
          }
        }
        $scope.missingRequiredFields = missingFieldIdentified
    } else {
      $scope.missingRequiredFields = false
    }
  }, true)

  $scope.$watch('swaggerDocument.info', function(info) {
    if (info == null) {
      return;
    }

    startDocumentUpdate();

    var name = info['x-ibm-name'];
    var title = info.title;
    var version = info.version;

    $scope.invalidInfo = true;
    if(title && name && version && /^[A-Za-z0-9_\-]*$/.test(name))
    {
      $scope.invalidInfo = false;
    }

    $scope.setCurrentItem({
      name: name || SlugService.createName(title),
      title: title,
      version: info.version
    });

    if ($scope.descriptionPreviewMode == undefined) {
      $scope.descriptionPreviewMode = !_.isEmpty(info.description);
    }

    endDocumentUpdate();
  }, true);

  var pathCount = function(swaggerDocument) {
    if (swaggerDocument.paths) {
      return Object.keys(swaggerDocument.paths).length;
    }

    return 0;
  };

  $scope.$watch('pathCount(swaggerDocument)', function(pathCount) {
    $scope.largeDocumentMode = (pathCount > 20);
  });

  var oldSwagger = null;
  var oldApiValue = null;

  $scope.$watchCollection('swaggerDocument', function(doc, oldVal) {
    if (doc == null) {
      return;
    }

    if (oldSwagger === null || oldApiValue === null) {
      $scope.clearDirtyApi();
    }

    if ($scope.firstWatchHit) {
      $scope.checkDirtyApi();
    } else {
      startDocumentUpdate();
      $scope.firstWatchHit = true;
      setRefreshTokenSupported();

      // track if a large swagger file is opened
      self.largeSwagger = isLargeSwagger();
      if (!self.largeSwagger) {
        // only enable animation for small swagger documents
        $scope.animate = true;
      }

      if ($scope.features.components) {
        $scope.getDocumentReferences();
      }
      endDocumentUpdate();
    }
  });

  function findTopmostSection() {
    var editor = ace.edit('ace-api-editor');
    if (!editor) return;
    var line = editor.getCursorPosition().row;
    var firstLine = editor.getFirstVisibleRow();
    var lastLine = editor.getLastVisibleRow();
    if (line < firstLine) {
      // current line is off the top of the screen
      // scrolling down, look from top for current section
      line = firstLine;
    }
    if (line > lastLine) {
      // current line is off the bottom of the screen
      // scrolling up, look from bottom for current section
      line = lastLine;
    }
    var lineText = editor.session.getDisplayLine(line);
    while (/^\s/.test(lineText) && line >= 0) {
      // not a top-level category
      lineText = editor.session.getDisplayLine(--line);
    }
    if (lineText.indexOf(':') < 0) return;
    return lineText.substring(0, lineText.lastIndexOf(':'));
  }

  $scope.aceLoaded = function(e) {
    $scope.editorLoaded = true;
    var editor = ace.edit('ace-api-editor');
    editor.getSession().on('changeScrollTop', _.debounce(
      function(scroll) {
        var path = findTopmostSection();
        if (path) $scope.setSelectedPathFromCode(path);
        $scope.$apply();
      }, 200)
    );
  };

  function onAceChange() {
    if ($scope.firstWatchHitCode) {
      $scope.checkDirtyApi();

      try {
        var tempSwaggerDoc = new Api(jsyaml.safeLoad($rootScope.apiValue));
        var name = tempSwaggerDoc.info['x-ibm-name'];
        var title = tempSwaggerDoc.info.title;
        var version = tempSwaggerDoc.info.version;
        $scope.invalidInfo = true;

        if(title && name && version && /^[A-Za-z0-9_\-]*$/.test(name))
        {
          $scope.invalidInfo = false;
        }
      }
      catch (e) {
        $scope.invalidInfo = true;
      }
    } else {
      $scope.firstWatchHitCode = true;
    }
  }

  var debouncedOnAceChange = _.debounce(onAceChange, 200);

  $scope.aceChanged = function () {
    debouncedOnAceChange();
  };

  SchemaForm.options = {
    theme: 'bluemix',
    show_errors: 'change',
    no_additional_properties: true,
    disable_edit_json: true,
    required_by_default: true
  };

  $scope.validateApi = function () {
    $scope.validateDisabled = true;
    validate($rootScope.apiValue);
  }

  $scope.saveVersion = function() {
    // if (!$scope.checkDirtyApi()) return;
    if (!$scope.editable) return;
    var messageId = new Date().getTime();
    $scope.$root.notifyUser('apiSaving', [], "BUSY", false, messageId);
    $scope.apiInFlux = true;
    if($scope.mainTab == "code") {
      // convert swagger to object
      var id = $scope.swaggerDocument.$$id;
      $scope.swaggerDocument = new Api(jsyaml.safeLoad($rootScope.apiValue));
      $scope.swaggerDocument.$$id = id;
    }
    function responseHandler(response) {
      if(response.api) {
        $scope.swaggerDocument = response.api;
        $scope.convertApi(true);
      }
      $scope.apiInFlux = false;
      $scope.checkDirtyApi();
      $scope.$broadcast('api_saved');
      $scope.$root.notifyUser('apiSaved', [], "SUCCESS", true, messageId);
      $scope.clearDirtyApi();

      if ($rootScope.offlineMode){
        // update current url path to reflect new slug
        var apiPath = $filter('apiLink')(response.data);
        $window.parent.location.href = '/'+apiPath; // todo replace by proper route
      }
      else {
        var info = response.data.info;
        if ($state.params.id.indexOf(':') > -1) {
          $state.transitionTo($state.current,
            {id: info['x-ibm-name'] + ':' + info.version}, {
            reload: false, inherit: false, notify: false
          });
        }
      }
      var apiId = $scope.apiId.split(':');
      if (apiId.length >= 2) {
        apiId[0] = $scope.swaggerDocument.info['x-ibm-name'];
        apiId[1] = $scope.swaggerDocument.info.version;
        $scope.apiId = apiId.join(':');
        $state.transitionTo($state.current, {id: $scope.apiId}, {
          reload: false, inherit: false, notify: false
        });
      }
    };
    function errorHandler() {
      $scope.apiInFlux = false;
    }
    var headers = {
      "Content-Type": "application/json"
    }
    if ($scope.swaggerHeaders && $scope.swaggerHeaders['x-ibm-swagger-file']) {
      headers["x-ibm-swagger-file"] = $scope.swaggerHeaders["x-ibm-swagger-file"];
    }
    $http.put('proxy/apimanager/orgs/' + $scope.orgId + '/apis/' + $scope.apiId + '?mode=swagger',
      angular.toJson($scope.swaggerDocument), {headers: headers}).then(responseHandler, errorHandler);
    // } else {
      //  $scope.swaggerDocument.$update({orgId: $scope.orgId, apiId: $scope.apiId},
        //    responseHandler,
        //    errorHandler
        //  );
      // }
};

  $scope.saveVersionKey = function(){
    if ( !$scope.apiInFlux && !$scope.invalidInfo && $scope.checkDirtyApi()) {
      $scope.saveVersion();
    }
  }

var checkIfApiUsed = function(orgId, swaggerDocument, swaggerHeaders) {
  return Product.query({ orgId: orgId }).$promise
    .then(function (products) {
      return products.some(function (product) {
        if (!product.apis) {
          return;
        }
        return Object.keys(product.apis).some(function (api) {
          if (product.apis[api].$ref) {
            return product.apis[api].$ref === swaggerHeaders['x-ibm-swagger-file'];
          }
          return product.apis[api].id === swaggerDocument.$$id;
        });
      });
    });
};

$scope.deleteVersion = function() {
  checkIfApiUsed($scope.orgId, $scope.swaggerDocument, $scope.swaggerHeaders)
    .then(function (isUsed) {
      if (isUsed) {
        showInUseError();
      } else {
        showDeleteConfirm();
      }
    });
};

var showInUseError = function() {
  var modalScope = $scope.$new();

  modalScope.information = {
    titleKey: 'apiCurrentlyInUseTitle',
    messageKey: 'apiCurrentlyInUse',
    accepted: function () { }
  };

  $modal.open({
    templateUrl: 'apim/partials/information.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'InformationController',
    scope: modalScope
  });
};

var showDeleteConfirm = function() {
  $scope.confirmation = {
    titleKey: 'confirmDeleteApiVersionTitle',
    messageKey: 'confirmDeleteApiVersion',
    confirmed: function() {
      $scope.apiInFlux = true;
      var fileHeader = ($scope.swaggerHeaders) ? $scope.swaggerHeaders["x-ibm-swagger-file"] : "";
      $scope.swaggerDocument.$delete({
        orgId: $scope.orgId,
        apiId: $scope.swaggerDocument.info['x-ibm-name'] + ":" + $scope.swaggerDocument.info.version,
        apimanager: 'apimanager',
        fileHeader: fileHeader
      }, function(data) {
        $scope.apiInFlux = false;
        $state.go('apis');
        $scope.setFavourite('api', $scope.swaggerDocument, true, $scope.swaggerDocument.info['x-ibm-name'] + ":" + $scope.swaggerDocument.info.version);
      }, function() {
        $scope.apiInFlux = false;
      });
    },
    rejected: function() {
    }
  };
  $modal.open({
    templateUrl: 'apim/partials/confirmation.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ConfirmationController',
    size: 'sm',
    scope: $scope
  });
};

$scope.downloadApi = function() {
  var startDownload = function() {
    $scope.downloadFrame = 'proxy/apimanager/orgs/' + $scope.orgId + '/apis/' + $scope.apiId + '?headers[accept]=' + encodeURIComponent('application/vnd.ibm-apim.swagger2+yaml') +
      '&nocache=' + new Date().getTime();
  };
  if($scope.checkDirtyApi()) {
    $scope.confirmation = {
      titleKey: 'api_download_confirm_unsaved_changes_title',
      messageKey: 'api_download_confirm_unsaved_changes',
      confirmed: function() {
        startDownload();
      },
      rejected: function() {
      }
    };

    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  } else {
    startDownload();
  }
};

// TODO(jtary) the way the filename is returned from the server should
//             be refactored to avoid having to do this.
  var stripDefintionsDir = function(filepath) {
    if (filepath && filepath.replace) {
      filepath = filepath.replace(/^definitions\//, '');
    }

    return filepath;
  };

var getApiRef = function() {
  if ($scope.swaggerHeaders && $scope.swaggerHeaders['x-ibm-swagger-file']) {
    return stripDefintionsDir($scope.swaggerHeaders['x-ibm-swagger-file']);
  }

  return $scope.swaggerDocument.info['x-ibm-name'] + ':' + $scope.swaggerDocument.info.version;
};

$scope.generateDefaultProduct = function() {
  $scope.newProduct = {
    name: $scope.swaggerDocument.info['x-ibm-name'] + '-product',
    title: $scope.swaggerDocument.info.title + ' product',
    version: $scope.swaggerDocument.info.version,
    apis: {}
  };

  $scope.newProduct.apis[$scope.swaggerDocument.info['x-ibm-name']] = getApiRef();
  $scope.publishOptions = {
    doPublish: true
  };

  $modal.open({
    templateUrl: 'apim/products/partials/create-product.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'CreateProductController',
    size: 'lg',
    scope: $scope
  });
};

$scope.addToExistingProducts = function() {
  $scope.addToProductType = "existing";
  $scope.apiRefs = {};
  var apiRef;
  if ($scope.swaggerHeaders && $scope.swaggerHeaders['x-ibm-swagger-file']) {
    apiRef = $scope.swaggerHeaders['x-ibm-swagger-file'];
  } else {
    apiRef = $scope.swaggerDocument.info["x-ibm-name"] + ":" + $scope.swaggerDocument.info.version;
  }
  $scope.apiRefs[$scope.swaggerDocument.info['x-ibm-name']] = apiRef;

  $scope.$modalInstance = $modal.open({
    templateUrl: 'apim/apis/partials/existing-products.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ApiProductBuilderController',
    size: 'lg',
    scope: $scope
  });
};

$scope.createNewVersion = function() {
  $modal.open({
    templateUrl: 'apim/apis/partials/api-save-as.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ApiSaveAsController',
    size: 'sm',
    scope: $scope
  });
};

$scope.updateVersion = function() {
  $modal.open({
    templateUrl: './apim/apis/partials/api-update.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ApiUpdateController',
    size: 'sm',
    scope: $scope,
    backdrop: 'static'
  });
};

  // Angular doesn't like ng-repeat with an object
  // So for each swagger area which uses an object for a list
  // We need to convert to an equivilent array and keep in sync
  // Should be run ONCE on open....

  // Paths
  $scope.$watchCollection('objectNames(swaggerDocument.paths)',
    function(pathNames) {
      $scope.pathNames = pathNames;
      $scope.paths = pathNames.map(function(pathName) {
        var transformedPath = $scope.swaggerDocument.paths[pathName];
        transformedPath['$$key'] = pathName;
        return transformedPath;
      });
    }
  );

  // Security definitions
  $scope.$watchCollection('objectNames(swaggerDocument.securityDefinitions)',
    function(securityDefsNames) {
      $scope.securityDefinitionsArray = securityDefsNames.map(function(securityDefnName) {
        var transformedSecurityDefn =  $scope.swaggerDocument.securityDefinitions[securityDefnName];
        transformedSecurityDefn['$$key'] = securityDefnName;
        return transformedSecurityDefn;
      });
    }
  );

  // Catalogs
  $scope.$watchCollection('objectNames(swaggerDocument["x-ibm-configuration"].catalogs)',
    function(catalogNames) {
      $scope.ibmCatalogs = catalogNames.map(function(catalogName) {
        var transformedCatalog =  $scope.swaggerDocument['x-ibm-configuration'].catalogs[catalogName];
        transformedCatalog['$$key'] = catalogName;
        return transformedCatalog;
      });
    }
  );

$scope.updateDocumentWithExtension = function(extension) {
  // First we create an instance if there isn't one
  var swaggerName = "x-" + extension.name;
  if (!$scope.swaggerDocument[swaggerName]) {
    if (extension.schema.properties.type == "array") {
      $scope.swaggerDocument[swaggerName] = [];
    } else if (extension.schema.properties.type == "string") {
      $scope.swaggerDocument[swaggerName] = "";
    } else if (extension.schema.properties.type == "object") {
      $scope.swaggerDocument[swaggerName] = {};
    } else if (extension.schema.properties.type == "boolean") {
      $scope.swaggerDocument[swaggerName] = false;
    } else if (extension.schema.properties.type == "integer") {
      $scope.swaggerDocument[swaggerName] = 0;
    } else if (extension.schema.properties.type == "number") {
      $scope.swaggerDocument[swaggerName] = 0;
    } else {
      $scope.swaggerDocument[swaggerName] = {};
    }
  }

  // Now we update the managed dictionary
  if (!$scope.swaggerDocument["x-ibm-configuration"]) {
    $scope.swaggerDocument["x-ibm-configuration"] = {};
  }
  if (!$scope.swaggerDocument["x-ibm-configuration"].extensions) {
    $scope.swaggerDocument["x-ibm-configuration"].extensions = {};
  }
  $scope.swaggerDocument["x-ibm-configuration"].extensions[extension.name] = extension.version;

  // Update our vendorExtensions list
  var veObj = {};
  veObj.name = extension.name;
  veObj.version = extension.version;
  veObj.title = extension.title;
  veObj.schema = extension.schema.properties;

  var foundExtension = false;
  for (var i = 0; i < $scope.vendorExtensions.length; i++) {
    var existingVeObj = $scope.vendorExtensions[i];
    if (existingVeObj.name == extension.name) {
      foundExtension = true;
      $scope.vendorExtensions[i] = veObj;
      break;
    }
  }

  if (!foundExtension) {
    $scope.vendorExtensions.push(veObj);
  }
}

$scope.addExtensionSchema = function(evt) {
  $modal.open({
    controller: 'SchemaEntryController',
    templateUrl: 'apim/apis/partials/provide-schema.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    scope: $scope,
    resolve: {
      orgId: function() {
        return $scope.orgId;
      },
      existingExtensions: function() {
        return $scope.vendorExtensions;
      },
    },
    focusOnOpen: false,
  }).result.then(function(selectedExtension) {
    // We need to check if this is a version change for a managed extension
    // and prompt for confirmation if they wish to change the version
    if (!$scope.swaggerDocument["x-ibm-configuration"]) $scope.swaggerDocument["x-ibm-configuration"] = {};
    if (!$scope.swaggerDocument["x-ibm-configuration"].extensions) $scope.swaggerDocument["x-ibm-configuration"].extensions = {}
    if ($scope.swaggerDocument["x-ibm-configuration"].extensions[selectedExtension.name]) {

      var versionInfo = {
        "oldVersion": $scope.swaggerDocument["x-ibm-configuration"].extensions[selectedExtension.name],
        "newVersion": selectedExtension.version
      }
      var confirmMessage = $filter('translate')('vendor_extension_change_version_message', versionInfo);

      $scope.confirmation = {
        titleKey: 'vendor_extension_change_version',
        message: confirmMessage,
        confirmed: function() {
          $scope.updateDocumentWithExtension(selectedExtension)
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    } else {
      $scope.updateDocumentWithExtension(selectedExtension)
    }
  });
};

$scope.$phase = function(value) {
  if (value !== undefined) {
    // setter
    if (!$scope.swaggerDocument['x-ibm-configuration']) $scope.swaggerDocument['x-ibm-configuration'] = {};
    $scope.swaggerDocument['x-ibm-configuration'].phase = value;
  } else {
    //getter
    if (!$scope.swaggerDocument || !$scope.swaggerDocument['x-ibm-configuration'] || $scope.swaggerDocument['x-ibm-configuration'].phase == undefined) return "realized";
    return $scope.swaggerDocument['x-ibm-configuration'].phase;
  }
};

$scope.$enforced = function(value) {
  if (value !== undefined) {
    // setter
    if (!$scope.swaggerDocument['x-ibm-configuration']) $scope.swaggerDocument['x-ibm-configuration'] = {};
    $scope.swaggerDocument['x-ibm-configuration'].enforced = value;
  } else {
    //getter
    if (!$scope.swaggerDocument || !$scope.swaggerDocument['x-ibm-configuration'] || $scope.swaggerDocument['x-ibm-configuration'].enforced == undefined) return true;
    return $scope.swaggerDocument['x-ibm-configuration'].enforced;
  }
};

$scope.$testable = function(value) {
  if (value !== undefined) {
    // setter
    if (!$scope.swaggerDocument['x-ibm-configuration']) $scope.swaggerDocument['x-ibm-configuration'] = {};
    $scope.swaggerDocument['x-ibm-configuration'].testable = value;
  } else {
    //getter
    if (!$scope.swaggerDocument || !$scope.swaggerDocument['x-ibm-configuration'] || $scope.swaggerDocument['x-ibm-configuration'].testable == undefined) return true;
    return $scope.swaggerDocument['x-ibm-configuration'].testable;
  }
};

$scope.$corsEnabled = function(value) {
  if (value !== undefined) {
    // setter
    if (!$scope.swaggerDocument['x-ibm-configuration']) $scope.swaggerDocument['x-ibm-configuration'] = {};
    if (!$scope.swaggerDocument['x-ibm-configuration'].cors) $scope.swaggerDocument['x-ibm-configuration'].cors = {};
    $scope.swaggerDocument['x-ibm-configuration'].cors.enabled = value;
  } else {
    //getter
    if (!$scope.swaggerDocument || !$scope.swaggerDocument['x-ibm-configuration'] ||
      !$scope.swaggerDocument['x-ibm-configuration'].cors || $scope.swaggerDocument['x-ibm-configuration'].cors.enabled == undefined) return true;
    return $scope.swaggerDocument['x-ibm-configuration'].cors.enabled;
  }
};

$scope.$mutualTLS = function(value) {
  if (value !== undefined) {
    if(value) {
      if (!$scope.swaggerDocument['x-ibm-configuration']) {
        $scope.swaggerDocument['x-ibm-configuration'] = {};
      }
      if (!$scope.swaggerDocument['x-ibm-configuration']['application-authentication']) {
        $scope.swaggerDocument['x-ibm-configuration']['application-authentication'] = {};
      }
      $scope.swaggerDocument['x-ibm-configuration']['application-authentication'].certificate = true;
    } else {
      delete $scope.swaggerDocument['x-ibm-configuration']['application-authentication'];
    }
  } else {
    if (!$scope.swaggerDocument || !$scope.swaggerDocument['x-ibm-configuration'] || !$scope.swaggerDocument['x-ibm-configuration']['application-authentication']) {
      return false;
    }
    if ($scope.swaggerDocument['x-ibm-configuration']['application-authentication'] && !$scope.swaggerDocument['x-ibm-configuration']['application-authentication'].certificate) {
      delete $scope.swaggerDocument['x-ibm-configuration']['application-authentication'];
      return false;
    }
    return true;
  }
}

var schemeGetter = function(scheme) {
  if(!$scope.swaggerDocument.schemes) return false;
  return $scope.swaggerDocument.schemes.indexOf(scheme) >= 0;
};
var schemeSetter = function(scheme, schemeEnabled) {
  if (schemeEnabled) {
    if(!$scope.swaggerDocument.schemes) $scope.swaggerDocument.schemes = [];
    if($scope.swaggerDocument.schemes.indexOf(scheme) < 0) {
      $scope.swaggerDocument.schemes.push(scheme);
    }
  } else {
    if($scope.swaggerDocument.schemes) {
      var index = $scope.swaggerDocument.schemes.indexOf(scheme);
      if(index >= 0) {
        $scope.swaggerDocument.schemes.splice(index, 1);
      }
    }
  }
};
$scope.$schemesHttp = function(schemeEnabled) {
  if ($scope.swaggerDocument == undefined) return;
  if (arguments.length){
    // Setter
    schemeSetter("http", schemeEnabled);
  } else {
    // Getter
    return schemeGetter("http");
  }
};
$scope.$schemesHttps = function(schemeEnabled) {
  if ($scope.swaggerDocument == undefined) return;
  if (arguments.length){
    // Setter
    schemeSetter("https", schemeEnabled);
  } else {
    // Getter
    return schemeGetter("https");
  }
};
$scope.$schemesWss = function(schemeEnabled) {
  if ($scope.swaggerDocument == undefined) return;
  if (arguments.length){
    // Setter
    schemeSetter("wss", schemeEnabled);
  } else {
    // Getter
    return schemeGetter("wss");
  }
};
$scope.$schemesWs = function(schemeEnabled) {
  if ($scope.swaggerDocument == undefined) return;
  if (arguments.length){
    // Setter
    schemeSetter("ws", schemeEnabled);
  } else {
    // Getter
    return schemeGetter("ws");
  }
};

function setRefreshTokenSupported() {
  var grantSupportsRefreshTokens = false;
  if ($scope.swaggerDocument &&
    $scope.swaggerDocument['x-ibm-configuration'] &&
    $scope.swaggerDocument['x-ibm-configuration'].oauth2 &&
    angular.isArray($scope.swaggerDocument['x-ibm-configuration'].oauth2.grants)) {
      grantSupportsRefreshTokens = (
        $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.indexOf("password") >= 0 ||
        $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.indexOf("accessCode") >= 0
      );
  }
  $scope.grantSupportsRefreshTokens = grantSupportsRefreshTokens;
};

$scope.grantType = function(grantType, value) {
  if (!$scope.swaggerDocument ||
    !$scope.swaggerDocument['x-ibm-configuration'] ||
    !$scope.swaggerDocument['x-ibm-configuration'].oauth2 ||
    !$scope.swaggerDocument['x-ibm-configuration'].oauth2.grants) return;
  if (value !== undefined) {
    // setter
    if (value && $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.indexOf(grantType) < 0) {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.push(grantType);
    }
    if (!value && $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.indexOf(grantType) > -1) {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants =
        $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.filter(function(type) {
          return (type !== grantType);
        });
    }
    setRefreshTokenSupported();
  } else {
    // getter
    return ($scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.indexOf(grantType) > -1);
  }
};

$scope.applicationGrantIncluded = function() {
  if (!$scope.swaggerDocument['x-ibm-configuration'] ||
    !$scope.swaggerDocument['x-ibm-configuration'].oauth2 ||
    !$scope.swaggerDocument['x-ibm-configuration'].oauth2.grants)
    return false;
  return $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.indexOf("application") >= 0;
};

$scope.onlyApplicationGrant = function() {
  return $scope.applicationGrantIncluded() && $scope.swaggerDocument['x-ibm-configuration'].oauth2.grants.length == 1;
};

$scope.$grantTypeImplicit = function(value) {
  return $scope.grantType("implicit", value);
};

$scope.$grantTypePassword = function(value) {
  return $scope.grantType("password", value);
};

$scope.$grantTypeApplication = function(value) {
  return $scope.grantType("application", value);
};

$scope.$grantTypeAccessCode = function(value) {
  return $scope.grantType("accessCode", value);
};

$scope.$oauthAuthenticate = function(value) {
  if (value !== undefined) {
    // setter
    if (value == "registry") {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.authentication['x-ibm-authentication-registry'] = "";
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2.authentication['x-ibm-authentication-url'];
    } else {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.authentication['x-ibm-authentication-url'] = {"url": ""};
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2.authentication['x-ibm-authentication-registry'];
    }
  } else {
    // getter
    if ($scope.swaggerDocument['x-ibm-configuration'].oauth2.authentication['x-ibm-authentication-registry'] !== undefined) {
      return "registry";
    } else {
      return "url";
    }
  }
};

$scope.$watch('swaggerDocument["x-ibm-configuration"].oauth2.authorization.type', function(newVal) {
  if (!newVal) return;
  if (newVal !== 'custom-form') {
    delete $scope.swaggerDocument['x-ibm-configuration'].oauth2.authorization['custom-form'];
  }
});

$scope.$watch('swaggerDocument["x-ibm-configuration"].oauth2["identity-extraction"].type', function(newVal) {
  if (!newVal) return;
  if (newVal !== 'custom-form') {
    delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['identity-extraction']['custom-form'];
  }
  if (newVal !== 'redirect') {
    delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['identity-extraction']['redirect-url'];
  }
});

$scope.$refreshTokens = function(value) {
  if (value !== undefined) {
    // setter
    if (value) {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2['refresh-token'] = {count: 2048, ttl: 2682000};
    } else {
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['refresh-token'];
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'];
    }
  } else {
    // getter
    return ($scope.swaggerDocument['x-ibm-configuration'].oauth2['refresh-token'] !== undefined);
  }
};

$scope.$maximumConsent = function(value) {
  if (value !== undefined) {
    // setter
    if(value) {
      try {
        $scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'] = {ttl: $scope.swaggerDocument['x-ibm-configuration'].oauth2['refresh-token'].ttl};
      }
      catch (e) {
        delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'];
      }
    } else {
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'];
    }
  } else {
    // getter
    return ($scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'] !== undefined);
  }
};

$scope.$revokeToken = function(value) {
  if (value === undefined) return $scope.swaggerDocument.paths['/oauth2/revoke'] !== undefined;
  if (value) {
    $scope.swaggerDocument.paths['/oauth2/revoke'] = {
      "post": {
        "responses": {
          "200": {
            "description": "response from revocation",
            "schema": {
              "$ref": "#/definitions/token_revoke_response"
            }
          }
        },
        "description": "This endpoint revokes a given access_token or refresh_token\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "description": "String value of the access_token, or refresh_token to be revoked",
            "in": "formData",
            "name": "token"
          },
          {
            "required": true,
            "type": "string",
            "description": "This must contain 'access_token' or 'refresh_token' to indicate the token type",
            "in": "formData",
            "name": "token_type_hint"
          }
        ],
        "produces": [
          "application/json"
        ],
        "security": [
          {
            "clientSecretHeader": [],
            "clientIdHeader": []
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "summary": "Revoke a given access_token or refresh_token"
      }
    };

    $scope.swaggerDocument.definitions['token_revoke_response'] = {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      }
    };

    if ($scope.swaggerDocument.securityDefinitions['clientIdHeader'] === undefined) {
      $scope.swaggerDocument.securityDefinitions['clientIdHeader'] = {
        "in": "header",
        "type": "apiKey",
        "name": "X-IBM-Client-Id"
      };
    }
    if ($scope.swaggerDocument.securityDefinitions['clientSecretHeader'] === undefined) {
      $scope.swaggerDocument.securityDefinitions['clientSecretHeader'] = {
        "in": "header",
        "type": "apiKey",
        "name": "X-IBM-Client-Secret"
      };
    }
  } else {
    delete $scope.swaggerDocument.paths['/oauth2/revoke'];
    delete $scope.swaggerDocument.definitions['token_revoke_response'];
  }
};

$scope.$permsMgmt = function(value) {
  if (value !== undefined) {
    if (value) {
      // insert the issued path
      $scope.swaggerDocument.paths['/oauth2/issued'] = {
        "get": {
          "produces": [
            "application/json"
          ],
          "summary": "Returns list of permission granted to the owner",
          "description": "This endpoint allows the return of all the issued permission for a given authenticated owner per owner authentication \ndefined in the x-ibm-configuration section\n",
          "security": [
            {
              "clientIdHeader": [],
              "clientSecretHeader": []
            }
          ],
          "responses": {
            "200": {
              "description": "json document containing issued information, etc.",
              "schema": {
                "$ref": "#/definitions/issued_responses"
              }
            },
            "401": {
              "description": "failure in retreiving issued list"
            }
          }
        },
        "delete": {
          "consumes": [
            "application/x-www-form-urlencoded"
          ],
          "produces": [
            "application/json"
          ],
          "summary": "Revoke an application/client permission by the authorized owner",
          "description": "Revoke an application/client permission by the authorized owner",
          "security": [
            {
              "clientIdHeader": [],
              "clientSecretHeader": []
            }
          ],
          "parameters": [
            {
              "name": "client-id",
              "in": "query",
              "description": "client-id is the OAuth client_id or application id to be revoked",
              "required": true,
              "type": "string"
            }
          ],
          "responses": {
            "200": {
              "description": "OK"
            }
          }
        }
      };
      $scope.swaggerDocument.definitions['issued_response'] = {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "clientId",
          "owner",
          "scope",
          "issuedAt",
          "expiredAt",
          "refreshTokenIssued"
        ],
        "properties": {
          "clientId": {
            "type": "string"
          },
          "clientName": {
            "type": "string"
          },
          "owner": {
            "type": "string"
          },
          "scope": {
            "type": "string"
          },
          "issuedAt": {
            "type": "string"
          },
          "expiredAt": {
            "type": "string"
          },
          "refreshTokenIssued": {
            "type": "boolean"
          },
          "miscInfo": {
            "type": "string"
          },
          "consentedOn": {
            "type": "string"
          },
          "appId": {
            "type": "string"
          },
          "org": {
            "type": "string"
          },
          "orgId": {
            "type": "string"
          },
          "provider": {
            "type": "string"
          },
          "providerId": {
            "type": "string"
          },
          "catalog": {
            "type": "string"
          },
          "catalogId": {
            "type": "string"
          }
        }
      };
      $scope.swaggerDocument.definitions['issued_responses'] = {
        "type": "array",
        "items": {
          "$ref": "#/definitions/issued_response"
        }
      };
      if (typeof $scope.swaggerDocument.securityDefinitions['clientIdHeader'] === 'undefined') {
        $scope.swaggerDocument.securityDefinitions['clientIdHeader'] = {
          "in": "header",
          "type": "apiKey",
          "name": "X-IBM-Client-Id"
        };
      }
      if (typeof $scope.swaggerDocument.securityDefinitions['clientSecretHeader'] === 'undefined') {
        $scope.swaggerDocument.securityDefinitions['clientSecretHeader'] = {
          "in": "header",
          "type": "apiKey",
          "name": "X-IBM-Client-Secret"
        };
      }
    } else {
      delete $scope.swaggerDocument.paths['/oauth2/issued'];
      delete $scope.swaggerDocument.definitions['issued_response'];
      delete $scope.swaggerDocument.definitions['issued_responses'];
    }
  } else {
    return $scope.swaggerDocument.paths['/oauth2/issued'] !== undefined;
  }
};

$scope.$revocation = function(value) {
  if (value !== undefined) {
    // setter
    if (value) {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.revocation = {type: 'gateway'};
      $scope.revocationType = "gateway";
    } else {
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2.revocation;
      delete $scope.revocationType;
    }
  } else {
    // getter
    var revocation = ($scope.swaggerDocument['x-ibm-configuration'].oauth2.revocation !== undefined);
    if (revocation) {
      if ($scope.swaggerDocument['x-ibm-configuration'].oauth2.revocation.type == "gateway") {
        if ($scope.revocationType !== "gateway") $scope.revocationType = "gateway";
      } else {
        if ($scope.revocationType !== "url") $scope.revocationType = "url";
      }
    }
    return revocation;
  }
};

$scope.$revocationType = function(value) {
  $scope.$revocation();
  if (value !== undefined) {
    // setter
    $scope.revocationType = value;
    if (value == "gateway") {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.revocation = {type: 'gateway'};
    } else if (value == "url") {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2.revocation = {url: ''};
    }
  } else {
    // getter
    return $scope.revocationType;
  }
};

$scope.$introspect = function(value) {
  if (value !== undefined) {
    if (value) {
      // insert the introspective path
      $scope.swaggerDocument.paths['/oauth2/introspect'] = {
        "post": {
          "consumes": [
            "application/x-www-form-urlencoded"
          ],
          "produces": [
            "application/json"
          ],
          "summary": "Introspect a given access_token supported",
          "description": "This endpoint introspects a given access_token\n",
          "security": [
            {
              "clientIdHeader": [],
              "clientSecretHeader": []
            }
          ],
          "parameters": [
            {
              "name": "token",
              "in": "formData",
              "description": "String value of the access_token to be introspected",
              "required": true,
              "type": "string"
            },
            {
              "name": "token_type_hint",
              "in": "formData",
              "description": "This must contain 'access_token' to indicate the token type",
              "required": true,
              "type": "string"
            }
          ],
          "responses": {
            "200": {
              "description": "json document containing access_token information, etc.",
              "schema": {
                "$ref": "#/definitions/introspect_response"
              }
            },
            "401": {
              "description": "failure"
            }
          }
        }
      };
      // definition
      $scope.swaggerDocument.definitions['introspect_response'] = {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "active",
          "client_id",
          "client_name",
          "username",
          "sub",
          "exp",
          "expstr",
          "iat",
          "nbf",
          "nbfstr",
          "scope"
        ],
        "properties": {
          "active": {
            "type": "boolean"
          },
          "client_id": {
            "type": "string"
          },
          "client_name": {
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "sub": {
            "type": "string"
          },
          "exp": {
            "type": "string"
          },
          "expstr": {
            "type": "string"
          },
          "iat": {
            "type": "string"
          },
          "nbf": {
            "type": "string"
          },
          "nbfstr": {
            "type": "string"
          },
          "scope": {
            "type": "string"
          },
          "miscinfo": {
            "type": "string"
          },
          "consented_on": {
            "type": "string"
          },
          "consented_on_str": {
            "type": "string"
          },
          "grant_type": {
            "type": "string"
          }
        }
      };
      if (typeof $scope.swaggerDocument.securityDefinitions['clientIdHeader'] === 'undefined') {
        $scope.swaggerDocument.securityDefinitions['clientIdHeader'] = {
          "in": "header",
          "type": "apiKey",
          "name": "X-IBM-Client-Id"
        };
      }
      if (typeof $scope.swaggerDocument.securityDefinitions['clientSecretHeader'] === 'undefined') {
        $scope.swaggerDocument.securityDefinitions['clientSecretHeader'] = {
          "in": "header",
          "type": "apiKey",
          "name": "X-IBM-Client-Secret"
        };
      }
    }
    else {
      delete $scope.swaggerDocument.paths['/oauth2/introspect'];
      delete $scope.swaggerDocument.definitions['introspect_response'];
    }
  }
  else {
    return $scope.swaggerDocument.paths['/oauth2/introspect'] !== undefined;
  }
};

// Used in the future when miscInfo is a toggle
// $scope.$miscinfoEnabled = function(value) {
  //   if (value !== undefined) {
    //     // setter
    //     if (value) {
      //       $scope.swaggerDocument['x-ibm-configuration'].oauth2['miscellaneous-info']['miscinfo-url'] = {
        //         url: '',
        //         'tls-profile': ''
        //       };
      //     } else {
        //       delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['miscellaneous-info'];
        //     }
    //   } else {
      //     // getter
      //     return true;
      //   }
  // };

$scope.createScope = function(scopeContainer) {
  var scopeNameRoot = $filter('translate')('api_oauth_new_scope');
  var scopeName = scopeNameRoot;
  var suffix = 2;
  while (scopeContainer[scopeName] !== undefined) {
    scopeName = scopeNameRoot + "_" + suffix;
    suffix++;
  }
  if (!scopeContainer.scopes) scopeContainer.scopes = {};
  scopeContainer.scopes[scopeName] = "";
};

function cleanScopeCheck() {
  if ($scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators']) {
    ['owner', 'application'].forEach(function(scopeType) {
      if (!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType] ||
        Object.keys($scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType]).length === 0) {
        delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType];
      }
    });
    if (Object.keys($scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators']).length !== 0) {
      return;
    }
  }
  delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'];
}

$scope.applicationScopeSwitch = false;
$scope.ownerScopeSwitch = false;

function cleanInitialOauthSwagger() {
  if ($scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators']) {
    ['application', 'owner'].forEach(function(scopeType) {
      if ($scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType]) {
        if (!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType].url) {
          delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType].url;
        }
        if (!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType]['tls-profile']) {
          delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType]['tls-profile'];
        }
      }
    });
  }

  if ($scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent']) {
    if ($scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'].ttl === 0) {
      delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['maximum-consent'];
    }
  }
}

$scope.$watch('swaggerDocument', function(newObj) {
  if ($scope.swaggerDocument &&
    $scope.swaggerDocument['x-ibm-configuration'] &&
    $scope.swaggerDocument['x-ibm-configuration'].oauth2) {
    cleanInitialOauthSwagger();
    cleanScopeCheck();
    try {
      $scope.applicationScopeSwitch = !!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'].application;
    } catch (e) {
      $scope.applicationScopeSwitch = false;
    }
    try {
      $scope.ownerScopeSwitch = !!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'].owner;
    } catch (e) {
      $scope.ownerScopeSwitch = false;
    }
  }
});

function advancedScopeType(scopeType, value) {
  var switchName = scopeType + "ScopeSwitch";
  if (value !== undefined) {
    if (value) {
       $scope[switchName] = true;
    } else {
      try {
        delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType];
      } catch (e) {
        cleanScopeCheck();
      }
      $scope[switchName] = false;
      if (!$scope.applicationScopeSwitch && !$scope.ownerScopeSwitch) {
        delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'];
      }
    }
  } else {
      return ($scope[switchName]);
  }
}

$scope.$ownerScopeCheck = function (value) {
  return advancedScopeType('owner', value);
};

$scope.$applicationScopeCheck = function (value) {
  return advancedScopeType('application', value);
};

function oauthProviderScopeCheckInit(scopeType) {
  if ($scope.swaggerDocument['x-ibm-configuration'] &&
    $scope.swaggerDocument['x-ibm-configuration'].oauth2) {
    if (!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators']) {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'] = {};
    }

    if (!$scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType]) {
      $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType] = {};
    }
  }
}

function oauthProviderScopeCheck (scopeType, property, newVal) {
  if (newVal != undefined) {
    if (newVal) {
      oauthProviderScopeCheckInit(scopeType);
      $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType][property] = newVal;
    } else {
      if ($scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'] &&
        $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType]) {
        delete $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType][property];
      }
      cleanScopeCheck();
    }
  } else {
    try {
      return $scope.swaggerDocument['x-ibm-configuration'].oauth2['scope-validators'][scopeType][property];
    } catch (e) {
      return;
    }
  }
}

$scope.$applicationScopeCheckURL = function(newVal) {
  if (arguments.length) {
    oauthProviderScopeCheck('application', 'url', newVal);
  } else {
    return oauthProviderScopeCheck('application', 'url');
  }
}

$scope.$ownerScopeCheckURL = function(newVal) {
  if (arguments.length) {
    oauthProviderScopeCheck('owner', 'url', newVal);
  } else {
    return oauthProviderScopeCheck('owner', 'url');
  }
}

$scope.$applicationScopeCheckTLS = function(newVal) {
  if (arguments.length) {
    oauthProviderScopeCheck('application', "tls-profile", newVal);
  } else {
    return oauthProviderScopeCheck('application', "tls-profile");
  }
}

$scope.$ownerScopeCheckTLS = function(newVal) {
  if (arguments.length) {
    oauthProviderScopeCheck('owner', 'tls-profile', newVal);
  } else {
    return oauthProviderScopeCheck('owner', 'tls-profile');
  }
}

$scope.isOauthProvider = function() {
  if ($scope.swaggerDocument &&
    $scope.swaggerDocument['x-ibm-configuration']) {
    var swaggerDoc = $scope.swaggerDocument['x-ibm-configuration'];
    return Boolean(swaggerDoc && swaggerDoc.oauth2);
  }
};

$scope.addSecurityDefinition = function(type) {
  if (!$scope.swaggerDocument.securityDefinitions) $scope.swaggerDocument.securityDefinitions = {};
  // Generate name
  var testNameBase = $filter('translate')("api_security_type_" + type).toLowerCase().replace(/\W/g, '-');
  var i = 1;
  while ($scope.swaggerDocument.securityDefinitions[testNameBase + "-" + i] != null) {
    i++;
  }
  var newDefinitionName = testNameBase + "-" + i;

  // Generate definition
  var newSecurityDefinition = {type: type, description: ''};
  if (type == 'apiKey') {
    // Check if id or secret have already been defined
    var clientIdExists = false;
    var clientSecretExists = false;
    for(var securityDefinitionName in $scope.swaggerDocument.securityDefinitions) {
      if ($scope.swaggerDocument.securityDefinitions[securityDefinitionName].name == 'X-IBM-Client-Id' ||
        $scope.swaggerDocument.securityDefinitions[securityDefinitionName].name == 'client_id') clientIdExists = true;
      if ($scope.swaggerDocument.securityDefinitions[securityDefinitionName].name == 'X-IBM-Client-Secret' ||
        $scope.swaggerDocument.securityDefinitions[securityDefinitionName].name == 'client_secret') clientSecretExists = true;
    }
    newSecurityDefinition["in"] = 'header';
    if (clientIdExists && clientSecretExists) {
      newSecurityDefinition.name = newDefinitionName;
    } else if (clientIdExists) {
      newSecurityDefinition.name = 'X-IBM-Client-Secret';
    } else {
      newSecurityDefinition.name = 'X-IBM-Client-Id';
    }
  } else if (type === 'oauth2') {
    if ($rootScope.features.experimental) {
      newSecurityDefinition['x-provider'] = '';
      newSecurityDefinition.flow = '';
    } else {
      newSecurityDefinition.flow = 'implicit';
      newSecurityDefinition.scopes = {};
    }
    newSecurityDefinition.authorizationUrl = '';
  }

  // Add new definition to swagger
  var updatedSecurityDefinitions = {};
  updatedSecurityDefinitions[newDefinitionName] = newSecurityDefinition;
  for (var definition in $scope.swaggerDocument.securityDefinitions) {
    updatedSecurityDefinitions[definition] = $scope.swaggerDocument.securityDefinitions[definition];
  }
  $scope.swaggerDocument.securityDefinitions = updatedSecurityDefinitions;
  TrackingServices.track('security', 'newSecurityDefinition');

};

$scope.externalDocs = {
  description: function(newDesc) {
    if ($scope.swaggerDocument == undefined) return;
    if (arguments.length) {
      // Setter
      if (newDesc != "") {
        if ($scope.swaggerDocument.externalDocs == undefined) {
          $scope.swaggerDocument.externalDocs = {};
        }
        $scope.swaggerDocument.externalDocs.description = newDesc;
      } else {
        delete $scope.swaggerDocument.externalDocs.description;
        if ($scope.swaggerDocument.externalDocs.url == undefined) {
          delete $scope.swaggerDocument.externalDocs;
        }
      }
    } else {
      // Getter
      if ($scope.swaggerDocument.externalDocs && $scope.swaggerDocument.externalDocs.description) {
        return $scope.swaggerDocument.externalDocs.description;
      } else {
        return "";
      }
    }
  },

  url: function(newUrl) {
    if ($scope.swaggerDocument == undefined) return;
    if (arguments.length) {
      // Setter
      if (newUrl != "") {
        if ($scope.swaggerDocument.externalDocs == undefined) {
          $scope.swaggerDocument.externalDocs = {};
        }
        $scope.swaggerDocument.externalDocs.url = newUrl;
      } else {
        delete $scope.swaggerDocument.externalDocs.url;
        if ($scope.swaggerDocument.externalDocs.description == undefined) {
          delete $scope.swaggerDocument.externalDocs;
        }
      }
    } else {
      // Getter
      if ($scope.swaggerDocument.externalDocs && $scope.swaggerDocument.externalDocs.url) {
        return $scope.swaggerDocument.externalDocs.url;
      } else {
        return "";
      }
    }
  }
};

$scope.setDefinitionExpanded = function(definitionName) {
  if ($scope.expandedDefinition == definitionName) $scope.expandedDefinition = null;
  else $scope.expandedDefinition = definitionName;
};

$scope.isDefinitionExpanded = function(definitionName) {
  return $scope.expandedDefinition == definitionName;
};

$scope.removeDefinition = function(name) {
  $scope.confirmation = {
    titleKey: 'api_definition_delete_title',
    messageKey: 'api_definition_delete_message',
    confirmed: function() {
      delete $scope.swaggerDocument.definitions[name];
      delete $scope.allTypes[name];
      if(angular.equals({}, $scope.swaggerDocument.definitions)) {
        delete $scope.swaggerDocument.definitions;
      }
    },
    rejected: function() {
    }
  };
  $modal.open({
    templateUrl: 'apim/partials/confirmation.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ConfirmationController',
    size: 'sm',
    scope: $scope
  });
};

$scope.renameDefinition = function(oldName, newName) {
  var defs = $scope.swaggerDocument.definitions;
  defs[newName] = defs[oldName];
  delete defs[oldName];

  // update the definition type entry
  $scope.allTypes[newName] = {
    type: newName,
    name: newName,
    $ref: '#/definitions/' + newName
  };

  delete $scope.allTypes[oldName];
};

$scope.addDefinition = function() {
  var testNameBase = $filter('translate')("api_definition_new").toLowerCase().replace(/\W/g, '-');
  var existingDefinitions = $scope.swaggerDocument.definitions;
  if (!existingDefinitions) existingDefinitions = {};
  var i = 1;
  while(existingDefinitions[testNameBase + "-" + i] != null) {
    i++;
  }

  var newDefinitionName = testNameBase + "-" + i;
  var propertyName = $filter('translate')("api_property_new").toLowerCase().replace(/\W/g, '-') + "-1";

  var updatedDefinitions = {};
  updatedDefinitions[newDefinitionName] = {properties: {}, additionalProperties: false};
  updatedDefinitions[newDefinitionName].properties[propertyName] = {type: "string"};
  for(var definitionName in existingDefinitions) {
    updatedDefinitions[definitionName] = existingDefinitions[definitionName];
  }
  $scope.swaggerDocument.definitions = updatedDefinitions;
  $scope.allTypes[newDefinitionName] = {
    type: newDefinitionName,
    name: newDefinitionName,
    $ref: '#/definitions/' + newDefinitionName
  };
};

$scope.updateDefinition = function(name, value) {
  $scope.updateSwagger(function(doc) {
    doc.definitions[name] = value;
    return doc;
  });
};

$scope.expandedProps = {};

$scope.togglePropertyExpanded = function(propertyName) {
  var isExpanded = $scope.expandedProps[propertyName];

  if (isExpanded == null) {
    isExpanded = false;
  }

  return ($scope.expandedProps[propertyName] = !isExpanded);
};

$scope.isPropertyExpanded = function(propertyName) {
  return $scope.expandedProps[propertyName] === true;
};

$scope.removeProperty = function($event, name) {
  $event.stopPropagation();
  $scope.confirmation = {
    titleKey: 'api_property_delete_title',
    messageKey: 'api_property_delete_message',
    confirmed: function() {
      delete $scope.swaggerDocument['x-ibm-configuration'].properties[name];
      delete $scope.expandedProps[name];
      if(angular.equals({}, $scope.swaggerDocument['x-ibm-configuration'].properties)) {
        delete $scope.swaggerDocument['x-ibm-configuration'].properties;
      }
      // go through any catalogs to remove the property as well
      var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
      if (catalogs) {
        for (var catalogName in catalogs) {
          var catalog = catalogs[catalogName];
          if (catalog.properties) {
            if (catalog.properties[name]) {
              delete catalog.properties[name];
            }
            if(angular.equals({}, catalog.properties)) {
              delete catalog.properties;
            }
          }
        } // end for
      }
    },
    rejected: function() {
    }
  };
  $modal.open({
    templateUrl: 'apim/partials/confirmation.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ConfirmationController',
    size: 'sm',
    scope: $scope
  });
};

$scope.addAPIProperty = function() {
  var testNameBase = $filter('translate')("api_properties_new").toLowerCase().replace(/\W/g, '-');
  if (!$scope.swaggerDocument['x-ibm-configuration']) {
    $scope.swaggerDocument['x-ibm-configuration'] = {};
  }
  var existingProperties = $scope.swaggerDocument['x-ibm-configuration'].properties;
  if (!existingProperties) existingProperties = {};
  var i = 1;
  while(existingProperties[testNameBase + "-" + i] != null) {
    i++;
  }
  var newPropertyName = testNameBase + "-" + i;
  var updatedProperties = {};
  updatedProperties[newPropertyName] = {
    value: "",
    description: "",
    encoded: false
  };
  for(var propertyName in existingProperties) {
    updatedProperties[propertyName] = existingProperties[propertyName];
  }
  $scope.swaggerDocument['x-ibm-configuration'].properties = updatedProperties;
};

$scope.getContextExtensions = function() {
  var extensions = [];
  if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].properties) {
    var properties = $scope.swaggerDocument['x-ibm-configuration'].properties;
    for (var propertyName in properties) {
      extensions.push(propertyName);
    } // end for
  }
  return extensions;
};

$scope.addPath = function() {
  if(!$scope.swaggerDocument.paths) $scope.swaggerDocument.paths = {};
  // Generate name
  var testNameBase = "/" + $filter('translate')("api_path").toLowerCase().replace(/\W/g, '-');
  var i = 1;
  while($scope.swaggerDocument.paths[testNameBase + "-" + i] != null) {
    i++;
  }
  var newPathName = testNameBase + "-" + i;

  // Add new path to swagger
  var updatedPaths = {};
  updatedPaths[newPathName] = {get: {responses:{200:{description:'200 OK'}}}};
  for(var path in $scope.swaggerDocument.paths) {
    updatedPaths[path] = $scope.swaggerDocument.paths[path];
  }
  $scope.swaggerDocument.paths = updatedPaths;
};

$scope.renamePath = function(oldName, newName) {
  var paths = $scope.swaggerDocument.paths;
  var path = paths[oldName];

  updateAssemblyModel(path, newName);
  paths[newName] = paths[oldName];
  paths[newName].$$key = newName;
  delete paths[oldName];
  return;
}

$scope.updatePath = function(name, value) {
  $scope.updateSwagger(function(doc) {
    doc.paths[name] = value;
    return doc;
  });
}

  function updateAssemblyModel(path, newName) {
  // ensure the assembly model is up to date
        if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].assembly && $scope.swaggerDocument['x-ibm-configuration'].assembly.execute) {
          var matches = _.filter($scope.swaggerDocument['x-ibm-configuration'].assembly.execute, {'operation-switch': {'case': [{operations: [{path: path.$$key}]}]}});
          matches.forEach(function(policy) {
            var caseMatches = _.filter(policy['operation-switch']['case'], {operations: [{path: path.$$key}]});
            caseMatches.forEach(function(thisCase) {
              var operationMatches = _.filter(thisCase.operations, {path: path.$$key});
              operationMatches.forEach(function(operation) {
                if (path.hasOwnProperty(operation.verb)) operation.path = newName;
              });
            });
          });
        }
  }

$scope.removePath = function(path) {
  $scope.confirmation = {
    titleKey: 'api_path_delete_title',
    messageKey: 'api_path_delete_message',
    confirmed: function() {
      delete $scope.swaggerDocument.paths[path];
      // if(angular.equals({}, $scope.swaggerDocument.paths)) {
        //  delete $scope.swaggerDocument.paths;
        // }
    },
    rejected: function() {
    }
  };
  $modal.open({
    templateUrl: 'apim/partials/confirmation.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ConfirmationController',
    size: 'sm',
    scope: $scope
  });
};

$scope.removeTag = function(name) {
  for (var i = 0; i < $scope.swaggerDocument.tags.length; i++) {
    if ($scope.swaggerDocument.tags[i].name == name) {
      $scope.swaggerDocument.tags.splice(i,1);
      if($scope.swaggerDocument.tags.length == 0) {
        delete $scope.swaggerDocument.tags;
      }
      return;
    }
  }
};

$scope.addTag = function() {
  if(!$scope.swaggerDocument.tags) $scope.swaggerDocument.tags = [];
  var testNameBase = $filter('translate')("api_tag").toLowerCase().replace(/\W/g, '-');
  var foundUnusedName = false;
  var nameSuffix = 1;
  while(!foundUnusedName) {
    foundUnusedName = true;
    var testName = testNameBase + "-" + nameSuffix;
    for(var i=0; i<$scope.swaggerDocument.tags.length; i++) {
      if($scope.swaggerDocument.tags[i].name == testName) {
        nameSuffix++;
        foundUnusedName = false;
        break;
      }
    }
  }
  var newTagName = testNameBase + "-" + nameSuffix;
  $scope.swaggerDocument.tags.unshift({name: newTagName});
};

$scope.removeSecurityDefinition = function(name) {
  $scope.confirmation = {
    titleKey: 'api_security_definition_delete_title',
    messageKey: 'api_security_definition_delete_message',
    confirmed: function() {
      // Tidy up operation security sections
      for(var pathName in $scope.swaggerDocument.paths) {
        for(var operationName in $scope.swaggerDocument.paths[pathName]) {
          var operation = $scope.swaggerDocument.paths[pathName][operationName];
          if(operation.security) {
            for(var i=0; operation.security && i<operation.security.length; i++) {
              for(var opSecuritySchemeName in operation.security[i]) {
                if(opSecuritySchemeName == name) {
                  operation.security.splice(i, 1);
                  if(operation.security.length == 0) {
                    delete operation.security;
                  }
                  break;
                }
              }
            }
          }
        }
      }

      // Tidy up the security section
      if($scope.swaggerDocument.security) {
        for(var j=0; $scope.swaggerDocument.security && j<$scope.swaggerDocument.security.length; j++) {
          for(var securitySchemeName in $scope.swaggerDocument.security[j]) {
            if(securitySchemeName == name) {
              delete $scope.swaggerDocument.security[j][securitySchemeName];
              if(angular.equals({}, $scope.swaggerDocument.security[j])) {
                $scope.swaggerDocument.security.splice(j, 1);
                if($scope.swaggerDocument.security.length == 0) {
                  delete $scope.swaggerDocument.security;
                }
              }
              break;
            }
          }
        }
      }

      // Remove the definition
      delete $scope.swaggerDocument.securityDefinitions[name];
    },
    rejected: function() {
    }
  };
  $modal.open({
    templateUrl: 'apim/partials/confirmation.html',
    windowTemplateUrl: 'apim/partials/main-template.html',
    controller: 'ConfirmationController',
    size: 'sm',
    scope: $scope
  });
};

$scope.keepEmailValid = function() {
  if($scope.swaggerDocument.info.contact.email == '') {
    delete $scope.swaggerDocument.info.contact.email;
  }
};

$scope.cleanUpKey = function(key) {
  return key.replace(/\W/g, '');
};

$scope.navigateToCode = function(path) {
  $scope.setMainTab('code');
  $scope.$watch('editorLoaded', function() {
    if ($scope.editorLoaded) {
      setTimeout(function() {
        $scope.navigate(path);
      }, 500);
    }
  });
};

var navigatedByTocClick = false;
$scope.navigate = function(path, subPath, expand) {
  selectedPath = path + (subPath ? "-" + $scope.cleanUpKey(subPath) : "");
  // Scroll in api editor
  if ($scope.mainTab == 'editor') {
    var editNode = null;
    if(subPath) {
      editNode = document.querySelector('.detailsEditor .navigate-' + selectedPath + "-" + $scope.cleanUpKey(subPath));
    }
    if(!editNode) {
      editNode = document.querySelector('.detailsEditor .navigate-' + selectedPath);
    }
    if (editNode) {
      navigatedByTocClick = true;
      $('.toc .tocItem .selected').removeClass('selected');
      $('.toc .tocItem .toc-navigate-' + selectedPath).addClass('selected');
      editNode.scrollIntoView();
      if (expand) $scope.$broadcast('expand-'+path+'-'+subPath);
    }
  } else if ($scope.mainTab == 'code') {
    // Scroll in ACE editor
    var editor = ace.edit('ace-api-editor');
    var stringToFind = path + ":";
    var lines = editor.session.doc.getAllLines();
    for(var i=0; i<lines.length; i++) {
      if (lines[i].indexOf(stringToFind) == 0) {
        if(subPath) {
          var subStringToFind = subPath;
          for(var j=i; j<lines.length; j++) {
            var index1 = lines[j].indexOf(subStringToFind + ":");
            var index2 = lines[j].indexOf(subStringToFind + "':");
            var index3 = lines[j].indexOf(subStringToFind + "\":");
            if(index1 >= 0 || index2 >= 0 || index3 >= 0) {
              i = j;
              break;
            }
          }
        }
        $scope.aceCurrentLine = i + 1;
        editor.scrollToLine($scope.aceCurrentLine, true, true, function () {});
        editor.gotoLine($scope.aceCurrentLine, 10, true);
        break;
      }
    }
  }
};

$scope.jumpToPolicy = function(policyName, instance) {
  // Scroll in ACE editor
  var editor = ace.edit('ace-api-editor');
  var lines = editor.session.doc.getAllLines();
  var stringToFind = "x-ibm-configuration:";
  for(var i = 0; i < lines.length; i++) {
    if (lines[i].indexOf(stringToFind) >= 0) break;
  }
  stringToFind = "assembly:";
  for(var j = i; j < lines.length; j++) {
    if (lines[j].indexOf(stringToFind) >= 0) break;
  }
  stringToFind = " - " + policyName + ":";
  var occurrence = 0;
  for(var k = j; k < lines.length; k++) {
    if (lines[k].indexOf(stringToFind) >= 0) {
      occurrence++;
      if (occurrence == instance) break;
    }
  }
  $scope.aceCurrentLine = k + 1;
  editor.scrollToLine($scope.aceCurrentLine, true, true, function () {});
  editor.gotoLine($scope.aceCurrentLine, 10, true);
};

$scope.$on('jump-to-policy', function($event, policyName, instance) {
  $scope.setMainTab('code');
  $scope.$watch('editorLoaded', function() {
    if ($scope.editorLoaded) {
      $timeout(function() {
        $scope.jumpToPolicy(policyName, instance);
      }, 0);
    }
  });
});

$scope.goToLine = function(lineNumber) {
  $scope.setMainTab('code');
  $timeout(function() {
    var editor = ace.edit('ace-api-editor');
    if(editor) {
      $scope.aceCurrentLine = lineNumber;
      editor.scrollToLine($scope.aceCurrentLine, true, true, function () {});
      editor.gotoLine($scope.aceCurrentLine, 10, true);
    }
  }, 1000);
};

$scope.goToPath = function(path) {
  if(path && path.length > 0) {
    if(path.length > 1) {
      $scope.navigate(path[0], path[1]);
    } else {
      $scope.navigate(path[0]);
    }
  }
};

$scope.persistYaml = function() {
  $scope.convertApi(true);
  //    var yaml = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.swaggerDocument)), {lineWidth: -1})
  //    $rootScope.editorValue =  yaml;

  // // Update our tag mapping
  // $scope.tagArray = [];
  //
    // if($scope.swaggerDocument.tags) {
      //  $scope.swaggerDocument.tags.forEach(function (tag) {
        //    $scope.tagArray.push(tag.name);
        //  });
      // }
  //
    // angular.forEach($scope.swaggerDocument.paths, function (path) {
      //  angular.forEach(path, function (operation) {
        //    if (operation.tags){
          //      operation.tags.forEach(function (tag) {
            //        if ($scope.tagArray.indexOf(tag) < 0) {
              //          $scope.tagArray.push(tag);
              //        }
            //      });
          //    }
        //  });
      // });
};

if($scope.helpEnabled) $scope.showHelp({id: "apim_help_api_editor", template: 'apim/help/partials/help-api-editor.html'});
}

angular.module('apim.apis').controller('ApiSaveAsController', ['$scope', '$modalInstance', '$state', '$http', 'Api', ApiSaveAsController]);

function ApiSaveAsController($scope, $modalInstance, $state, $http, Api) {

  function generateFilename() {
    if ($scope.swaggerHeaders && $scope.swaggerHeaders['x-ibm-swagger-file']) {
      var name = ($scope.swaggerDocument.info["x-ibm-name"]) ? $scope.swaggerDocument.info["x-ibm-name"] : $scope.swaggerDocument.info.title;
      var path = $scope.swaggerHeaders['x-ibm-swagger-file'].replace(/[^\/]+$/, '');
      $scope.$parent.filename = path + name + "_" + (($scope.newVersion) ? $scope.newVersion : $scope.swaggerDocument.info.version) + ".yaml";
    }
  }
  generateFilename();
  $scope.$watch('newVersion', generateFilename);

  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };

  $scope.createNewVersion = function(newVersion) {
    $scope.clearDirtyApi();
    $scope.saving = true;
    var newApi = new Api(angular.copy($scope.swaggerDocument));
    delete newApi.id;
    delete newApi.orgId;
    delete newApi.url;
    delete newApi.updatedAt;
    delete newApi.updatedBy;
    delete newApi.createdAt;
    delete newApi.createdBy;
    newApi.info.version = newVersion;
    function responseHandler() {
      $scope.saving = false;
      $modalInstance.dismiss('ok');
      $state.go('api', {id: $scope.swaggerDocument.info['x-ibm-name'] + ':' + newVersion});
    }
    function errorHandler() {
      $scope.saving = false;
    }
    if ($scope.swaggerHeaders && $scope.swaggerHeaders['x-ibm-swagger-file']) {
      $http.post('proxy/apimanager/orgs/' + $scope.orgId + '/apis/' + $scope.apiId + '?mode=swagger',
        angular.toJson(newApi),
        {
          headers: {
            "Content-Type": "application/json",
            "x-ibm-swagger-file": $scope.$parent.filename
          }
        }
      ).then(responseHandler, errorHandler);
    } else {
      newApi.$version({
        orgId: $scope.orgId
      }, responseHandler, errorHandler);
    }
  };
}

angular.module('apim.apis').controller('VendorExtensionController', ['$scope', '$mdDialog', VendorExtensionController]);

function VendorExtensionController($scope, $mdDialog) {
  $scope.swaggerName = "x-" + $scope.vendorExtension.name;

  $scope.deleteExtensionSchema = function() {
    delete $scope.swaggerDocument["x-" + $scope.vendorExtension.name];
    if ($scope.swaggerDocument["x-ibm-configuration"] &&
      $scope.swaggerDocument["x-ibm-configuration"].extensions &&
      $scope.swaggerDocument["x-ibm-configuration"].extensions[$scope.vendorExtension.name]) {
        delete $scope.swaggerDocument["x-ibm-configuration"].extensions[$scope.vendorExtension.name]
    }
    $scope.vendorExtensions.splice($scope.vendorExtensions.indexOf($scope.vendorExtension), 1);
  };

  $scope.switchToCodeView = function(section) {
    $scope.setMainTab('code');
    if(section) {
      setTimeout(function(){$scope.navigate(section);}, 0);
    }
  };
}

angular.module('apim.apis').controller('ApiUpdateController', ['$scope', '$modalInstance', '$filter', '$state','uiUploader', 'Api', 'errorHandler', ApiUpdateController]);

function ApiUpdateController($scope, $modalInstance, $filter, $state, uiUploader, Api, errorHandler) {
  $scope.updatingApi = false;
  $scope.importLabelText = $filter('translate')('api_update_description');

  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };
  $scope.attachToFileInput = function() {
    $scope.apiFileInput = document.getElementById('api_file');
    if ($scope.apiFileInput) {
      $scope.apiFileInput.addEventListener('change', function(e) {
        var files = e.target.files;
        uiUploader.removeAll();
        uiUploader.addFiles(files);
        $scope.selectedApiFile = uiUploader.getFiles()[0];
        $scope.importLabelText = $scope.selectedApiFile.name;
        $scope.$apply();
      });
    } else {
      setTimeout($scope.attachToFileInput, 500);
    }
  };
  $modalInstance.opened.then(function() {
    $scope.attachToFileInput();
  });
  $scope.update = function() {
    $scope.updatingApi = true;
    var url = 'proxy/apimanager/orgs/' + $scope.orgId + '/apis/' + $scope.apiId + '?mode=swagger2';
    uiUploader.startUpload({
      url: url,
      onProgress: function(file) {

      },
      onCompleted: function(file, response) {
        $scope.updatingApi = false;
        $modalInstance.dismiss('ok');
        var responseObject = response;
        if (typeof response == "string") {
          responseObject = JSON.parse(response);
        }
        if(responseObject.swagger) {
          $state.go('api', {id: $scope.apiId});
          $scope.setApi(responseObject);
        } else {
          responseObject.data = responseObject.responseText;
          responseObject.config = {url: url};
          errorHandler.checkResponse(responseObject);
        }
      },
      onCompletedAll: function() {
      }
    });
  };
}

angular.module('apim.apis').controller('SchemaEntryController', ['$scope', '$modalInstance', 'VendorExtension', 'orgId', 'existingExtensions', SchemaEntryController]);

function SchemaEntryController($scope, $modalInstance, VendorExtension, orgId, existingExtensions) {
  $scope.searchingForExtensions = true;
  $scope.extensions = VendorExtension.queryAll({
    orgId: orgId,
  });
  $scope.extensions.$promise.then(function() {
    $scope.searchingForExtensions = false;

    // Filter out existing extensions
    for (var i = 0; i < existingExtensions.length; i++) {
      var existingExtension = existingExtensions[i];
      for (var j = 0; j < $scope.extensions.length; j++){
        if ($scope.extensions[j].name == existingExtension.name &&
          $scope.extensions[j].version == existingExtension.version ) {
            $scope.extensions.splice(j, 1);
            break;
        }
      }
    }

    $scope.searchResults = $scope.extensions;
  });

  $scope.searchExtensions = function() {
    var search = $scope.searchString;
    var exts = $scope.extensions || [];
    $scope.searchResults = !search ? exts : exts.filter(function(extension) {
      return extension.name.indexOf(search) > -1 ||
        extension.title.indexOf(search) > -1 ||
        extension.version.indexOf(search) > -1;
    });
  };

  $scope.cancel = function() {
    $modalInstance.dismiss();
  };
  $scope.add = function() {
    $modalInstance.close($scope.$parent.selectedExtension);
  };
}

angular.module('apim.apis').controller('ApiKeyController', ['$scope', '$rootScope', ApiKeyController]);

function ApiKeyController($scope, $rootScope) {

  // $scope.sslProfiles = ["Alpha Profile", "Bravo Profile", "Charlie Profile"];
  // $scope.userRegistries = ["Alpha Registry", "Bravo Registry", "Charlie Registry"];

  $scope.$watch('definition.in', function() {
    // we're changing the 'in' property... make sure we keep name / in in sync for IBM api keys
    // If toolkit is running with experimental v6 DP, we don't want to change the name.
    if ($rootScope.features.experimental) return;
    if ($scope.definition['in'] == "header") {
      if ($scope.definition.name == "client_id") {
        $scope.definition.name = "X-IBM-Client-Id";
      } else if ($scope.definition.name == "client_secret") {
        $scope.definition.name = "X-IBM-Client-Secret";
      }
    } else if ($scope.definition['in'] == "query") {
      if ($scope.definition.name == "X-IBM-Client-Id") {
        $scope.definition.name = "client_id";
      } else if ($scope.definition.name == "X-IBM-Client-Secret") {
        $scope.definition.name = "client_secret";
      }
    }
  });

  $scope.$securityDefinitionName = function(newName) {
    if (arguments.length) {
      // Setter
      if(newName) {
        // Check for name clash
        for(var definitionName in $scope.swaggerDocument.securityDefinitions) {
          if(definitionName == newName) {
            $scope.tempName = newName;
            return;
          }
        }
        $scope.tempName = null;

        // Update
        var updatedSecurityDefinitions = {};
        for(var securityDefinitionName in $scope.swaggerDocument.securityDefinitions) {
          if(securityDefinitionName == $scope.definition.$$key) {
            updatedSecurityDefinitions[newName] = $scope.swaggerDocument.securityDefinitions[securityDefinitionName];
          } else {
            updatedSecurityDefinitions[securityDefinitionName] = $scope.swaggerDocument.securityDefinitions[securityDefinitionName];
          }
        }
        $scope.swaggerDocument.securityDefinitions = updatedSecurityDefinitions;

        // rename any references to the old name
        var oldName = $scope.definition.$$key;
        if ($scope.swaggerDocument.security) {
          $scope.swaggerDocument.security.forEach(function(security) {
            if (security[oldName]) {
              security[newName] = security[oldName];
              delete security[oldName];
            }
          });
        }
        if ($scope.swaggerDocument.paths) {
          Object.keys($scope.swaggerDocument.paths).forEach(function(pathName) {
            Object.keys($scope.swaggerDocument.paths[pathName]).forEach(function(verb) {
              if ($scope.swaggerDocument.paths[pathName][verb].security) {
                $scope.swaggerDocument.paths[pathName][verb].security.forEach(function(security) {
                  if (security[oldName]) {
                    security[newName] = security[oldName];
                    delete security[oldName];
                  }
                });
              }
            });
          });
        }

        $scope.definition.$$key = newName;
      }
    } else {
      // Getter
      if($scope.tempName) return $scope.tempName;
      return $scope.definition.$$key;
    }
  };

  if($scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]) {
    if($scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"] && $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]['url']) {
      $scope["in"] = 'authUrl';
      $scope.selectedAuthUrl = $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]['url'];
      if($scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]['tls-profile']) {
        $scope.selectedTlsProfile = $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]['tls-profile'];
        //$scope.tlsEnabled = true;
      }
    } else if($scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-registry"] && $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-registry"]) {
      $scope["in"] = 'ldap';
      $scope.selectedIdpName = $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-registry"];
    }
  }

  $scope.idpName = function(value) {
    if (typeof value === "undefined") {
      return $scope.selectedIdpName;
    } else {
      $scope.selectedIdpName = value;
      $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-registry"] = $scope.selectedIdpName;
      delete $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"];
    }
  }

  $scope.authUrl = function(value) {
    if (typeof value === "undefined") {
      return $scope.selectedAuthUrl;
    } else {
      $scope.selectedAuthUrl = value;
      if(!$scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]) {
        $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"] = {};
      }
      $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]['url'] = $scope.selectedAuthUrl;
      delete $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-registry"];
    }
  }

  $scope.tlsProfile = function(value) {
    if (typeof value === "undefined") {
      return $scope.selectedTlsProfile;
    } else {
      $scope.selectedTlsProfile = value;
      if(!$scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]) {
        $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"] = {};
      }
      $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']]["x-ibm-authentication-url"]['tls-profile'] = $scope.selectedTlsProfile;
    }
  }
}

angular.module('apim.apis').controller('ApiOAuthController', ['$scope', '$rootScope', ApiOAuthController]);

function ApiOAuthController($scope, $rootScope) {
  function cleanFlow() {
    if ($scope.selectedOauth && $rootScope.features.experimental) {
      var path = 'https://' + $scope.swaggerDocument.host + '/' + $scope.selectedOauth.basePath.replace(/^\/*|\/*$/g, '') + '/';
      if ($scope.definition.flow === 'application') {
        delete $scope.definition.authorizationUrl;
        $scope.definition.tokenUrl = path + $scope.selectedOauth['apic-token-endpoint'].replace(/^\/*|\/*$/g, '');
      } else if ($scope.definition.flow === 'implicit') {
        delete $scope.definition.tokenUrl;
        // use regex to remove any slash at the begining/end
        $scope.definition.authorizationUrl = path + $scope.selectedOauth['apic-authorize-endpoint'].replace(/^\/*|\/*$/g, '');
      } else if ($scope.definition.flow === 'accessCode') {
        $scope.definition.authorizationUrl = path + $scope.selectedOauth['apic-authorize-endpoint'].replace(/^\/*|\/*$/g, '');
        $scope.definition.tokenUrl = path + $scope.selectedOauth['apic-token-endpoint'].replace(/^\/*|\/*$/g, '');
      }
      if (!$scope.definition.flow) {
        delete $scope.definition.authorizationUrl;
        delete $scope.definition.tokenUrl;
      }
    }
  }

  $scope.$selectedScope = function(value) {
    if (!value) return $scope.selectedScope;
      $scope.selectedScope = value;
      if ($rootScope.features.experimental && $scope.selectedOauth) {
        if (!$scope.definition.scopes) $scope.definition.scopes = {};
          $scope.definition.scopes[value] = $scope.selectedOauth.scopes[value];
        delete $scope.selectedScope;
      }
  }

  $scope.$watch('definition.flow', function() {
    // clean up any unrelated properties in the model
    // type       implicit, password, application, accessCode
    // description    implicit, password, application, accessCode
    // flow       implicit, password, application, accessCode
    // scopes     implicit, password, application, accessCode
    // tokenUrl     password, application, accessCode
    // authorizationUrl implicit, accessCode
    if ($scope.definition.flow === 'implicit') delete $scope.definition.tokenUrl;
    if ($scope.definition.flow === 'password' || $scope.definition.flow === 'application') {
      delete $scope.definition.authorizationUrl;
    }
    cleanFlow();
  });

  $scope.$watch('definition["x-provider"]', function(newOauth, oldOauth) {
    if($scope.definition['x-provider'] && $rootScope.features.experimental) {
      $scope.oauthProviders.forEach(function(oauth) {
        if ($scope.definition['x-provider'] === oauth.name) {
          $scope.definition.description = oauth.description;
          $scope.selectedOauth = oauth;
        }
      });
      if (newOauth !== oldOauth) {
        delete $scope.definition.scopes;
        delete $scope.definition.flow;
        cleanFlow();
      }
    }
  });

  $scope.removeScope = function(scope) {
    delete $scope.definition.scopes[scope];
  }

  var selectedDefinition = $scope.swaggerDocument.securityDefinitions[$scope.definition.$$key];

  $scope.advancedScopeSwitch = false;

  $scope.$watch('swaggerDocument', function(newObj) {
    try {
      $scope.advancedScopeSwitch = !!selectedDefinition['x-scopeValidate'];
    } catch (e) {
      $scope.advancedScopeSwitch = false;
    }
    if (!selectedDefinition['x-scopeValidate'] ||
      Object.keys(selectedDefinition['x-scopeValidate']).length === 0) {
      delete selectedDefinition['x-scopeValidate'];
    }
  });

  $scope.$advancedScopeCheck = function (value) {
    if (value !== undefined) {
      if(value) {
        $scope.advancedScopeSwitch = true;
      } else {
        delete selectedDefinition['x-scopeValidate'];
        $scope.advancedScopeSwitch = false;
      }
    } else {
      return $scope.advancedScopeSwitch;
    }
  };

  function advancedScope(property, newVal) {
    if (newVal !== undefined) {
      if (newVal) {
        if (!selectedDefinition['x-scopeValidate']) {
          selectedDefinition['x-scopeValidate'] = {};
        }
        selectedDefinition['x-scopeValidate'][property] = newVal;
      } else {
        if (selectedDefinition['x-scopeValidate']) {
          delete selectedDefinition['x-scopeValidate'][property];
          if (Object.keys(selectedDefinition['x-scopeValidate']).length === 0) {
            delete (selectedDefinition['x-scopeValidate']);
          }
        }
      }
    } else {
      try {
        return selectedDefinition['x-scopeValidate'][property];
      } catch (e) {
        return;
      }
    }
  }

  $scope.$advancedScopeCheckURL = function (newVal) {
    if (arguments.length) {
      //setter
      advancedScope('url', newVal);
    } else {
      //getter
      return advancedScope('url');
    }
  };

  $scope.$advancedScopeCheckTLS = function (newVal) {
    if (arguments.length) {
      //setter
      advancedScope('tls-profile', newVal);
    } else {
      //getter
      return advancedScope('tls-profile');
    }
  };

  $scope.$securityDefinitionName = function(newName) {
    if (arguments.length) {
      // Setter
      if(newName) {
        // Check for name clash
        for(var definitionName in $scope.swaggerDocument.securityDefinitions) {
          if(definitionName == newName) {
            $scope.tempName = newName;
            return;
          }
        }
        $scope.tempName = null;

        // Update
        var updatedSecurityDefinitions = {};
        for(var securityDefinitionName in $scope.swaggerDocument.securityDefinitions) {
          if(securityDefinitionName == $scope.definition.$$key) {
            updatedSecurityDefinitions[newName] = $scope.swaggerDocument.securityDefinitions[securityDefinitionName];
          } else {
            updatedSecurityDefinitions[securityDefinitionName] = $scope.swaggerDocument.securityDefinitions[securityDefinitionName];
          }
        }
        $scope.swaggerDocument.securityDefinitions = updatedSecurityDefinitions;

        // rename any references to the old name
        var oldName = $scope.definition.$$key;
        if ($scope.swaggerDocument.security) {
          $scope.swaggerDocument.security.forEach(function(security) {
            if (security[oldName]) {
              security[newName] = security[oldName];
              delete security[oldName];
            }
          });
        }
        if ($scope.swaggerDocument.paths) {
          Object.keys($scope.swaggerDocument.paths).forEach(function(pathName) {
            Object.keys($scope.swaggerDocument.paths[pathName]).forEach(function(verb) {
              if ($scope.swaggerDocument.paths[pathName][verb].security) {
                $scope.swaggerDocument.paths[pathName][verb].security.forEach(function(security) {
                  if (security[oldName]) {
                    security[newName] = security[oldName];
                    delete security[oldName];
                  }
                });
              }
            });
          });
        }

        $scope.definition.$$key = newName;
      }
    } else {
      // Getter
      if($scope.tempName) return $scope.tempName;
      return $scope.definition.$$key;
    }
  };
}

angular.module('apim.apis').controller('ApiOAuthScopeController', [
  '$scope',
  '$rootScope',
  ApiOAuthScopeController
]);

function ApiOAuthScopeController($scope, $rootScope) {

  var self = this;

  self.$oauthScopeName = function(newName) {
    if (arguments.length) {
      // Setter
      if(newName !== undefined) {
        // Check for name clash
        for(var definitionName in $scope.swaggerDocument.securityDefinitions) {
          if(definitionName == newName) {
            $scope.tempName = newName;
            return;
          }
        }
        $scope.tempName = null;

        // Update
        var updatedScopes = {};
        for(var scopeName in $scope.definition.scopes) {
          if(scopeName == $scope.oauthScopeName) {
            updatedScopes[newName] = $scope.oauthScope;
            $rootScope.$emit('event:updateScopes', scopeName);
          } else {
            updatedScopes[scopeName] = $scope.definition.scopes[scopeName];
          }
        }
        $scope.swaggerDocument.securityDefinitions[$scope.definition['$$key']].scopes = updatedScopes;
        $scope.oauthScopeName = newName;
      }
    } else {
      // Getter
      if($scope.tempName) return $scope.tempName;
      return $scope.oauthScopeName;
    }
  };

  self.removeScope = function() {
    var updatedScopes = {};
    Object.keys($scope.definition.scopes).forEach(function(scopeName) {
      if(scopeName !== $scope.oauthScopeName) {
        updatedScopes[scopeName] = $scope.definition.scopes[scopeName];
      }
    });
    $scope.definition.scopes = updatedScopes;
  };
}
angular.module('apim.apis').controller('ApiOAuthProviderScopeController', ['$scope', ApiOAuthProviderScopeController]);

function ApiOAuthProviderScopeController($scope) {

  var self = this;

  self.$oauthScopeName = function(newName) {
    if (arguments.length) {
      // Setter
      if(newName) {
        var updatedScopes = {};
        Object.keys($scope.swaggerDocument['x-ibm-configuration'].oauth2.scopes).forEach(function(scopeName) {
          if(scopeName == $scope.oauthScopeName) {
            updatedScopes[newName] = $scope.oauthScope;
          } else {
            updatedScopes[scopeName] = $scope.swaggerDocument['x-ibm-configuration'].oauth2.scopes[scopeName];
          }
        });
        $scope.swaggerDocument['x-ibm-configuration'].oauth2.scopes = updatedScopes;
        $scope.oauthScopeName = newName;
      }
    } else {
      // Getter
      return $scope.oauthScopeName;
    }
  };

  self.removeScope = function() {
    var updatedScopes = {};
    Object.keys($scope.swaggerDocument['x-ibm-configuration'].oauth2.scopes).forEach(function(scopeName) {
      if(scopeName !== $scope.oauthScopeName) {
        updatedScopes[scopeName] = $scope.swaggerDocument['x-ibm-configuration'].oauth2.scopes[scopeName];
      }
    });
    $scope.swaggerDocument['x-ibm-configuration'].oauth2.scopes = updatedScopes;
  };
}

angular.module('apim.apis').controller('SecurityOptionsController', ['$scope', '$mdDialog', SecurityOptionsController]);

function SecurityOptionsController($scope, $mdDialog) {
  var self = this;

  $scope.$watch('swaggerDocument', function() {
    if (!$scope.swaggerDocument) return;
    // operation- or swagger-level security
    self.containerObject = $scope.operation || $scope.swaggerDocument;
  });

  $scope.addSecurityOption = function() {
    if(!self.containerObject.security) self.containerObject.security = [];
    self.containerObject.security.push({});
  };
  $scope.deleteSecurityOption = function($index) {
    if ($index < self.containerObject.security.length) {
      self.containerObject.security.splice($index, 1);
    }
  };
  self.moveUp = function(index) {
    if (index <= 0) return;
    var newOptions = [];
    self.containerObject.security.forEach(function(thisOption, currentIndex) {
      if (currentIndex == index) return;
      if (currentIndex == index - 1) {
        newOptions.push(self.containerObject.security[index]);
        newOptions.push(thisOption);
      } else {
        newOptions.push(thisOption);
      }
    });
    self.containerObject.security = newOptions;
  }
  self.moveDown = function(index) {
    if (index >= self.containerObject.security.length - 1) return;
    var newOptions = [];
    self.containerObject.security.forEach(function(thisOption, currentIndex) {
      if (currentIndex == index) return;
      if (currentIndex == index + 1) {
        newOptions.push(thisOption);
        newOptions.push(self.containerObject.security[index]);
      } else {
        newOptions.push(thisOption);
      }
    });
    self.containerObject.security = newOptions;
  }
}

angular.module('apim.apis').controller('ApiSecuritySchemeController', ['$scope', ApiSecuritySchemeController]);

function ApiSecuritySchemeController($scope) {

  $scope.$schemeEnabled = function(enabled) {
    var securitySchemeName = "";
    if (arguments.length) {
      // Setter
      if(enabled) {
        var scopes = Object.keys($scope.swaggerDocument.securityDefinitions[$scope.securityDefinitionName].scopes || {});
        $scope.securityOption[$scope.securityDefinitionName] = scopes;
      } else {
        delete $scope.securityOption[$scope.securityDefinitionName];
      }
    } else {
      // Getter
      return $scope.securityOption[$scope.securityDefinitionName] !== undefined;
    }
  };
}

angular.module('apim.apis').controller('ApiSecuritySchemeScopeController', [
  '$scope',
  '$rootScope',
  ApiSecuritySchemeScopeController
]);

function ApiSecuritySchemeScopeController($scope, $rootScope) {
  var self = this;

  function removeScope(scopeName, currentScopes) {
    if (!currentScopes) {
      currentScopes = [];
    };
    var index = currentScopes.indexOf(scopeName);
    if (index >= 0) {
      currentScopes.splice(index, 1);
      $scope.securityOption[$scope.securityDefinitionName] = currentScopes;
    };
  };

  $rootScope.$on('event:updateScopes', function(eventScope, scopeName){
    var currentScopes = $scope.securityOption[$scope.securityDefinitionName];
    if (!currentScopes) {
      currentScopes = [];
    }
    removeScope(scopeName, currentScopes);
  });

  $scope.$scopeEnabled = function(enabled) {
    var currentScopes = $scope.securityOption[$scope.securityDefinitionName];
    if (!currentScopes) {
      currentScopes = [];
    }
    if (arguments.length) {
      // Setter
      if(enabled) {
        if (currentScopes.indexOf($scope.scope) < 0) {
          currentScopes.push($scope.scope);
          $scope.securityOption[$scope.securityDefinitionName] = currentScopes;
        }
      } else {
        removeScope($scope.scope, currentScopes);
      }
    } else {
      // Getter
      return currentScopes.indexOf($scope.scope) >= 0;
    }
  }
}

angular.module('apim.apis').controller('TagController', ['$scope', TagController]);

function TagController($scope) {

  $scope.externalDocs = {
    description: function(newDesc) {
      if (arguments.length) {
        // Setter
        if (newDesc != "") {
          if ($scope.tag.externalDocs == undefined) {
            $scope.tag.externalDocs = {};
          }
          $scope.tag.externalDocs.description = newDesc;
        } else {
          delete $scope.tag.externalDocs.description;
          if ($scope.tag.externalDocs.url == undefined) {
            delete $scope.tag.externalDocs;
          }
        }
      } else {
        // Getter
        if ($scope.tag.externalDocs && $scope.tag.externalDocs.description) {
          return $scope.tag.externalDocs.description;
        } else {
          return "";
        }
      }
    },

    url: function(newUrl) {
      if (arguments.length) {
        // Setter
        if (newUrl != "") {
          if ($scope.tag.externalDocs == undefined) {
            $scope.tag.externalDocs = {};
          }
          $scope.tag.externalDocs.url = newUrl;
        } else {
          delete $scope.tag.externalDocs.url;
          if ($scope.tag.externalDocs.description == undefined) {
            delete $scope.tag.externalDocs;
          }
        }
      } else {
        // Getter
        if ($scope.tag.externalDocs && $scope.tag.externalDocs.url) {
          return $scope.tag.externalDocs.url;
        } else {
          return "";
        }
      }
    }
  };

  // $scope.sslProfiles = ["Alpha Profile", "Bravo Profile", "Charlie Profile"];
  // $scope.userRegistries = [{name:"Alpha Registry", url:"http://11111111"}, {name:"Bravo Registry", url:"http://22222222"}];

}

angular.module('apim.apis').controller('PathController', ['$scope', '$modal', PathController]);

function PathController($scope, $modal) {

  $scope.pathExpanded = !$scope.largeDocumentMode;

  $scope.$on('expand-paths-'+$scope.path.$$key, function() {
    $scope.pathExpanded = true;
  });

  $scope.$pathName = function(newName) {
    if (arguments.length) {
      // Setter
      if(newName) {
        // Check for name clash
        for(var name in $scope.swaggerDocument.paths) {
          if(name == newName) {
            $scope.tempName = newName;
            return;
          }
        }
        $scope.tempName = null;

        // Update
        var updatedPaths = {};
        for(var pathName in $scope.swaggerDocument.paths) {
          if(pathName == $scope.path.$$key) {
            updatedPaths[newName] = $scope.swaggerDocument.paths[pathName];
          } else {
            updatedPaths[pathName] = $scope.swaggerDocument.paths[pathName];
          }
        }

        // ensure the assembly model is up to date
        if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].assembly && $scope.swaggerDocument['x-ibm-configuration'].assembly.execute) {
          var matches = _.filter($scope.swaggerDocument['x-ibm-configuration'].assembly.execute, {'operation-switch': {'case': [{operations: [{path: $scope.path.$$key}]}]}});
          matches.forEach(function(policy) {
            var caseMatches = _.filter(policy['operation-switch']['case'], {operations: [{path: $scope.path.$$key}]});
            caseMatches.forEach(function(thisCase) {
              var operationMatches = _.filter(thisCase.operations, {path: $scope.path.$$key});
              operationMatches.forEach(function(operation) {
                if ($scope.path.hasOwnProperty(operation.verb)) operation.path = newName;
              });
            });
          });
        }
        // end of assembly update

        $scope.swaggerDocument.paths = updatedPaths;
        $scope.path.$$key = newName;
      }
    } else {
      // Getter
      if($scope.tempName) return $scope.tempName;
      return $scope.path.$$key;
    }
  };

  $scope.$watch("path", function(newDefn, oldDefn) {
    if (newDefn === oldDefn) return;

    if (oldDefn['$$key'] == newDefn['$$key']) {
      $scope.swaggerDocument.paths[newDefn['$$key']] = newDefn;
    } else {
      delete  $scope.swaggerDocument.paths[oldDefn['$$key']];
      $scope.swaggerDocument.paths[newDefn['$$key']] = newDefn;
    }
    $scope.operations = [];
    for (var operation in $scope.path) {
      // ignore strings
      if (typeof $scope.path[operation] !== "object") continue;
      // ignore parameters
      if (operation == "parameters") continue;
      var transformedDefn =  $scope.path[operation];
      transformedDefn['$$key'] = operation;
      $scope.operations.push(transformedDefn);
    }
  }, true);

  $scope.operations = [];
  for (var operation in $scope.path) {
    if (typeof $scope.path[operation] !== "object") continue;
    // ignore parameters
    if (operation == "parameters") continue;
    var transformedDefn =  $scope.path[operation];
    transformedDefn['$$key'] = operation;
    $scope.operations.push(transformedDefn);
  }

  $scope.addOperation = function(method) {
    $scope.swaggerDocument.paths[$scope.path.$$key][method] = {responses:{200:{description:'200 OK'}}};

    for(var i=0; i<$scope.paths.length; i++) {
      if($scope.paths[i].$$key == $scope.path.$$key) {
        $scope.paths[i][method] = {responses:{200:{description:'200 OK'}}};
        break;
      }
    }
    $scope.operations.push({'$$key': method, responses:{200:{description:'200 OK'}}});
  };

  $scope.removeOperation = function($event, operation) {
    $event.stopPropagation();
    $scope.confirmation = {
      titleKey: 'api_operation_delete_title',
      messageKey: 'api_operation_delete_message',
      confirmed: function() {
        delete $scope.swaggerDocument.paths[$scope.path.$$key][operation.$$key];

        for(var i=0; i<$scope.operations.length; i++) {
          if($scope.operations[i].$$key == operation.$$key) {
            $scope.operations.splice(i, 1);
            break;
          }
        }
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
}

angular.module('apim.apis').controller('PropertiesController', ['$scope', '$filter', PropertiesController]);

function PropertiesController($scope, $filter) {
  $scope.catalogList = [];
  // merge catalogs found in the swagger document with the ones currently known to the UI
  var mergeCatalogs = function() {
    $scope.catalogList = [];
    var lookup = {};
    // always add pre-defined catalog
    $scope.catalogList.push({
      name: "apic-dev",
      value: "apic-dev"
    });
    lookup["apic-dev"] = true;
    // go through the catalogs already in the swagger doc first
    if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].catalogs) {
      for (var catalogName in $scope.swaggerDocument['x-ibm-configuration'].catalogs) {
        if (!lookup[catalogName]) {
          $scope.catalogList.push({
            name: catalogName,
            value: catalogName
          });
          // track these names so we dont double add from global catalog list
          lookup[catalogName] = true;
        }
      } // end for
    }
    // add new environments when available
    var unwatcher = $scope.$watch('environments', function() {
      if (!$scope.environments) return;
      unwatcher();
      for (var i = 0; i < $scope.environments.length; i++) {
        var env = $scope.environments[i];
        if (!lookup[env.name]) {
          $scope.catalogList.push({
            name: env.name,
            value: env.name
          });
        }
      } // end for
    });
  };
  // one-off call to init the catalog list
  mergeCatalogs();
  // decode a base64 value, if present
  $scope.decodeValue = function(value) {
    if (value) {
      var base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      var isEncoded = base64regex.test(value)
      if (isEncoded) return atob(value)
    }
    return value;
  };
  // encode a value with a prefix, if required
  $scope.encodeValue = function(value) {
    if (value) {
      var base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      var isEncoded = base64regex.test(value)
      if (!isEncoded) return btoa(value)
    }
    return value;
  };
  $scope.$propertyName = function(newName) {
    if (arguments.length){
      // Setter
      if(newName) {
        // Check for name clash
        for(var propName in $scope.swaggerDocument['x-ibm-configuration'].properties) {
          if(propName == newName) {
            $scope.tempName = newName;
            return;
          }
        }
        $scope.tempName = null;
        // Update
        var updatedProperties = {};
        for(var propertyName in $scope.swaggerDocument['x-ibm-configuration'].properties) {
          if(propertyName == $scope.propertyName) {
            updatedProperties[newName] = $scope.swaggerDocument['x-ibm-configuration'].properties[propertyName];
          } else {
            updatedProperties[propertyName] = $scope.swaggerDocument['x-ibm-configuration'].properties[propertyName];
          }
        }
        $scope.swaggerDocument['x-ibm-configuration'].properties = updatedProperties;
        // go through any catalogs to update prop name as well
        var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
        if (catalogs) {
          for (var catalogName in catalogs) {
            var catalog = catalogs[catalogName];
            if (catalog.properties && typeof catalog.properties[$scope.propertyName] != "undefined") {
              // found a catalog entry for this property - update to new name
              var catProperties = {};
              for (var catPropName in catalog.properties) {
                if (catPropName == $scope.propertyName) {
                  catProperties[newName] = catalog.properties[catPropName];
                } else {
                  catProperties[catPropName] = catalog.properties[catPropName];
                }
              } // end for
              catalog.properties = catProperties;
            }
          } // end for
        }
        $scope.propertyName = newName;
        $scope.togglePropertyExpanded(newName);
      }
    } else {
      // Getter
      if($scope.tempName) return $scope.tempName;
      return $scope.propertyName;
    }
  };
  // work out next catalog name to use
  var nextCatalog = function() {
    var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
    if (!catalogs) {
      catalogs = {};
      $scope.swaggerDocument['x-ibm-configuration'].catalogs = catalogs;
    }
    var catalogName = "";
    if ($scope.isOffline()) {
      var testNameBase = $filter('translate')("api_properties_catalog_name").toLowerCase().replace(/\W/g, '-');
      var j = 1;
      while (catalogs[testNameBase + "-" + j] != null) {
        j++;
      }
      catalogName = testNameBase + "-" + j;
    } else {
      var propertyName = $scope.$propertyName();
      var len = $scope.catalogList.length;
      for (var i=0;i<len;i++) {
        var catalog = $scope.catalogList[i];
        if (!catalogs[catalog.name]) {
          catalogName = catalog.name;
          break;
        } else if (!catalogs[catalog.name].properties) {
          catalogName = catalog.name;
          break;
        } else if (typeof catalogs[catalog.name].properties[propertyName] == "undefined") {
          catalogName = catalog.name;
          break;
        }
      } // end for
    }
    return catalogName;
  };
  // add a new value for this property in a catalog
  $scope.addValue = function() {
    var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
    if (!catalogs) {
      catalogs = {};
      $scope.swaggerDocument['x-ibm-configuration'].catalogs = catalogs;
    }
    // work out next catalog name to use
    var catalogName = nextCatalog();
    if (!catalogs[catalogName]) {
      catalogs[catalogName] = {};
      catalogs[catalogName].$$key = catalogName;
    }
    if (!catalogs[catalogName].properties) {
      catalogs[catalogName].properties = {};
    }
    var propertyName = $scope.$propertyName();
    catalogs[catalogName].properties[propertyName] = "";
  };
  // work out if we have any catalogs left to add this property to
  $scope.canAddValue = function() {
    var ret = true;
    if (!$scope.isOffline()) {
      var catalogName = nextCatalog();
      if (!catalogName) {
        ret = false;
      }
    }
    return ret;
  };
  $scope.encodeDecode = function(propertyName, propertyValue) {
    // update encoding for the given value
    if (propertyValue.encoded) {
      propertyValue.value = $scope.encodeValue(propertyValue.value);
    } else if (!propertyValue.encoded) {
      propertyValue.value = $scope.decodeValue(propertyValue.value);
    }
    // encode/decode all catalog values
    var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
    if (catalogs) {
      for (var catalogName in catalogs) {
        var catalog = catalogs[catalogName];
        if (catalog.properties) {
          // found a catalog entry with properties
          for (var catPropName in catalog.properties) {
            if (catPropName == propertyName) {
              var catValue = catalog.properties[catPropName];
              if (propertyValue.encoded) {
                catalog.properties[catPropName] = $scope.encodeValue(catValue);
              } else {
                catalog.properties[catPropName] = $scope.decodeValue(catValue);
              }
            }
          } // end for
        }
      } // end for
    }
  };
}

angular.module('apim.apis').controller('PropertiesCatalogController', ['$scope', '$filter', '$modal', PropertiesCatalogController]);

function PropertiesCatalogController($scope, $filter, $modal) {
  var defaultText = $filter('translate')('api_properties_default');
  $scope.$propertyValue = function(newValue) {
    var propertyName = $scope.$propertyName();
    var catalogName = $scope.$catalogName();
    var encoded = $scope.swaggerDocument['x-ibm-configuration'].properties[propertyName].encoded;
    var catalogs;
    if (arguments.length){
      // Setter
      var value = newValue;
      if (encoded) {
        value = $scope.encodeValue(newValue);
      }
      if (catalogName && catalogName != defaultText) {
        // make sure we create all the structure we need from scratch if necessary
        catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
        if (!catalogs) {
          catalogs = {};
          $scope.swaggerDocument['x-ibm-configuration'].catalogs = catalogs;
        }
        if (!catalogs[catalogName]) {
          catalogs[catalogName] = {};
        }
        if (!catalogs[catalogName].properties) {
          catalogs[catalogName].properties = {};
        }
        catalogs[catalogName].properties[propertyName] = value;
      } else {
        // no catalog chosen or default catalog
        $scope.swaggerDocument['x-ibm-configuration'].properties[propertyName].value = value;
      }
    } else {
      // Getter
      if (catalogName && catalogName != defaultText) {
        catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
        if (catalogs && catalogs[catalogName] && catalogs[catalogName].properties &&
          typeof catalogs[catalogName].properties[propertyName] != "undefined") {
            var ret = catalogs[catalogName].properties[propertyName];
            if (encoded) {
              ret = $scope.decodeValue(ret);
            }
            return ret;
        }
      } else {
        // no catalog chosen or default catalog
        var propVal = $scope.swaggerDocument['x-ibm-configuration'].properties[propertyName];
        var retVal = propVal.value;
        if (encoded) {
          retVal = $scope.decodeValue(retVal);
        }
        return retVal;
      }
    }
  };
  $scope.$catalogName = function(newName) {
    if (arguments.length){
      // Setter
      if (newName) {
        var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
        var propertyName = $scope.$propertyName();
        // Check for name clash
        for (var name in catalogs) {
          if (name == newName && catalogs[name].properties && typeof catalogs[name].properties[propertyName] != "undefined") {
            $scope.tempName = newName;
            return;
          }
        } // end for
        $scope.tempName = null;
        var updatedCatalogs = {};
        for (var catalogName in catalogs) {
          if (catalogName == $scope.catalog.$$key) {
            if (updatedCatalogs[newName]) {
              // merge old properties into new
              for (var propName in catalogs[catalogName].properties) {
                updatedCatalogs[newName].properties[propName] = catalogs[catalogName].properties[propName];
              } // end for
            } else {
              updatedCatalogs[newName] = catalogs[catalogName];
            }
          } else {
            updatedCatalogs[catalogName] = catalogs[catalogName];
          }
        } // end for
        $scope.swaggerDocument['x-ibm-configuration'].catalogs = updatedCatalogs;
        $scope.catalog.$$key = newName;
      }
    } else {
      // Getter
      if ($scope.tempName) return $scope.tempName;
      return ($scope.catalog ? $scope.catalog.$$key : defaultText);
    }
  };
  // remove a property value for a given catalog
  $scope.deleteValue = function() {
    $scope.confirmation = {
      titleKey: 'api_properties_delete_value_title',
      messageKey: 'api_properties_delete_value_message',
      confirmed: function() {
        var propertyName = $scope.$propertyName();
        var catalogs = $scope.swaggerDocument['x-ibm-configuration'].catalogs;
        delete catalogs[$scope.catalog.$$key].properties[propertyName];
        if (angular.equals({}, catalogs[$scope.catalog.$$key].properties)) {
          delete catalogs[$scope.catalog.$$key].properties;
        }
        if (angular.equals({}, catalogs[$scope.catalog.$$key])) {
          delete catalogs[$scope.catalog.$$key];
        }
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
}

angular.module('apim.apis').controller('ApiAnalyticsController', ['$scope', '$filter', '$modal', ApiAnalyticsController]);

function ApiAnalyticsController($scope, $filter, $modal) {
  var self = this;

  var releaseWatch = $scope.$watchCollection('swaggerDocument', function() {
    if(!$scope.swaggerDocument) return;
    releaseWatch(); // releases this watch on swaggerDocument
    if (!$scope.swaggerDocument['x-ibm-configuration']) $scope.swaggerDocument['x-ibm-configuration'] = {};
    if (!$scope.analyticsContainer) $scope.analyticsContainer = $scope.swaggerDocument['x-ibm-configuration'];
  });

  self.isBodyOrHeader = function(parameter) {
    return parameter.in == 'body' || parameter.in == 'header';
  };

  self.getReference = function(ref) {
    return ref.replace('#/parameters/', '');
  };

  self.getFieldIn = function(paramIn) {
    if (paramIn == 'body') {
      return 'payload';
    }
    return paramIn;
  }

  self.addField = function() {
    if ($scope.analyticsContainer && !$scope.analyticsContainer.analytics) $scope.analyticsContainer.analytics = {};
    if (!$scope.analyticsContainer.analytics.mappings) $scope.analyticsContainer.analytics.mappings = [];

    var testNameBase = $filter('translate')('field').toLowerCase();
    var testName = testNameBase;
    var nameSuffix = 1;
    var fieldList = $scope.analyticsContainer.analytics.mappings;
    fieldList.forEach(function(field) {
      if (field.schema['name'] && field.schema['name'].indexOf(testName) >= 0) {
        testName = testNameBase + "-" + nameSuffix++;
      }
    });

    $scope.analyticsContainer.analytics.mappings.push({
      'schema': {
        'name': testName,
        'in': 'header'
      },
      'es-type': 'keyword',
      'from': 'request'
    });
  };

  self.hasMappingName = function(mapping){
    if (mapping.schema && mapping.schema.name) {
      $scope.mappingName = mapping.schema.name;
      return true;
    }
    return false;
  };

  self.checkEmptyName = function(mapping){
    if (mapping.schema && !mapping.schema.name) {
      mapping.schema.name = $scope.mappingName;
    }
  };

  self.hasField = function(parameter) {
    if (!$scope.analyticsContainer.analytics || !$scope.analyticsContainer.analytics.mappings)
      return false;
    var filtered = $scope.analyticsContainer.analytics.mappings.filter(function(thisField) {
      return (thisField.schema.$ref == '#/parameters/' + parameter.name || thisField.schema.name == parameter.name);
    });
    return filtered.length > 0;
  };

  self.referenceParameter = function(parameterName, parameterRef, parameter) {
    if ($scope.analyticsContainer && !$scope.analyticsContainer.analytics) $scope.analyticsContainer.analytics = {};
    if (!$scope.analyticsContainer.analytics.mappings) $scope.analyticsContainer.analytics.mappings = [];

    if (!self.hasField(parameter)) {
      $scope.analyticsContainer.analytics.mappings.push({
        'schema': {$ref: parameterRef},
        'es-type': 'keyword',
        'from': 'request'
      });
    }
  };

  self.deleteField = function(mapping) {
    $scope.confirmation = {
      titleKey: 'api_analytics_delete_title',
      messageKey: 'api_analytics_delete_message',
      confirmed: function() {
        var index = $scope.analyticsContainer.analytics.mappings.indexOf(mapping);
        if (index > -1) {
          $scope.analyticsContainer.analytics.mappings.splice(index, 1);
        }
        if ($scope.analyticsContainer.analytics.mappings.length === 0) {
          delete $scope.analyticsContainer.analytics;
        }
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
}

angular.module('apim.apis').controller('ApiParametersController', ['$scope', '$filter', '$modal', ApiParametersController]);

function ApiParametersController($scope, $filter, $modal) {

  var self = this;

  $scope.$watch('swaggerDocument', function() {
    if (!$scope.swaggerDocument) return;
    $scope.parametersContainer = $scope.swaggerDocument;
  });
  self.documentScope = "document";

  self.addParameter = function() {
    if(!$scope.parametersContainer.parameters) $scope.parametersContainer.parameters = {};
    // Generate name
    var testNameBase = $filter('translate')("api_parameter").toLowerCase().replace(/\W/g, '-');
    var testName = testNameBase;
    var nameSuffix = 1;
    var existingNames = Object.keys($scope.parametersContainer.parameters);
    while(existingNames.indexOf(testName) >= 0) {
      testName = testNameBase + "-" + nameSuffix++;
    }
    var newParameter = {
      name: testName,
      type: 'string',
      required: false,
      "in": 'query'
    };

    $scope.parametersContainer.parameters[testName] = newParameter;
  };

  self.deleteProperty = function(parameterName) {
    $scope.confirmation = {
      titleKey: 'api_parameter_delete_title',
      messageKey: 'api_parameter_delete_message',
      confirmed: function() {
        delete $scope.swaggerDocument.parameters[parameterName];
        if (Object.keys($scope.swaggerDocument.parameters).length == 0) delete $scope.swaggerDocument.parameters;
        if ($scope.swaggerDocument.paths) {
          Object.keys($scope.swaggerDocument.paths).forEach(function(pathName) {
            var path = $scope.swaggerDocument.paths[pathName];
            if (path.parameters) {
              path.parameters = path.parameters.filter(function(parameter) {
                return (parameter.$ref !== "#/parameters/" + parameterName);
              });
            }
            Object.keys(path).forEach(function(verb) {
              var operation = path[verb];
              if (typeof operation == "object" && operation.parameters) {
                operation.parameters = operation.parameters.filter(function(parameter) {
                  return (parameter.$ref !== "#/parameters/" + parameterName);
                });
              }
            });
          });
        }
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
}


angular.module('apim.apis').controller('PathParametersController', ['$scope', '$filter', '$mdDialog', '$modal', '$http', 'DirtyService', 'ComponentRegistry', PathParametersController]);

function PathParametersController($scope, $filter, $mdDialog, $modal, $http, DirtyService, ComponentRegistry) {

  var self = this;

  // what level of the document am I at?
    if ($scope.operation) {
      $scope.parametersContainer = $scope.operation;
      self.documentScope = "operation";
    } else {
      $scope.parametersContainer = $scope.path;
      self.documentScope = "path";
    }

  self.addExternalParameter = function($event) {
    return $mdDialog.show({
      controller: 'ComponentReferenceDialogController',
      templateUrl: "apim/components/partials/choose-component-reference.html",
      parent: angular.element(document.body),
      targetEvent: $event,
      locals: {
        currentReference: null,
        references: $scope.componentReferences.parameters,
        components: $scope.components
      },
      focusOnOpen: false
    }).then(function(reference) {
      $scope.parametersContainer.parameters.push({$ref: reference});
      self.populateParameterArray();
    }, function() {
    });
  };


  $scope.referenceToLink = function(ref) {
    if ($scope.features.components) {
      return ComponentRegistry.referenceToLink(ref);
    } else {
      return "";
    }
  };



  if ($scope.features.components) {
    self.populateParameterArray = function() {
      var parameters = [];
      var originalParameters = [];
      // make sure all parameters are de-reffed
      if ($scope.parametersContainer.parameters) {
        $scope.parametersContainer.parameters.forEach(function(param) {
          originalParameters.push(param);
          var thisParam;
          if (!param.$ref) {
            parameters.push(param);
          } else {
            // we have a reference
            var resolved = ComponentRegistry.getReference(param.$ref, 'parameters');
            if (resolved) {
              resolved = angular.copy(resolved);
              resolved.$ref = param.$ref;
              parameters.push(resolved);
            } else {
              resolved = angular.copy($scope.documentReferences[param.$ref]);
              if (!resolved) {
                // last chance - try refreshing the document references
                $scope.getDocumentReferences().then(function() {
                  resolved = angular.copy($scope.documentReferences[param.$ref]);
                  if (!resolved) {
                    console.warn("Missing reference: " + param.$ref);
                  } else {
                    resolved.$ref = param.$ref;
                    parameters.push(resolved);
                  }
                });
              } else {
                resolved.$ref = param.$ref;
                parameters.push(resolved);
              }
            }
          }
        });
      }
      self.originalParameters = originalParameters;
      self.parameters = parameters;
    };
  } else {
    self.populateParameterArray = function() {
      var parameters = [];
      // make sure all parameters are de-reffed
      if ($scope.parametersContainer.parameters) {
        $scope.parametersContainer.parameters.forEach(function(param) {
          if (!param.$ref) parameters.push(param);
          if (param.$ref && param.$ref.startsWith("#/parameters/")) {
            var ref = param.$ref.replace("#/parameters/", "");
            if ($scope.swaggerDocument.parameters && $scope.swaggerDocument.parameters[ref]) {
              var thisParam = angular.copy($scope.swaggerDocument.parameters[ref]);
              thisParam.$$ref = param.$ref;
              parameters.push(thisParam);
            }
          }
        });
      }
      self.parameters = parameters;
    };
  }

  $scope.$watch('parametersContainer', self.populateParameterArray, true);

  $scope.parameterReferenceChanged = function($ref, $index) {
    if ($ref) {
      self.originalParameters[$index].$ref = $ref;
    } else {
      delete self.originalParameters[$index].$ref;
    }
    self.populateParameterArray();
  };

  self.addParameter = function() {
    if(!$scope.parametersContainer.parameters) $scope.parametersContainer.parameters = [];
    // Generate name
    var testNameBase = $filter('translate')("api_parameter").toLowerCase().replace(/\W/g, '-');
    var foundUnusedName = false;
    var nameSuffix = 1;
    while(!foundUnusedName) {
      foundUnusedName = true;
      var testName = testNameBase + "-" + nameSuffix;
      for(var i = 0; i < self.parameters.length; i++) {
        if(self.parameters[i].name == testName) {
          nameSuffix++;
          foundUnusedName = false;
          break;
        }
      }
    }
    var newParameterName = testNameBase + "-" + nameSuffix;

    var newParameter = {
      name: newParameterName,
      type: 'string',
      required: false,
      "in": 'query'
    };

    $scope.parametersContainer.parameters.push(newParameter);
    self.populateParameterArray();
  };

  self.hasParameter = function(parameter) {
    var filtered = self.parameters.filter(function(thisParameter) {
      return (thisParameter.name == parameter.name);
    });
    return filtered.length > 0;
  };

  self.referenceParameter = function(parameterName, parameterRef, parameter) {
    if (!$scope.parametersContainer.parameters) $scope.parametersContainer.parameters = [];
    if (!self.hasParameter(parameter)) {
      $scope.parametersContainer.parameters.push({
        $ref: parameterRef
      });
      self.populateParameterArray();
    }
  };

  self.deleteProperty = function(parameter) {
    $scope.confirmation = {
      titleKey: 'api_parameter_delete_title',
      messageKey: 'path_parameter_delete_message',
      confirmed: function() {
        $scope.parametersContainer.parameters = $scope.parametersContainer.parameters.filter(function(thisParameter) {
          if (thisParameter.$ref && thisParameter.$ref == parameter.$ref) return false;
          if (thisParameter.$ref && thisParameter.$ref == parameter.$$ref) return false;
          if (thisParameter.name && thisParameter.name == parameter.name) return false;
          return true;
        });
        if ($scope.parametersContainer.parameters.length == 0) delete $scope.parametersContainer.parameters;
        self.populateParameterArray();
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
}

angular.module('apim.apis').controller('ParameterController', ['$scope', '$filter', '$mdDialog', ParameterController]);

function ParameterController($scope, $filter, $mdDialog) {

  var self = this;

  var firstWatch = false;
  $scope.$watch('parameter.$ref', function() {
    if (!firstWatch) {
      firstWatch = true;
      return;
    }
    if ($scope.parameterReferenceChanged) $scope.parameterReferenceChanged($scope.parameter.$ref, $scope.$index);
  });

  // check for references
  if ($scope.parameter.$ref) {
    $scope.isRef = true;
  }
  function isKnownFormat(format) {
    if(!format) return false;
    switch(format) {
      case "byte":
      case "binary":
      case "date":
      case "date-time":
      case "password":
        return true;
    }
    return false;
  };

  $scope.$watch('parameter.in', function() {
    if ($scope.parameter.in === "path") {
      $scope.parameter.required = true;
    }
    if ($scope.parameter.in == "body") {
      // make sure we have no type or format
      delete $scope.parameter.type;
      delete $scope.parameter.format;
      // make sure we have a schema
      if (!$scope.parameter.schema) $scope.parameter.schema = {"type": "object"};
    } else {
      // make sure we have no schema
      delete $scope.parameter.schema;
      // make sure we have a type
      if (!$scope.parameter.type && !$scope.parameter.$ref) $scope.parameter.type = "string";
    }
  });

  self.addExternalDefinition = function($event) {
    return $mdDialog.show({
      controller: 'ComponentReferenceDialogController',
      templateUrl: "apim/components/partials/choose-component-reference.html",
      parent: angular.element(document.body),
      targetEvent: $event,
      locals: {
        currentReference: null,
        references: $scope.componentReferences.definitions,
        components: $scope.components
      },
      focusOnOpen: false
    }).then(function(reference) {
      $scope.parameter.schema = {'$ref': reference};
    }, function() {
    });
  };

  $scope.$parameterName = function(newName) {
    // $scope.parameterName is the unique key in the hash
    // $scope.parameter.name is the non-unique name in the object
    // this code derives a unique key from the user-provided
    // non-unique name.
      if (arguments.length) {
        // Setter
        if (newName) {
          // Check for name clash
          var suffix = 1;
          var uniqueName = newName;
          while ($scope.swaggerDocument.parameters[uniqueName] &&
            uniqueName !== $scope.parameterName) {
              uniqueName = newName + '-' + suffix;
              suffix++;
          }
          // Update
          var updatedParameters = {};
          for(var parameterName in $scope.swaggerDocument.parameters) {
            if(parameterName == $scope.parameterName) {
              updatedParameters[uniqueName] = $scope.swaggerDocument.parameters[parameterName];
              updatedParameters[uniqueName].name = newName;
            } else {
              updatedParameters[parameterName] = $scope.swaggerDocument.parameters[parameterName];
            }
          }
          $scope.swaggerDocument.parameters = updatedParameters;
          $scope.parameterName = newName;
        }
      } else {
        // Getter
        // return the user-provided name, not the generated unique name
        return $scope.parameter.name;
      }
  };

  self.getTypeValue = function(type) {
    if(!type || !type.type) return type;
    if(type.type == "string") {
      return type.type + (type.format && isKnownFormat(type.format) ? "-" + type.format : '');
    }
    return type.type + (type.format ? "-" + type.format : '');
  };

  $scope.$propertyType = function(type) {
    if (arguments.length) {
      // Setter
      if (type === "__ref__") {
        self.addExternalDefinition();
        return;
      }
      var propertyType = $scope.propertyTypes[type];
      if(propertyType && $scope.parameter.in !== "body") {
        delete $scope.parameter.schema;
        $scope.parameter.type = propertyType.type;
        if(propertyType.format) {
          $scope.parameter.format = propertyType.format;
        } else {
          delete $scope.parameter.format;
        }
        if(propertyType.items) {
          $scope.parameter.items = propertyType.items;
        } else {
          delete $scope.parameter.items;
        }
      } else {
        delete $scope.parameter.type;
        delete $scope.parameter.format;
        delete $scope.parameter.items;
        propertyType = $scope.allTypes[type];
        var schemaObj = {};
        if (!propertyType) {
          // we'll assume this is an external ref...
            schemaObj.$ref = type;
        } else if (propertyType.$ref) {
          schemaObj.$ref = propertyType.$ref;
        } else {
          if (propertyType.type) schemaObj.type = propertyType.type;
          if (propertyType.format) schemaObj.format = propertyType.format;
          if(propertyType.items) schemaObj.items = propertyType.items;
        }
        $scope.parameter.schema = schemaObj;
      }
    } else {
      // Getter
      if($scope.parameter && $scope.parameter.schema && $scope.parameter.schema.$ref) {
        // tweak so the getter is comparing the name not the $ref value
        // for the selected attribute on the dropdown
        if ($scope.parameter.schema.$ref.indexOf('#/definitions/') === 0){
          return $scope.parameter.schema.$ref.slice(14);
        }
        return $scope.parameter.schema.$ref;
      }
      // if($scope.parameter && $scope.parameter.$ref) {
        //  var index = $scope.parameter.$ref.lastIndexOf('/');
        //  var name = $scope.parameter.$ref.substring(index+1);
        //  return name;
        // }
      if(!$scope.parameter || (!$scope.parameter.type && !($scope.parameter.schema && $scope.parameter.schema.type))) {
        return 'object';
      }

      var typeObj = $scope.parameter.schema || $scope.parameter;
      var returnType = self.getTypeValue(typeObj);
      if(returnType == "integer" && typeObj.format == null) {
        returnType = "integer-int32";
      } else if(returnType == "number" && typeObj.format == null) {
        returnType = "number-float";
      }
      return returnType;
    }
  };

}

angular.module('apim.apis').controller('OperationController', ['$scope', '$mdDialog', '$modal', '$filter', 'ComponentRegistry', 'DirtyService', OperationController]);

function OperationController($scope, $mdDialog, $modal, $filter, ComponentRegistry, DirtyService) {

  var isKnownFormat = function(format) {
    if(!format) return false;
    switch(format) {
      case "byte":
      case "binary":
      case "date":
      case "date-time":
      case "password":
        return true;
    }
    return false;
  };

  var self = this;

  // what level of the document am I at?
    if ($scope.operation) {
      $scope.parametersContainer = $scope.operation;
      self.documentScope = "operation";
    } else {
      $scope.parametersContainer = $scope.path;
      self.documentScope = "path";
    }

  self.addExternalParameter = function($event) {
    return $mdDialog.show({
      controller: 'ComponentReferenceDialogController',
      templateUrl: "apim/components/partials/choose-component-reference.html",
      parent: angular.element(document.body),
      targetEvent: $event,
      locals: {
        currentReference: null,
        references: $scope.componentReferences.parameters,
        components: $scope.components
      },
      focusOnOpen: false
    }).then(function(reference) {
      if (!$scope.parametersContainer.parameters) $scope.parametersContainer.parameters = [];
      $scope.parametersContainer.parameters.push({$ref: reference});
      self.populateParameterArray();
    }, function() {
    });
  };


  $scope.referenceToLink = function(ref) {
    if ($scope.features.components) {
      return ComponentRegistry.referenceToLink(ref);
    } else {
      return "";
    }
  };



  if ($scope.features.components) {
    self.populateParameterArray = function() {
      var parameters = [];
      var originalParameters = [];
      // make sure all parameters are de-reffed
      if ($scope.parametersContainer.parameters) {
        $scope.parametersContainer.parameters.forEach(function(param) {
          originalParameters.push(param);
          var thisParam;
          if (!param.$ref) {
            parameters.push(param);
          } else {
            // we have a reference
            var resolved = ComponentRegistry.getReference(param.$ref, 'parameters');
            if (resolved) {
              resolved = angular.copy(resolved);
              resolved.$ref = param.$ref;
              parameters.push(resolved);
            } else {
              resolved = angular.copy($scope.documentReferences[param.$ref]);
              if (!resolved) {
                // last chance - try refreshing the document references
                $scope.getDocumentReferences().then(function() {
                  resolved = angular.copy($scope.documentReferences[param.$ref]);
                  if (!resolved) {
                    console.warn("Missing reference: " + param.$ref);
                  } else {
                    resolved.$ref = param.$ref;
                    parameters.push(resolved);
                  }
                });
              } else {
                resolved.$ref = param.$ref;
                parameters.push(resolved);
              }
            }
          }
        });
      }
      self.originalParameters = originalParameters;
      self.parameters = parameters;
    };
  } else {
    self.populateParameterArray = function() {
      var parameters = [];
      // make sure all parameters are de-reffed
      if ($scope.parametersContainer.parameters) {
        $scope.parametersContainer.parameters.forEach(function(param) {
          if (!param.$ref) parameters.push(param);
          if (param.$ref && param.$ref.startsWith("#/parameters/")) {
            var ref = param.$ref.replace("#/parameters/", "");
            if ($scope.swaggerDocument.parameters && $scope.swaggerDocument.parameters[ref]) {
              var thisParam = angular.copy($scope.swaggerDocument.parameters[ref]);
              thisParam.$$ref = param.$ref;
              parameters.push(thisParam);
            }
          }
        });
      }
      self.parameters = parameters;
    };
  }

  self.populateParameterArray();

  $scope.parameterReferenceChanged = function($ref, $index) {
    if ($ref) {
      self.originalParameters[$index].$ref = $ref;
    } else {
      delete self.originalParameters[$index].$ref;
    }
    self.populateParameterArray();
  };

  self.addParameter = function() {
    if(!$scope.parametersContainer.parameters) $scope.parametersContainer.parameters = [];
    // Generate name
    var testNameBase = $filter('translate')("api_parameter").toLowerCase().replace(/\W/g, '-');
    var foundUnusedName = false;
    var nameSuffix = 1;
    while(!foundUnusedName) {
      foundUnusedName = true;
      var testName = testNameBase + "-" + nameSuffix;
      for(var i = 0; i < self.parameters.length; i++) {
        if(self.parameters[i].name == testName) {
          nameSuffix++;
          foundUnusedName = false;
          break;
        }
      }
    }
    var newParameterName = testNameBase + "-" + nameSuffix;

    var newParameter = {
      name: newParameterName,
      type: 'string',
      required: false,
      "in": 'query'
    };

    $scope.parametersContainer.parameters.push(newParameter);
    self.populateParameterArray();
  };

  self.hasParameter = function(parameter) {
    var filtered = self.parameters.filter(function(thisParameter) {
      return (thisParameter.name == parameter.name);
    });
    return filtered.length > 0;
  };

  self.referenceParameter = function(parameterName, parameterRef, parameter) {
    if (!$scope.parametersContainer.parameters) $scope.parametersContainer.parameters = [];
    if (!self.hasParameter(parameter)) {
      $scope.parametersContainer.parameters.push({
        $ref: parameterRef
      });
      self.populateParameterArray();
    }
  };

  self.deleteProperty = function(parameter) {
    $scope.confirmation = {
      titleKey: 'api_parameter_delete_title',
      messageKey: 'path_parameter_delete_message',
      confirmed: function() {
        $scope.parametersContainer.parameters = $scope.parametersContainer.parameters.filter(function(thisParameter) {
          if (thisParameter.$ref && thisParameter.$ref == parameter.$ref) return false;
          if (thisParameter.$ref && thisParameter.$ref == parameter.$$ref) return false;
          if (thisParameter.name && thisParameter.name == parameter.name) return false;
          return true;
        });
        if ($scope.parametersContainer.parameters.length == 0) delete $scope.parametersContainer.parameters;
        self.populateParameterArray();
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };

  $scope.getTypeValue = function(type) {
    if(!type || !type.type) return type;
    if(type.type == "string") {
      return type.type + (type.format && isKnownFormat(type.format) ? "-" + type.format : '');
    }
    return type.type + (type.format ? "-" + type.format : '');
  };

  $scope.responses = [];
  for (var response in $scope.operation.responses) {
    var transformedDefn =  $scope.operation.responses[response];
    transformedDefn['$$key'] = response;
    $scope.responses.push(transformedDefn);
  }

  $scope.$watch("operation", function(newDefn, oldDefn) {
    if (newDefn === oldDefn) return;

    if (oldDefn['$$key'] == newDefn['$$key']) {
      $scope.path[newDefn['$$key']] = newDefn;
    } else {
      delete $scope.path[oldDefn['$$key']];
      $scope.path[newDefn['$$key']] = newDefn;
    }
  }, true);

  $scope.$watch("operation.operationId", function(newValue, oldValue) {
    if (newValue === oldValue) return;

    // ensure the assembly model is up to date
    if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].assembly && $scope.swaggerDocument['x-ibm-configuration'].assembly.execute) {
      var matches = _.filter($scope.swaggerDocument['x-ibm-configuration'].assembly.execute, {'operation-switch': {'case': [{operations: [oldValue]}]}});
      matches.forEach(function(policy) {
        var caseMatches = _.filter(policy['operation-switch']['case'], {operations: [oldValue]});
        caseMatches.forEach(function(thisCase) {
          var operationMatches = _.filter(thisCase.operations, oldValue);
          for (var i = 0; i < thisCase.operations.length; i++) {
            if (typeof thisCase.operations[i] == "string" && thisCase.operations[i] == oldValue) {
              thisCase.operations[i] = newValue;
            }
          }
        });
      });
    }
    // end of assembly update
  });

  $scope.addParameter = function() {
    if(!$scope.operation.parameters) $scope.operation.parameters = [];
    // Generate name
    var testNameBase = $filter('translate')("api_parameter").toLowerCase().replace(/\W/g, '-');
    var foundUnusedName = false;
    var nameSuffix = 1;
    while(!foundUnusedName) {
      foundUnusedName = true;
      var testName = testNameBase + "-" + nameSuffix;
      for(var i=0; i<$scope.operation.parameters.length; i++) {
        if($scope.operation.parameters[i].name == testName) {
          nameSuffix++;
          foundUnusedName = false;
          break;
        }
      }
    }
    var newParameterName = testNameBase + "-" + nameSuffix;

    var newParameter = {
      name: newParameterName,
      type: 'string',
      required: false,
      "in": 'query'
    };

    $scope.operation.parameters.push(newParameter);
  };

  $scope.addResponse = function() {
    if(!$scope.operation.responses) $scope.operation.responses = {description: ''};
    // Generate name
    var newResponseCode = "2XX";
    if($scope.operation.responses[newResponseCode]) {
      var i = 1;
      while($scope.operation.responses[newResponseCode + "-" + i] != null) {
        i++;
      }
      newResponseCode = newResponseCode + "-" + i;
    }

    $scope.operation.responses[newResponseCode] = {description: ''};
    $scope.responses.unshift({'$$key': newResponseCode, description: ''});
  };

  $scope.removeTag = function(tag) {
    var index = $scope.operation.tags.indexOf(tag);
    if (index >= 0) {
      $scope.operation.tags.splice(index, 1);
    }
  };

  $scope.tag = {};
  $scope.addTag = function() {
    if ($scope.tag.newTag && (!$scope.operation.tags || $scope.operation.tags.indexOf($scope.tag.newTag) < 0)) {
      if(!$scope.operation.tags) $scope.operation.tags = [];
      $scope.operation.tags.push($scope.tag.newTag);
    }
    $scope.tag.newTag = "";
  };

  $scope.addTagCancelEvent = function($event) {
    $event.stopPropagation();
    $scope.addTag();
  };

  $scope.$inheritScheme = function(enabled) {
    if (arguments.length) {
      // Setter
      if(enabled) {
        delete $scope.operation.security;
      } else {
        $scope.operation.security = [{}];
      }
    } else {
      // Getter
      return $scope.operation.security == null;
    }
  };
}

angular.module('apim.apis').controller('OperationPropertyController', ['$scope', '$modal', OperationPropertyController]);

function OperationPropertyController($scope, $modal) {

  $scope.$propertyType = function(type) {
    if (arguments.length) {
      // Setter
      var propertyType = $scope.propertyTypes[type];
      if(propertyType) {
        delete $scope.parameter.schema;
        $scope.parameter.type = propertyType.type;
        if(propertyType.format) {
          $scope.parameter.format = propertyType.format;
        } else {
          delete $scope.parameter.format;
        }
        if(propertyType.items) {
          $scope.parameter.items = propertyType.items;
        } else {
          delete $scope.parameter.items;
        }
      } else {
        propertyType = $scope.allTypes[type];
        $scope.parameter.schema = {'$ref': propertyType.$ref};
        delete $scope.parameter.type;
        delete $scope.parameter.format;
      }
    } else {
      // Getter
      if($scope.parameter && $scope.parameter.schema && $scope.parameter.schema.$ref) {
        return $scope.parameter.schema.$ref;
      }
      if($scope.parameter && $scope.parameter.$ref) {
        return $scope.parameter.$ref;
      }
      if(!$scope.parameter || !$scope.parameter.type || $scope.parameter['in'] == 'body') {
        return 'object';
      }

      var returnType = $scope.getTypeValue($scope.parameter);
      if(returnType == "integer" && $scope.parameter.format == null) {
        returnType = "integer-int32";
      } else if(returnType == "number" && $scope.parameter.format == null) {
        returnType = "number-float";
      }
      return returnType;
    }
  };

  $scope.deleteProperty = function() {
    $scope.confirmation = {
      titleKey: 'api_parameter_delete_title',
      messageKey: 'api_parameter_delete_message',
      confirmed: function() {
        var parameters = $scope.swaggerDocument.paths[$scope.path['$$key']][$scope.operation['$$key']].parameters;
        if(parameters) {
          for(var i=0; i<parameters.length; i++) {
            if(parameters[i].name == $scope.parameter.name) {
              $scope.swaggerDocument.paths[$scope.path['$$key']][$scope.operation['$$key']].parameters.splice(i, 1);
              break;
            }
          }
        }
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
}

angular.module('apim.apis').controller('ResponseController', ['$scope', '$modal', '$mdDialog', ResponseController]);

function ResponseController($scope, $modal, $mdDialog) {

  var self = this;

  self.addExternalDefinition = function($event) {
    return $mdDialog.show({
      controller: 'ComponentReferenceDialogController',
      templateUrl: "apim/components/partials/choose-component-reference.html",
      parent: angular.element(document.body),
      targetEvent: $event,
      locals: {
        currentReference: null,
        references: $scope.componentReferences.definitions,
        components: $scope.components
      },
      focusOnOpen: false
    }).then(function(reference) {
      $scope.response.schema = {'$ref': reference};
    }, function() {
    });
  };

  $scope.$watch("response", function(newDefn, oldDefn) {
    if (newDefn === oldDefn) return;

    if (oldDefn['$$key'] == newDefn['$$key']) {
      $scope.operation.responses[newDefn['$$key']] = newDefn;
    } else {
      delete $scope.operation.responses[oldDefn['$$key']];
      $scope.operation.responses[newDefn['$$key']] = newDefn;
    }
  }, true);

  $scope.$watch("response.$$key", function(newDefn, oldDefn) {
    if (newDefn === oldDefn) return;
    delete $scope.operation.responses[oldDefn];
    $scope.operation.responses[newDefn] = $scope.response;

  });

  $scope.responseSchemaString = angular.toJson($scope.response.schema, true);

  $scope.$responseType = function(type) {
    if (arguments.length) {
      // Setter
      if (type === "__ref__") {
        self.addExternalDefinition();
        return;
      }
      var propertyType = $scope.propertyTypes[type];
      if(propertyType) {
        $scope.response.schema = {};
        $scope.response.schema.type = propertyType.type;
        if(propertyType.format) {
          $scope.response.schema.format = propertyType.format;
        }
      } else {
        $scope.response.schema = {'$ref': type};
      }
    } else {
      // Getter
      if($scope.response && $scope.response.schema && $scope.response.schema.$ref) {
        return $scope.response.schema.$ref;
      }
      if(!$scope.response || !$scope.response.schema || !$scope.response.schema.type || $scope.response.schema.type == 'object') {
        return 'object';
      }

      var returnType = $scope.getTypeValue($scope.response.schema);
      if(returnType == "integer" && $scope.response.schema.format == null) {
        returnType = "integer-int32";
      } else if(returnType == "number" && $scope.response.schema.format == null) {
        returnType = "number-float";
      }
      return returnType;
    }
  };
}

angular.module('apim.apis').controller('WebServiceController', ['$scope', '$modal', WebServiceController]);

function WebServiceController($scope, $modal) {

  $scope.addWebService = function($event, wsdlName) {
    $scope.wsdlDialogMode = "inline";
    $modal.open({
      templateUrl: 'apim/apis/partials/api-import-wsdl.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ApiImportWsdlController',
      size: 'md',
      scope: $scope
    });
  }

  $scope.addWebServiceAdditionalSchema = function($event, serviceName) {
    $scope.wsdlDialogMode = 'inline';
    $scope.serviceName = serviceName;

    $modal.open({
      templateUrl: 'apim/apis/partials/api-import-xsd.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ApiImportXSDController',
      size: 'md',
      scope: $scope
    });
  };


  $scope.addWsdlDocuments = function(services) {
    services.forEach(function(service) {
      var swagger = null;
      var swaggerString = service.swagger.replace(/#\/definitions/g, "#/x-ibm-configuration/targets/" + service.title + "/definitions");
      try {
        swagger = JSON.parse(swaggerString);
      } catch (e) {
        return;
      }
      if (!$scope.swaggerDocument['x-ibm-configuration'].targets) $scope.swaggerDocument['x-ibm-configuration'].targets = {};
      $scope.swaggerDocument['x-ibm-configuration'].targets[service.title] = swagger;
      // track if a large swagger file is opened
      $scope.checkIfLargeSwagger();
    });
  }

  $scope.getXSDDefinitionsCount = function(xsdDefinitions) {
    var count = 0;
    if (xsdDefinitions) {
      // Find all of the elements
      Object.keys(xsdDefinitions).forEach(function(defName) {
          count++;
      });
    }
    return count;
  }

  $scope.saveXSDDefinitions = function(xsdDefinitions) {
    if (xsdDefinitions) {
      var definitions = null;
      // The XSD definitions were built in the root definitions section, but we want to scope them
      // to the definitions of the specific service.  The string replace is necessary to fix all of the refs.
      var defString = JSON.stringify(xsdDefinitions).replace(/#\/definitions/g, "#/x-ibm-configuration/targets/" + $scope.serviceName + "/definitions");
      try {
        definitions = JSON.parse(defString);
        // Add or replace the swagger service-scoped definitions with the new definitions
        for (var defName in definitions) {
          if (definitions.hasOwnProperty(defName)) {
            $scope.swaggerDocument['x-ibm-configuration'].targets[$scope.serviceName].definitions[defName] =
            definitions[defName];
          }
        }
      } catch (e) {
        return;
      };
      // track if a large swagger file is opened
      $scope.checkIfLargeSwagger();
    }
  }

  $scope.removeWebService = function($event, wsdlName) {
    delete $scope.swaggerDocument['x-ibm-configuration'].targets[wsdlName];
    if (_.isEmpty($scope.swaggerDocument['x-ibm-configuration'].targets)) delete $scope.swaggerDocument['x-ibm-configuration'].targets;
  }

}

angular.module('apim.apis').controller('ContentTypeController', ['$scope', ContentTypeController]);

function ContentTypeController($scope) {

  var contentTypeContainer;
  var releaseWatch = $scope.$watchCollection('swaggerDocument', function() {
    // $ctrl is a component controller from ApiPathOperationComponent.js
    if (!$scope.swaggerDocument && !$scope.$ctrl) return;
    releaseWatch();

    if ($scope.$ctrl && $scope.$ctrl.operation) {
      contentTypeContainer = $scope.$ctrl.operation;
    } else {
      contentTypeContainer = $scope.swaggerDocument;
    }

    if (contentTypeContainer.consumes) {
      $scope.additionalTypesConsumed = [];
      for (var i = 0; i < contentTypeContainer.consumes.length; i++) {
        var consumesType = contentTypeContainer.consumes[i];
        if (consumesType !== "application/json" && consumesType !== "application/xml") {
          $scope.additionalTypesConsumed.push(consumesType);
        }
      }
    }
    if (contentTypeContainer.produces) {
      $scope.additionalTypesProduced = [];
      for (var j = 0; j < contentTypeContainer.produces.length; j++) {
        var producesType = contentTypeContainer.produces[j];
        if (producesType !== "application/json" && producesType !== "application/xml") {
          $scope.additionalTypesProduced.push(producesType);
        }
      }
    }
  });

  function inherit(enabled, property) {
    if (contentTypeContainer === undefined) return;
    if (typeof enabled !== "undefined") {
      // Setter
      if (enabled) {
        delete contentTypeContainer[property];
      } else {
        contentTypeContainer[property] = [];
      }
    } else {
      // Getter
      return !contentTypeContainer[property];
    }
  };

  function hasType(enabled, type, property) {
    if (contentTypeContainer == undefined) return;
    if (typeof enabled !== "undefined") {
      // Setter
      if (enabled) {
        if (!contentTypeContainer[property]) contentTypeContainer[property] = [];
        if (contentTypeContainer[property].indexOf(type) < 0) {
          contentTypeContainer[property].unshift(type);
        }
      } else {
        if (contentTypeContainer[property]) {
          var index = contentTypeContainer[property].indexOf(type);
          if (index >= 0) {
            contentTypeContainer[property].splice(index, 1);
            if (contentTypeContainer[property].length == 0) delete contentTypeContainer[property];
          }
        }
      }
    } else {
      // Getter
      if (contentTypeContainer[property]) {
        return contentTypeContainer[property].indexOf(type) >= 0;
      }
      return false;
    }
  };

  function addType(property, value, container) {
    if (!$scope[property] || !value || value === "") return;
    if (!contentTypeContainer[property]) contentTypeContainer[property] = [];
    if (contentTypeContainer[property].indexOf(value) < 0) {
      contentTypeContainer[property].push(value);
    }
    if (container.indexOf(value) < 0) {
      container.push(value);
    }
  };

  function removeType(type, property, container) {
    if (contentTypeContainer[property]) {
      var index = contentTypeContainer[property].indexOf(type);
      contentTypeContainer[property].splice(index, 1);
      if(contentTypeContainer[property].length == 0) delete contentTypeContainer[property];
    }
    if (container) {
      container.splice(container.indexOf(type), 1);
    }
  }

  $scope.$inheritConsumes = function(enabled) {
    return inherit(enabled, 'consumes');
  };

  $scope.$consumeJson = function(enabled) {
    return hasType(enabled, 'application/json', 'consumes');
  };

  $scope.$consumeXml = function(enabled) {
    return hasType(enabled, 'application/xml', 'consumes');
  };

  $scope.consumes = {};

  $scope.addConsumesType = function() {
    if (!$scope.consumes.newConsumesType || $scope.consumes.newConsumesType == "") return;
    if (!$scope.additionalTypesConsumed) $scope.additionalTypesConsumed = [];
    addType('consumes', $scope.consumes.newConsumesType, $scope.additionalTypesConsumed);
    $scope.consumes.newConsumesType = "";
  };

  $scope.removeConsumesType = function(type) {
    removeType(type, 'consumes', $scope.additionalTypesConsumed);
  };

  $scope.$inheritProduces = function(enabled) {
    return inherit(enabled, 'produces');
  };

  $scope.$produceJson = function(enabled) {
    return hasType(enabled, 'application/json', 'produces');
  };

  $scope.$produceXml = function(enabled) {
    return hasType(enabled, 'application/xml', 'produces');
  };

  $scope.produces = {};

  $scope.addProducesType = function() {
    if (!$scope.produces.newProducesType || $scope.produces.newProducesType == "") return;
    if (!$scope.additionalTypesProduced) $scope.additionalTypesProduced = [];
    addType('produces', $scope.produces.newProducesType, $scope.additionalTypesProduced);
    $scope.produces.newProducesType = "";
  };

  $scope.removeProducesType = function(type) {
    removeType(type, 'produces', $scope.additionalTypesProduced);
  };

};

angular.module('apim.apis').controller('APICategoriesController', ['$scope', 'CommonUtils', APICategoriesController]);

function APICategoriesController($scope, CommonUtils) {
  $scope.$categories = function(value) {
    if (!$scope.swaggerDocument) return;
    if (typeof value !== "undefined") {
      // Setter
      var paths = value.split("\n");
      var len = paths.length;
      for (var i = 0; i < len; i++) {
        paths[i] = CommonUtils.stripOuterQuotes(paths[i]);
      } // end for
      $scope.swaggerDocument['x-ibm-configuration'].categories = paths;
    } else {
      // Getter
      var ret = "";
      $scope.swaggerDocument['x-ibm-configuration'] =
        $scope.swaggerDocument['x-ibm-configuration'] || {};
      var pathList = $scope.swaggerDocument['x-ibm-configuration'].categories;
      if (pathList) {
        ret = pathList.join("\n");
      }
      return ret;
    }
  };
};
