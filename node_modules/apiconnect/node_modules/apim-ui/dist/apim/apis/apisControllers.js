/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var apis = angular.module('apim.apis', ['ngResource', 'prettyXml']);

apis.controller('ApisController', ['$scope', '$rootScope', '$modal', '$state', '$http', 'Api', 'APITag', 'uniqueFilter', 'constructTagsFilter', apisController]);

function apisController($scope, $rootScope, $modal, $state, $http, Api, APITag, uniqueFilter, constructTagsFilter) {
  // pagination
  $scope.totalItems = 0;
  $scope.currentPage = 1;
  $scope.pageSize = 100;
  $scope.setMainTab("apis");	// make sure we initialise the correct menu

  $scope.pageChanged = function (pageNo) {
    $scope.refreshApis();
  };
  // end pagination

  // expand to full width by default
  $scope.panelExpanded = true;
  $scope.setPanelExpanded = function(expanded) {
    $scope.panelExpanded = expanded;
  };

  var initialQueryWatch = false;
  $scope.refreshApisForQuery = function(resetQuery) {
    if (!initialQueryWatch) {
      initialQueryWatch = true;
      return;
    }

    // reset search and refresh apis after deletion of an api
    if(resetQuery) {
      $scope.query = '';
      $scope.refreshApis();
    }

    // don't bpther refreshing APIs if we can do it on the glass
    if ($scope.firstTimeTotal <= $scope.pageSize) return;
    $scope.refreshApis();
  };
  $scope.refreshApis = function() {
    $scope.$watch('currentOrg', function() {
      if (!$scope.currentOrg || $scope.currentOrg.loading) return;
      $scope.xhrProcessing = true;
      var queryArgs = {
        orgId: $scope.orgId,
        page: $scope.currentPage,
        size: $scope.pageSize
      };
      if ($scope.query && $scope.query != "") queryArgs.filter = $scope.query;
      if ($scope.selectedTagsString && $scope.selectedTagsString != "") queryArgs['tags.name'] = $scope.selectedTagsString;
      $scope.apis = Api.query(queryArgs, function(data, headers) {
        $scope.xhrProcessing = false;
        var totalCount = headers('x-total-count');
        if (totalCount) {
          $scope.totalItems = totalCount * 1;
          if (!$scope.firstTimeTotal) $scope.firstTimeTotal = $scope.totalItems;
        }
      });
    });
  };
  $scope.selectAllTags = function(selected) {
    for (var tag in $scope.selectedTags) {
      if ($scope.selectedTags.hasOwnProperty(tag)) {
        $scope.selectedTags[tag] = selected;
      }
    }
    $scope.trackFiltering();
  };
  $scope.trackFiltering = function() {
    var selectedTags = "";
    var allSelected = true;
    if ($scope.selectedTags) {
      Object.keys($scope.selectedTags).forEach(function(tag) {
        if ($scope.selectedTags[tag]) {
          selectedTags += tag + ",";
        } else {
          allSelected = false;
        }
      });
    }
    $scope.filtered = !allSelected;
    if ($scope.firstTimeTotal <= $scope.pageSize) return;
    if (selectedTags.length > 0) selectedTags = selectedTags.substring(0, selectedTags.length - 1);
    if (allSelected && $scope.selectedTagsString != "") {
      $scope.selectedTagsString = "";
    } else {
      if ($scope.selectedTagsString != selectedTags) $scope.selectedTagsString = selectedTags;
    }
  };
  $scope.refreshTags = function() {
    if ($scope.isOffline()) {
      $scope.allTags = [];
      return
    }
    $scope.$watch('currentOrg', function() {
      if (!$scope.currentOrg || $scope.currentOrg.loading) return;
      $scope.allTags = APITag.query({
        orgId: $scope.orgId
      });
      $scope.allTags.$promise.then(function() {
        $scope.processTags();
      });
    });
  };
  $scope.processTags = function() {
    $scope.tags = constructTagsFilter($scope.allTags, false, "apiTag tinyTag fixedWidthTag", false);
    var selectedTags = {};
    $scope.tags.forEach(function(tag) {
      selectedTags[tag.value] = true;
    });
    $scope.selectedTags = selectedTags;
  };
  $scope.orderProp = 'info.title';
  $scope.query = '';
  $scope.typeFilterStates = {
    "REST": true,
    "SOAP": true,
    "OAUTH": true
  };
  $scope.$watch('query', function(){
    $scope.refreshApisForQuery();
  });
  $scope.$watch('selectedTagsString', $scope.refreshApis);
  $scope.refreshTags();
  $scope.createApi = function(oauth) {

    $scope.creatingOAuthProvider = false;
    $scope.apiTemplate = null;
    $scope.createDialogTitle = null;

    if (oauth) {
      $scope.creatingOAuthProvider = true;
      $scope.apiTemplate = 'oauth2';
      $scope.createDialogTitle = 'composeOauthAPILabel';
    }
    $modal.open({
      templateUrl: 'apim/apis/partials/create-api-with-product.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ApiCreateController',
      size: 'lg',
      scope: $scope
    }).result.then(function(api) {
        $state.go('api', {id: api.info['x-ibm-name'] + ":" + api.info.version});
    });
  };
  $scope.createWsdlApi = function() {
    $modal.open({
      templateUrl: 'apim/apis/partials/api-import-wsdl.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ApiImportWsdlController',
      size: 'lg',
      scope: $scope
    });
  };
  $scope.createSwaggerApi = function() {
    $modal.open({
      templateUrl: 'apim/apis/partials/api-import-swagger.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ApiImportSwaggerController',
      size: 'lg',
      scope: $scope
    });
  };
  $scope.openImportSampleAPIModal = function() {
    $modal.open({
      templateUrl: 'apim/apis/partials/api-import-sample.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ImportSampleAPIsController',
      size: 'md',
      scope: $scope
    });
  };

  $scope.importSampleAPI = function(url, username, password) {
    var proxyUrl = 'proxy/apimanager/orgs/' + $scope.orgId + '/apis';
    var headers = {
      "Content-Type": "application/vnd.ibm-apim.swagger2.remote+json"
    };
    if ($scope.isOffline()) {
      // content type must be JSON for offline - Express does not recognize our custom swagger type
      headers["Content-Type"] = "application/json";
    }

    var postData = {
      url: url,
      headers: {"Authorization": ["Basic " + btoa(username + ":" + password)]},
      readTimeout: 20000,
      connectTimeout: 20000
    };

    return $http({
      method: 'POST',
      url: proxyUrl,
      data: postData,
      headers: headers
    })
  };

  $scope.importWeatherAPI = function() {
    $scope.importingApi = true;
    var url = 'https://api.us-south.apiconnect.appdomain.cloud/developmentoperations-apiconnect/sb/subscription/' + $scope.orgId + '?action=create';
    var urlUsername = 'fa1e0248a14fcee1806dd93b82087359a64a885c';
    var urlPassword = '82af0797d62c90d5cadf1b692a6bb837854c822d';

    $scope.importSampleAPI(url, urlUsername, urlPassword)
      .then(function(response) {
        $state.go('api', {id: response.data.info['x-ibm-name'] + ":" + response.data.info.version});
        $rootScope.gsState.import = true;
        $rootScope.imagesrc.import = 'check_circle';
      })
      .finally(function() {
        $scope.importingApi = false;
      });
  };

  // need to attach a transition listener to handle slide effect properly
  var mainColumn = angular.element(document.getElementsByClassName("majorColumnLeft"));
  if (mainColumn) {
    mainColumn.on("transitionend", function() {
      var container = mainColumn.parent();
      var parentContainer = container.parent();
      if (container.hasClass("expanded")) {
        parentContainer.addClass("slideOverflow");
      } else {
        parentContainer.removeClass("slideOverflow");
      }
    });
  }

  if($scope.helpEnabled) $scope.showHelp({id: "apim_help_draft_apis", template: 'apim/help/partials/help-draft-apis.html'});
}

angular.module('apim').controller('ImportSampleAPIsController', ['$scope','$rootScope', '$http', '$modalInstance', '$state', '$timeout', '$translate', 'TrackingServices', importSampleAPIsController]);

function importSampleAPIsController($scope,$rootScope, $http, $modalInstance, $state, $timeout, $translate, TrackingServices) {
  /*
    * TODO there needs to be a unique identifier for the samples instead of "id" in the
    * hardcoded sample below.  Possibly x-ibm-name?
    */
    $scope.sampleAPIs = [
      {"id":"1",
        "title": $translate.instant('importSampleApiTitle'),
        "version":"1.0.0",
        "description": $translate.instant('importSampleApiDesc')}
    ];

  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };

  $scope.import = function() {
    $scope.importingApi = true;
    var url = 'https://api.us.apiconnect.ibmcloud.com/developmentoperations-apiconnect/sb/subscription/' + $scope.orgId + '?action=create';
    var urlUsername = 'fa1e0248a14fcee1806dd93b82087359a64a885c';
    var urlPassword = '82af0797d62c90d5cadf1b692a6bb837854c822d';

    $scope.importSampleAPI(url, urlUsername, urlPassword)
      .then(function(response) {
        $scope.importingApi = false;
        $modalInstance.dismiss('ok');
        TrackingServices.track('api', 'importSampleApi');
        $state.go('api', {id: response.data.info['x-ibm-name'] + ":" + response.data.info.version});
        $rootScope.gsState.import = true;
        $rootScope.imagesrc.import = 'check_circle';
      });

    $timeout(function() {
      angular.element(document.getElementById('generatetooltip')).triggerHandler('showGenerateEvent');
    }, 500);
  };

  $scope.idSelectedSample = $scope.sampleAPIs[0].id;
  $scope.setSelected = function(id){
    $scope.idSelectedSample === id ? $scope.idSelectedSample = null : $scope.idSelectedSample = id;
  }
}

angular.module('apim').controller('ApiImportSwaggerController', ['$scope', '$controller', '$modalInstance','$state', '$q', '$filter', '$http', 'uiUploader', 'Product', 'errorHandler', 'TrackingServices', ApiImportSwaggerController]);

function ApiImportSwaggerController($scope, $controller, $modalInstance, $state, $q, $filter, $http, uiUploader, Product, errorHandler, TrackingServices) {

  $scope.currentPage = 1;
  $scope.pageCount = 2;
  $scope.addToProductType = "new";
  $scope.data = {};

  $scope.createNewProduct = false;

  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };

  // put the created APIs in a new product
  $scope.createProduct = function(api, filename) {
    var apiRefs = {};
    apiRefs[api.info['x-ibm-name']] = (filename) ? filename : api.info['x-ibm-name'] + ":" + api.info.version;
    var result;
    if ($scope.addToProductType === "new") {
      result = $scope.createAndAppendToProduct(apiRefs, $scope.newProduct);
    } else if ($scope.addToProductType === "existing") {
      result = $scope.appendToProduct(apiRefs, Object.keys($scope.selectedRefs));
    } else {
      result = $q.resolve();
    }
    return result;
  };

  $scope['import'] = function() {
    $scope.importingApi = true;
    var url = 'proxy/apimanager/orgs/' + $scope.orgId + '/apis';
    if(!$scope.fromUrl) {
      // make sure any previous upload file list is cleared
      uiUploader.removeAll();
      $scope.markFilesInactive($scope.swaggerFiles);
      uiUploader.addFiles($scope.swaggerFiles);
      uiUploader.startUpload({
        url: url,
        onProgress: function(file) {

        },
        onCompleted: function(file, response) {
          $scope.importingApi = false;
          $modalInstance.dismiss('ok');
          var responseObject = response;
          if (typeof response == "string") {
            responseObject = JSON.parse(response);
          }
          responseObject.data = responseObject.responseText;
          responseObject.config = {url: url};
          errorHandler.checkResponse(responseObject);
          if(!responseObject.errors) {
            if ($scope.createNewProduct && ($scope.addToProductType === "new" || $scope.addToProductType === "existing")) {
              if ($scope.offlineMode) {
                var apiRef = responseObject.info['x-ibm-name'] + ":" + responseObject.info.version;
                $http.get("proxy/orgs/localhost/filenames/" + apiRef).then(function(response) {
                  $scope.createProduct(responseObject, response.filename).then(function() {
                    var itemName = responseObject.info['x-ibm-name'] ? responseObject.info['x-ibm-name'] : responseObject.info.title;
                    $state.go('api', {id: itemName + ":" + responseObject.info.version});
                  });
                });
              } else {
                $scope.createProduct(responseObject).then(function() {
                  var itemName = responseObject.info['x-ibm-name'] ? responseObject.info['x-ibm-name'] : responseObject.info.title;
                  $state.go('api', {id: itemName + ":" + responseObject.info.version});
                });
              }
            } else {
              var itemName = responseObject.info['x-ibm-name'] ? responseObject.info['x-ibm-name'] : responseObject.info.title;
              $state.go('api', {id: itemName + ":" + responseObject.info.version});
            }
          }
        },
        onCompletedAll: function() {
          TrackingServices.track('api', 'importFromYamlFile');
        }
      });
    } else {
      var headers = {
        "Content-Type": "application/vnd.ibm-apim.swagger2.remote+json"
      };
      if ($scope.isOffline()) {
        // content type must be JSON for offline - Express does not recognize our custom swagger type
        headers["Content-Type"] = "application/json";
      }
      var postData = {
        url: $scope.data.importUrl
      };
      // add credentials if supplied
      if ($scope.urlUsername && $scope.urlPassword) {
        // note: the value of "authorization" really is an array!!
        postData.headers = {"Authorization": ["Basic " + btoa($scope.urlUsername + ":" + $scope.urlPassword)]};
      }
      $http({
        method: 'POST',
        url: url,
        data: postData,
        headers: headers
      }).then(function(response) {
        var responseObject = response.data;
        TrackingServices.track('api', 'importFromYamlUrl');
        $scope.importingApi = false;

        if ($scope.createNewProduct && ($scope.addToProductType === "new" || $scope.addToProductType === "existing")) {
          if ($scope.offlineMode) {
            var apiRef = responseObject.info['x-ibm-name'] + ":" + responseObject.info.version;
            $http.get("proxy/orgs/localhost/filenames/" + apiRef).then(function(response) {
              $scope.createProduct(responseObject, response.filename).then(function() {
                $modalInstance.dismiss('ok');
                var itemName = responseObject.info['x-ibm-name'] ? responseObject.info['x-ibm-name'] : responseObject.info.title;
                $state.go('api', {id: itemName + ":" + responseObject.info.version});
              });
            });
          } else {
            $scope.createProduct(responseObject).then(function() {
              $modalInstance.dismiss('ok');
              var itemName = responseObject.info['x-ibm-name'] ? responseObject.info['x-ibm-name'] : responseObject.info.title;
              $state.go('api', {id: itemName + ":" + responseObject.info.version});
            });
          }
        } else {
          $modalInstance.dismiss('ok');
          var itemName = responseObject.info['x-ibm-name'] ? responseObject.info['x-ibm-name'] : responseObject.info.title;
          $state.go('api', {id: itemName + ":" + responseObject.info.version});
        }
      }, function(response) {
        $scope.importingApi = false;
      });
    }
  };

  $controller('ApiProductBuilderController', {$scope: $scope});
};

angular.module('apim').controller('ApiImportWsdlController', ['$scope', '$controller', '$modalInstance', '$filter', '$http', '$modal', '$state', '$q', 'uiUploader', 'errorHandler', 'Product', 'TrackingServices', ApiImportWsdlController]);

function ApiImportWsdlController($scope, $controller, $modalInstance, $filter, $http, $modal, $state, $q, uiUploader, errorHandler, Product, TrackingServices) {
  $scope.currentPage = 1;
  $scope.data = {
    wsdlChosen: false,
    wsdlFiles: [],
    wsdl: {
      url: "",
      id: "",
      services: []
    },
    url: {
      url: "",
      username: "",
      password: ""
    },
    api: {
      createProduct: false,
      productName: ""
    },
    discover: {
      name: "",
      type: "wsrr",
      protocol: "https",
      hostname: "",
      port: "",
      contextRoot: "",
      username: "",
      password: "",
      queryString: ""
    }
  };

  $scope.newApi = $scope.data.api;

  $scope.registryTypes = [];
  $scope.registryTypesLookup = {};
  $scope.protocolTypes = [
    {name: $filter('translate')('importProtocolSecure'), value: "https"},
    {name: $filter('translate')('importProtocolInsecure'), value: "http"}
  ];
  $scope.registryList = [];
  $scope.registryListLookup = {};
  $scope.selectedServices = {};
  $scope.revealOperations = {};
  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };

  var normalizeServiceIds = function(services) {
    // add a serviceId field to make consistent with discovered services
    return services.map(function(svc) {
      svc.serviceId = svc.service;
      if (svc.filename) {
        svc.serviceId += '```' + svc.filename;
      }
      return svc;
    });
  };

  var handleWsdlUrlResponse = function(response) {
    // store response data for later use
    $scope.data.wsdl.url = response.wsdlUrl;

    return $q.resolve(normalizeServiceIds(response.services));
  };

  var handleWsdlFileResponse = function(response, uploadUrl) {
    // store response data for later use
    $scope.data.wsdl.url = response.url;
    $scope.data.wsdl.id = response.wsdlId;

    // Generate service URL for uploaded file
    var serviceUrl = uploadUrl + '?wsdlId=' + response.wsdlId;
    if ($scope.wsdlDialogMode == 'inline') {
      serviceUrl += '&preview=true';
    }

    return $http.get(serviceUrl)
      .then(function (response) {
        return normalizeServiceIds(response.data.services);
      });
  };

  var handleWsdlResponse = function(response, uploadUrl) {
    var responseObject = response;
    var services = null;

    if (typeof response == 'string') {
      responseObject = JSON.parse(response);
    }

    if (responseObject.errors) {
      return $q.reject(responseObject);
    }

    if (responseObject.wsdlUrl) {
      services = handleWsdlUrlResponse(responseObject);
    } else if (responseObject.wsdlId) {
      services = handleWsdlFileResponse(responseObject, uploadUrl);
    }

    if (services) {
      return services.then(function(services) {
        $scope.data.wsdl.services = services;
      });
    } else {
      // catch all in the case of a wonky WSDL file
      return $q.reject({
        errors: [
          $filter('translate')('errorWsdlMissingUrlOrId')
        ]
      });
    }
  };

  // perform initial WSDL upload
  $scope.import = function() {
    $scope.importingApi = true;
    // reset any previous services
    $scope.data.wsdl.services = [];
    $scope.selectedServices = {};
    $scope.revealOperations = {};
    // Upload WSDL
    var url = 'proxy/orgs/' + $scope.orgId + '/apis';
    var wsdlUrl = url + '/wsdl';
    var uploadUrl = wsdlUrl;
    if ($scope.wsdlDialogMode == "inline") uploadUrl += "?preview=true";

    if (!$scope.fromUrl) {
      // make sure any previous upload file list is cleared
      uiUploader.removeAll();
      $scope.markFilesInactive($scope.data.wsdlFiles);
      uiUploader.addFiles($scope.data.wsdlFiles);
      uiUploader.startUpload({
        url: uploadUrl,
        onCompleted: function(file, response) {
          handleWsdlResponse(response, wsdlUrl)
            .then(function() {
              $scope.importingApi = false;
            }).catch(function(error) {
              errorHandler.checkResponse(error);
              $scope.importingApi = false;
              $scope.cancel();
            });
        }
      });
    } else {
      var postData = {
        wsdlUrl: $scope.data.url.url
      };
      // add credentials if supplied
      if ($scope.data.url.username && $scope.data.url.password) {
        postData.basicAuth = "Basic " + btoa($scope.data.url.username + ":" + $scope.data.url.password);
      }
      $http.post(wsdlUrl, postData).then(
        function(response) {
          // TODO(jtary) To avoid issues with publishing, the WSDL URL import saves
          //             the file locally and triggers the file based import.
            //             This should be fixed properly, but will require a complete
          //             rework of the WSDL import backend.
            $scope.fromUrl = false;
          handleWsdlResponse(response.data, wsdlUrl)
            .then(function() {
              $scope.fromUrl = true;
              $scope.importingApi = false;
            }, function(response) {
              errorHandler.checkResponse(response);
              $scope.importingApi = false;
            })
        },
        function(error) {
          $scope.importingApi = false;
          $scope.currentPage = 2;
        }
      );
    }
  };
  // save the API with the given options
  $scope.save = function() {
    var url = 'proxy/orgs/' + $scope.orgId + '/apis?mode=swagger';
    if ($scope.wsdlDialogMode == "inline") url += "&preview=true";
    // work out which services to send based on what was selected
    var services = [];
    var len = $scope.data.wsdl.services.length;
    for (var i=0;i<len;i++) {
      var service = $scope.data.wsdl.services[i];
      if ($scope.selectedServices[service.serviceId]) {
        if (!service.service) {
          // dsicovered services need to store slitghtly differently
          services.push({
            service: service.name,
            serviceId: service.serviceId
          });
        } else {
          services.push(service);
        }
      }
    } // end for
    var postData = {
      name: "SOAP",
      context: "SOAP",
      protocol: "SOAP",
      soapApiDefinition: {
        wsdlUrl: $scope.data.wsdl.url,
        wsdlId: $scope.data.wsdl.id,
        services: services
      }
    };
    if ($scope.currentRegistry) {
      postData.soapApiDefinition.registryId = $scope.currentRegistry;
    }
    if ($scope.fromUrl) {
      postData.soapApiDefinition.username = $scope.data.url.username;
      postData.soapApiDefinition.password = $scope.data.url.password;
    }
    // Create API
    $scope.savingAPI = true;
    $http.post(url, postData).then(
      function(response) {
        TrackingServices.track('api', 'createFromWsdl', { productType: $scope.addToProductType });
        // if inline mode
        $scope.savingAPI = false;
        if ($scope.wsdlDialogMode == "inline") {
          $scope.addWsdlDocuments(response.data);
          $modalInstance.dismiss('ok');
        } else {
          if ($scope.currentPage === 4 && ($scope.addToProductType === "new" || $scope.addToProductType === "existing")) {
            $scope.createProduct(response.data, response.headers).then(function() {
              $modalInstance.dismiss('ok');
              $state.go('api', {id: response.data[0].name + ":" + response.data[0].version});
            });
          } else {
            $modalInstance.dismiss('ok');
            $state.go('api', {id: response.data[0].name + ":" + response.data[0].version});
          }
        }
      },
      function(error) {
        $scope.savingAPI = false;
      }
    );
  };
  // put the created APIs in a new product
  $scope.createProduct = function(apis, responseHeaders) {
    var apiRefs = {};
    // add each API we created to the product
    var swaggerFilename = responseHeaders("X-IBM-Swagger-File");	// yes, it's a function call
    var apiId = responseHeaders("is");	// yes, it's a function call
    for (var i = 0; i < apis.length; i++) {
      var api = apis[i];
      if (swaggerFilename) {
        apiRefs[api.name] = swaggerFilename;
      } else if (apiId) {
        apiRefs[api.name] = apiId;
      } else {
        apiRefs[api.name] = api.name + ":" + api.version;
      }
    }
    var result;
    if ($scope.addToProductType === "new") {
      result = $scope.createAndAppendToProduct(apiRefs, $scope.newProduct);
    } else if ($scope.addToProductType === "existing") {
      result = $scope.appendToProduct(apiRefs, Object.keys($scope.selectedRefs));
    } else {
      result = $q.resolve();
    }
    return result;
  };
  // append the created APIs in an existing product
  $scope.appendWsdlAPIToProduct = function(apis, responseHeaders) {
    var apiRefs = {};
    // add each API we created to the product
    var swaggerFilename = responseHeaders("X-IBM-Swagger-File");	// yes, it's a function call
    for (var i = 0; i < apis.length; i++) {
      var api = apis[i];
      if (swaggerFilename) {
        apiRefs[api.name] = {
          "$ref": swaggerFilename
        };
      } else {
        apiRefs[api.name] = {
          "$ref": api.id
        };
      }
    }
    return $scope.createAndAppendToProduct(apiRefs, $scope.newProduct);
  };
  // handle the move to the next page
  $scope.doNext = function() {
    if ($scope.fromUrl && $scope.currentPage == 2) {
      // moving from URL input page to service results page
      $scope.currentPage = 3;
      // now run the actual import
      $scope.import();
    } else if ($scope.fromDiscover && $scope.currentPage == 2) {
      // moving from discover page to service results page
      $scope.savingAPI = true;
      $scope.testConnection().then(function(response) {
        if (response.data.RESULT == "SUCCESS") {
          if ($scope.createNewRegistry) {
            $scope.createRegistry().then(function(resp) {
              $scope.currentRegistry = resp.data.payload.uuid;
              // update lookup table
              $scope.registryListLookup[resp.data.payload.uuid] = resp.data.payload;
              resp.data.payload.type = $scope.data.discover.type;
              // discover the services on the given registry and move on in the wizard
              $scope.data.wsdl.services = [];
              $scope.runRegistryQuery();
              $scope.currentPage = 3;
              $scope.savingAPI = false;
            }, function(err) {
              // user will have already seen error box
              $scope.savingAPI = false;
            });
          } else {
            $scope.savingAPI = false;
          }
        } else {
          // input data wasn't good show error to user
          $scope.information = {
            titleKey: 'importTestConnectionError',
            message: response.data.messages[0].message,
            accepted: function() {
            }
          };
          $modal.open({
            templateUrl: 'apim/partials/information.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'InformationController',
            scope: $scope
          });
          $scope.savingAPI = false;
        }
      }, function(error) {
        // do nothing - user will see error box and page switch will be vetoed
        $scope.savingAPI = false;
      });
    } else {
      // default action is move to next page
      $scope.currentPage += 1;
    }
  };
  // handle the move to the previous page
  $scope.doPrevious = function() {
    if ($scope.fileMode && $scope.currentPage == 3) {
      $scope.currentPage = 1;
      $scope.fileMode = false;
    } else if ($scope.currentRegistry && $scope.currentPage == 3) {
      // directly selected registries need to go back to initial page
      $scope.currentPage = 1;
    } else {
      // default action is move to previous page
      $scope.currentPage -= 1;
    }
    // refresh registry list when we go back to page 1
    if ($scope.currentPage == 1) {
      $scope.refreshRegistries();
    }
  };
  $scope.isServiceSelected = function() {
    var ret = false;
    for (var key in $scope.selectedServices) {
      var service = $scope.selectedServices[key];
      if (service) {
        ret = true;
        break;
      }
    } // end for
    return (ret);
  };
  $scope.validatePort = function(value) {
    var ret = false;
    var num = parseInt(value);
    if (num >= 1 && num <= 65535) {
      ret = true;
    }
    return (ret);
  };
  $scope.selectedRegistry = function(registryId) {
    if (registryId) {
      // use existing registry - jump straight to service list
      $scope.fromDiscover = true;
      $scope.fromUrl = false;
      $scope.currentRegistry = registryId;
      // discover the services on the given registry and move on in the wizard
      $scope.data.wsdl.services = [];
      $scope.runRegistryQuery();
      $scope.currentPage = 3;
    } else {
      // define a new registry
      $scope.currentRegistry = "";
      $scope.createNewRegistry = true;
      $scope.getRegistryTypes();
    }
  };
  $scope.selectedWSDL = function(wsdl) {
    $scope.selectedWsdl = wsdl;
    $scope.currentPage = 5;
  };
  $scope.selectedDefinition = function(definition) {
    $scope.userSelectedDefinition = definition;
    $scope.currentPage = 5;
  };
  $scope.setDefinition = function() {
    $modalInstance.close({
      definition: $scope.userSelectedDefinition,
      wsdl: $scope.selectedWsdl
    });
  };
  // get the information needed to populate the type drop-down and for later REST calls
  $scope.getRegistryTypes = function() {
    $scope.savingAPI = true;
    var url = 'proxy/orgs/' + $scope.orgId + '/registryDiscovery/types';
    $http.get(url).then(function(response) {
      var len = response.data.items.length;
      for (var i=0;i<len;i++) {
        var item = response.data.items[i];
        var registry = {
          connectionData: item.connectionData,
          endpointType: item.endpointType,
          test: item.test
        };
        if (item.endpointType.indexOf('/WSRR') != -1) {
          registry.name = $filter('translate')('importWSRRProductName');
          registry.value = "wsrr";
          $scope.registryTypesLookup["wsrr"] = registry;
        } else {
          registry.name = $filter('translate')('importCustomRegistry');
          registry.value = "custom";
          $scope.registryTypesLookup["custom"] = registry;
        }
        $scope.registryTypes.push(registry);
      } // end for
      // move to registry definition page
      $scope.savingAPI = false;
      $scope.fromDiscover = true;
      $scope.fromUrl = false;
      $scope.currentPage = 2;
    }, function(error) {
      // do nothing on error - user will have already seen error box
      // page switch in wizard is effectively vetoed
      $scope.savingAPI = false;
    });
  };
  // test connection to registry given current input data and return the promise
  $scope.testConnection = function() {
    var url = $scope.registryTypesLookup[$scope.data.discover.type].test;
    var postData = {
      name: $scope.data.discover.name,
      type: $scope.registryTypesLookup[$scope.data.discover.type].connectionData,
      protocol: $scope.data.discover.protocol,
      hostname: $scope.data.discover.hostname,
      port: $scope.data.discover.port,
      instancePrefix: $scope.data.discover.contextRoot,
      username: $scope.data.discover.username,
      password: $scope.data.discover.password
    };
    var promise = $http.post(url, postData);
    return (promise);
  };
  // create a new registry connection definition
  $scope.createRegistry = function() {
    var url = $scope.registryTypesLookup[$scope.data.discover.type].connectionData;
    var postData = {
      name: $scope.data.discover.name,
      type: $scope.registryTypesLookup[$scope.data.discover.type].connectionData,
      protocol: $scope.data.discover.protocol,
      hostname: $scope.data.discover.hostname,
      port: $scope.data.discover.port,
      instancePrefix: $scope.data.discover.contextRoot,
      username: $scope.data.discover.username,
      password: $scope.data.discover.password
    };
    var promise = $http.post(url, postData);
    return (promise);
  };
  // delete a registry connection definition
  $scope.deleteRegistry = function(registry) {
    $scope.confirmation = {
      titleKey: 'importConfirmDeleteRegistryTitle',
      messageKey: 'importConfirmDeleteRegistry',
      confirmed: function() {
        $scope.deletingRegistry = true;
        $http["delete"](registry.uri).then(function(response) {
          $scope.deletingRegistry = false;
          $scope.refreshRegistries();
        }, function(error) {
          // user will see standard error box
          $scope.deletingRegistry = false;
        });
      },
      rejected: function() {
        // no-op
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  // query the selected registry for services
  $scope.runRegistryQuery = function() {
    if ($scope.currentRegistry) {
      $scope.runningQuery = true;
      var url = "proxy/orgs/" + $scope.orgId + "/registryDiscovery/instance/" + $scope.currentRegistry + "/services";
      var queryString = encodeURIComponent($scope.data.discover.queryString);
      $http.get(url + "?query=" + queryString + "&data=summary").then(function(response) {
        if (response.data) {
          $scope.data.wsdl.services = response.data.services;
        }
        $scope.runningQuery = false;
      }, function(error) {
        // user will see the standard error dialog
        $scope.runningQuery = false;
      });
    }
  };
  // refresh the list of discovered services based on the query string
  $scope.refreshServiceQuery = function() {
    $scope.runRegistryQuery();
  };
  // open or close the registry filter panel
  $scope.toggleFilterPanel = function() {
    $scope.filterVisible = !$scope.filterVisible;
    // check if we need to fetch filter data for this registry
    var registry = $scope.registryListLookup[$scope.currentRegistry];
    if (registry) {
      if (!registry.filterData) {
        // go fetch the classifications and states
        $scope.fetchingFilters = true;
        var url = "proxy/orgs/" + $scope.orgId + "/registryDiscovery/instance/" + $scope.currentRegistry + "/filterElements";
        $http.get(url).then(function(response) {
          registry.filterData = response.data;
          // must process the heirarchical data into a flat view
          $scope.flattenFilterData(registry);
          $scope.fetchingFilters = false;
        }, function(error) {
          // user will see standard error box
          $scope.fetchingFilters = false;
        });
      }
    }
  };
  // recursive function to flatten a heirarchy
  var makeFlat = function(outputArray, inputArray, depth) {
    var len = inputArray.length;
    for (var i=0;i<len;i++) {
      var item = inputArray[i];
      outputArray.push({
        depth: depth,
        entry: item
      });
      if (item.children && item.children.length > 0) {
        makeFlat(outputArray, item.children, depth + 1);
      }
    } // end for
  };
  // turn the heirarchical data into flat lists
  $scope.flattenFilterData = function(registry) {
    registry.flatData = {
      service: {
        "Classifications": []
      },
      endpoint: {
        "Classifications": []
      }
    };
    makeFlat(registry.flatData.service["Classifications"], registry.filterData.serviceSpecificFilterElements["Classifications"], 0);
    makeFlat(registry.flatData.endpoint["Classifications"], registry.filterData.endpointSpecificFilterElements["Classifications"], 0);
  };
  // clear current filter selections
  $scope.resetFilter = function() {
    var deselectAll = function(inputArray) {
      var len = inputArray.length;
      for (var i=0;i<len;i++) {
        var item = inputArray[i];
        if (item.entry) {
          item.entry.selected = false;
        } else {
          item.selected = false;
        }
      } // end for
    };
    var registry = $scope.registryListLookup[$scope.currentRegistry];
    if (registry) {
      deselectAll(registry.filterData.serviceSpecificFilterElements["Governance States"]);
      deselectAll(registry.flatData.service["Classifications"]);
      deselectAll(registry.filterData.endpointSpecificFilterElements["Environments"]);
      deselectAll(registry.filterData.endpointSpecificFilterElements["Governance States"]);
      deselectAll(registry.flatData.endpoint["Classifications"]);
    }
  };
  // store current selections and re-run query
  $scope.applyFilter = function() {
    var url = "proxy/orgs/" + $scope.orgId + "/registryDiscovery/instance/" + $scope.currentRegistry + "/filterElements";
    var registry = $scope.registryListLookup[$scope.currentRegistry];
    $scope.savingFilter = true;
    $http.put(url, registry.filterData).then(function(response) {
      $scope.savingFilter = false;
      // now turn off the filter box and re-run the main query
      $scope.filterVisible = false;
      $scope.refreshServiceQuery();
    }, function(error) {
      // user will get standard error box
      $scope.savingFilter = false;
    });
  };
  // refresh the list of stored registries
  $scope.refreshRegistries = function() {
    $scope.fetchingRegistries = true;
    var baseUrl = "proxy/orgs/" + $scope.orgId + "/registryDiscovery/instance/";
    var wsrrPromise = $http.get(baseUrl + "WSRR/connectionData");
    var customPromise = $http.get(baseUrl + "CUSTOM/connectionData");
    $q.all([wsrrPromise, customPromise]).then(function(response) {
      $scope.registryList = [];
      var len = response[0].data.items.length;
      for (var i=0;i<len;i++) {
        var item = response[0].data.items[i];
        item.type = "wsrr";
        $scope.registryList.push(item);
        $scope.registryListLookup[item.uuid] = item;
      } // end for
      len = response[1].data.items.length;
      for (var j=0;j<len;j++) {
        var item2 = response[1].data.items[j];
        item2.type = "custom";
        $scope.registryList.push(item2);
        $scope.registryListLookup[item2.uuid] = item2;
      } // end for
      $scope.fetchingRegistries = false;
    }, function(error) {
      // user will see the standard error dialog
      $scope.fetchingRegistries = false;
    });
  };
  // must get initial list of registries on startup
  if (!$scope.offlineMode) {
    $scope.refreshRegistries();
  }

  $scope.$watchCollection('data.wsdlFiles', function() {
    if (!$scope.data.wsdlFiles || $scope.data.wsdlFiles.length == 0) {
      // reset any previous services
      $scope.data.wsdl.services = [];
      $scope.selectedServices = {};
      $scope.revealOperations = {};
      return;
    }
    $scope.fromUrl = false;
    $scope.fromDiscover = false;
    $scope.fileMode = true;
    $scope.currentPage = 3;
    // now run the actual import
    $scope.import();
  });
  $scope.$watch('data.discover.queryString', $scope.refreshServiceQuery);

  $controller('ApiProductBuilderController', {$scope: $scope});
};

angular.module('apim').controller('ApiImportXSDController', ['$scope', '$controller', '$modalInstance', '$filter', '$http', '$modal', '$q', 'uiUploader', 'errorHandler', 'Product', 'TrackingServices', ApiImportXSDController]);

function ApiImportXSDController($scope, $controller, $modalInstance, $filter, $http, $modal, $q, uiUploader, errorHandler, Product, TrackingServices) {
	$scope.currentPage = 1;
	$scope.data = {
		xsdChosen: false,
		xsdFiles: [],
		xsd: {
			numDefinitions : -1,
			definitions: null
		},
		url: {
			url: "",
			username: "",
			password: ""
		},
	};

	$scope.protocolTypes = [
	    {name: $filter('translate')('importProtocolSecure'), value: 'https'},
	    {name: $filter('translate')('importProtocolInsecure'), value: 'http'}
	];

  $scope.cancel = $scope.$dismiss;

	var handleXSDImportResponse = function(response, xsdUrl) {
		var responseObject = response;

    try {
			if (typeof response == 'string') {
		  	responseObject = JSON.parse(response);
		  }
		  if (responseObject.errors) {
		  	$scope.importingApi = false;
				$scope.data.xsd.numDefinitions = 0;
		  	errorHandler.checkResponse(responseObject);
		  } else if (responseObject) {
				$scope.data.xsd.definitions = JSON.parse(responseObject.definitions);
			  $scope.data.xsd.numDefinitions = $scope.getXSDDefinitionsCount($scope.data.xsd.definitions);
		  }
		} catch (error) {
			$scope.importingApi = false;
			$scope.currentPage = 1;
		}
	};

	// perform initial XSD upload
	$scope.import = function() {
		$scope.importingApi = true;

		// Upload XSD
		var url = 'proxy/orgs/' + $scope.orgId + '/apis';

		if (!$scope.fromUrl) {
			var uploadUrl = url + '/uploadxsd';
			// make sure any previous upload file list is cleared
			uiUploader.removeAll();
			$scope.markFilesInactive($scope.data.xsdFiles);
			uiUploader.addFiles($scope.data.xsdFiles);
			uiUploader.startUpload({
				url: uploadUrl,
				onCompleted: function(file, response) {
					handleXSDImportResponse(response, uploadUrl);
				}
			});
	  } else {
			var xsdUrl = url + '/xsd';
			var postData = {
			   xsdUrl: $scope.data.url.url
			};
			// add credentials if supplied
			if ($scope.data.url.username && $scope.data.url.password) {
				postData.basicAuth = 'Basic ' + btoa($scope.data.url.username + ':' + $scope.data.url.password);
			}
			$http.post(xsdUrl, postData).then(
				function(response) {
					handleXSDImportResponse(response.data, xsdUrl)
						.then(function() {
							$scope.currentPage = 3;
						})
				}, function(error) {
					$scope.importingApi = false;
					$scope.currentPage = 2;
				}
			);
		}
	};

	// save the API with the given options
	$scope.save = function() {
		try {
			$scope.savingAPI = true;
			$scope.saveXSDDefinitions($scope.data.xsd.definitions);
			$modalInstance.dismiss('ok');
			$scope.currentPage = 1;
    } catch (e) {
	  	$modalInstance.dismiss('ok');
		  $scope.savingAPI = false;
    }

	};

	// handle the move to the next page
	$scope.doNext = function() {
		if ($scope.fromUrl && $scope.currentPage == 2) {
			// moving from URL input page to xsd select/save
			$scope.currentPage = 3;
			// now run the actual import
			$scope.import();
		} else {
			// default action is move to next page
			$scope.currentPage++;
		}
	};
	// handle the move to the previous page
	$scope.doPrevious = function() {
		$scope.importingApi = false;
		$scope.savingAPI = false;
		if ($scope.fileMode && $scope.currentPage == 3) {
			$scope.currentPage = 1;
			$scope.data.xsd.numDefinitions = -1;
			$scope.fileMode = false;
		} else {
			// default action is move to previous page
			$scope.currentPage -= 1;
		}
	};


	$scope.$watchCollection('data.xsdFiles', function() {
    if (!$scope.data.xsdFiles || $scope.data.xsdFiles.length == 0) {
      return;
    }
		$scope.fromUrl = false;
		$scope.fromDiscover = false;
		$scope.fileMode = true;
		$scope.currentPage = 3;
		// now run the actual import
		$scope.import();
	});
	$scope.$watch('data.discover.queryString', $scope.refreshServiceQuery);
  $controller('ApiProductBuilderController', {$scope: $scope});
};

apis.controller('ApiVersionController', ['$scope', '$http', '$modal', '$filter', 'Product', 'convertTagsFilter', apiVersionController]);

function apiVersionController($scope, $http, $modal, $filter, Product) {
  $scope.apiTypeLookup = {
    "REST": $filter('translate')('apiTypeREST'),
    "SOAP": $filter('translate')('apiTypeSOAP'),
    "OAUTH": $filter('translate')('apiTypeOauth'),
    "rest": $filter('translate')('apiTypeREST'),
    "soap": $filter('translate')('apiTypeSOAP'),
    "oauth": $filter('translate')('apiTypeOauth')
  };
  $scope.deletableTags = true;

  var checkIfApiUsed = function(orgId, apiVersion) {
    return Product.query({ orgId: orgId }).$promise
      .then(function (products) {
        return products.some(function (product) {
          if (!product.apis) {
            return;
          }
          return Object.keys(product.apis).some(function (api) {
            if (product.apis[api].$ref) {
              return product.apis[api].$ref === apiVersion.file;
            }
            return product.apis[api].id === apiVersion.id;
        });
      });
    });
  };

  $scope.delete = function(apiVersion) {
    checkIfApiUsed($scope.orgId, apiVersion)
      .then(function (isUsed) {
        if (isUsed) {
          showInUseError();
        } else {
          showDeleteConfirm(apiVersion);
        }
      });
  };

  var showInUseError = function() {
    var modalScope = $scope.$new();

    modalScope.information = {
      titleKey: 'apiCurrentlyInUseTitle',
      messageKey: 'apiCurrentlyInUse',
      accepted: function () { }
    };

    $modal.open({
      templateUrl: 'apim/partials/information.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'InformationController',
      scope: modalScope
    });
  };

  var showDeleteConfirm = function (apiVersion) {
    var modalScope = $scope.$new();

    modalScope.confirmation = {
      titleKey: 'confirmDeleteApiVersionTitle',
      messageKey: 'confirmDeleteApiVersion',
      confirmed: function () {
        $scope.beingDeleted = true;
        var apiId = $scope.apiVersion.id || $scope.apiVersion.info['x-ibm-name'] + ':' + $scope.apiVersion.info.version;
        $scope.apiVersion.$delete({
          orgId: $scope.orgId,
          apiId: apiId,
          apimanager: 'apimanager',
          fileHeader: $scope.apiVersion.file
        }).then(function () {
          // skip if another delete dialog is open - the refresh from that delete will cover this one
          if (!$scope.apiDeleteOpen) {
            $scope.apiDeleteRefreshPending = false;
            $scope.refreshApisForQuery(true);
            $scope.setFavourite('api', $scope.apiVersion, true, $scope.apiVersion.info['x-ibm-name'] + ':' + $scope.apiVersion.info.version);
          } else {
            $scope.apiDeleteRefreshPending = true;
          }
        }, function () {
          $scope.beingDeleted = false;
        });

        $scope.apiDeleteOpen = false;
      },
      rejected: function () {
        $scope.apiDeleteOpen = false;
        if ($scope.apiDeleteRefreshPending) {
          $scope.apiDeleteRefreshPending = false;
          $scope.refreshApis();
        }
      }
    };

    $scope.apiDeleteOpen = true;
    modalScope.apiVersion = apiVersion;
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: modalScope
    });
  };

  $scope.assignTag = function(tag) {
    if (tag.value == "favourite") {
      $scope.setFavourite('api', $scope.apiVersion);
      $scope.refreshTags();
    } else {
      $http.post('proxy/orgs/' + $scope.orgId + '/apis/' + $scope.apiVersion.id + '/tags', { name: tag.label }).then(function (tagObject) {
        $scope.refreshTags();
      });
    }
  };

  $scope.createTag = function($event) {
    if ($event.which == 13) {
      var existing = $scope.tags.filter(function(tag) {
        return (tag.label == $scope.newTag);
      });
      if (existing.length > 0) {
        $scope.tagDropdownOpen = false;
        return;
      }
      $http.post('proxy/orgs/' + $scope.orgId + '/apis/' + $scope.apiVersion.id + '/tags', {name: $scope.newTag}).then(function(tagObject) {
        $scope.refreshTags();
      });
      $scope.newTag = "";
      $scope.tagDropdownOpen = false;
    }
  };

  $scope.deleteTag = function(tag) {
    if (tag.value == "favourite") {
      $scope.setFavourite('api', $scope.apiVersion, true);
      $scope.refreshTags();
    } else {
      $http['delete']('proxy/orgs/' + $scope.orgId + '/apis/' + $scope.apiVersion.id + '/tags/' + tag.label).then(function() {
        $scope.refreshTags();
      });
    }
  };

};

apis.controller('ApiCreateController', ['$scope', '$controller', '$modalInstance', '$filter', '$q', '$http','convertPlansToTagsFilter', 'Api', 'Product', 'ProductUtil', 'ArtifactBuilder', 'ProductPublisher', 'SlugService', 'TrackingServices', apiCreateController]);

function apiCreateController($scope, $controller, $modalInstance, $filter, $q, $http, convertPlansToTagsFilter, Api, Product, ProductUtil, ArtifactBuilder, ProductPublisher, SlugService, TrackingServices) {

  if (!$scope.createDialogTitle) {
    $scope.createDialogTitle = 'composeAPI';
  }

  var secPolicyName = "clientID";

  var securitySetting = "id";
  $scope.newApi = {
    version: "1.0.0",
    title: "",
    clientId: true,
    cors: true,
    gateway: "both",
    basepath: "/"
  };

  $scope.savedProperties = {};
  $scope.additionalProperties = {};

  if (!$scope.apiTemplate) {
    $scope.apiTemplate = ArtifactBuilder.defaultApiName;
  }

  $scope.identifyUsing = function(value) {
    if (typeof value !== "undefined") {
      // setter
      securitySetting = value;
      switch (value) {
        case "none":
          delete $scope.newApi.clientId;
          delete $scope.newApi.clientSecret;
          break;
        case "id":
          $scope.newApi.clientId = true;
          delete $scope.newApi.clientSecret;
          break;
        case "both":
          $scope.newApi.clientId = true;
          $scope.newApi.clientSecret = true;
          break;
      }
    } else {
      // getter
      return securitySetting;
    }
  };

  var generateApiName = function() {
    // apply title -> name conversion rules
    $scope.newApi.name = SlugService.createName($scope.newApi.title);
    $scope.newApi.basepath = "/" + $scope.newApi.name;
  };
  $scope.$watch('newApi.title', generateApiName);

  var newPropertyKey = '';
  $scope.newPropertyKey = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value === newPropertyKey) return;
      if (typeof $scope.additionalProperties[value] !== "undefined" ||
        typeof $scope.newApi[value] !== "undefined") {
          $scope.newPropertyError = {"clash": true};
          newPropertyKey = value;
          return;
      }
      delete $scope.newPropertyError;
      if (newPropertyValue) {
        // create the new property
        $scope.additionalProperties[value] = $scope.additionalProperties[newPropertyKey] || newPropertyValue;
        newPropertyKey = '';
        newPropertyValue = '';
      } else {
        newPropertyKey = value;
      }
    } else {
      // getter
      return newPropertyKey;
    }
  };

  var newPropertyValue = '';
  $scope.newPropertyValue = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value === newPropertyValue) return;
      newPropertyValue = value;
      if (newPropertyKey && !$scope.newPropertyError) {
        if (typeof $scope.additionalProperties[newPropertyKey] !== "undefined" ||
          typeof $scope.newApi[newPropertyKey] !== "undefined") {
            $scope.newPropertyError = {"clash": true};
            return;
        }
        delete $scope.newPropertyError;
        $scope.additionalProperties[newPropertyKey] = value;
        newPropertyKey = '';
        newPropertyValue = '';
      }
    } else {
      // getter
      return newPropertyValue;
    }
  };

  function reset() {
    $scope.currentPage = 1;
    newPropertyKey = '';
    newPropertyValue = '';
    delete $scope.newPropertyError;
  }

  $scope.saveProperties = function() {
    $scope.savedProperties = angular.copy($scope.additionalProperties);
    reset();
  };

  $scope.cancelProperties = function() {
    $scope.additionalProperties = angular.copy($scope.savedProperties);
    reset();
  };

  $scope.validateAndCreate = function() {
    if (!$scope.newApiForm.$valid) return;
    if ($scope.currentPage === 3 && !$scope.productFormValid()) return;
    if ($scope.creatingApi) return;
    $scope.create();
  };

  $scope.create = function() {
    $scope.creatingApi = true;
    if (!$scope.newApi.hostname || $scope.newApi.hostname === '') $scope.newApi.hostname = "$(catalog.host)";
    if ($scope.newApi.gateway === "both") {
      // then don't set anything in the swagger
      delete $scope.newApi.gateway;
    }
    var templateProperties = angular.copy($scope.newApi);
    angular.extend(templateProperties, $scope.additionalProperties);
    var templateDeferred = ArtifactBuilder.createFromTemplate($scope.apiTemplate, templateProperties);
    templateDeferred.promise.then(function(newApi) {
      var api = new Api(newApi);
      api.$save({orgId: $scope.orgId, mode: "swagger2"}, function(api, headers) {
        var apiRef = {};
        var appendResult;

        $scope.apis.push(api);

        if (headers('x-ibm-swagger-file')) {
          apiRef = headers('x-ibm-swagger-file');
        } else {
          apiRef = api.info["x-ibm-name"] + ":" + api.info.version;
        }

        var apiRefs = {};
        apiRefs[api.info["x-ibm-name"]] = apiRef;
        if ($scope.currentPage === 3 && $scope.addToProductType === "new") {
          appendResult = $scope.createAndAppendToProduct(apiRefs, $scope.newProduct);
        } else if ($scope.currentPage === 3 && $scope.addToProductType === "existing") {
          appendResult = $scope.appendToProduct(apiRefs, Object.keys($scope.selectedRefs));
        } else {
          appendResult = $q.resolve();
        }
        appendResult.then(null, function(err) {
          var timestamp = (new Date()).getTime();
          $scope.notifyUser('apiCreateProductError', {}, 'ERROR', true, "createApiProduct-" + timestamp);
        });
        appendResult.finally(function() {
          $scope.creatingApi = false;
          TrackingServices.track('api', 'createNewApi', { productType: $scope.addToProductType, apiTemplate: $scope.apiTemplate});
          $modalInstance.close(api);
        });
      }, function() {
        $scope.creatingApi = false;
      });
    });
  };
  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };
  $scope.next = function() {
    $scope.currentPage = 3;
  };
  $scope.back = function() {
    $scope.currentPage = 1;
  };
  $scope.selected = function(item) {
    $scope.selectedPlans.push(item);
    $scope.userInput = null;
  };

  $controller('ApiProductBuilderController', {$scope: $scope});
};

apis.controller('TemplatePropertyController', ['$scope', function($scope) {
  var invalidKey;
  $scope.propertyKey = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value === $scope.key) return;
      if (typeof $scope.additionalProperties[value] !== "undefined" ||
        typeof $scope.newApi[value] !== "undefined") {
          $scope.existingPropertyError = {"clash": true};
          invalidKey = value;
          return;
      }
      invalidKey = null;
      delete $scope.existingPropertyError;
      if ($scope.additionalProperties[$scope.key]) {
        $scope.additionalProperties[value] = $scope.additionalProperties[$scope.key];
        delete $scope.additionalProperties[$scope.key];
      }
      $scope.key = value;
    } else {
      // getter
      return invalidKey || $scope.key;
    }
  }
}]);

apis.controller('ApiProductBuilderController', ['$scope', '$q', '$http', 'Product', 'ArtifactBuilder', 'ProductPublisher', 'SlugService', 'TrackingServices', ApiProductBuilderController]);

function ApiProductBuilderController($scope, $q, $http, Product, ArtifactBuilder, ProductPublisher, SlugService, TrackingServices) {

  if (!$scope.addToProductType) {
    $scope.addToProductType = "new";
  }

  $scope.selectedRefs = {};

  if (!$scope.productTemplate) {
    $scope.productTemplate = ArtifactBuilder.defaultProductName;
  }

  $scope.appendExistingApiToExistingProducts = function() {
    if ($scope.$modalInstance) $scope.$modalInstance.close('ok');
    return $scope.appendToProduct($scope.apiRefs, Object.keys($scope.selectedRefs));
  };

  $scope.appendToProduct = function(apiRefs, productName) {
    if (!apiRefs || !productName) {
      return $q.reject('missing or invalid parameter');
    }

    return $q.when(productName.map(function(prodId) {
      var dfd = $q.defer();
      var querySpec = {
        orgId: $scope.orgId,
        productVersion: prodId
      };

      Product.get(querySpec, function(product, headers) {
        product.apis = product.apis || {};

        Object.keys(apiRefs).forEach(function(apiRef) {
          product.apis[apiRef] = {
            "$ref": apiRefs[apiRef]
          };
        });

        $http.put(
          'proxy/orgs/' + $scope.orgId + '/products/' + prodId,
          angular.toJson(product),
          {
            headers: {
              "Content-Type": "application/json",
              "x-ibm-product-file": headers("x-ibm-product-file")
            }
          }
        ).then(function() {
          dfd.resolve();
          TrackingServices.track('product', 'addProductApi');
        })
          .catch(function(err) {
            dfd.reject(err);
          })
      }, function(err) {
        dfd.reject(err);
      });

      return dfd.promise;
    }));
  };

  if ($scope.$modalInstance) {
    $scope.cancel = function() {
      $scope.$modalInstance.dismiss('cancel');
    };
  }

  $scope.createAndAppendToProduct = function(apiRefs, product) {
    if (!product || !apiRefs) {
      return $q.reject('missing or invalid parameter');
    }

    if (!product.name) product.name = SlugService.createName(product.title);
    product.apis = apiRefs;

    $scope.creatingProducts = true;
    var deferred = $q.defer();
    var templateDeferred = ArtifactBuilder.createFromTemplate($scope.productTemplate, product);
    templateDeferred.promise.then(function(newProduct) {
      new Product(newProduct).$create({orgId: $scope.orgId}, function(product, headers) {
        deferred.resolve(product);
        delete $scope.creatingProducts;

        var productDescriptor = {
          info: product.info
        };
        var productHeaders = headers();
        if (productHeaders['x-ibm-product-file']) {
          productDescriptor.file = productHeaders['x-ibm-product-file'];
        }
        TrackingServices.track('product','createProductApi');
        TrackingServices.track('product','addProductApi');

        if ($scope.publishOptions.doPublish && $scope.publishOptions.publishTarget) {
          ProductPublisher.publish(productDescriptor, $scope.publishOptions.publishTarget);
          TrackingServices.track('product','publishProductApi');
        }
      }, function(error) {
        deferred.reject(error);
      });
    });
    return deferred.promise;
  };

  $scope.newProduct = {
    version: "1.0.0",
    title: ""
  };

  if (!$scope.publishOptions) {
    $scope.publishOptions = {
      doPublish: !$scope.hidePublishOption
    };
  }

  $scope.$watch('publishTargets', function() {
    if (!$scope.environments) return;
    $scope.publishOptions.publishTarget = $scope.publishTargets.length ? $scope.publishTargets[0] : null;
  });

  $scope.productFormValid = function() {
    if ($scope.publishOptions.doPublish === false) return true;
    if ($scope.addToProductType === "new" &&
      $scope.publishOptions.doPublish &&
      !$scope.publishOptions.publishTarget) return false;
    if ($scope.addToProductType === "none") return true;
    if ($scope.addToProductType === "existing" &&
      !_.isEmpty($scope.selectedRefs)) {
        var keys = Object.keys($scope.selectedRefs);
        for (var i = 0; i < keys.length; i++) {
          if ($scope.selectedRefs[keys[i]] === true) return true;
        }
        return false;
    }
    if ($scope.addToProductType === "new" &&
      $scope.newProduct.version &&
      $scope.newProduct.version !== "" &&
      $scope.newProduct.name &&
      $scope.newProduct.name !== "" &&
      $scope.newProduct.title &&
      $scope.newProduct.title !== "") return true;
    return false;
  };

  var generateProductName = function() {
    // apply title -> name conversion rules
    $scope.newProduct.name = SlugService.createName($scope.newProduct.title);
  };

  $scope.$watch('newProduct.title', generateProductName);
  $scope.$watch('newApi.title', function() {
    if (!$scope.newApi) return;
    $scope.newProduct.title = $scope.newApi.title + " product" || "";
  });
  $scope.$watch('selectedServices', function() {
    if (!$scope.selectedServices) return;
    var keys = Object.keys($scope.selectedServices);
    for (var i = 0; i < keys.length; i++) {
      if ($scope.selectedServices[keys[i]] === true) {
        var name = keys[i].split("```");
        $scope.newProduct.title = name[0] + " product";
        return;
      }
    }
  }, true);
}

apis.controller('ResourceSelectorController', ['$scope', '$modalInstance', 'Api', 'Resource', 'apiVersionQueryFilter', resourceSelectorController]);

function resourceSelectorController($scope, $modalInstance, Api, Resource, apiVersionQueryFilter) {
  $scope.loadingApis = true;
  $scope.allSelected = false;
  $scope.selectedResources = {};
  $scope.planVersion.apis.forEach(function(apiContainer) {
    var api = apiContainer.api;
    $scope.selectedResources[api.id] = {
      api: {
        id: api.id,
        name: api.name,
        url: api.url
      },
      resources: []
    };
    apiContainer.resources.forEach(function(resource) {
      $scope.selectedResources[api.id].resources.push({
        id: resource.id,
        url: resource.url
      });
    });
  });
  $scope.apis = Api.query({
    orgId: $scope.orgId
  });
  $scope.apis.$promise.then(function() {
    $scope.loadingApis = false;
    if ($scope.apis.length > 0) $scope.selectedApi = $scope.apis[0];
  });
  $scope.$watch('selectedApi', function() {
    if (!$scope.selectedApi) return;
    var versions = apiVersionQueryFilter($scope.apis, $scope.selectedApi);
    if (versions.length > 0) {
      $scope.selectedApiVersion = versions[versions.length - 1];
    }
  });
  $scope.$watch('selectedApiVersion', function() {
    if (!$scope.selectedApiVersion) return;
    $scope.loadingResources = true;
    $scope.resources = Resource.query({
      orgId: $scope.orgId,
      apiId: $scope.selectedApiVersion.apiId,
      version: "v" + $scope.selectedApiVersion.version
    });
    $scope.resources.$promise.then(function() {
      $scope.loadingResources = false;
      var allSelected = true;
      $scope.resources.forEach(function(resource) {
        var existing = $scope.selectedResources[resource.apiId];
        if (existing) {
          var filtered = existing.resources.filter(function(thisResource) {
            return thisResource.url == resource.url;
          });
          resource.selected = (filtered.length > 0);
          if (!resource.selected) allSelected = false;
        } else {
          allSelected = false;
        }
      });
      $scope.allSelected = allSelected;
    });
  });
  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };
  $scope.apply = function() {
    var asArray = [];
    for (var apiId in $scope.selectedResources) {
      asArray.push($scope.selectedResources[apiId]);
    }
    $modalInstance.close(asArray);
  };
  $scope.selectAllResources = function() {
    $scope.resources.forEach(function(resource) {
      if ($scope.allSelected && !resource.selected) {
        $scope.addResource(resource, true);
      } else if (!$scope.allSelected && resource.selected) {
        $scope.removeResource(resource, true);
      }
      resource.selected = $scope.allSelected;
    });
  };
  $scope.selectResource = function(resource) {
    if (resource.selected) {
      $scope.addResource(resource);
    } else {
      $scope.removeResource(resource);
    }
  };
  $scope.addResource = function(resource, skipAllFlag) {
    var existing = $scope.selectedResources[$scope.selectedApiVersion.apiId];
    if (!existing || existing.api.url != $scope.selectedApiVersion.url) {
      existing = {
        api: {
          id: $scope.selectedApiVersion.apiId,
          name: $scope.selectedApiVersion.name,
          url: $scope.selectedApiVersion.url
        },
        resources: [{
          id: resource.id,
          url: resource.url
        }]
      };
      $scope.selectedResources[$scope.selectedApiVersion.apiId] = existing;
    } else {
      existing.resources.push({
        id: resource.id,
        url: resource.url
      });
    }
    if (!skipAllFlag) $scope.allSelected = (existing.resources.length == $scope.resources.length);
  };
  $scope.removeResource = function(resource, skipAllFlag) {
    var existing = $scope.selectedResources[$scope.selectedApiVersion.apiId];
    if (!existing) return;
    var index = -1;
    for (var i = 0; i < existing.resources.length; i++) {
      if (existing.resources[i].id == resource.id && existing.resources[i].url == resource.url) index = i;
    }
    if (index >= 0) existing.resources.splice(index, 1);
    if (existing.resources.length == 0) {
      delete $scope.selectedResources[$scope.selectedApiVersion.apiId];
    }
    if (!skipAllFlag) $scope.allSelected = (existing.resources.length == $scope.resources.length);
  };
};
