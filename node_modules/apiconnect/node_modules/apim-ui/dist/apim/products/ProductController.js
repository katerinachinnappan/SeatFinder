/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apim.products', []).controller('ProductEditorController', ['$scope', '$rootScope', '$timeout', '$http', '$modal', '$location', '$stateParams', 'Product', 'ProductUtil', 'DeployedProduct', 'Api', 'ApiSearch', 'Reference', 'DirtyService', 'TrackingServices', ProductEditorController]);

function ProductEditorController($scope, $rootScope, $timeout, $http, $modal, $location, $stateParams, Product, ProductUtil, DeployedProduct, Api, ApiSearch, Reference, DirtyService, TrackingServices) {

  var self = this;

  $scope.setMainTab("editor");	// make sure we initialise the correct menu

  // this object will contain a hash
  $scope.apisByRef = {};

  $rootScope.$broadcast('update.bannerItems');

  $scope.getApiByRef = function(api) {
    if (typeof api == "string") return $scope.apisByRef[api];
    if (api.$ref) return $scope.apisByRef[api.$ref];
    if (api.id) return $scope.apisByRef[api.id];
    if (api.name) return $scope.apisByRef[api.name];
  };

  $scope.setApiByRef = function(api, file) {
    if (api.info['x-ibm-name']) {
      $scope.apisByRef[api.info['x-ibm-name'] + ":" + api.info.version] = api;
    } else {
      $scope.apisByRef[api.info.title + ":" + api.info.version] = api;
    }
    if (api.id) $scope.apisByRef[api.id] = api;
    if (file) {
      $scope.apisByRef[file] = api;
      $scope.apisByRef[file.replace("definitions/", "")] = api;
    }
  };

  $scope.buildOperations = function(api) {
    var operations = [];
    if (!api || !api.paths) return;
    if (api.operations) return;
    Object.keys(api.paths).forEach(function(path) {
      Object.keys(api.paths[path]).forEach(function(operation) {
        if (['get', 'put', 'post', 'delete', 'patch', 'head', 'options'].indexOf(operation) < 0) return;
        var thisOperation = api.paths[path][operation];
        thisOperation.path = path;
        thisOperation.operation = operation;
        operations.push(thisOperation);
      });
    });
    api.operations = operations;
  };

  function isYamlFile(ref) {
    return (ref.match(/\.y[a]*ml$/i) !== null);
  }

  self.resolveReferences = function() {
    // reference resolution is not valid onprem
    if (!$scope.offlineMode) return;
    if (!$scope.product.apis) return;
    Object.keys($scope.product.apis).forEach(function(apiName) {
      var api = $scope.product.apis[apiName];
      if (!api.$ref) return;
      if (!isYamlFile(api.$ref)) return;
      Reference.get({
        orgId: $scope.orgId,
        ref: api.$ref
      }, function(data) {
        $scope.apisByRef[api.$ref] = data;
        data.$$ref = api.$ref;
        data.$$refObj = {$ref: api.$ref};
        data.$$name = (data.info["x-ibm-name"]) ? data.info["x-ibm-name"] : data.info.title;
        $scope.buildOperations(data);
        $scope.updateToc();
      });
    });
  };

  $scope.checkDirtyProduct = function() {
    return DirtyService.isDirty('ProductEditorController');
  };

  $scope.$on("$locationChangeStart", function (event, next, current) {
    if ($scope.checkDirtyProduct()) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          DirtyService.clearDirty('ProductEditorController');
          $location.path($location.url(next).hash());
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });

  $scope.$watch('permissions', function() {
    if (!$scope.permissions) return;
    $scope.editable = !!$scope.permissions['org_draftProducts/edit'];
  });

  $scope.$watch('mainTab', function() {
    if (!$scope.mainTab) return;
    if($scope.selectedPath) $scope.navigate($scope.selectedPath);
  });

  $scope.$watch('mainTab', function() {
    if ($scope.mainTab == "code" && $scope.product) {
      $rootScope.productValue = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.product)), {lineWidth: -1});
    }
  });

  // var unwatcher;
  function watchProduct() {
    // if (unwatcher) unwatcher();
    // unwatcher = $scope.$watch('product', function() {
      $scope.$watch('product', function() {
        if (!$scope.product || !$scope.product.info) return;

        $scope.setCurrentItem({name: $scope.product.info.name, title: $scope.product.info.title, version: $scope.product.info.version});

        if ($scope.descriptionPreviewMode == undefined) $scope.descriptionPreviewMode = !_.isEmpty($scope.product.info.description);

        if ($scope.firstWatchHit) {
          DirtyService.setDirty('ProductEditorController');
        } else {
          $scope.refreshDescriptors();
          $scope.firstWatchHit = true;
        }
        validate();
      }, true);
    }


      var validateFn = function() {
        try {
          var productToValidate = angular.fromJson(angular.toJson($scope.product));
          $scope.clearErrorsAndWarnings();
          window.apicValidate.validateObject(productToValidate).then(function(results) {
            var errors = [];
            var warnings = [];
            results.forEach(function(thisResult) {
              if (thisResult.error) errors = errors.concat(thisResult.error);
              if (thisResult.warning) warnings = warnings.concat(thisResult.warning);
            });
            var path;
            if(errors.length > 0) {
              for(var i=0; i<errors.length; i++) {
                if(errors[i].path && errors[i].path.length > 0) {
                  path = errors[i].path[0];
                  for(var j=1; j<errors[i].path.length; j++) {
                    path += " -> " + errors[i].path[j];
                  }
                }
                $scope.addError(errors[i]);
              }
            }
            if(warnings.length > 0) {
              for(var k=0; k<warnings.length; k++) {
                $scope.addWarning(warnings[k]);
              }
            }
            $scope.$apply();
          }, function (err) {
            $scope.addError(err);
            $scope.$apply();
          });
        } catch(error) {
          $scope.addError(error);
          $scope.$apply();
        }
      };

      var validate = _.debounce(validateFn, 1000);

      $scope.validationErrors = [];
      $scope.validationWarnings = [];
      $scope.clearErrorsAndWarnings = function() {
        $scope.validationErrors = [];
        $scope.validationWarnings = [];
        $rootScope.$broadcast('update.bannerItems');
      };

      $scope.addError = function(error) {
        $scope.validationErrors.push(error);
        $rootScope.$broadcast('update.bannerItems');
      };
      $scope.addWarning = function(warning) {
        $scope.validationWarnings.push(warning);
        $rootScope.$broadcast('update.bannerItems');
      };

      $scope.$watch('currentOrg', function() {
        if (!$scope.currentOrg) return;
        $scope.xhrProcessingProduct = true;
        Product.get({orgId: $scope.orgId, productVersion: $stateParams.id},
          function(product, headers) {
            $scope.xhrProcessingProduct = false;
            $scope.productHeaders = headers();
            $scope.productId = product.id;
            $scope.cleanProduct(product);
            $scope.product = product;

            if (!$scope.offlineMode) {
              // we may have paginated APIs, get all APIs for this product
              ApiSearch.query({
                orgId: $scope.orgId,
                productId: $scope.productId
              }, function(data) {
                if (angular.isArray(data)) {
                  data.forEach(function(api) {
                    $scope.decorateApi(api);
                    $scope.setApiByRef(api);
                    $scope.updateToc();
                  });
                }
              });
            }

            self.resolveReferences();

            watchProduct();
          },
          function(error) {
            $scope.xhrProcessingProduct = false;
          }
        );
        $scope.refreshApis();
      });

      $scope.pageSize = 100;
      $scope.currentPage = 1;
      $scope.totalItems = 0;

      $scope.pageChanged = function (pageNo, queryString) {
        $scope.currentPage = pageNo;
        $scope.refreshApis(queryString);
      };

      $scope.updateToc = function() {
        $scope.$broadcast('update-toc');
      };

      $scope.refreshApis = function(queryString, hideSpinner) {
        if (!hideSpinner) {
          $scope.xhrProcessingApis = true;
        }
        var queryArgs = {
          orgId: $scope.orgId,
          page: $scope.currentPage,
          size: $scope.pageSize
        };
        if (queryString) queryArgs['filter'] = queryString;
        $scope.apis = Api.query(queryArgs, function(data, headers) {
          $scope.xhrProcessingApis = false;
          var totalCount = headers('x-total-count');
          if (totalCount) {
            $scope.totalItems = totalCount * 1;
            if (!$scope.firstTimeTotal) $scope.firstTimeTotal = $scope.totalItems;
          }
          $scope.apis.forEach(function(api) {
            $scope.decorateApi(api);
            $scope.buildOperations(api);
            $scope.updateToc();
          });
        });
        return $scope.apis.$promise;
      };

      $scope.decorateApi = function(api) {
        var key = (api.info["x-ibm-name"] ? api.info["x-ibm-name"] : api.info.title);
        api.$$name = key;
        key += ":" + api.info.version;
        if (api.id) {
          api.$$ref = api.id;
          api.$$refObj = {id: api.id};
        } else {
          api.$$ref = key;
          api.$$refObj = {name: key};
        }
        $scope.apisByRef[key] = api;
        $scope.apisByRef[api.id] = api;
        if (api.file) {
          // we have a filename, so also log a file reference
          $scope.apisByRef[api.file] = api;
          var fileRef = api.file;
          $scope.apisByRef[fileRef] = api;
          api.$$ref = fileRef;
          api.$$refObj = {$ref: fileRef};
        }
      };

      $scope.cleanUpKey = function(key) {
        if (!key) return;
        return key.replace(/\W/g, '');
      };

      $scope.getApiName = function(api) {
        if (!$scope.apisByRef) return;
        if (!api) return;
        var apiDetails = null;
        if (api.$ref) apiDetails = $scope.apisByRef[api.$ref];
        if (api.id) apiDetails = $scope.apisByRef[api.id];
        if (api.name) apiDetails = $scope.apisByRef[api.name];
        if(apiDetails && apiDetails.info && apiDetails.info.title) {
          return apiDetails.info.title + (apiDetails.info.version ? " " + apiDetails.info.version : "");
        } else if (apiDetails && apiDetails.info && apiDetails.info['x-ibm-name']) {
          return apiDetails.info['x-ibm-name'] + (apiDetails.info.version ? " " + apiDetails.info.version : "");
        } else if (api.name) {
          return api.name;
        } else if (api.$ref) {
          return api.$ref;
        } else if (api.id) {
          return api.id;
        }
        return "";
      };

      $scope.getApiKey = function(api) {
        if (!$scope.apisByRef) return;
        if (!api) return;
        var apiKey = null, apiDetails = null;
        if (api.$ref) apiDetails = $scope.apisByRef[api.$ref];
        if (api.id) apiDetails = $scope.apisByRef[api.id];
        if (api.name) apiDetails = $scope.apisByRef[api.name];
        if (apiDetails && apiDetails.info && apiDetails.info['x-ibm-name']) {
          apiKey = apiDetails.info['x-ibm-name'];
        } else if (apiDetails && apiDetails.info && apiDetails.info.title) {
          apiKey = apiDetails.info.title;
        } else if (api.name) {
          apiKey = api.name;
        }
        return $scope.cleanUpKey(apiKey);
      };

      $scope.cleanProduct = function(product) {
        delete product.id;
        delete product.url;
        delete product.orgId;
        delete product.createdAt;
        delete product.updatedAt;
        delete product.createdBy;
        delete product.updatedBy;
      };

      $scope.setProduct = function(product) {
        $scope.product = new Product(product);
        $scope.$apply();
      };

      $scope.refreshDescriptors = function() {
        if ($scope.offlineMode) return;
        $scope.loadingDescriptors = true;
        var descriptors = DeployedProduct.query({
          orgId: $scope.orgId,
          expand: false
        });
        descriptors.$promise.then(function() {
          $scope.descriptors = descriptors.filter(function(descriptor) {
            return (descriptor.productName == $scope.product.info.name && descriptor.productVersion == $scope.product.info.version);
          });
          $scope.loadingDescriptors = false;
        });
      };

      function onAceChange() {
        // ignore these events if ywe're not on the code tab
        if ($scope.mainTab !== "code") return;
        $scope.setProduct(jsyaml.safeLoad($rootScope.productValue));
      }

      var debouncedOnAceChange = _.debounce(onAceChange, 200);

      $scope.aceChanged = function () {
        debouncedOnAceChange();
      };

      $scope.selectedPath = 'info';
      $scope.selectedPathIndex = 1;
      $scope.setSelectedPath = function(inview, path, index) {
        if(!inview && $scope.selectedPath == path) {
          $scope.selectedPathGone = true;
        } else if(inview && ($scope.selectedPathGone || index < $scope.selectedPathIndex)) {
          $scope.selectedPath = path;
          $scope.selectedPathIndex = index;
          $scope.selectedPathGone = false;
          var tocItem = document.querySelector('.toc .tocItem .selected');
          if(tocItem) {
            tocItem.scrollIntoView(true);
            document.querySelector('.toc').scrollTop += -50;
          }
        }
      };

      $scope.navigate = function(path) {
        $scope.selectedPath = path;
        // Scroll in product editor
        var editNode = document.querySelector('.detailsEditor .navigate-' + $scope.selectedPath);
        if (editNode) editNode.scrollIntoView();

        // Scroll in ACE editor
        var editor = ace.edit('ace-product-editor');
        var pathArray = path.split('-');
        var stringToFind = pathArray[pathArray.length - 1] + ":";
        var lines = editor.session.doc.getAllLines();
        for(var i=0; i<lines.length; i++) {
          if (lines[i].indexOf(stringToFind) != -1) {
            $scope.aceCurrentLine = i + 1;
            editor.scrollToLine($scope.aceCurrentLine, true, true, function () {});
            editor.gotoLine($scope.aceCurrentLine, 10, true);
            break;
          }
        }
      };

      $scope.saveVersion = function() {
        if (!$scope.checkDirtyProduct()) return;
        if (!$scope.editable) return;
        var messageId = new Date().getTime();
        $scope.$root.notifyUser('realProductSaving', [], "BUSY", false, messageId);
        $scope.productInFlux = true;
        // $scope.firstWatchHit = false;
        function responseHandler(product) {
          if (!product.info && product.data) product = product.data;
          $scope.productInFlux = false;
          DirtyService.clearDirty('ProductEditorController');
          $scope.$root.notifyUser('realProductSaved', [], "SUCCESS", true, messageId);
          window.location.hash = '/design/products/editor/' + product.info.name + ':' + product.info.version;
        };
        function errorHandler() {
          $scope.productInFlux = false;
        };
        if ($scope.productHeaders && $scope.productHeaders['x-ibm-product-file']) {
          $http.put('proxy/orgs/' + $scope.orgId + '/products/' + ($scope.productId ? $scope.productId : $scope.product.info.name + ":" + $scope.product.info.version),
            angular.toJson($scope.product),
            {
              headers: {
                "Content-Type": "application/json",
                "x-ibm-product-file": $scope.productHeaders["x-ibm-product-file"]
              }
            }
          ).then(responseHandler, errorHandler);
        } else {
          $scope.product.$save({
            orgId: $scope.orgId,
            productVersion: ($scope.productId ? $scope.productId : $scope.product.info.name + ":" + $scope.product.info.version)
          }, responseHandler, errorHandler);
        }
      };

      $scope.deleteVersion = function() {
        $scope.confirmation = {
          titleKey: 'product_confirm_delete_version_title',
          messageKey: 'product_confirm_delete_version',
          confirmed: function() {
            $scope.productInFlux = true;
            var fileHeader = ($scope.productHeaders) ? $scope.productHeaders["x-ibm-product-file"] : "";
            var id = $scope.product.info.name + ":" + $scope.product.info.version;
            $scope.product.$deleteVersion({
              orgId: $scope.orgId,
              productVersion: id,
              fileHeader: fileHeader
            }, function(data) {
              $scope.productInFlux = false;
              window.location.hash = '/design/products';
              $scope.setFavourite('product', $scope.product, true, id);
            }, function() {
              $scope.productInFlux = false;
            });
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'sm',
          scope: $scope
        });
      };
      $scope.stageVersion = function(publishTarget) {
        if ($scope.checkDirtyProduct()) {
          $scope.confirmation = {
            titleKey: 'unsavedProductDeployTitle',
            messageKey: 'unsavedProductDeployMessage',
            confirmed: function() {
              $scope.stageVersionHelper(publishTarget);
            },
            rejected: function() {
            }
          };
          $modal.open({
            templateUrl: 'apim/partials/confirmation.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'ConfirmationController',
            size: 'sm',
            scope: $scope
          });
        } else {
          $scope.stageVersionHelper(publishTarget);
        }
      };
      $scope.stageVersionHelper = function(publishTarget) {
        var messageId = new Date().getTime();
        var url = "";
        if (publishTarget.type == "SPACE") {
          $scope.$root.notifyUser('deployBeingDeployedSpace', {name: $scope.product.info.title, version: $scope.product.info.version, space: publishTarget.spaceTitle, environment: publishTarget.environmentTitle}, "BUSY", messageId);
          url = 'proxy/orgs/' + $scope.orgId + '/environments/' + publishTarget.environmentId + '/spaces/' + publishTarget.spaceId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version
        } else {
          $scope.$root.notifyUser('deployBeingDeployed', {name: $scope.product.info.title, version: $scope.product.info.version, environment: publishTarget.environmentTitle}, "BUSY", messageId);
          url = 'proxy/orgs/' + $scope.orgId + '/environments/' + publishTarget.environmentId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version;
        }
        $http.post(url)
          .success(function(data) {
            $scope.refreshDescriptors();
            // $scope.refreshVersions();
            var messageKey = "";
            if (publishTarget.type == "SPACE") {
              messageKey = "deployDoneBeingDeployedSpace";
              if (data && data.deploymentState == "pending") {
                messageKey = "deployDoneBeingDeployedSpacePending";
              }
              $scope.$root.notifyUser(messageKey, {name: $scope.product.info.title, version: $scope.product.info.version, space: publishTarget.spaceTitle, environment: publishTarget.environmentTitle}, "SUCCESS", messageId);
            } else {
              messageKey = "deployDoneBeingDeployed";
              if (data && data.deploymentState == "pending") {
                messageKey = "deployDoneBeingDeployedPending";
              }
              $scope.$root.notifyUser(messageKey, {name: $scope.product.info.title, version: $scope.product.info.version, environment: publishTarget.environmentTitle}, "SUCCESS", messageId);
            }
          }).error(function() {
            $scope.$root.notifyUser('', {}, "", messageId);
          });
      };
      $scope.downloadProduct = function() {
        var startDownload = function() {
          $scope.downloadFrame = 'proxy/orgs/' + $scope.orgId + '/products/' + $scope.product.info.name + ":" + $scope.product.info.version +
            '?headers[accept]=' + encodeURIComponent('application/vnd.ibm-apim.product+yaml') +
            '&nocache=' + new Date().getTime();
        };
        if($scope.checkDirtyProduct()) {
          $scope.confirmation = {
            titleKey: 'product_download_confirm_unsaved_changes_title',
            messageKey: 'product_download_confirm_unsaved_changes',
            confirmed: function() {
              startDownload();
            },
            rejected: function() {
            }
          };
          $modal.open({
            templateUrl: 'apim/partials/confirmation.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'ConfirmationController',
            size: 'sm',
            scope: $scope
          });
        } else {
          startDownload();
        }
      };

      $scope.createNewVersion = function() {
        $modal.open({
          templateUrl: 'apim/apis/partials/api-save-as.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ProductSaveAsController',
          size: 'sm',
          scope: $scope
        });
      };

      $scope.updateVersion = function() {
        $modal.open({
          templateUrl: 'apim/products/partials/product-update.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ProductUpdateController',
          size: 'sm',
          scope: $scope,
          backdrop: 'static'
        });
      };
  };


    angular.module('apim.products').controller('ProductSaveAsController', ['$scope', '$modalInstance', 'Product', ProductSaveAsController]);

    function ProductSaveAsController($scope, $modalInstance, Product) {
      $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
      };

      $scope.createNewVersion = function(newVersion) {
        $scope.saving = true;
        var newproduct = new Product(angular.copy($scope.product));
        $scope.cleanProduct(newproduct);
        newproduct.info.version = newVersion;
        newproduct.$create({
          orgId: $scope.orgId
        }, function(data) {
          $scope.saving = false;
          $modalInstance.dismiss('ok');
          window.location.hash = '/design/products/editor/' + newproduct.info.name + ':' + newVersion;
        });
      };
    }

    angular.module('apim.products').controller('ProductApiTocController', ['$scope', ProductApiTocController]);

    function ProductApiTocController($scope) {
      var self = this;
      self.updateNameAndKey = function() {
        $scope.apiName = $scope.getApiName($scope.api);
        $scope.apiKey = $scope.getApiKey($scope.api);
      };
      self.updateNameAndKey();
      $scope.$on('update-toc', self.updateNameAndKey);
    };



    angular.module('apim.products').controller('ProductsController', ['$scope', '$modal', 'Product', 'ProductTag', 'ProductUtil', 'uniqueFilter', 'constructTagsFilter', productsController]);

    function productsController($scope, $modal, Product, ProductTag, ProductUtil, uniqueFilter, constructTagsFilter) {

      if($scope.helpEnabled) $scope.showHelp({id: "apim_help_draft_products", template: 'apim/help/partials/help-draft-products.html'});
      $scope.setMainTab("products");	// make sure we initialise the correct menu

      $scope.setPanelExpanded = function(expanded) {
        $scope.panelExpanded = expanded;
      };

      $scope.panelExpanded = true;
      $scope.selectedTags = {'untagged': true};
      $scope.processTags = function() {
        var tags = uniqueFilter($scope.allTags, "name");
        $scope.tags = constructTagsFilter(tags, false, "productTag tinyTag fixedWidthTag");
        var selectedTags = {};
        $scope.tags.forEach(function(tag) {
          selectedTags[tag.value] = true;
        });
        $scope.selectedTags = selectedTags;
      };
      $scope.selectAllTags = function(selected) {
        for (var tag in $scope.selectedTags) {
          if ($scope.selectedTags.hasOwnProperty(tag)) {
            $scope.selectedTags[tag] = selected;
          }
        }
      };

      $scope.trackFiltering = function() {
        var selectedTags = "";
        var allSelected = true;
        if ($scope.selectedTags) {
          Object.keys($scope.selectedTags).forEach(function(tag) {
            if ($scope.selectedTags[tag]) {
              selectedTags += tag + ",";
            } else {
              allSelected = false;
            }
          });
        }
        $scope.filtered = !allSelected;
        if ($scope.firstTimeTotal <= $scope.pageSize) return;
        if (selectedTags.length > 0) selectedTags = selectedTags.substring(0, selectedTags.length - 1);
        if (allSelected && $scope.selectedTagsString != "") {
          $scope.selectedTagsString = "";
        } else {
          if ($scope.selectedTagsString != selectedTags) $scope.selectedTagsString = selectedTags;
        }
      };

      $scope['delete'] = function(product) {
        $scope.confirmation = {
          titleKey: 'product_confirm_delete_version_title',
          messageKey: 'product_confirm_delete_version',
          confirmed: function() {
            $scope.beingDeleted = true;
            if($scope.isFavourite('product', product)) {
              $scope.setFavourite('product', product);	// Remove product from favourites
            }
            product.$deleteVersion({
              orgId: $scope.orgId,
              productVersion: product.info.name + ":" + product.info.version,
              fileHeader: product.file
            }).then(function() {
              // force a full re-fetch of the API list as we could be deleting a multi-revision API
              $scope.refreshProducts();
            }, function() {
              $scope.beingDeleted = false;
            });
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'sm',
          scope: $scope
        });
      };

      $scope.refreshProducts = function() {
        ProductUtil.refreshProducts($scope);
      };

      $scope.refreshTags = function() {
        if ($scope.isOffline()) {
          $scope.allTags = [];
          return;
        }
        $scope.$watch('currentOrg', function() {
          if (!$scope.currentOrg) return;
          $scope.allTags = ProductTag.query({
            orgId: $scope.orgId
          });
          $scope.allTags.$promise.then(function() {
            $scope.processTags();
          });
        });
      };
      $scope.refreshProducts();
      $scope.refreshTags();
      $scope.orderProp = 'name';
      $scope.query = '';
      $scope['import'] = function() {
        $modal.open({
          templateUrl: 'apim/products/partials/product-import.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'CreateProductController',
          size: 'sm',
          scope: $scope,
          backdrop: 'static'
        }).result.then(function(product) {
          // close
        }, function() {
          // dismiss
        });
      };

      $scope.createProduct = function() {
        $scope.hidePublishOption = true;
        $modal.open({
          templateUrl: 'apim/products/partials/create-product.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'CreateProductController',
          size: 'lg',
          scope: $scope
        }).result.then(function(product) {
          // close
          window.location.hash = "#/design/products/editor/" + product.info.name + ":" + product.info.version;
        }, function() {
          // dismiss
        });
      };
      // need to attach a transition listener to handle slide effect properly
      var mainColumn = angular.element(document.getElementsByClassName("majorColumnLeft"));
      if (mainColumn) {
        mainColumn.on("transitionend", function() {
          var container = mainColumn.parent();
          var parentContainer = container.parent();
          if (container.hasClass("expanded")) {
            parentContainer.addClass("slideOverflow");
          } else {
            parentContainer.removeClass("slideOverflow");
          }
        });
      }
    };

    angular.module('apim.products').controller('productListController', ['$scope', 'ProductUtil', productListController]);

    function productListController($scope, ProductUtil) {
      ProductUtil.refreshProducts($scope);
    };

    angular.module('apim.products').controller('ProductVersionController', ['$scope', '$http', '$modal', 'productsQueryFilter', 'TrackingServices', ProductVersionController]);

    function ProductVersionController($scope, $http, $modal, productsQueryFilter, TrackingServices) {
      $scope.deletableTags = true;
      $scope['delete'] = function(product) {
        $scope.confirmation = {
          titleKey: 'product_confirm_delete_version_title',
          messageKey: 'product_confirm_delete_version',
          confirmed: function() {
            $scope.beingDeleted = true;
            var id = $scope.productVersion.info.name + ":" + $scope.productVersion.info.version;
            $scope.productVersion.$deleteVersion({
              orgId: $scope.orgId,
              productVersion: id,
              fileHeader: $scope.productVersion.file
            }).then(function() {
              // force a full re-fetch of the API list as we could be deleting a multi-revision API
              $scope.refreshProducts();
              $scope.setFavourite('product', $scope.productVersion, true, id);
            }, function() {
              $scope.beingDeleted = false;
            });
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'sm',
          scope: $scope
        });
      };
      $scope.assignTag = function(tag) {
        if (tag.value == "favourite" && !$scope.isFavourite('product', $scope.productVersion)) {
          $scope.setFavourite('product', $scope.productVersion);
          $scope.refreshTags();
        } else {
          $http.post('proxy/orgs/' + $scope.orgId + '/products/' + $scope.productVersion.info.name + ':' + $scope.productVersion.info.version + '/tags', {name: tag.label}).then(function(tagObject) {
            $scope.refreshTags();
          });
        }
      };
      $scope.createTag = function($event) {
        if ($event.which == 13) {
          var existing = $scope.tags.filter(function(tag) {
            return (tag.label == $scope.newTag);
          });
          if (existing.length > 0) {
            $scope.tagDropdownOpen = false;
            return;
          }
          $http.post('proxy/orgs/' + $scope.orgId + '/products/' + $scope.productVersion.info.name + ':' + $scope.productVersion.info.version + '/tags', {name: $scope.newTag}).then(function(tagObject) {
            $scope.refreshTags();
          });
          $scope.newTag = "";
          $scope.tagDropdownOpen = false;
        }
      };
      $scope.deleteTag = function(tag) {
        if (tag.value == "favourite" && $scope.isFavourite('product', $scope.productVersion)) {
          $scope.setFavourite('product', $scope.productVersion, true);
          $scope.refreshTags();
        } else {
          $http['delete']('proxy/orgs/' + $scope.orgId + '/products/' + $scope.productVersion.info.name + ':' + $scope.productVersion.info.version + '/tags/' + tag.label).then(function() {
            $scope.refreshTags();
          });
        }
      };
    };


    angular.module('apim.products').controller('ProductUpdateController', ['$scope', '$modalInstance', '$filter', 'uiUploader', 'Product', 'errorHandler', productUpdateController]);

    function productUpdateController($scope, $modalInstance, $filter, uiUploader, Product, errorHandler) {
      $scope.importLabelText = $filter('translate')('product_update_description');
      $scope.cancel = function() {
        $modalInstance.dismiss('cancel');
      };
      $scope.attachToFileInput = function() {
        $scope.productFileInput = document.getElementById('product_file');
        if ($scope.productFileInput) {
          $scope.productFileInput.addEventListener('change', function(e) {
            var files = e.target.files;
            uiUploader.removeAll();
            uiUploader.addFiles(files);
            $scope.selectedProductFile = uiUploader.getFiles()[0];
            $scope.importLabelText = $scope.selectedProductFile.name;
            $scope.$apply();
          });
        } else {
          setTimeout($scope.attachToFileInput, 500);
        }
      };
      $modalInstance.opened.then(function() {
        $scope.attachToFileInput();
      });
      $scope.update = function() {
        $scope.updatingProduct = true;
        var url = 'proxy/orgs/' + $scope.orgId + '/products/' + $scope.product.info.name + ":" + $scope.product.info.version;
        uiUploader.startUpload({
          url: url,
          onProgress: function(file) {

          },
          onCompleted: function(file, response) {
            $scope.updatingProduct = false;
            $modalInstance.dismiss('ok');
            var responseObject = response;
            if (typeof response == "string") {
              responseObject = JSON.parse(response);
            }
            responseObject.data = responseObject.responseText;
            responseObject.config = {url: url};
            errorHandler.checkResponse(responseObject);
            if(responseObject.product) {
              window.location.hash = '/design/products/editor/' + responseObject.info.name + ':' + responseObject.info.version;
              $scope.setProduct(responseObject);
            }
          },
          onCompletedAll: function() {
          }
        });
      };
    };


    angular.module('apim.products').controller('ProductVisualEditorController', ['$scope', '$http', '$q', '$modal', '$filter', 'uniqueFilter', 'communityToTagFilter', 'Product', 'ProductUtil', 'Api', 'DeployedProduct', 'translateFilter', 'translateMultipleFilter',  'planLevelRateLimitFilter', 'resourceLevelTaskFilter', 'planLevelTaskFilter', 'SlugService', 'DirtyService', ProductVisualEditorController]);

    function ProductVisualEditorController($scope, $http, $q, $modal, $filter, uniqueFilter, communityToTagFilter, Product, ProductUtil, Api, DeployedProduct, translateFilter, translateMultipleFilter, planLevelRateLimitFilter, resourceLevelTaskFilter, planLevelTaskFilter, SlugService, DirtyService) {
      $scope.orderProp = "path";

      $scope.hasApis = function() {
        if (!$scope.product) return false;
        return !_.isEmpty($scope.product.apis);
      };
      $scope.showPlanContent = function(planName) {
        if($scope.visiblePlan == planName) $scope.visiblePlan = null;
        else $scope.visiblePlan = planName;
      };
      $scope.shouldShowPlanContent = function(planName) {
        return $scope.visiblePlan == planName;
      };

      $scope.onNavigateOut = function() {
        var deferred = $q.defer();
        if($scope.checkDirtyProduct()) {
          $scope.confirmation = {
            titleKey: 'unsavedChanges',
            message: $filter('translate')($scope.product.info.title, 'product_unsaved_changes', 'productTitle'),
            confirmed: function() {
              DirtyService.clearDirty('ProductEditorController');
              deferred.resolve(true);
            },
            rejected: function() {
              deferred.reject();
            }
          };
          $modal.open({
            templateUrl: 'apim/partials/confirmation.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'ConfirmationController',
            scope: $scope
          });
        } else {
          deferred.resolve(true);
        }
        return deferred.promise;
      };

      $scope.selectAPIs = function() {
        $modal.open({
          templateUrl: 'apim/products/partials/api-selector.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ProductAPISelectorController',
          size: 'lg',
          scope: $scope
        });
      };

      $scope.$watch('product', function() {
        if (!$scope.product || !$scope.product.info) return;
        $scope.productLoaded = true;
        $scope.planLevelRateLimit = planLevelRateLimitFilter($scope.planVersion);
        $scope.rateLimit = $scope.planLevelRateLimit;

        // if(!$scope.product.visibility) {
          // 	$scope.product.visibility = {view: {type: "public"}, subscribe: {type: "authenticated"}};
          // }

        var selectedViewTags = [];
        if($scope.product.visibility && $scope.product.visibility.view.tags) {
          $scope.product.visibility.view.tags.forEach(function(tag) {
            selectedViewTags.push({name: tag});
          });
        }
        if($scope.product.visibility && $scope.product.visibility.view.orgs) {
          $scope.product.visibility.view.orgs.forEach(function(tag) {
            selectedViewTags.push({name: tag});
          });
        }
        selectedViewTags = uniqueFilter(selectedViewTags, "name");
        $scope.selectedOrgsVisible = communityToTagFilter(selectedViewTags, false);

        var selectedSubscribeTags = [];
        if($scope.product.visibility && $scope.product.visibility.subscribe.tags) {
          $scope.product.visibility.subscribe.tags.forEach(function(tag) {
            selectedSubscribeTags.push({name: tag});
          });
        }
        if($scope.product.visibility && $scope.product.visibility.subscribe.orgs) {
          $scope.product.visibility.subscribe.orgs.forEach(function(tag) {
            selectedSubscribeTags.push({name: tag});
          });
        }
        selectedSubscribeTags = uniqueFilter(selectedSubscribeTags, "name");
        $scope.selectedOrgsSubscribable = communityToTagFilter(selectedSubscribeTags, false);
      });

      $scope.createPlan = function() {
        if (!$scope.product.plans) $scope.product.plans = {};
        var index = 1;

        var planTitle = $filter('translate')("newPlan", {"number":index});
        var planName = SlugService.createUniqueName("new plan", $scope.product.plans);

        var updatedPlans = {};
        updatedPlans[planName] = {"title": planTitle, "apis": {}};
        for(var name in $scope.product.plans) {
          updatedPlans[name] = $scope.product.plans[name];
        }
        $scope.product.plans = updatedPlans;
      };
      $scope.deletePlan = function($event, planName) {
        $event.stopPropagation();
        $scope.confirmation = {
          titleKey: 'product_confirm_plan_delete_title',
          messageKey: 'product_confirm_plan_delete',
          confirmed: function() {
            delete $scope.product.plans[planName];
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'sm',
          scope: $scope
        });
      };
      $scope.pruneApi = function(api) {
        // remove it from any plans
        var apiName = ProductUtil.getUsedRefForApi($scope.product, api);
        Object.keys($scope.product.plans).forEach(function(planName) {
          if ($scope.product.plans[planName].apis) {
            delete $scope.product.plans[planName].apis[apiName];
          }
        });
        delete $scope.product.apis[apiName];
      };
      $scope.zeroPlans = function() {
        return (!$scope.product || !$scope.product.plans || Object.keys($scope.product.plans).length == 0);
      };
      $scope.planDropped = function(planName, node, index) {
        console.log("Dropped at index " + index);
        // data is the planName
        // index is the plan at which we should position the plan
        // i.e. index 0 means position it after the zero index plan
        // undefined index means right at the start
        var newPlans = {};
        var existingPlans = Object.keys($scope.product.plans);
        if (index === undefined) {
          index = existingPlans.length;
        }
        var x, thisPlanName;
        for (x = 0; x < index; x++) {
          thisPlanName = existingPlans[x];
          if (thisPlanName !== planName) {
            newPlans[thisPlanName] = $scope.product.plans[thisPlanName];
          }
        }
        // insert it now...
          newPlans[planName] = $scope.product.plans[planName];
        for (x = index; x < existingPlans.length; x++) {
          thisPlanName = existingPlans[x];
          if (thisPlanName !== planName) {
            newPlans[thisPlanName] = $scope.product.plans[thisPlanName];
          }
        }
        $scope.product.plans = {};
        setTimeout(function() {
          $scope.product.plans = newPlans;
          $scope.$apply();
        }, 0);
      };
    };

    angular.module('apim.products').controller('ProductApiController', ['$scope', '$modal', 'ProductUtil', productAPIController]);

    function productAPIController($scope, $modal, ProductUtil) {

      var setApi = function() {
        $scope.apiVersion = $scope.getApiByRef($scope.api);
        if ($scope.apiVersion) {
        } else {
          $scope.apiRef = $scope.api.$ref;
        }
      };

      $scope.$watchCollection('apisByRef', function() {
        if (_.isEmpty($scope.apisByRef)) return;
        setApi();
      });

      $scope.showApiResolver = function() {
        var modalInstance = $modal.open({
          templateUrl: 'apim/products/partials/api-resolver.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ProductAPIResolverController',
          size: 'lg',
          scope: $scope
        });
        modalInstance.result.then(function(api) {
          var apiRefName = ProductUtil.getUsedRefForApi($scope.product, $scope.api);
          $scope.api = api.$$refObj;
          $scope.product.apis[apiRefName] = $scope.api;
          // var apiRef = $scope.apiRef;
          setApi();
          // $scope.updateRef(apiRef, $scope.api['$ref']);
          delete $scope.apiRef;
        });
      };
      $scope.removeApi = function() {
        $scope.confirmation = {
          titleKey: 'product_confirm_remove_api_title',
          messageKey: 'product_confirm_remove_api',
          confirmed: function() {
            $scope.pruneApi($scope.api);
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'sm',
          scope: $scope
        });
      };
    };

angular.module('apim.products').controller('ProductPlanEditor', ['$scope', 'translateFilter', 'DeveloperOrganization', 'ProductCurrency', productPlanEditor]);

function productPlanEditor($scope, translateFilter, DeveloperOrganization, ProductCurrency) {

  $scope.currencies = ProductCurrency.getCurrencies();
  $scope.models = {};
  $scope.amounts = {};

  // take care of fractions in currency input
  $scope.removeFractional = function(amount, fractions) {
    return Math.round(amount * Math.pow(10, fractions));
  };

  $scope.addFractional = function(amount, fractions) {
    return  amount / Math.pow(10, fractions);
  };

  // add watcher to plan amount
  var amountWatcher = function(newValue, oldValue) {
    if ($scope.plan['billing-model']) {
      var fractional = $scope.addFractional(newValue, $scope.fractionLength);
      if (!isNaN(fractional) && $scope.amounts.amount != fractional) {
        $scope.amounts.amount = fractional;
      }
    }
  };

  var decimalCount = function(num) {
    if (Math.floor(num) === num) return 0;
    var decimal = num.toString().split('.');
    return decimal[1].length;
  };

  var getFractions = function() {
    return $scope.currencies[$scope.plan['billing-model'].currency].fractions;
  };

  $scope.$watch('amounts',  function(newValue, oldValue) {
    if ($scope.plan['billing-model']) {
      if (isNaN(parseInt(newValue.amount)) && !isNaN(parseInt(oldValue.amount))) {
        delete $scope.plan['billing-model'].amount;
      } else {
        if ((!isNaN(parseInt(newValue.amount)) && decimalCount(newValue.amount) > $scope.fractionLength) || (newValue.amount > (99999999 / Math.pow(10, $scope.fractionLength)))) {
          newValue.amount = oldValue.amount;
        }
        var nonfractional = $scope.removeFractional(newValue.amount, $scope.fractionLength);
        if (!isNaN(nonfractional) && $scope.plan['billing-model'].amount != nonfractional) {
          $scope.plan['billing-model'].amount = nonfractional;
        }
      }
    }
  }, true);

  // update tooltip for currency
  var updateTooltip = function() {
    $scope.currencyTooltip = translateFilter('monetizationMonthlyTooltip', {
      currency: $scope.plan['billing-model'].currency,
      minimum: ProductCurrency.getMinimum($scope.plan['billing-model'].currency)
    });
  };

  $scope.changeCurrency = function() {
    $scope.fractionLength = getFractions();
    delete $scope.amounts.amount;
    updateTooltip();
  }

  // populate models on load
  if ($scope.plan['billing-model']) {
    $scope.models[$scope.planName] = 'stripe_monthly_fixed';
    $scope.fractionLength = getFractions();
    updateTooltip();
    $scope.$watch("plan['billing-model'].amount", amountWatcher, true);
  } else {
    $scope.models[$scope.planName] = 'none';
  };

  // update hidden dropdown
  $scope.updateBillingPlan = function(val) {
    if (val === 'none') {
      delete $scope.plan['billing-model'];
    } else {
      $scope.plan['billing-model'] = {
        model: val,
        currency: 'USD',
        provider: 'stripe',
        amount: 0,
        'trial-period-days': 0
      };
      $scope.amounts.amount = 0;
      $scope.fractionLength = 2;
      $scope.$watch("plan['billing-model'].amount", amountWatcher, true);
    }
  };

      $scope.name = function(newName) {
        if (arguments.length) {
          // Setter
          if (newName == $scope.planName) return;
          if ($scope.product.plans[newName]) {
            // cowardly refuse to replace an existing plan
            return;
          }
          var updatedPlans = {};
          for(var planName in $scope.product.plans) {
            if(planName == $scope.planName) {
              updatedPlans[newName] = $scope.product.plans[planName];
            } else {
              updatedPlans[planName] = $scope.product.plans[planName];
            }
          }
          $scope.product.plans = updatedPlans;
          if($scope.shouldShowPlanContent($scope.planName)) {
            $scope.showPlanContent(newName);
          }
          $scope.planName = newName;
        } else {
          // Getter
          return $scope.planName;
        }
      };

      function getNextLimitName(container, prefix) {
        var i = 1;
        while (container[prefix + "-" + i]) i++;
        return prefix + "-" + i;
      };

      $scope.addBurstLimit = function() {
        convertRateLimitToGroup();
        if (!$scope.plan['burst-limits']) $scope.plan['burst-limits'] = {};
        var limitName = getNextLimitName($scope.plan['burst-limits'], 'burst-limit');
        $scope.plan['burst-limits'][limitName] = {value: "1/minute"};
      };

      $scope.deleteBurstLimit = function(name) {
        delete $scope.plan['burst-limits'][name];
        if (_.isEmpty($scope.plan['burst-limits'])) delete $scope.plan['burst-limits'];
      };

      $scope.addRateLimit = function() {
        convertRateLimitToGroup();
        var limitName = getNextLimitName($scope.plan['rate-limits'], 'rate-limit');
        $scope.plan['rate-limits'][limitName] = {value: "1/minute"};
      };

      function convertRateLimitToGroup() {
        if (!$scope.plan['rate-limits']) {
          $scope.plan['rate-limits'] = {};
          // lazily migrate separate rate limits
          if ($scope.plan['rate-limit']) {
            // if it's anything but unlimited...
            if ($scope.plan['rate-limit'].value !== 'unlimited') {
              $scope.plan['rate-limits']['rate-limit-1'] =
                {value: $scope.plan['rate-limit'].value};
            }
            delete $scope.plan['rate-limit'];
          }
        }
      }

      $scope.deleteRateLimit = function(name) {
        if (name === undefined) {
          // delete the singleton
          delete $scope.plan['rate-limit'];
        } else {
          delete $scope.plan['rate-limits'][name];
          if (_.isEmpty($scope.plan['rate-limits'])) delete $scope.plan['rate-limits'];
        }
      };

      $scope.unlimitedRateLimit = function() {
        if (!$scope.plan['rate-limit'] && (!$scope.plan['rate-limits'] || _.isEmpty($scope.plan['rate-limits']))) return true;
        if (!$scope.plan['rate-limits'] || _.isEmpty($scope.plan['rate-limits'])) {
          if ($scope.plan['rate-limit'].value == "unlimited") return true;
        }
        return false;
      };
    };

    angular.module('apim.products').controller('ProductVisibilityEditor', ['$scope', 'communityToTagFilter', 'translateFilter', productVisibilityEditor]);

    function productVisibilityEditor($scope, communityToTagFilter, translateFilter) {

      // create lookup tables for options
      $scope.visibleOptions = [
        {id: "public", name: translateFilter("planPublic")},
        {id: "authenticated", name: translateFilter("planAuthenticated")},
        {id: "custom", name: translateFilter("planCustom")}
      ];
      $scope.subscribeOptions = [
        {id: "authenticated", name: translateFilter("planAuthenticated")},
        {id: "custom", name: translateFilter("planCustom")}
      ];

      var defaultVisiblity = {view: {type: "public"}, subscribe: {type: "authenticated"}};

      var visibility;

      $scope.$watch('product', function() {
        if(!$scope.product) return;
        visibility = $scope.product.visibility || defaultVisiblity;
        // if(!$scope.product.visibility) {
          // 	$scope.product.visibility = {view: {type: "public"}, subscribe: {type: "authenticated"}};
          // }
        $scope.visibleTo = visibility.view.type;
        $scope.subscribableBy = visibility.subscribe.type;

        // tie together related variables
        var firstWatchHitVisibleTo = false;
        $scope.$watch('visibleTo', function() {
          if (firstWatchHitVisibleTo == false) {
            firstWatchHitVisibleTo = true;
            return;
          }
          $scope.product.visibility = visibility;
          if ($scope.visibleTo == "custom") $scope.subscribableBy = "custom";
          $scope.product.visibility.view.type = $scope.visibleTo;
          $scope.product.visibility.subscribe.type = $scope.subscribableBy;
          if($scope.product.visibility.view.type != "custom") {
            delete $scope.product.visibility.view.tags;
            delete $scope.product.visibility.view.orgs;
          } else if ($scope.product.visibility.view.type == "custom") {
            // replicate subscribable tags if empty list
            if ((!$scope.product.visibility.view.tags || $scope.product.visibility.view.tags.length == 0) &&
              $scope.product.visibility.subscribe.tags) {
                $scope.product.visibility.view.tags = [].concat($scope.product.visibility.subscribe.tags);
            }
            if ((!$scope.product.visibility.view.orgs || $scope.product.visibility.view.orgs.length == 0) &&
              $scope.product.visibility.subscribe.orgs) {
                $scope.product.visibility.view.orgs = [].concat($scope.product.visibility.subscribe.orgs);
            }
            $scope.selectedOrgsVisible = [].concat($scope.selectedOrgsSubscribable);
            $scope.userInputVisible = "";
          }
        });
        var firstWatchHitSubscribableBy = false;
        $scope.$watch('subscribableBy', function() {
          if (firstWatchHitSubscribableBy == false) {
            firstWatchHitSubscribableBy = true;
            return;
          }
          $scope.product.visibility = visibility;
          if ($scope.subscribableBy != "custom" && $scope.visibleTo == "custom") $scope.visibleTo = "authenticated";
          $scope.product.visibility.view.type = $scope.visibleTo;
          $scope.product.visibility.subscribe.type = $scope.subscribableBy;
          if($scope.product.visibility.subscribe.type != "custom") {
            delete $scope.product.visibility.subscribe.tags;
            delete $scope.product.visibility.subscribe.orgs;
          }
        });
      });

      $scope.addVisibilityTag = function(event) {
        if(!$scope.selectedOrgsVisible) $scope.selectedOrgsVisible = [];
        var filtered = $scope.selectedOrgsVisible.filter(function(tag) {
          return (tag.value == $scope.userInputVisible);
        });
        if (filtered.length > 0) {
          //tag already exists, so don't add it again
          $scope.userInputVisible = "";
          return;
        }
        var tag = {name: $scope.userInputVisible};
        // if(!$scope.selectedCommunitiesVisible) $scope.selectedCommunitiesVisible = [];
        $scope.selectedOrgsVisible.push(communityToTagFilter([tag], false)[0]);
        // $scope.selectedCommunitiesVisible.push(communityToTagFilter([tag], false)[0]);
        $scope.userInputVisible = "";

        $scope.product.visibility.view.tags = [];
        $scope.product.visibility.view.orgs = [];
        $scope.selectedOrgsVisible.forEach(function(org) {
          $scope.product.visibility.view.tags.push(org.value);
          $scope.product.visibility.view.orgs.push(org.value);
        });
      };

      $scope.addSubscribabilityTag = function(event) {
        if(!$scope.selectedOrgsSubscribable) $scope.selectedOrgsSubscribable = [];
        var filtered = $scope.selectedOrgsSubscribable.filter(function(tag) {
          return (tag.value == $scope.userInputSubscribable);
        });
        if (filtered.length > 0) {
          //tag already exists, so don't add it again
          $scope.userInputSubscribable = "";
          return;
        }
        $scope.userInputVisible = $scope.userInputSubscribable;
        // only replicate to visibility if it's custom
        if ($scope.product.visibility.view.type == "custom") {
          $scope.addVisibilityTag(event);
        }

        var tag = {name: $scope.userInputSubscribable};
        // if(!$scope.selectedCommunitiesSubscribable) $scope.selectedCommunitiesSubscribable = [];
        $scope.selectedOrgsSubscribable.push(communityToTagFilter([tag], false)[0]);
        // $scope.selectedCommunitiesSubscribable.push(communityToTagFilter([tag], false)[0]);
        $scope.userInputSubscribable = "";

        $scope.product.visibility.subscribe.tags = [];
        $scope.product.visibility.subscribe.orgs = [];
        $scope.selectedOrgsSubscribable.forEach(function(org) {
          $scope.product.visibility.subscribe.tags.push(org.value);
          $scope.product.visibility.subscribe.orgs.push(org.value);
        });
      };

      $scope.deleteTag = function(tagToDelete) {
        if($scope.selectedOrgsVisible) {
          $scope.selectedOrgsVisible = $scope.selectedOrgsVisible.filter(function(tag) {
            return (tag.value != tagToDelete.value);
          });
          $scope.product.visibility.view.tags = $scope.product.visibility.view.tags.filter(function(tag) {
            return (tag != tagToDelete.value);
          });
          $scope.product.visibility.view.orgs = $scope.product.visibility.view.orgs.filter(function(tag) {
            return (tag != tagToDelete.value);
          });
        }
        if($scope.selectedOrgsSubscribable) {
          $scope.selectedOrgsSubscribable = $scope.selectedOrgsSubscribable.filter(function(tag) {
            return (tag.value != tagToDelete.value);
          });
          $scope.product.visibility.subscribe.tags = $scope.product.visibility.subscribe.tags.filter(function(tag) {
            return (tag != tagToDelete.value);
          });
          $scope.product.visibility.subscribe.orgs = $scope.product.visibility.subscribe.orgs.filter(function(tag) {
            return (tag != tagToDelete.value);
          });
        }
      };
    };

    angular.module('apim.products').controller('ProductPlanApiController', ['$scope', 'Api', productPlanAPIController]);

    function productPlanAPIController($scope, Api) {

      /* jshint validthis: true */
        var self = this;

      $scope.expandContent = function() {
        if (!$scope.apiVersion || !$scope.apiVersion.swagger) {
          // we haven't pulled the real API yet
          if ($scope.apiVersion && $scope.apiVersion.$promise) return;
          $scope.loadingOperations = true;
          var apiId = "";
          if ($scope.apiVersion) {
            apiId = $scope.apiVersion.$$name + ":" + $scope.apiVersion.info.version;
          } else if ($scope.api.id) {
            apiId = $scope.api.id;
          } else {
            apiId = $scope.api.name;
          }
          Api.get({
            orgId: $scope.orgId,
            apiId: apiId
          }, function(data) {
            $scope.loadingOperations = false;
            $scope.apiVersion = data;
            $scope.setApiByRef(data);
            $scope.buildOperations($scope.apiVersion);
            $scope.showApiContent = !$scope.showApiContent;
            $scope.updateToc();
          }, function(error) {
            $scope.loadingOperations = false;
          });
        } else if (!$scope.apiVersion.operations) {
          $scope.buildOperations($scope.apiVersion);
          $scope.showApiContent = !$scope.showApiContent;
        } else {
          $scope.showApiContent = !$scope.showApiContent;
        }
      };
      var setApi = function() {
        $scope.$watch('apisByRef', function() {
          if (!$scope.apisByRef) return;
          $scope.apiVersion = $scope.getApiByRef($scope.api);
          $scope.setPlanApi();
        });
      };
      $scope.$watch('api.$ref', setApi);
      $scope.setPlanApi = function() {
        if ($scope.plan.apis) {
          $scope.planApi = $scope.plan.apis[$scope.apiName] || {};
        } else {
          $scope.planApi = {};
        }
      };

      var firstWatch = false;
      $scope.$watch('planApi', function() {
        if (!$scope.planApi) return;
        if (!firstWatch) {
          firstWatch = true;
          return;
        }
        if (_.isEmpty($scope.planApi)) {
          planApiDefaulted($scope.planApi, $scope.apiName);
        } else {
          planApiCustomized($scope.planApi, $scope.apiName);
        }
      }, true);

      var planApiDefaulted = function(planApi, apiName) {
        // user has defaulted a plan... might be able to reset to defaults
        $scope.plan.apis[apiName] = {};
        if (isIdentityApi()) delete $scope.plan.apis;
      };

      var planApiCustomized = function(planApi, apiName) {
        // user has customized a plan... maybe breaking from defaults
        if (_.isEmpty($scope.plan.apis)) {
          populateApis([apiName]);
        }
        $scope.plan.apis[apiName] = planApi;
        if (isIdentityApi()) delete $scope.plan.apis;
      };

      function populateApis(excluding) {
        if (!excluding || excluding.length == 0) {
          $scope.plan.apis = {};
        } else {
          if (!$scope.plan.apis) $scope.plan.apis = {};
          Object.keys($scope.product.apis).forEach(function(apiName) {
            if (excluding.indexOf(apiName) < 0) {
              $scope.plan.apis[apiName] = $scope.plan.apis[apiName] || {};
            }
          });
        }
      }

      function isIdentityApi() {
        if (_.isEmpty($scope.plan.apis)) return true;
        var isIdentity = true;
        Object.keys($scope.product.apis).forEach(function(apiName) {
          if (!$scope.plan.apis[apiName] || Object.keys($scope.plan.apis[apiName]).length !== 0) {
            isIdentity = false;
          }
        });
        return isIdentity;
      }

      $scope.apiSelected = function(value) {
        if (value != undefined) {
          //setter
          if (value) {
            if (!$scope.plan.apis) $scope.plan.apis = {};
            $scope.plan.apis[$scope.apiName] = $scope.plan.apis[$scope.apiName] || {};
            if (isIdentityApi()) delete $scope.plan.apis;
          } else {
            // ok, we're removing an API from a plan... is it the last one?
              if ($scope.plan.apis && Object.keys($scope.plan.apis).length == 1 && $scope.plan.apis[$scope.apiName]) {
                $scope.$root.notifyUser('product_plan_must_contain_api', [], "ERROR");
                return;
              }
            if ($scope.plan.apis) delete $scope.plan.apis[$scope.apiName];
            if (_.isEmpty($scope.plan.apis)) populateApis([$scope.apiName]);
            if (_.isEmpty($scope.plan.apis)) delete $scope.plan.apis;
            firstWatch = false;
          }
          $scope.setPlanApi();
        } else {
          //getter
          if (!$scope.plan.apis) return true;
          if (_.isEmpty($scope.plan.apis)) return true;
          return !!$scope.plan.apis[$scope.apiName];
        }
      };

      $scope.selectAllOperations = function() {
        var operations = [];
        $scope.apiVersion.operations.forEach(function(operation) {
          operations.push({
            operation: operation.operation,
            path: operation.path
          });
        });
        $scope.planApi.operations = operations;
      };
    };

    angular.module('apim.products').controller('ProductPlanApiOperationController', ['$scope', productPlanAPIOperationController]);

    function productPlanAPIOperationController($scope) {

      $scope.$on('addOperation', function(event, args) {
        if(!$scope.planApi.operations) return;

        var alreadyAdded = false;
        for(var i=0; i<$scope.planApi.operations.length; i++) {
          if($scope.planApi.operations[i].operation == $scope.operation.operation && $scope.planApi.operations[i].path == $scope.operation.path) {
            alreadyAdded = true;
          }
        }
        if(!alreadyAdded) {
          $scope.planApi.operations.push({
            operation: $scope.operation.operation,
            path: $scope.operation.path
          });
        }
      });

      function getNextLimitName(container, prefix) {
        var i = 1;
        while (container[prefix + "-" + i]) i++;
        return prefix + "-" + i;
      };

      $scope.addRateLimit = function() {
        if (!$scope.planApiOperation['rate-limits']) {
          $scope.planApiOperation['rate-limits'] = {};
          // lazily migrate separate rate limits
          if ($scope.planApiOperation['rate-limit']) {
            // if it's anything but unlimited...
              if ($scope.planApiOperation['rate-limit'].value !== "unlimited") {
                $scope.planApiOperation['rate-limits']['rate-limit-1'] = {value: $scope.planApiOperation['rate-limit'].value};
              }
            delete $scope.planApiOperation['rate-limit'];
          }
        }
        var limitName = getNextLimitName($scope.planApiOperation['rate-limits'], 'rate-limit');
        $scope.planApiOperation['rate-limits'][limitName] = {value: "1/minute"};
      };

      $scope.$unlimitedRateLimit = function(value) {
        if (typeof value !== "undefined") {
          // setter
          if (value) {
            delete $scope.planApiOperation['rate-limit'];
            $scope.planApiOperation['rate-limits'] = {'unlimited': {value: "unlimited"}};
          } else {
            delete $scope.planApiOperation['rate-limit'];
            $scope.planApiOperation['rate-limits'] = {'rate-limit-1': {value: "1/minute"}};
          }
        } else {
          // getter
          if ($scope.planApiOperation['rate-limit'] && $scope.planApiOperation['rate-limit'].value === "unlimited") return true;
          if ($scope.planApiOperation['rate-limits'] && Object.keys($scope.planApiOperation['rate-limits']).length === 1 && $scope.planApiOperation['rate-limits'][Object.keys($scope.planApiOperation['rate-limits'])[0]].value === "unlimited") return true;
          return false;
        }
      };

      $scope.deleteRateLimit = function(name) {
        if (name === undefined) {
          // delete the singleton
          delete $scope.planApiOperation['rate-limit'];
        } else {
          delete $scope.planApiOperation['rate-limits'][name];
          if (_.isEmpty($scope.planApiOperation['rate-limits'])) delete $scope.planApiOperation['rate-limits'];
        }
      };

      $scope.operationSelected = function(value) {
        if (value != undefined) {
          // setter
          if (value) {
            // user has selected the operation
            if (!$scope.planApi.operations) {
              // but we don't currently have anything selected... unusual case...
                $scope.planApi.operations = [{
                  operation: $scope.operation.operation,
                  path: $scope.operation.path
                }];
            } else {
              // add it to the list of selected operations... usual case...
                $scope.planApi.operations.push({
                  operation: $scope.operation.operation,
                  path: $scope.operation.path
                });
              if ($scope.planApi.operations.length == $scope.apiVersion.operations.length) {
                // we've selected all operations - go to default include-all logic
                var operationsWithRateLimits = $scope.planApi.operations.filter(function(thisOperation) {
                  return (thisOperation['rate-limit']);
                });
              }
            }
          } else {
            // user has selected to remove an operation
            var filtered;
            if ($scope.planApi.operations) {
              // we already have a subset of operations for this api
              filtered = $scope.planApi.operations.filter(function(thisOperation) {
                return (thisOperation.operation !== $scope.operation.operation || thisOperation.path !== $scope.operation.path);
              });
              if (filtered.length > 0) {
                // there are still some operations selected
                $scope.planApi.operations = filtered;
              } else {
                // we've just de-selected the last operation - back to default include-all logic
                $scope.apiSelected(false);
                // delete $scope.planApi.operations;
              }
            } else {
              // we're de-selecting an operation from a default list, so
              // populate the list with all the *other* operations
              filtered = $scope.apiVersion.operations.filter(function(thisOperation) {
                return (thisOperation.operation !== $scope.operation.operation || thisOperation.path !== $scope.operation.path);
              });
              var selectedOperations = [];
              filtered.forEach(function(thisOperation) {
                selectedOperations.push({
                  operation: thisOperation.operation,
                  path: thisOperation.path
                });
              });
              $scope.planApi.operations = selectedOperations;
            }
          }
        } else {
          // getter
          if (!$scope.planApi) return false;
          if (!$scope.planApi.operations) {
            // default case - all operations are selected by default
            return true;
          } else {
            return $scope.planApi.operations.filter(function(thisOperation) {
              return (thisOperation.operation == $scope.operation.operation && thisOperation.path == $scope.operation.path);
            }).length > 0;
          }
        }
      };

      $scope.getPlanApiOperation = function() {
        if (!$scope.planApi || !$scope.planApi.operations) return null;
        var filtered = $scope.planApi.operations.filter(function(thisOperation) {
          return (thisOperation.operation == $scope.operation.operation && thisOperation.path == $scope.operation.path);
        });
        if (filtered.length > 0) {
          $scope.planApiOperation = filtered[0];
          return filtered[0];
        }
        return null;
      };

      $scope.showRateLimitContent = function() {
        if (!$scope.operationSelected()) return false;
        var apiOperation = $scope.getPlanApiOperation();
        if (!apiOperation) return false;
        return apiOperation['rate-limit'] || apiOperation['rate-limits'];
      };

      $scope.setRateLimit = function($event) {
        $event.stopPropagation();
        // if this operation isn't *explicitly* selected, make it so...
          if (!$scope.planApi.operations) {
            $scope.selectAllOperations();
          }
        // if this operation isn't selected...
          if (!$scope.operationSelected()) $scope.operationSelected(true);
        if (!$scope.planApi.operations) return;
        var filtered = $scope.planApi.operations.filter(function(thisOperation) {
          return (thisOperation.operation == $scope.operation.operation && thisOperation.path == $scope.operation.path);
        });
        if (filtered.length > 0) {
          var theOperation = filtered[0];
          if (theOperation['rate-limit']) {
            theOperation['rate-limits'] = {'rate-limit-1': theOperation['rate-limit']};
            delete theOperation['rate-limit'];
          }
          if (!theOperation['rate-limits'] || _.isEmpty(theOperation['rate-limits'])) {
            theOperation['rate-limits'] = {'rate-limit-1': {value: "1/1minute"}};
          }
        }
      };

      $scope.clearRateLimit = function($event) {
        $event.stopPropagation();
        var filtered = $scope.planApi.operations.filter(function(thisOperation) {
          return (thisOperation.operation == $scope.operation.operation && thisOperation.path == $scope.operation.path);
        });
        if (filtered.length > 0) {
          delete filtered[0]['rate-limit'];
          delete filtered[0]['rate-limits'];
        }
        if ($scope.planApi.operations.length == $scope.apiVersion.operations.length) {
          var operationsWithRateLimits = $scope.planApi.operations.filter(function(thisOperation) {
            return (thisOperation['rate-limit'] || thisOperation['rate-limits']);
          });
          if(operationsWithRateLimits.length == 0) delete $scope.planApi.operations;
        }
      };
    };

    angular.module('apim.products').controller('ProductAPISelectorController', ['$scope', 'ProductUtil', ProductAPISelectorController]);

    function ProductAPISelectorController($scope, ProductUtil) {
      // Reset the selected items and the search query
      $scope.selectedAPIs = {};
      $scope.apiTitleQuery = '';

      // Refresh the list of APIs. This gives a clean slate (no filters applied)
      $scope.xhrQueryingAPIs = true;
      $scope.refreshApis('', true)
        .then(function(apis) {
          apis.forEach(function(api) {
            // Check to see if the APIs are attached to the product already
            var selected = ProductUtil.containsApi($scope.product, api);
            $scope.selectedAPIs[api.$$ref] = selected;
          });
        })
        .finally(function() {
          $scope.xhrQueryingAPIs = false;
        });

      // Filter the list of APIs based on the search query when it's changed
      $scope.queryForApis = function() {
        $scope.xhrQueryingAPIs = true;
        $scope.refreshApis($scope.apiTitleQuery, true)
          .finally(function() {
            $scope.xhrQueryingAPIs = false;
          });
      };

      // Stage the APIs to the product so they can be saved later
      $scope.apply = function() {
        // have any APIs been removed?
          Object.keys($scope.selectedAPIs).forEach(function(apiNameRef) {
            var api = $scope.getApiByRef(apiNameRef);
            var productContainsApi = ProductUtil.containsApi($scope.product, api);
            if (!api) return;
            if ($scope.selectedAPIs[apiNameRef] == false && productContainsApi) {
              // this one has been removed
              $scope.pruneApi(api);
            }
            if ($scope.selectedAPIs[apiNameRef] == true && !productContainsApi) {
              // this one has been added
              if (!$scope.product.apis) $scope.product.apis = {};
              var internalRef = ProductUtil.getNewRefForApi($scope.product, api);
              $scope.product.apis[internalRef] = api.$$refObj;
            }
          });
        $scope.$close();
      };
    };

    angular.module('apim.products').controller('ProductAPIResolverController', ['$scope', '$modalInstance', 'translateFilter', productAPIResolverController]);

    function productAPIResolverController($scope, $modalInstance, translateFilter) {
      var firstWatchApiQuery = false;
      $scope.refreshApis("");	// always refresh full list on startup
      $scope.unwatchQueryString = $scope.$watch('apiTitleQuery', function() {
        if (!firstWatchApiQuery) {
          firstWatchApiQuery = true;
          return;
        }
        $scope.refreshApis($scope.apiTitleQuery);
      });
      $scope.message = translateFilter("product_resolve_api_description", {apiRef: $scope.apiRef});
      $scope.apply = function() {
        // $scope.api['$ref'] = $scope.selectedApi;
        // $scope.api = $scope.selectedApi.$$refObj;
        $modalInstance.close($scope.selectedApi);
      };
      $scope.cancel = function() {
        // need to unwatch on the query string otherwise we get a visible query on screen before
        // the dialog actually gets closed
        $scope.unwatchQueryString();
        $scope.apiTitleQuery = "";
        $modalInstance.dismiss('cancel');
      };
    };

    angular.module('apim.products').controller('BurstLimitController', ['$scope', BurstLimitController]);

    function BurstLimitController($scope) {
      var extractInt = function(str) {
        var length = 1;
        var testStr = str.substring(0, length);
        while (!isNaN(testStr * 1) && length < str.length) {
          length++;
          testStr = str.substring(0, length);
        }
        var count = (length == 1) ? 1 : str.substring(0, length - 1) * 1;
        return [count, str.substring(length - 1)];
      };
      $scope.requests = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model.value = "" + newValue + "/" + $scope.count() + $scope.period();
        } else {
          // Getter
          if (!$scope.model || !$scope.model.value || $scope.model.value === "unlimited") return;
          var value = $scope.model.value;
          return value.split('/')[0] * 1;
        }
      };
      $scope.count = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model.value = "" + $scope.requests() + "/" + ((newValue > 1) ? newValue : "") + $scope.period();
        } else {
          // Getter
          if (!$scope.model || !$scope.model.value || $scope.model.value === "unlimited") return;
          var value = $scope.model.value;
          var countPerPeriod = value.split('/')[1];
          return extractInt(countPerPeriod)[0];
        }
      };
      $scope.period = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model.value = "" + $scope.requests() + "/" + $scope.count() + newValue;
        } else {
          // Getter
          if (!$scope.model || !$scope.model.value || $scope.model.value === "unlimited") return;
          var value = $scope.model.value;
          var countPerPeriod = value.split('/')[1];
          return extractInt(countPerPeriod)[1];
        }
      };
    }

    angular.module('apim.products').controller('RateLimitController', ['$scope', RateLimitController]);

    function RateLimitController($scope) {
      var extractInt = function(str) {
        var length = 1;
        var testStr = str.substring(0, length);
        while (!isNaN(testStr * 1) && length < str.length) {
          length++;
          testStr = str.substring(0, length);
        }
        var count = (length == 1) ? 1 : str.substring(0, length - 1) * 1;
        return [count, str.substring(length - 1)];
      };
      $scope.requests = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model.value = "" + newValue + "/" + $scope.count() + $scope.period();
        } else {
          // Getter
          if (!$scope.model || !$scope.model.value || $scope.model.value === "unlimited") return;
          var value = $scope.model.value;
          return value.split('/')[0] * 1;
        }
      };
      $scope.count = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model.value = "" + $scope.requests() + "/" + ((newValue > 1) ? newValue : "") + $scope.period();
        } else {
          // Getter
          if (!$scope.model || !$scope.model.value || $scope.model.value === "unlimited") return;
          var value = $scope.model.value;
          var countPerPeriod = value.split('/')[1];
          return extractInt(countPerPeriod)[0];
        }
      };
      $scope.period = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model.value = "" + $scope.requests() + "/" + $scope.count() + newValue;
        } else {
          // Getter
          if (!$scope.model || !$scope.model.value || $scope.model.value === "unlimited") return;
          var value = $scope.model.value;
          var countPerPeriod = value.split('/')[1];
          return extractInt(countPerPeriod)[1];
        }
      };
      $scope.hardLimit = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.model) $scope.model = {};
          $scope.model['hard-limit'] = newValue;
        } else {
          // Getter
          if (!$scope.model || !$scope.model['hard-limit']) return;
          return $scope.model['hard-limit'];
        }
      };
    }

    angular.module('apim.products').controller('ProductRateLimitController', ['$scope', 'resourceLevelRateLimitFilter', 'resourceLevelTaskFilter', 'planLevelTaskFilter', 'translateFilter', productRateLimitController]);

    function productRateLimitController($scope, resourceLevelRateLimitFilter, resourceLevelTaskFilter, planLevelTaskFilter, translateFilter) {
      $scope.detectRateLimit = function() {
        var root;
        if ($scope.getPlanApiOperation) {
          $scope.rateLimitContainer = $scope.getPlanApiOperation();
          root = "operation";
        } else if ($scope.api) {
          $scope.rateLimitContainer = $scope.api;
          root = "api";
        } else if ($scope.plan) {
          $scope.rateLimitContainer = $scope.plan;
          root = "plan";
        } else {
          $scope.rateLimitContainer = $scope.product;
          root = "product";
        }
        $scope.overridden = (typeof $scope.rateLimitContainer['rate-limit'] === 'object');
        if (!$scope.overridden) {
          // what rate limit applies here then?
            if (root == "operation" && typeof $scope.api['rate-limit'] == "object") {
              $scope.applicableRateLimit = $scope.api['rate-limit'];
            } else if (root == "operation" && typeof $scope.plan['rate-limit'] == "object") {
              $scope.applicableRateLimit = $scope.plan['rate-limit'];
            } else if (root == "api" && typeof $scope.plan['rate-limit'] == "object") {
              $scope.applicableRateLimit = $scope.plan['rate-limit'];
            } else if ($scope.product['rate-limit']) {
              $scope.applicableRateLimit = $scope.product['rate-limit'];
            } else {
              $scope.applicableRateLimit = "unlimited";
            }
        }
      };
      $scope.$watch('apiOperation', $scope.detectRateLimit);
      $scope.$watch('planApi', $scope.detectRateLimit);
      $scope.$watch('plan', $scope.detectRateLimit);
      $scope.$watch('product', $scope.detectRateLimit);
      $scope.$watch('overridden', function() {
        if (!$scope.applicableRateLimit) return;
        if (!$scope.overridden) {
          // remove any rate limit object in rateLimitContainer
          delete $scope.rateLimitContainer['rate-limit'];
        } else {
          // add a rate limit object to rateLimitContainer, defaulting to applicableRateLimit
          $scope.rateLimitContainer['rate-limit'] = {
            value: $scope.applicableRateLimit.value,
            'hard-limit': $scope.applicableRateLimit['hard-limit']
          };
        }
      });
      $scope.hardLimit = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.rateLimitContainer['rate-limit']) $scope.rateLimitContainer['rate-limit'] = {};
          $scope.rateLimitContainer['rate-limit']['hard-limit'] = newValue;
        } else {
          // Getter
          if (!$scope.rateLimitContainer || !$scope.rateLimitContainer['rate-limit'] || !$scope.rateLimitContainer['rate-limit']['hard-limit']) return;
          return $scope.rateLimitContainer['rate-limit']['hard-limit'];
        }
      };
      $scope.unlimited = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.rateLimitContainer['rate-limit']) $scope.rateLimitContainer['rate-limit'] = {};
          if(newValue) {
            $scope.rateLimitContainer['rate-limit'].value = "unlimited";
            delete $scope.rateLimitContainer['rate-limit']['hard-limit'];
          } else {
            $scope.rateLimitContainer['rate-limit'].value = "1/second";
          }
        } else {
          // Getter
          if (!$scope.rateLimitContainer) return;
          if(!$scope.rateLimitContainer['rate-limit'] || !$scope.rateLimitContainer['rate-limit'].value) {
            return true;
          }
          return $scope.rateLimitContainer['rate-limit'].value == "unlimited";
        }
      };
      $scope.requests = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.rateLimitContainer['rate-limit']) $scope.rateLimitContainer['rate-limit'] = {};
          $scope.rateLimitContainer['rate-limit'].value = "" + newValue + "/" + $scope.count() + $scope.period();
        } else {
          // Getter
          if (!$scope.rateLimitContainer || !$scope.rateLimitContainer['rate-limit'] || !$scope.rateLimitContainer['rate-limit'].value) return;
          var value = $scope.rateLimitContainer['rate-limit'].value;
          return value.split('/')[0] * 1;
        }
      };
      $scope.count = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.rateLimitContainer['rate-limit']) $scope.rateLimitContainer['rate-limit'] = {};
          $scope.rateLimitContainer['rate-limit'].value = "" + $scope.requests() + "/" + ((newValue > 1) ? newValue : "") + $scope.period();
        } else {
          // Getter
          if (!$scope.rateLimitContainer || !$scope.rateLimitContainer['rate-limit'] || !$scope.rateLimitContainer['rate-limit'].value) return;
          var value = $scope.rateLimitContainer['rate-limit'].value;
          var countPerPeriod = value.split('/')[1];
          return $scope.extractInt(countPerPeriod)[0];
        }
      };
      $scope.period = function(newValue) {
        if (arguments.length) {
          // Setter
          if (!$scope.rateLimitContainer['rate-limit']) $scope.rateLimitContainer['rate-limit'] = {};
          $scope.rateLimitContainer['rate-limit'].value = "" + $scope.requests() + "/" + $scope.count() + newValue;
        } else {
          // Getter
          if (!$scope.rateLimitContainer || !$scope.rateLimitContainer['rate-limit'] || !$scope.rateLimitContainer['rate-limit'].value) return;
          var value = $scope.rateLimitContainer['rate-limit'].value;
          var countPerPeriod = value.split('/')[1];
          return $scope.extractInt(countPerPeriod)[1];
        }
      };
      $scope.extractInt = function(str) {
        var length = 1;
        var testStr = str.substring(0, length);
        while (!isNaN(testStr * 1) && length < str.length) {
          length++;
          testStr = str.substring(0, length);
        }
        var count = (length == 1) ? 1 : str.substring(0, length - 1) * 1;
        return [count, str.substring(length - 1)];
      };
    };

angular.module('apim.products').controller('NamedRateLimitController', ['$scope', NamedRateLimitController]);

function NamedRateLimitController($scope) {
  $scope.$rateLimitName = function(value) {
    if (arguments.length) {
      // setter
      if (value && !$scope.plan['rate-limits'][value]) {
        // Update
        var updatedRateLimits = {};
        Object.keys($scope.plan['rate-limits']).forEach(function(rateLimitName) {
          if(rateLimitName == $scope.rateLimitName) {
            updatedRateLimits[value] = {
              'hard-limit': $scope.plan['rate-limits'][rateLimitName]['hard-limit'],
              value: $scope.plan['rate-limits'][rateLimitName].value
            };
          } else {
            updatedRateLimits[rateLimitName] = $scope.plan['rate-limits'][rateLimitName];
          }
        });
        $scope.plan['rate-limits'] = updatedRateLimits;
      }
    } else {
      return $scope.rateLimitName;
    }
  }
};

angular.module('apim.products').controller('NamedBurstLimitController', ['$scope', NamedBurstLimitController]);

function NamedBurstLimitController($scope) {
  $scope.$burstLimitName = function(value) {
    if (arguments.length) {
      // setter
      if (value && !$scope.plan['rate-limits'][value]) {
        // Update
        var updatedBurstLimits = {};
        Object.keys($scope.plan['burst-limits']).forEach(function(burstLimitName) {
          if(burstLimitName == $scope.burstLimitName) {
            updatedBurstLimits[value] = {
              value: $scope.plan['burst-limits'][burstLimitName].value
            };
          } else {
            updatedBurstLimits[burstLimitName] = $scope.plan['burst-limits'][burstLimitName];
          }
        });
        $scope.plan['burst-limits'] = updatedBurstLimits;
      }
    } else {
      return $scope.burstLimitName;
    }
  }
};

    angular.module('apim.products').controller('OperationNamedRateLimitController', ['$scope', OperationNamedRateLimitController]);

    function OperationNamedRateLimitController($scope) {
      $scope.$rateLimitName = function(value) {
        if (typeof value !== "undefined") {
          // setter
          if (value !== "" && $scope.planApiOperation['rate-limits'][value] === undefined) {

            // Update
            var updatedRateLimits = {};
            Object.keys($scope.planApiOperation['rate-limits']).forEach(function(rateLimitName) {
              if(rateLimitName == $scope.rateLimitName) {
                updatedRateLimits[value] = $scope.planApiOperation['rate-limits'][rateLimitName];
              } else {
                updatedRateLimits[rateLimitName] = $scope.planApiOperation['rate-limits'][rateLimitName];
              }
            });
            $scope.planApiOperation['rate-limits'] = updatedRateLimits;
          }
        } else {
          return $scope.rateLimitName;
        }
      }
    };

angular.module('apim.products').controller('CreateProductController', ['$state', '$scope', '$rootScope', '$modalInstance', '$filter', 'uiUploader', 'errorHandler', 'Product', 'DeployedProduct', '$timeout', 'ArtifactBuilder', 'ProductPublisher', 'TrackingServices', CreateProductController]);

function CreateProductController($state, $scope, $rootScope, $modalInstance, $filter, uiUploader, errorHandler, Product, DeployedProduct, $timeout, ArtifactBuilder, ProductPublisher, TrackingServices) {

  if (!$scope.newProduct) {
    $scope.newProduct = {
      version: "1.0.0",
      title: ""
    };
  }
  if (!$scope.publishOptions) {
    $scope.publishOptions = {
      doPublish: !$scope.hidePublishOption
    };
  }
  $scope.importLabelText = $filter('translate')('product_import_description');
  $scope.productTemplate = ArtifactBuilder.defaultProductName;

  var generateName = function() {
    // apply title -> name conversion rules
    $scope.newProduct.name = $scope.generateName($scope.newProduct.title);
  };
  $scope.$watch('newProduct.title', generateName);

  function refreshDescriptors(product) {
    if ($scope.offlineMode) return;
    $scope.loadingDescriptors = true;
    var descriptors = DeployedProduct.query({
      orgId: $scope.orgId
    });
    descriptors.$promise.then(function() {
      $scope.descriptors = descriptors.filter(function(descriptor) {
        return (descriptor.productName == $scope.newProduct.name && descriptor.productVersion == $scope.newProduct.version);
      });
      $scope.loadingDescriptors = false;
      $rootScope.gsState.import = true;
      $rootScope.gsState.generate = true;
      $rootScope.imagesrc.generate = 'check_circle';
      $timeout(function() {
        angular.element(document.getElementById('exploretooltip')).triggerHandler('showExploreEvent');
      }, 500);
    });
  };

  $scope.create = function() {
    $scope.creatingProduct = true;
    var templateDeferred = ArtifactBuilder.createFromTemplate($scope.productTemplate, $scope.newProduct);
    templateDeferred.promise.then(function(newProduct) {
      var product = new Product(newProduct);
      product.$create({orgId: $scope.orgId}, function(prod, headers) {
        $scope.creatingProduct = false;
        if ($scope.products) $scope.products.push(product);
        $modalInstance.close(product);

        if($scope.publishOptions.doPublish && $scope.publishOptions.publishTarget) {
          $rootScope.gettingStartedActive =false;

          var productDescriptor = {
            info: prod.info
          };
          var productHeaders = headers();
          if (productHeaders['x-ibm-product-file']) {
            productDescriptor.file = productHeaders['x-ibm-product-file'];
          }

          ProductPublisher.publish(productDescriptor, $scope.publishOptions.publishTarget).then(function() {
            refreshDescriptors();
            if ($rootScope.gsState) {
              $rootScope.gsState.publishedToCatalog = $scope.publishOptions.publishTarget.environmentId;
              $rootScope.gsState.publishedApiId = product.apis[$scope.swaggerDocument.info['x-ibm-name']].id;
              $rootScope.gsState.publishedApiName = $scope.swaggerDocument.info['x-ibm-name'];
            }
            TrackingServices.track('product', 'publishProductApi');
          });
        } else {
          $rootScope.gettingStartedActive =false;
        }
        if (product.apis) {
          TrackingServices.track('product', 'addProductApi');
        }
        TrackingServices.track('product', 'createNewProduct');
      }, function() {
        $scope.creatingProduct = false;
      });
    });
  };

  $scope.$watch('publishTargets', function() {
    if (!$scope.publishTargets) return;
    if ($scope.publishTargets.length > 0) {
      $scope.publishOptions.publishTarget = $scope.publishTargets[0];
    } else {
      $scope.publishOptions.publishTarget = null;
    }
  });

  $scope.cancel = function(){
    $rootScope.gettingStartedActive =false;
    $modalInstance.dismiss('cancel');
  };
  $scope.attachToFileInput = function() {
    $scope.productFileInput = document.getElementById('product_file');
    if ($scope.productFileInput) {

      $scope.productFileInput.addEventListener('change', function(e) {
        var files = e.target.files;
        uiUploader.removeAll();
        uiUploader.addFiles(files);
        $scope.selectedProductFile = uiUploader.getFiles()[0];
        $scope.importLabelText = $scope.selectedProductFile.name;
        $scope.$apply();
      });
    } else {
      setTimeout($scope.attachToFileInput, 500);
    }
  };
  $modalInstance.opened.then(function() {
    $scope.attachToFileInput();
  });
  $scope['import'] = function() {
    $scope.importingProduct = true;
    var url = 'proxy/orgs/' + $scope.orgId + '/products';
    uiUploader.startUpload({
      url: url,
      onProgress: function(file) {

      },
      onCompleted: function(file, response) {
        $scope.importingProduct = false;
        $modalInstance.dismiss('ok');
        var responseObject = response;
        if (typeof response == "string") {
          responseObject = JSON.parse(response);
        }
        responseObject.data = responseObject.responseText;
        responseObject.config = {url: url};
        errorHandler.checkResponse(responseObject);

        if(!responseObject.errors) $scope.refreshProducts();
      },
      onCompletedAll: function() {
      }
    });
  };

}

angular.module('apim.products').controller('ProductCategoriesController', ['$scope', 'CommonUtils', ProductCategoriesController]);

function ProductCategoriesController($scope, CommonUtils) {
  $scope.$categories = function(value) {
    if (!$scope.product) return;
    if (typeof value !== "undefined") {
      // Setter
      var paths = value.split("\n");
      var len = paths.length;
      for (var i=0;i<len;i++) {
        paths[i] = CommonUtils.stripOuterQuotes(paths[i]);
      } // end for
      $scope.product.info.categories = paths;
    } else {
      // Getter
      var ret = "";
      var pathList = $scope.product.info.categories;
      if (pathList) {
        ret = pathList.join("\n");
      }
      return ret;
    }
  };
};
