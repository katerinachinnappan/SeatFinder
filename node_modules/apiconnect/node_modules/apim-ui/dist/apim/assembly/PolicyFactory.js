/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
  // Node module: apiconnect-assembly

'use strict';

angular.module('apim.apis').factory('Policies', ['$resource',
  function($resource) {
    return $resource('proxy/orgs/:orgId/policies/:policyId/', {}, {
      query: {method: 'GET', params: {orgId: '@orgId'}, isArray: true}
    });
  }
]);

angular.module('apim.apis').factory('ApimPolicyFactory', ['$q', '$rootScope', 'Assembly', 'Policies', 'translateFilter', '$http', function($q, $rootScope, Assembly, Policies, translateFilter, $http) {
  var policies = [];
  policies.push({
    info: {
      title: translateFilter('policy.switch.title'),
      description: translateFilter('policy.switch.description'),
      name: 'switch',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.logic')],
      display: {
        color: 'inherit',
        icon: 'call_split'
      },
    },
    logic: true,
    classes: ["logic"],
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["case"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "case": {
          "type": "array",
            "minItems": 1,
            "items": {
              "type": "object",
              "additionalProperties": false,
              "oneOf": [
                {"required": ["condition", "execute"]},
                {"required": ["otherwise"]}
              ],
              "properties": {
                "condition": {
                  "type": "string"
                },
                "execute": {
                  "type": "array"
                },
                "otherwise": {
                  "type": "array"
                }
              }
            }
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.operation-switch.title'),
      name: 'operation-switch',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.logic')],
      display: {
        color: 'inherit',
        icon: 'call_split'
      }
    },
    logic: true,
    classes: ["logic"],
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["case"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "case": {
          "type": "array",
            "minItems": 1,
            "items": {
              "type": "object",
              "additionalProperties": false,
              "required": ["operations", "execute"],
              "properties": {
                "operations": {
                  "type": "array",
                  "minItems": 1,
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/definitions/operationId"
                      },
                      {
                        "$ref": "#/definitions/operationVerbPath"
                      }
                    ]
                  },
                  "uniqueItems": true
                },
                "execute": {
                  "type": "array"
                }
              }
            }
        },
        "otherwise": {
          "type": "array"
        }
      },
      "definitions": {
        "operationId": {
          "type": "string",
          "additionalProperties": false,
          "not": {
            "type": "string",
            "pattern": "^\\s*$"
          }
        },
        "operationVerbPath": {
          "type": "object",
          "additionalProperties": false,
          "required":[
            "verb",
            "path"
          ],
          "properties":{
            "verb":{
              "type": "string"
            },
            "path":{
              "type": "string"
            }
          }
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.if.title'),
      name: 'if',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.logic')],
      display: {
        color: 'inherit',
        icon: 'call_made'
      }
    },
    logic: true,
    classes: ["logic"],
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["condition"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "condition": {
          "type": "string"
        },
        "execute": {
          type: "array"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.throw.title'),
      name: 'throw',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.logic')],
      display: {
        color: '#D0021B',
        icon: 'report_problem'
      }
    },
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["name"],
      "properties": {
        "title": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "message": {
          "type": "string"
        }
      }
    }
  });

  policies.push({
    info: {
      title: translateFilter('policy.redact.title'),
      description: translateFilter('policy.redact.description'),
      name: 'redact',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.transforms')],
      display: {
        color: '#AF6EE8',
        icon: 'filter_list'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "actions": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/redact_actions"
          }
        }
      },
      "definitions": {
        "redact_actions": {
          "type": "object",
          "additionalProperties": false,
          "required": ["path"],
          "properties": {
            "path": {
              "type": "string"
            },
            "action": {
              "type": "string",
              "enum": [
                "remove",
                "redact"
              ],
              "default": "redact"
            },
            "from": {
              "type":"array",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/redact_from"
              },
              "default": ["all"]
            }
          }
        },
        "redact_from": {
          "type": "string",
          "additionalProperties": false,
          "enum": [
            "all",
            "request",
            "response",
            "logs"
          ]
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.handlebars.title'),
      description: translateFilter('policy.handlebars.description'),
      name: 'handlebars',
      version: "1.0.0",
      categories: [translateFilter('policy.categories.transforms')],
      display: {
        color: '#FF5050',
        icon: 'clear_all'
      }
    },
    gateways: [/*"datapower-gateway", */"micro-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["source"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "source": {
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.map.title'),
      name: 'map',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.transforms')],
      display: {
        color: '#00B4A0',
        icon: 'swap_horiz'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "inputs": {
          "type": "object"
        },
        "outputs": {
          "type": "object"
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "options": {
          "type": "object"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.transform-xslt.title'),
      description: translateFilter('policy.transform-xslt.description'),
      categories: [translateFilter('policy.categories.transforms')],
      name: 'xslt',
      version: '1.0.0',
      display: {
        color: '#FF5050',
        icon: 'clear_all'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["source", "input"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "input": {
          "type": "boolean",
          "default": false
        },
        "source": {
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.xml-to-json.title'),
      description: translateFilter('policy.xml-to-json.description'),
      name: 'xml-to-json',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.transforms')],
      display: {
        color: '#4B68FA',
        icon: 'transform'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.json-to-xml.title'),
      description: translateFilter('policy.json-to-xml.description'),
      name: 'json-to-xml',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.transforms')],
      display: {
        color: '#4B68FA',
        icon: 'transform'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["root-element-name","always-output-root-element" ],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "root-element-name": {
          "label": "Root XML Element Name",
          "description": "The root element name of the resultant XML document.  This is only required if the input JSON document is not hierarchial and has more than one top level properties.",
          "type": "string",
          "default": "json"
        },
        "always-output-root-element": {
          "label": "Always output the root element.",
          "description": "Output the root element even if it is not required to make the XML document well formed.",
          "type": "boolean",
          "default": false
        },
        "unnamed-element-name": {
          "label": "Element name for JSON array elements",
          "description": "The XML element name to be used for JSON array elements.",
          "type": "string",
          "default": "element"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.invoke.title'),
      description: translateFilter('policy.invoke.description'),
      name: 'invoke',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#5AA700',
        icon: 'play_arrow'
      }
    },
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["target-url"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "target-url": {
          "label": "Invoke URL",
          "description": "The Invoke URL to be used.",
          "type": "string"
        },
        "secure-gateway": {
          "label": "Access URL through Secure Gateway",
          "description": "Access the URL through a Secure Gateway. The gateway is set when the API is moved from staged state to published state.",
          "type": "boolean"
        },
        "tls-profile": {
          "label": "SSL Profile",
          "description": "The SSL Profile to use for the request",
          "type": "string"
        },
        "timeout": {
          "label": "Timeout",
          "description": "Time to wait before a reply back from the endpoint. Default is 60 seconds.",
          "type": "integer",
          "default": 60
        },
        "username": {
          "label": "Username",
          "description": "The username to use for HTTP Basic authentication.",
          "type": "string"
        },
        "password": {
          "label": "Password",
          "description": "The password to use for HTTP Basic authentication.",
          "type": "string"
        },
        "verb": {
          "label": "HTTP Method",
          "description": "HTTP Method to use for the Invoke.",
          "type": "string",
          "enum": [
            "keep",
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH",
            "HEAD",
            "OPTIONS"
          ],
          "default": "GET"
        },
        "compression": {
          "label": "Compression",
          "description": "Used to enable/disable Content-Encoding compression on upload.",
          "type": "boolean"
        },
        "cache-response": {
          "label": "Cache Type",
          "description": "The cache type determines whether to cache documents and the mechanism to use to remove cached entries. The default is 'no-cache'.",
          "type": "string",
          "enum": [
            "protocol",
            "time-to-live",
            "no-cache"
          ],
          "default": "protocol"
        },
        "cache-ttl": {
          "label": "Cache Time-to-Live",
          "description": "Sets the validity period in seconds for documents in the cache. TTL applies to only the 'time-to-live' policy type. Enter a value in the range 5 - 31708800. The default value is 900.",
          "type": "integer",
          "default": 900,
          "minimum": 5,
          "maximum": 31708800
        },
        "cache-key": {
          "label": "Cache Key",
          "description": "The cache key to use to identify the cache item. If this is not set the target-url will be used.",
          "type": "string"
        },
        "stop-on-error": {
          "label": "Stop on error",
          "description": "Used to enable/disable stop-on-error semantics.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "output": {
          "label": "Response object variable",
          "description": "A name of a variable that will be used to store the response data from the request. This can then be used in other actions like 'Map' etc.",
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.proxy.title'),
      description: translateFilter('policy.proxy.description'),
      name: 'proxy',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#5AA700',
        icon: 'play_arrow'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["target-url"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "target-url": {
          "label": "Invoke URL",
          "description": "The Invoke URL to be used.",
          "type": "string"
        },
        "secure-gateway": {
          "label": "Access URL through Secure Gateway",
          "description": "Access the URL through a Secure Gateway. The gateway is set when the API is moved from staged state to published state.",
          "type": "boolean"
        },
        "tls-profile": {
          "label": "SSL Profile",
          "description": "The SSL Profile to use for the request",
          "type": "string"
        },
        "timeout": {
          "label": "Timeout",
          "description": "Time to wait before a reply back from the endpoint. Default is 60 seconds.",
          "type": "integer",
          "default": 60
        },
        "username": {
          "label": "Username",
          "description": "The username to use for HTTP Basic authentication.",
          "type": "string"
        },
        "password": {
          "label": "Password",
          "description": "The password to use for HTTP Basic authentication.",
          "type": "string"
        },
        "verb": {
          "label": "HTTP Method",
          "description": "HTTP method to use to replace the current api HTTP method",
          "type": "string",
          "enum": [
            "keep",
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH",
            "HEAD",
            "OPTIONS"
          ],
          "default": "keep"
        },
        "compression": {
          "label": "Compression",
          "description": "Used to enable/disable Content-Encoding compression on upload.",
          "type": "boolean"
        },
        "cache-response": {
          "label": "Cache Type",
          "description": "The cache type determines whether to cache documents and the mechanism to use to remove cached entries. The default is 'no-cache'.",
          "type": "string",
          "enum": [
            "protocol",
            "time-to-live",
            "no-cache"
          ],
          "default": "protocol"
        },
        "cache-ttl": {
          "label": "Cache Time-to-Live",
          "description": "Sets the validity period in seconds for documents in the cache. TTL applies to only the 'time-to-live' policy type. Enter a value in the range 5 - 31708800. The default value is 900.",
          "type": "integer",
          "default": 900,
          "minimum": 5,
          "maximum": 31708800
        },
        "cache-key": {
          "label": "Cache Key",
          "description": "The cache key to use to identify the cache item. If this is not set the target-url will be used.",
          "type": "string"
        },
        "output": {
          "label": "Response object variable",
          "description": "A name of a variable that will be used to store the response data from the request. This can then be used in other actions like 'Map' etc.",
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.activity-log.title'),
      description: translateFilter('policy.activity-log.description'),
      name: 'activity-log',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#BE9B00',
        icon: 'list'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["content", "error-content"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "content": {
          "description": "Activity to log when operation is succesful",
          "type": "string",
          "default": "activity"
        },
        "error-content": {
          "description": "Activity to log when operation is not succesful",
          "type": "string",
          "default": "payload"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.validate.title'),
      description: translateFilter('policy.validate.description'),
      name: 'validate',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#7ED321',
        icon: 'check'
      }
    },
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["definition"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "definition": {
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.gatewayscript.title'),
      description: translateFilter('policy.gatewayscript.description'),
      name: 'gatewayscript',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#FF5050',
        icon: 'clear_all'
      }
    },
    gateways: ["datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["source"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "source": {
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.javascript.title'),
      description: translateFilter('policy.javascript.description'),
      name: 'javascript',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#FF5050',
        icon: 'clear_all'
      }
    },
    gateways: ["micro-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["source"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "source": {
          "type": "string"
        }
      }
    }
  });
  policies.push({
    info: {
      title: translateFilter('policy.set-variable.title'),
      description: translateFilter('policy.set-variable.description'),
      name: 'set-variable',
      version: '1.0.0',
      categories: [translateFilter('policy.categories.policies')],
      display: {
        color: '#929EAA',
        icon: 'check_box'
      }
    },
    gateways: ["micro-gateway", "datapower-gateway"],
    properties: {
      "type": "object",
      "additionalProperties": false,
      "required": ["actions"],
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "actions": {
          "type": "array",
          "items": {
            "oneOf": [
              {
                "$ref": "#/definitions/set-variable-policy-set-action"
              },
              {
                "$ref": "#/definitions/set-variable-policy-add-action"
              },
              {
                "$ref": "#/definitions/set-variable-policy-clear-action"
              }
            ]
          }
        }
      },
      "definitions": {
        "set-variable-policy-clear-action": {
          "type": "object",
          "title": "clear",
          "additionalProperties": false,
          "required": ["clear"],
          "properties": {
            "clear": {
              "type": "string"
            }
          }
        },
        "set-variable-policy-add-action": {
          "type": "object",
          "title": "add",
          "additionalProperties": false,
          "required": ["add", "value"],
          "properties": {
            "add": {
              "type": "string"
            },
            "value": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "integer"
                }
              ]
            }
          }
        },
        "set-variable-policy-set-action": {
          "type": "object",
          "title": "set",
          "additionalProperties": false,
          "required": ["set", "value"],
          "properties": {
            "set": {
              "type": "string"
            },
            "value": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "integer"
                }
              ]
            }
          }
        }
      }
    }
  });

  if (!$rootScope.features['useJWT101']) {
    policies.push({
      "info": {
        "title": translateFilter('policy.jwt-validate.title'),
        "description": translateFilter('policy.jwt-validate.description'),
        "name": "jwt-validate",
        "version": '1.0.0',
        "categories": [translateFilter('policy.categories.security')],
        display: {
          color: '#7ED321',
          icon: 'check'
        }
      },
      gateways: ["datapower-gateway"],
      "properties": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "jwt": {
            "label": "JSON Web Token (JWT)",
            "description": "Context or runtime variable containing JWT to be validated",
            "type": "string",
            "default": "request.headers.authorization"
          },
          "output-claims": {
            "label": "Validated Claims variable name",
            "description": "Runtime variable to which the set of claims returned from the JWT validation step will be assigned",
            "type": "string",
            "default": "decoded.claims"
          },
          "iss-claim": {
            "label": "Issuer Claim",
            "description": "PCRE used to validate the Issuer (iss) Claim",
            "type": "string"
          },
          "aud-claim": {
            "label": "Audience Claim",
            "description": "PCRE used to validate the Audience (aud) Claim",
            "type": "string"
          },
          "jwe-crypto": {
            "label": "Decrypt Crypto Object",
            "description": "Specify the crypto object used to decrypt the message",
            "type": "string"
          },
          "jwe-jwk": {
            "label": "Decrypt Crypto JWK variable name",
            "description": "Runtime variable containing JWK to be used to decrypt the JWT",
            "type": "string"
          },
          "jws-crypto": {
            "label": "Verify Crypto Object",
            "description": "Specify the crypto object used to verify the signature",
            "type": "string"
          },
          "jws-jwk": {
            "label": "Verify Crypto JWK variable name",
            "description": "Runtime variable containing JWK to be used to verify the signature",
            "type": "string"
          }
        },
        "required": [
          "jwt"
        ]
      }
    });

    policies.push({
      "info": {
        "title": translateFilter('policy.jwt-generate.title'),
        "description": translateFilter('policy.jwt-generate.description'),
        "name": "jwt-generate",
        "version": '1.0.0',
        "categories": [translateFilter('policy.categories.security')],
        display: {
          color: '#5EACF7',
          icon: 'adjust'
        }
      },
      gateways: ["datapower-gateway"],
      "properties": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "jwt": {
            "label": "JSON Web Token (JWT)",
            "description": "Runtime variable in which to place the generated JWT. If not set JWT is placed in Authorization Header as Bearer Token.",
            "type": "string"
          },
          "jti-claim": {
            "label": "JWT ID Claim",
            "description": "Indicate whether a JWT ID (jti) claim should be included in JWT.  If selected, jti claim value will be a uuid",
            "type": "boolean"
          },
          "iss-claim": {
            "label": "Issuer Claim",
            "description": "Runtime variable from which from which a string representing the Principal (iss) that issued the JWT can be retrieved",
            "type": "string",
            "default": "iss.claim"
          },
          "sub-claim": {
            "label": "Subject Claim",
            "description": "Runtime variable from which a string representing the Subject (sub) Claim can be retrieved",
            "type": "string"
          },
          "aud-claim": {
            "label": "Audience Claim",
            "description": "Runtime variable from which the Audience (aud) Claim string can be retrieved. Multiple are set via a comma separated string",
            "type": "string"
          },
          "exp-claim": {
            "label": "Validity Period",
            "description": "The validity period (in seconds) for calculating the JWT expiration time (exp) claim of the JWT",
            "type": "integer",
            "default": 3600
          },
          "private-claims": {
            "label": "Private Claims",
            "description": "Runtime variable from which a valid JSON set of claims can be retrieved",
            "type": "string"
          },
          "jws-jwk": {
            "label": "Sign JWK variable name",
            "description": "Runtime variable containing JWK to be used to sign the JWT",
            "type": "string"
          },
          "jws-alg": {
            "label": "Cryptographic Algorithm",
            "description": "Select a cryptographic algorithm",
            "type": "string",
            "enum": [
              "HS256",
              "HS384",
              "HS512",
              "RS256",
              "RS384",
              "RS512",
              "ES256",
              "ES384",
              "ES512",
              "none"
            ]
          },
          "jws-crypto": {
            "label": "Sign Crypto Object",
            "description": "Specify the crypto object used to sign the message",
            "type": "string"
          },
          "jwe-enc": {
            "label": "Encryption Algorithm",
            "description": "Select an encryption algorithm",
            "type": "string",
            "enum": [
              "A128CBC-HS256",
              "A192CBC-HS384",
              "A256CBC-HS512"
            ]
          },
          "jwe-jwk": {
            "label": "Encrypt JWK variable name",
            "description": "Runtime variable containing JWK to be used to encrypt the JWT",
            "type": "string"
          },
          "jwe-alg": {
            "label": "Key Encryption Algorithm",
            "description": "Select a key encryption algorithm",
            "type": "string",
            "enum": [
              "RSA1_5",
              "RSA-OAEP",
              "RSA-OAEP-256",
              "dir",
              "A128KW",
              "A192KW",
              "A256KW"
            ]
          },
          "jwe-crypto": {
            "label": "Encrypt Crypto Object",
            "description": "Specify the crypto object used to encrypt the message",
            "type": "string"
          }
        },
        "required": [
          "exp-claim",
          "iss-claim"
        ]
      }
    });
  } else {
    policies.push({
      "info": {
        "title": translateFilter('policy.jwt-validate.title'),
        "description": translateFilter('policy.jwt-validate.description'),
        "name": "jwt-validate",
        "version": '1.0.1',
        "categories": [translateFilter('policy.categories.security')],
        display: {
          color: '#7ED321',
          icon: 'check'
        }
      },
      gateways: ["datapower-gateway"],
      "properties": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "jwt": {
            "label": "JSON Web Token (JWT)",
            "description": "Context or runtime variable containing JWT to be validated",
            "type": "string",
            "default": "request.headers.authorization"
          },
          "output-claims": {
            "label": "Validated Claims variable name",
            "description": "Runtime variable to which the set of claims returned from the JWT validation step will be assigned",
            "type": "string",
            "default": "decoded.claims"
          },
          "iss-claim": {
            "label": "Issuer Claim",
            "description": "PCRE used to validate the Issuer (iss) Claim",
            "type": "string"
          },
          "aud-claim": {
            "label": "Audience Claim",
            "description": "PCRE used to validate the Audience (aud) Claim",
            "type": "string"
          },
          "jwe-obj": {
            "label": "Private Key or Shared Secret for Decrypt",
            "description": "Security object to use to decode the claim.",
            "type": "string"
          },
          "jws-obj": {
            "label": "Certifcate or Shared Secret for Verify",
            "description": "Security object used to verify the claim.",
            "type": "string"
          }
        },
        "required": [
          "jwt"
        ]
      }
    });

    policies.push({
      "info": {
        "title": translateFilter('policy.jwt-generate.title'),
        "description": translateFilter('policy.jwt-generate.description'),
        "name": "jwt-generate",
        "version": '1.0.1',
        "categories": [translateFilter('policy.categories.security')],
        display: {
          color: '#5EACF7',
          icon: 'adjust'
        }
      },
      gateways: ["datapower-gateway"],
      "properties": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "jwt": {
            "label": "JSON Web Token (JWT)",
            "description": "Runtime variable in which to place the generated JWT. If not set JWT is placed in Authorization Header as Bearer Token.",
            "type": "string"
          },
          "jti-claim": {
            "label": "JWT ID Claim",
            "description": "Indicate whether a JWT ID (jti) claim should be included in JWT.  If selected, jti claim value will be a uuid",
            "type": "boolean"
          },
          "iss-claim": {
            "label": "Issuer Claim",
            "description": "Runtime variable from which from which a string representing the Principal (iss) that issued the JWT can be retrieved",
            "type": "string",
            "default": "iss.claim"
          },
          "sub-claim": {
            "label": "Subject Claim",
            "description": "Runtime variable from which a string representing the Subject (sub) Claim can be retrieved",
            "type": "string"
          },
          "aud-claim": {
            "label": "Audience Claim",
            "description": "Runtime variable from which the Audience (aud) Claim string can be retrieved. Multiple are set via a comma separated string",
            "type": "string"
          },
          "exp-claim": {
            "label": "Validity Period",
            "description": "The validity period (in seconds) for calculating the JWT expiration time (exp) claim of the JWT",
            "type": "integer",
            "default": 3600
          },
          "private-claims": {
            "label": "Private Claims",
            "description": "Runtime variable from which a valid JSON set of claims can be retrieved",
            "type": "string"
          },
          "jws-obj": {
            "label": "Private Key or Shared Secret for Sign",
            "description": "Security object used to sign the JWT.",
            "type": "string"
          },
          "jws-alg": {
            "label": "Cryptographic Algorithm",
            "description": "Select a cryptographic algorithm",
            "type": "string",
            "enum": [
              "HS256",
              "HS384",
              "HS512",
              "RS256",
              "RS384",
              "RS512",
              "ES256",
              "ES384",
              "ES512",
              "none"
            ]
          },
          "jwe-enc": {
            "label": "Encryption Algorithm",
            "description": "Select an encryption algorithm",
            "type": "string",
            "enum": [
              "A128CBC-HS256",
              "A192CBC-HS384",
              "A256CBC-HS512"
            ]
          },
          "jwe-obj": {
            "label": "Public Key or Shared Secret for Encrypt",
            "description": "Security object used to encrypt the JWT.",
            "type": "string"
          },
          "jwe-alg": {
            "label": "Key Encryption Algorithm",
            "description": "Select a key encryption algorithm",
            "type": "string",
            "enum": [
              "RSA1_5",
              "RSA-OAEP",
              "RSA-OAEP-256",
              "dir",
              "A128KW",
              "A192KW",
              "A256KW"
            ]
          }
        },
        "required": [
          "exp-claim",
          "iss-claim"
        ]
      }
    });
  }

  policies.push({
    "info": {
      "title": translateFilter('policy.validate-usernametoken.title'),
      "description": translateFilter('policy.validate-usernametoken.description'),
      "name": "validate-usernametoken",
      "version": '1.0.0',
      "categories": [translateFilter('policy.categories.security')],
      display: {
        color: '#7ED321',
        icon: 'check'
      }
    },
    gateways: ["datapower-gateway"],
    "properties": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "auth-type": {
          "label": "Authentication Type",
          "description": "Select how username token should be authenticated.",
          "type": "string",
          "enum": [
            "Authentication URL",
            "LDAP Registry"
          ],
          "default": "Authentication URL"
        },
        "auth-url": {
          "label": "Authentication URL Definition",
          "description": "Select authentication URL definition to use for validation.",
          "type": "string"
        },
        "tls-profile": {
          "label": "TLS Profile",
          "description": "The TLS Profile to use for the secure transmission of data.",
          "type": "string"
        },
        "ldap-user-registry": {
          "label": "User Registry Definition",
          "description": "Select user registry definition to validate with.",
          "type": "string"
        }
      },
      "required": [
        "auth-type"
      ]
    }
  });
  policies.push({
    "policy": "1.0.0",
    "info": {
      "title": translateFilter('policy.ltpa-generate.title'),
      "description": translateFilter('policy.ltpa-generate.description'),
      "name": "ltpa-generate",
      "version": "1.0.0",
      "contact": {
        "name": "Krithika Prakash",
        "url": "ibm.com",
        "email": "krithika@ca.ibm.com"
      },
      "categories": [translateFilter('policy.categories.security')],
      display: {
        color: '#5EACF7',
        icon: 'adjust'
      }
    },
    "attach": [
      "rest",
      "soap"
    ],
    "properties": {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "authenticatedUserName": {
          "label": "${messages:ltpagenerate.properties.authenticatedusername.label}",
          "description": "${messages:ltpagenerate.properties.authenticatedusername.description}",
          "type": "string"
        },
        "tokenVersion": {
          "label": "${messages:ltpagenerate.properties.tokenversion.label}",
          "description": "${messages:ltpagenerate.properties.tokenversion.description}",
          "enum": [
            "WebSphereVersion1",
            "WebSphereVersion1-FIPS",
            "WebSphereVersion2",
            "WebSphere70Version2"
          ],
          "default": "WebSphereVersion2",
          "type": "string"
        },
        "tokenExpiry": {
          "label": "${messages:ltpagenerate.properties.tokenexpiry.label}",
          "description": "${messages:ltpagenerate.properties.tokenexpiry.description}",
          "default": 600,
          "type": "integer"
        },
        "key": {
          "label": "${messages:ltpagenerate.properties.key.label}",
          "description": "${messages:ltpagenerate.properties.key.description}",
          "type": "string"
        },
        "tokenOutput": {
          "label": "${messages:ltpagenerate.properties.tokenoutput.label}",
          "description": "${messages:ltpagenerate.properties.tokenoutput.description}",
          "enum": [
            "in-cookie-header",
            "in-wssec-header"
          ],
          "default": "in-cookie-header",
          "type": "string"
        }
      },
      "required": [
        "authenticatedUserName",
        "tokenVersion",
        "tokenExpiry",
        "key",
        "tokenOutput"
      ]
    },
    "gateways": [
      "datapower-gateway"
    ],
    "errors": [
      "LTPAGenerateError"
    ]
  });
  if ($rootScope.features.certificates) {
    policies.push({
      "policy": "1.0.0",
      "info": {
        "title": translateFilter('policy.encrypt.title'),
        "name": "encrypt",
        "version": "1.0.0",
        "description": translateFilter('policy.encrypt.description'),
        "display": {
          color: '#7ED321',
          icon: 'lock'
        },
        "categories": [translateFilter('policy.categories.security')],
      },
      "gateways": [
        "datapower-gateway"
      ],
      "properties": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "certificate": {
            "label": "Certificate",
            "description": null,
            "type": "string",
            "oneOf": [
              {
                "$ref": "#/definitions/Certificate"
              }
            ]
          },
          "messageSource": {
            "label": "Source",
            "description": "Location of plaintext information to encrypt",
            "type": "string",
            "default": "message.body"
          },
          "messageDestination": {
            "label": "Destination",
            "description": "Where to put the encrypted result",
            "type": "string",
            "default": "message.body"
          }
        },
        "required": [
          "certificate"
        ],
        "throw": [
          "CryptoError",
          "CertificateExpiredError"
        ]
      }
    });
    policies.push({
      "policy": "1.0.0",
      "info": {
        "title": translateFilter('policy.decrypt.title'),
        "name": "decrypt",
        "version": "1.0.0",
        "description": translateFilter('policy.decrypt.description'),
        "display": {
          color: '#7ED321',
          icon: 'lock_open'
        },
        "categories": [translateFilter('policy.categories.security')],
      },
      "gateways": [
        "datapower-gateway"
      ],
      "properties": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "certificate": {
            "label": "Certificate",
            "description": null,
            "type": "string",
            "oneOf": [
              {
                "$ref": "#/definitions/Certificate"
              }
            ]
          },
          "messageSource": {
            "label": "Source",
            "description": "Location of plaintext information to encrypt",
            "type": "string",
            "default": "message.body"
          },
          "messageDestination": {
            "label": "Destination",
            "description": "Where to put the encrypted result",
            "type": "string",
            "default": "message.body"
          }
        },
        "required": [
          "certificate"
        ],
        "throw": [
          "CryptoError",
          "CertificateExpiredError"
        ]
      }
    });
  }

  var policyPartials = {
    "map:1.0.0": "src/html/policies/mapper.html",
    "set-variable:1.0.0": "apim/assembly/policies/set-variable.html",
    "if:1.0.0": "src/html/policies/if.html",
    "throw:1.0.0": "src/html/policies/throw.html",
    "redact:1.0.0": "apim/assembly/policies/redact.html",
    "switch:1.0.0": "src/html/policies/switch.html",
    "operation-switch:1.0.0": "apim/assembly/policies/operation-switch.html",
    "validate:1.0.0": "apim/assembly/policies/validate.html",
    "activity-log:1.0.0": "apim/assembly/policies/activity-log.html",
    "invoke:1.0.0": "apim/assembly/policies/invoke.html",
    "proxy:1.0.0": "apim/assembly/policies/invoke.html",
    "xml-to-json:1.0.0": "apim/assembly/policies/xml2json.html",
    "json-to-xml:1.0.0": "apim/assembly/policies/json2xml.html",
    "catch:1.0.0": "src/html/policies/catch.html",
    "gatewayscript:1.0.0": "apim/assembly/policies/gatewayscript.html",
    /*jshint scripturl:true*/
    "javascript:1.0.0": "apim/assembly/policies/gatewayscript.html",
    "xslt:1.0.0": "apim/assembly/policies/transform-xslt.html",
    "jwt-generate:1.0.0": "apim/assembly/policies/jwt-generate-1.0.0.html",
    "jwt-generate:1.0.1": "apim/assembly/policies/jwt-generate-1.0.1.html",
    "jwt-validate:1.0.0": "apim/assembly/policies/jwt-validate-1.0.0.html",
    "jwt-validate:1.0.1": "apim/assembly/policies/jwt-validate-1.0.1.html",
    "oauth-generate:1.0.0": "apim/assembly/policies/oauth-generate.html",
    "validate-usernametoken:1.0.0": "apim/assembly/policies/validate-usernametoken.html",
    "ltpa-generate:1.0.0": "apim/assembly/policies/ltpa-generate.html",
    "encrypt:1.0.0": "apim/assembly/policies/encrypt.html",
    "decrypt:1.0.0": "apim/assembly/policies/decrypt.html",
    "assembly:1.0.0": "apim/assembly/policies/assembly.html",
    "pre-invoke-hook:1.0.0": "apim/assembly/policies/pre-invoke-hook.html",
    "post-invoke-hook:1.0.0": "apim/assembly/policies/post-invoke-hook.html",
    "handlebars:1.0.0": "apim/assembly/policies/handlebars.html",
    "parse:1.0.0": "apim/assembly/policies/parse.html"
  };

  return {
    getPolicies: function() {
      return $q(function(resolve, reject) {
        var allPolicies = angular.copy(policies);
        var httpError = '';
        function getPoliciesList(customPolicies) {
          customPolicies.forEach(function(policy) {
            if (!$rootScope.offlineMode) {
              // these policies can only apply to dp gateways
              // policy.info.gateways = {'micro': false};
            }
            policy.custom = true;
            // if the policy doesn't already define a version property, add one
            if (policy.properties && policy.properties.properties && !policy.properties.properties.version) {
              policy.properties.properties.version = {"type": "string"};
            }
            allPolicies.push(policy);
          });
        }

        if (!$rootScope.offlineMode)
          Policies.query({orgId: $rootScope.orgId}, function(response) {
            getPoliciesList(response);
          }).$promise.finally(function() {
            resolve(allPolicies);
          });
        else {
          Policies.query({orgId: $rootScope.orgId}, function(response) {
            getPoliciesList(response);
          }).$promise.then(function(response) {
            // check if running with API Connect v6 DataPower Gateway (experimental)
            return $http.get('/apic-config/get?key=datapower-api-gateway-experimental');
          }).then(function(apicConfig) {
            if (apicConfig.data === 'true')
              return $http.get('proxy/orgs/localhost/DPConfigPolicies');
          }).then(function(response) {
            if (response) {
              var DPConfigPolicies = response.data;
              allPolicies.forEach(function(policy, key) {
                var dpGatewayIndex = policy.gateways.indexOf('datapower-gateway');
                if (dpGatewayIndex > -1 && this.indexOf(policy.info.name) === -1) {
                  // filter out policies not supported by v6 DataPower Gateway (experimental)
                  policy.gateways.splice(dpGatewayIndex, 1);
                }
              }, DPConfigPolicies);

              // add DP Assembly Parse Action
              allPolicies.push({
                info: {
                  title: translateFilter('policy.parse.title'),
                  description: translateFilter('policy.parse.description'),
                  name: 'parse',
                  version: '1.0.0',
                  categories: [translateFilter('policy.categories.transforms')],
                  display: {
                    color: '#4B68FA',
                    icon: 'transform'
                  }
                },
                gateways: ['datapower-gateway'],
                properties: {
                  type: 'object',
                  additionalProperties: false,
                  properties: {
                    title: {
                      type: 'string'
                    },
                    description: {
                      type: 'string'
                    },
                    version: {
                      type: 'string'
                    },
                    'settings-reference': {
                      type: 'string',
                      'default': 'apic-default-parsesettings'
                    }
                  }
                }
              });

              allPolicies.push({
                info: {
                  title: translateFilter('policy.oauth-generate.title'),
                  description: translateFilter('policy.oauth-generate.description'),
                  name: "oauth-generate",
                  version: "1.0.0",
                  categories: [translateFilter('policy.categories.security')],
                  display: {
                    color: '#5EACF7',
                    icon: 'adjust'
                  }
                },
                gateways: ["datapower-gateway"],
                properties: {
                  type: "object",
                  additionalProperties: false,
                  properties: {
                    url: {
                      type: "string"
                    },
                    literal: {
                      type: "string"
                    },
                    provider: {
                      type: "string"
                    }
                  }
                }
              });
            }
          }).catch(function(err) {
            if (err.config && err.config.url.indexOf('DPConfigPolicies') > -1)
              httpError = err;
          }).finally(function() {
            if (httpError === '')
              resolve(allPolicies);
            else
              reject(httpError);
          });
        }
      });
    },
    getPolicyPartial: function(policyName, policyVersion) {
      if (!policyVersion) policyVersion = "1.0.0";
      var customPartial = policyPartials[policyName + ":" + policyVersion];
      return (customPartial) ? customPartial : "src/html/policies/generator.html";
    }
  }
}]);

angular.module("apim.apis").controller("ValidateUsernameTokenController", ['$scope', ValidateUsernameTokenController]);

function ValidateUsernameTokenController($scope) {

  if (!$scope.selectedNode['auth-type']) $scope.selectedNode['auth-type'] = "Authentication URL";
  $scope.$authType = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value === "Authentication URL") {
        delete $scope.selectedNode['ldap-registry'];
        delete $scope.selectedNode['ldap-search-attribute'];
      } else if (value === "LDAP Registry") {
        delete $scope.selectedNode['auth-url'];
        delete $scope.selectedNode['tls-profile'];
      }
      $scope.selectedNode['auth-type'] = value;
    } else {
      return $scope.selectedNode['auth-type'];
    }
  }

};

angular.module("apim.apis").controller("ActivityLogController", ['$scope', ActivityLogController]);

function ActivityLogController($scope) {

  this.logLevels = [{
    value: "none",
    name: "none"
  },{
    value: "activity",
    name: "activity"
  },{
    value: "header",
    name: "header"
  },{
    value: "payload",
    name: "payload"
  }];

};

angular.module('apiconnect-assembly').controller('LtpaKeyListController', ['$rootScope', '$scope', 'translateFilter', 'LtpaKey', LtpaKeyListController]);

function LtpaKeyListController($rootScope, $scope, translateFilter, LtpaKey) {
  var ltpaKeys = [];
  if (!$rootScope.offlineMode) {
    LtpaKey.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
      var uniqueNames = {};
      keys.forEach(function(key) {
        if (!uniqueNames[key.info.name]) {
          uniqueNames[key.info.name] = true;
          ltpaKeys.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: key.info.name + ":latest"});
        }
        ltpaKeys.push({name: key.info.title + ", " + key.info.version, value: key.info.name + ":" + key.info.version});
      });
    });
  }
  this.ltpaKeys = ltpaKeys;
};

angular.module('apiconnect-assembly').controller('CertificateListController', ['$rootScope', '$scope', 'Certificate', 'translateFilter', CertificateListController]);

function CertificateListController($rootScope, $scope, Certificate, translateFilter) {
  var certificates = [];
  if (!$rootScope.offlineMode) {
    Certificate.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
      var uniqueNames = {};
      keys.forEach(function(key) {
        if (!uniqueNames[key.info.name]) {
          uniqueNames[key.info.name] = true;
          certificates.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: key.info.name + ":latest"});
        }
        certificates.push({name: key.info.title + ", " + key.info.version, value: key.info.name + ":" + key.info.version});
      });
    });
  }
  this.certificates = certificates;
};

angular.module('apiconnect-assembly').controller('PrivateKeyListController', ['$rootScope', '$scope', 'PrivateKey', 'translateFilter', PrivateKeyListController]);

function PrivateKeyListController($rootScope, $scope, PrivateKey, translateFilter) {
  var privateKeys = [];
  if (!$rootScope.offlineMode) {
    PrivateKey.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
      var uniqueNames = {};
      keys.forEach(function(key) {
        if (!uniqueNames[key.info.name]) {
          uniqueNames[key.info.name] = true;
          privateKeys.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: key.info.name + ":latest"});
        }
        privateKeys.push({name: key.info.title + ", " + key.info.version, value: key.info.name + ":" + key.info.version});
      });
    });
  }
  this.privateKeys = privateKeys;
};

angular.module('apiconnect-assembly').controller('SharedSecretListController', ['$rootScope', '$scope', 'SharedSecret', 'translateFilter', SharedSecretListController]);

function SharedSecretListController($rootScope, $scope, SharedSecret, translateFilter) {
  var sharedSecrets = [];
  if (!$rootScope.offlineMode) {
    SharedSecret.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
      var uniqueNames = {};
      keys.forEach(function(key) {
        if (!uniqueNames[key.info.name]) {
          uniqueNames[key.info.name] = true;
          sharedSecrets.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: key.info.name + ":latest"});
        }
        sharedSecrets.push({name: key.info.title + ", " + key.info.version, value: key.info.name + ":" + key.info.version});
      });
    });
  }
  this.sharedSecrets = sharedSecrets;
};

angular.module('apiconnect-assembly').controller('PrivateKeyAndSharedSecretListController', ['$rootScope', '$scope', 'PrivateKey', 'SharedSecret', 'translateFilter', PrivateKeyAndSharedSecretListController]);

function PrivateKeyAndSharedSecretListController($rootScope, $scope, PrivateKey, SharedSecret, translateFilter) {
  var first = true;
  var second = true;
  var result = [];
  var uniqueNames = {};

  if (!$rootScope.offlineMode) {
    PrivateKey.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
      keys.forEach(function(key) {
        if (!uniqueNames[key.info.name]) {
          uniqueNames[key.info.name] = true;
          if (first) {
            result.push({name: translateFilter("subsection-private-keys"), value: "*header"});
            first = false;
          }
          result.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: "private-key/" + key.info.name + ":latest"});
        }
        result.push({name: key.info.title + ", " + key.info.version, value: "private-key/" + key.info.name + ":" + key.info.version});
      });

      SharedSecret.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
        keys.forEach(function(key) {
          if (!uniqueNames[key.info.name]) {
            uniqueNames[key.info.name] = true;
            if (second) {
              result.push({name: translateFilter("subsection-shared-secrets"), value: "*header"});
              second = false;
            }
            result.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: "shared-secret/" + key.info.name + ":latest"});
          }
          result.push({name: key.info.title + ", " + key.info.version, value: "shared-secret/" + key.info.name + ":" + key.info.version});
        });
      });
    });
  }
  this.result = result;
};

angular.module('apiconnect-assembly').controller('CertificateAndSharedSecretListController', ['$rootScope', '$scope', 'Certificate', 'SharedSecret', 'translateFilter', CertificateAndSharedSecretListController]);

function CertificateAndSharedSecretListController($rootScope, $scope, Certificate, SharedSecret, translateFilter) {
  var first = true;
  var second = true;
  var result = [];
  var uniqueNames = {};

  if (!$rootScope.offlineMode) {
    Certificate.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
      keys.forEach(function(key) {
        if (!uniqueNames[key.info.name]) {
          uniqueNames[key.info.name] = true;
          if (first) {
            result.push({name: translateFilter("subsection-certificates"), value: "*header"});
            first = false;
          }
          result.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: "public-key/" + key.info.name + ":latest"});
        }
        result.push({name: key.info.title + ", " + key.info.version, value: "public-key/" + key.info.name + ":" + key.info.version});
      });

      SharedSecret.query({orgId: $rootScope.orgId}).$promise.then(function(keys) {
        keys.forEach(function(key) {
          if (!uniqueNames[key.info.name]) {
            uniqueNames[key.info.name] = true;
            if (second) {
              result.push({name: translateFilter("subsection-shared-secrets"), value: "*header"});
              second = false;
            }
            result.push({name: key.info.title + ", " + translateFilter("assembly_latest_version"), value: "shared-secret/" + key.info.name + ":latest"});
          }
          result.push({name: key.info.title + ", " + key.info.version, value: "shared-secret/" + key.info.name + ":" + key.info.version});
        });
      });
    });
  }

  this.result = result;
};

angular.module('apiconnect-assembly').controller('ExternalAssemblyController', ['$scope', 'ComponentRegistry', ExternalAssemblyController]);

function ExternalAssemblyController($scope, ComponentRegistry) {

  $scope.referenceLink = ComponentRegistry.referenceToLink($scope.selectedNode.$ref);

  $scope.$watch("selectedNode.title", function() {
    $scope.selectedNode.$$parent.title = $scope.selectedNode.title;
  });

};

angular.module('apiconnect-assembly').controller('oauthAssemblyController', ['$scope', '$rootScope', 'Oauth', oauthAssemblyController]);

function oauthAssemblyController($scope, $rootScope, Oauth) {
  $scope.oauthProviders = Oauth.query({
    orgId: $rootScope.orgId
  });
};

