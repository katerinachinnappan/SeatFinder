/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apim.models')
  .controller('ModelEditController', [
    '$scope',
    '$log',
    '$stateParams',
    '$modal',
    '$location',
    '$q',
    '$timeout',
    'ModelDefinition',
    'ModelConfig',
    'ModelProperty',
    'DataSourceDefinition',
    'Project',
    'DirtyService',
    'TrackingServices',
    function ModelEditController(
      $scope, $log, $stateParams, $modal, $location, $q, $timeout, ModelDefinition, ModelConfig,
      ModelProperty, DataSourceDefinition, Project, DirtyService, TrackingServices
    ) {
      var propWatchOverride = true;

      $scope.model = null;
      $scope.modelConfig = null;
      $scope.xhrProcessing = 4;
      $scope.propertyTypes = null;
      $scope.modelPropertyErrors = false;

      $scope.$on('event:modelPropertyError', function($event, isInvalid){
        $scope.modelPropertyErrors = isInvalid;
      });

      $scope.$watch('model', function(newVal, oldVal) {
        if (newVal && oldVal) {
          DirtyService.setDirty('ModelEditController');
        }
      }, true);

      $scope.$watch('modelConfig', function(newVal, oldVal) {
        if (newVal && oldVal) {
          DirtyService.setDirty('ModelEditController');
        }
      }, true);

      $scope.$watch('modelProperties', function (newVal, oldVal) {
        // this is to prevent the dirty state being set after saving
        // due to the property array being updated.
          //
          // TODO(jtary) change the watches to avoid needing this
        if (propWatchOverride) {
          $timeout(function() {
            propWatchOverride = false;
          }, 1000);

          return;
        }

        if (newVal && oldVal) {
          DirtyService.setDirty('ModelEditController');
        }

        if (Array.isArray(newVal)) {
          newVal.map(function (prop) {
            prop.id = [prop.facetName, $scope.model.name, prop.name].join('.');
          });
        }
      }, true);

      $scope.checkDirtyModel = function() {
        return DirtyService.isDirty('ModelEditController');
      };

      $scope.$on("$locationChangeStart", function (event, next, current) {
        if ($scope.checkDirtyModel()) {
          event.preventDefault();
          $scope.confirmation = {
            titleKey: 'unsaved_changes_title',
            messageKey: 'unsaved_changes',
            confirmed: function() {
              DirtyService.clearDirty('ModelEditController');
              $location.path($location.url(next).hash());
            },
            rejected: function() {
            }
          };
          $modal.open({
            templateUrl: 'apim/partials/confirmation.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'ConfirmationController',
            size: 'sm',
            scope: $scope
          });
        }
      });

      $scope.propertyIdExists = function(id){
        var idExists = false;

        $scope.modelProperties.forEach(function(prop, i){
          if (prop.id === id){
            idExists = true;
          }
        });

        return idExists;
      };

      // check if properties have duplicate ids
      $scope.propertiesHasDuplicateIds = function(){
        $scope.propertyErrors = {};

        $scope.modelProperties.forEach(function(prop, i){
          // let duplicate ids that are marked for delete pass the duplicate name check
          var withoutDeletions = _.filter($scope.modelProperties, function(item){
            return !item.deleted;
          });

          var existingProp = _.filter(withoutDeletions, { 'name': prop.name });

          if (existingProp.length > 1){
            $scope.propertyErrors[existingProp.id] = 'Duplicate property name';
          }
        });

        return Object.keys($scope.propertyErrors).length;
      };

      $scope.$watch('xhrProcessing', function(newVal) {
        if (newVal === 0) {
          $timeout(function() {
            $scope.$root.$broadcast('update.bannerItems');
          }, 0);
        }
      });

      $scope.decrementXhrProcessing = function(){
        if ( $scope.xhrProcessing > 0 ) {
          $scope.xhrProcessing -= 1;
        }
      };

      $scope.incrementXhrProcessing = function(){
        $scope.xhrProcessing += 1;
      };

      ModelConfig.find(
        { filter: { where: { name: $stateParams.id } } },
        function (response) {
          $scope.decrementXhrProcessing();

          if (response.length > 0) {
            $scope.modelConfig = response[0];
          } else {
            $scope.modelConfig = {
              dataSource: 'db',
              facetName: 'server',
              id: 'server.' + $stateParams.id,
              name: $stateParams.id
            }
          }

          // if public isn't set, loopback will treat it as enabled
          if ($scope.modelConfig.public == null) {
            $scope.modelConfig.public = true;
          }
        }
      );

      ModelDefinition.find(
        { filter: { where: { name: $stateParams.id } } },
        function (response) {
          $scope.decrementXhrProcessing();
          $scope.model = response[0];
          refreshModelProperties(null, $scope.model);
        }
      );

      ModelProperty.getAvailableTypes(
        function (response) {
          $scope.propertyTypes = response.filter(function(type) {
            return type !== 'array';
          });
        }
      );

      function refreshModelProperties(opts, model) {
        ModelProperty.find(
          { filter: { where: { modelId: model.id }}},
          function (response) {
            $scope.modelProperties = response;
            response.map(function(prop){
              //refresh from server, so we save the id for deletion later if
              //property has changed.
                prop.origId = prop.id;
            });

            $scope.decrementXhrProcessing();
          }
        );
      }

      DataSourceDefinition.find(
        {},
        function (response) {
          $scope.decrementXhrProcessing();
          $scope.dataSources = response.map(function(ds) {
            return ds.name;
          });
        }
      );

      $scope.addProperty = function() {
        // don't let user add more than one blank property at a time
        if ($scope.propertyIdExists($scope.model.id+'.')){
          var messageId = new Date().getTime();

          return $scope.$root.notifyUser(
            'duplicatePropertyName', [], "ERROR", true, messageId
          );
        }

        $scope.modelProperties.push({
          facetName: $scope.model.facetName,
          modelId: $scope.model.id,
          name: '',
          required: false,
          type: 'number'
        });

        DirtyService.setDirty('ModelEditController');
      };

      function includeProp(prop) {
        return prop.name !== '' && !prop.deleted;
      }

      function saveProperties (promises) {
        var currReq;

        function makeReq(prop, index){
          if (prop.deleted) {
            return ModelProperty.deleteById({ id: prop.id }).$promise;
          } else if (includeProp(prop)){
            //avoid new id where updated properties were resulting in new generated properties
            //doing an update
            if ( prop.origId ) {
              return ModelProperty.deleteById({ id: prop.origId }).$promise
                .then(function(){
                  delete prop.origId;
                  return ModelProperty.upsert({id: prop.id}, prop).$promise
                    .then(function (res) {
                      prop.updateResource = res;
                    });
                })
            } else {
              return ModelProperty.upsert({id: prop.id}, prop).$promise
                .then(function (res) {
                  prop.updateResource = res;
                });
            }
          }
        }


        $scope.modelProperties.map(function (prop, index) {
          if (!currReq) {
            currReq = makeReq(prop, index);
          } else {
            currReq = currReq.then(function(result){
              return makeReq(prop, index);
            });
          }
        });

        //get response from chain of promises
        if (currReq){
          return currReq.then(function () {
            $scope.modelProperties = $scope.modelProperties.map(
              function(prop) {
                if (!includeProp(prop)) {
                  return null;
                }

                return angular.extend(prop, prop.updateResource);
              }
            ).filter(function(prop) {
              return prop != null;
            });
          });
        } else {
          var def = $q.defer();
          def.resolve();
          return def.promise;
        }
      }

      $scope.exportSwagger = function(cb) {
        $timeout(function() {
          Project.exportSwagger().$promise
            .then(cb)
            .finally(function(){
              $scope.xhrProcessing = false;
            });
        }, 1000);
      };

      $scope.save = function() {
        if (!$scope.checkDirtyModel()) return;
        var promises = [];
        var messageId = new Date().getTime();

        $scope.incrementXhrProcessing();

        $scope.$root.notifyUser(
          'savingModel', [], "BUSY", false, messageId
        );

        promises.push(ModelDefinition.upsert($scope.model));
        promises.push(ModelConfig.upsert($scope.modelConfig));

        if ($scope.propertiesHasDuplicateIds()) {
          $scope.decrementXhrProcessing();
          return $scope.$root.notifyUser(
            'duplicatePropertyName', [], "ERROR", true, messageId
          );
        }

        return saveProperties(promises).then(function () {
          var dfd = $q.defer();

          $scope.exportSwagger(function() {
            DirtyService.clearDirty('ModelEditController');
            propWatchOverride = true;
            $scope.$root.notifyUser(
              'modelSaved', [], "SUCCESS", true, messageId
            );

            refreshModelProperties(null, $scope.model);
            TrackingServices.track('model', 'saveModelProperties', { dataSource: $scope.modelConfig.dataSource });
            dfd.resolve();
          });

          return dfd.promise;
        })
          .catch(function(err){
            $scope.$root.notifyUser(
              'saveModelFailed', [], "ERROR", true, messageId
            );
          });
      };
    }
  ])
  .controller('NewModelDialogController', [
    '$scope',
    '$modalInstance',
    'models',
    'TrackingServices',
    function($scope, $modalInstance, models, TrackingServices) {
      $scope.model = {};
      $scope.models = models;

      $scope.cancel = function() {
        $modalInstance.dismiss();
      };

      $scope.submit = function(form) {
        if (form.$invalid) {
          return;
        }

        TrackingServices.track('model', 'addNewModel');

        $modalInstance.close($scope.model);
      };
    }
  ])
  .controller('ModelsController', [
    '$scope',
    '$log',
    '$state',
    '$modal',
    '$timeout',
    '$q',
    'ModelDefinition',
    'ModelConfig',
    'ModalHelper',
    'ModelServices',
    'Project',
    'DataSourceDefinition',
    function ModelsController($scope, $log, $state, $modal, $timeout, $q,
      ModelDefinition, ModelConfig, ModalHelper, ModelServices, Project,
      DataSourceDefinition) {
        $scope.models = [];
        $scope.xhrProcessing = true;

        var dataSources;
        DataSourceDefinition.find().$promise
          .then(function (response) {
            dataSources = response;
          });

        var getModels = function() {
          ModelDefinition.find(
            { filter: { where: { readonly: false } } },
            function (response) {
              $scope.xhrProcessing = false;
              $scope.models = response;
            }
          );
        };
        getModels();

        var openModel = function (model) {
          $state.go('model', {id: model.name});
        };

        $scope.newModel = function () {
          $modal.open({
            templateUrl: 'apim/models/partials/newModelDialog.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'NewModelDialogController',
            resolve: {
              models: function () {
                return ModelDefinition.find(
                  { filter: { where: { readonly: false } } }
                );
              }
            }
          }).result
            .then(function(model) {
              $scope.xhrProcessing = true;

              ModelServices.create(model.name, dataSources)
                .then(function(model) {
                  Project.exportSwagger();
                  openModel(model);
                })
                .finally(function () {
                  $scope.xhrProcessing = false;
                })
            })
        };

        $scope.deleteModel = function(models) {
          if (!models || models.length < 1) {
            return;
          }

          var plural = models.length > 1 ? 's' : '';
          ModalHelper.confirm({
            title: 'confirmDeleteItem' + plural + 'Title',
            message: 'confirmDeleteItem' + plural,
            confirmation: function() {
              var messageId = new Date().getTime();
              $scope.$root.notifyUser('deletingModel', [], 'BUSY', false, messageId);

              $q.all(models.map(function (model) {
                return ModelConfig.deleteById({
                  id: 'server.' + model.name
                }).$promise
                  .then(function() {
                    return ModelDefinition.deleteById(model).$promise;
                  })
                  .then(function() {
                    $scope.models.splice($scope.models.indexOf(model), 1);
                    return $q.resolve();
                  });
              }))
                .then(function() {
                  $scope.$root.notifyUser('modelDeleted', [], 'SUCCESS', false, messageId);
                  return Project.exportSwagger();
                })
                .finally(getModels)
                .catch(function(err) {
                  $scope.$root.notifyUser('deleteModelError', [], 'ERROR', true, messageId);
                });
            },
            rejected: function() {}
          });
        };
    }
  ]);

