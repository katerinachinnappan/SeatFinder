/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var objects = angular.module('apim.objects', ['ngResource']);

objects.controller('ObjectsController', ['$scope', '$rootScope', '$stateParams', '$mdDialog', '$modal', 'Oauth', 'LtpaKey', 'SharedSecret', 'Certificate', 'PrivateKey', 'KerberosKeytab', 'SSLProfile', 'UserRegistry', ObjectsController]);

function ObjectsController($scope, $rootScope, $stateParams, $mdDialog, $modal, Oauth, LtpaKey, SharedSecret, Certificate, PrivateKey, KerberosKeytab, SSLProfile, UserRegistry) {

  $scope.objectTypes = {
    1: {
      label: 'subsection-tlsprofiles',
      value: 'tls',
      resource: SSLProfile,
      template: 'apim/objects/partials/tls-profile-editor.html',
      controller: 'ObjectsTLSProfileController',
      idParameter: 'objId'
    },
    2: {
      label: 'subsection-userregistries',
      value: 'idp',
      resource: UserRegistry,
      template: '',
      controller: '',
      idParameter: 'idpId'
    },
    3: {
      label: 'subsection-ltpa-keys',
      value: 'ltpa',
      resource: LtpaKey,
      template: 'apim/objects/partials/ltpa-key-editor.html',
      controller: 'ObjectsLtpaKeyController',
      idParameter: 'objId'
    },
    4: {
      label: 'subsection-certificates',
      value: 'public-key',
      resource: Certificate,
      template: 'apim/objects/partials/certificate-editor.html',
      controller: 'ObjectsCertificateController',
      idParameter: 'objId'
    },
    5: {
      label: 'subsection-private-keys',
      value: 'private',
      resource: PrivateKey,
      template: 'apim/objects/partials/private-key-editor.html',
      controller: 'ObjectsPrivateKeyController',
      idParameter: 'objId'
    },
    6: {
      label: 'subsection-kerberos-keytabs',
      value: 'keytab',
      resource: KerberosKeytab,
      template: 'apim/objects/partials/kerberos-keytab-editor.html',
      controller: 'ObjectsKerberosKeytabController',
      idParameter: 'objId'
    },
    7: {
      label: 'subsection-shared-secrets',
      value: 'sharedsecret',
      resource: SharedSecret,
      template: 'apim/objects/partials/shared-secret-editor.html',
      controller: 'ObjectsSharedSecretController',
      idParameter: 'objId'
    },
    8: {
      label: 'subsection-oauth-providers',
      value: 'oauth',
      resource: Oauth,
      template: 'apim/objects/partials/oauth-provider-editor.html',
      controller: 'ObjectsOauthProviderController',
      idParameter: 'objId'
    }
  };

  var TLS_TABNUMBER, OAUTH_TABNUMBER;
  if ($stateParams.section && $scope.objectTypes[$stateParams.section]) {
    $scope.tab = $stateParams.section;
  } else {
    for (var object in $scope.objectTypes) {
      if ($scope.objectTypes[object].value === 'tls') {
        TLS_TABNUMBER = Number(object);
      }
      if ($scope.objectTypes[object].value === 'oauth') {
        OAUTH_TABNUMBER = Number(object);
      }
    }
    $scope.tab = $scope.offlineMode ? OAUTH_TABNUMBER : TLS_TABNUMBER;
  }

  $scope.sectionTitle = $scope.objectTypes[$scope.tab].label;
  $scope.orderProp = 'title';

  $scope.query = "";
  if ($stateParams.filter) {
    $scope.query = $stateParams.filter;
  }

  $scope.hideToc = false;
  $scope.toggleToc = function() {
    $scope.hideToc = !$scope.hideToc;
  };

  $scope.openView = function(tab, query) {
    $scope.tab = tab;
    $scope.query = query;
    $scope.sectionTitle = $scope.objectTypes[$scope.tab].label;
    $scope.orderProp = 'title';
    $scope.orderDirection = false;
    $scope.refreshContent();
  };

  $scope.refreshContent = function() {
    $scope.objects = $scope.objectTypes[$scope.tab].resource.query({
      orgId: $scope.orgId
    });
  };

  $scope.addItem = function($event) {
    $modal.open({
      controller: $scope.objectTypes[$scope.tab].controller,
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: $scope.objectTypes[$scope.tab].template,
      resolve: {
        object: function () {
          return null;
        },
      },
      scope: $scope,
    }).result.then(function(newObject) {
      $scope.refreshContent();
    });
  };

  $scope.deleteItem = function(object, suffix) {
    $scope.confirmation = {
      title: suffix + '-title',
      messageKey: suffix + '-message',
      confirmed: function() {
        var args = {orgId: $scope.orgId};
        if ($scope.tab === 8) {
          args.objId = object.name;
        } else {
          args[$scope.objectTypes[$scope.tab].idParameter] = object.id;
        }
        $scope.objects.splice($scope.objects.indexOf(object), 1);
        object.$delete(args).catch($scope.refreshContent);
      },
      rejected: function() {}
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };

  $scope.editItem = function($event, object) {
    $modal.open({
      controller: $scope.objectTypes[$scope.tab].controller,
      templateUrl: $scope.objectTypes[$scope.tab].template,
      windowTemplateUrl: 'apim/partials/main-template.html',
      resolve: {
        object: function () {
          return object;
        },
      },
      scope: $scope,
    }).result.then (function(newObject) {
      $scope.refreshContent();
    });
  };

  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.refreshContent();
  });

};

objects.controller('UserRegistriesController', ['$scope', '$rootScope', '$modalStack', '$modal', 'IDP', 'CmcIDP', 'CmcIDPScopes', UserRegistriesController]);

function UserRegistriesController($scope, $rootScope, $modalStack, $modal, IDP, CmcIDP, CmcIDPScopes) {

  function showUserRegistryDialog(evt, controller, templateUrl, locals) {
    $modal.open({
      controller: controller,
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: templateUrl,
      scope: $scope,
      resolve: locals
    }).result.then(function(idp) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of registries here
      $scope.refreshContent();
    });
  };

  $scope.newLdapProfile = function(evt) {
    showUserRegistryDialog(evt, 'CreateLDAPCtrl', 'apim/idps/partials/createLdapDialog.html', {
      outerScope: function() { return $scope},
      source: function() { return  ["portal"] },
      object: function() { return null }
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateLDAPCtrl',
      // 	templateUrl: 'apim/idps/partials/createLdapDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["portal"],
        //         object: null
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.newLdapProfileAPIOnly = function(evt) {
    showUserRegistryDialog(evt, 'CreateLDAPCtrl', 'apim/idps/partials/createLdapDialog.html', {
      outerScope: function() { return $scope },
      source: function() { return ["api"] },
      object: function() { return null }
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateLDAPCtrl',
      // 	templateUrl: 'apim/idps/partials/createLdapDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["api"],
        //         object: null
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.editLdapProfile = function(evt, object) {
    showUserRegistryDialog(evt, 'CreateLDAPCtrl', 'apim/idps/partials/editLdapDialog.html', {
      outerScope: function() { return $scope },
      source: function() { return ["portal"] },
      object: function() { return object }
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateLDAPCtrl',
      // 	templateUrl: 'apim/idps/partials/editLdapDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["portal"],
        // 		object: object
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.newAuthUrlProfile = function(evt) {
    showUserRegistryDialog(evt, 'CreateAuthUrlCtrl', 'apim/idps/partials/createAuthUrlDialog.html', {
      outerScope: function() { return $scope },
      source: function() { return ["portal"] },
      object: function() { return null }
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateAuthUrlCtrl',
      // 	templateUrl: 'apim/idps/partials/createAuthUrlDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["portal"],
        //         object: null
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.editAuthUrlProfile = function(evt, object) {
    showUserRegistryDialog(evt, 'CreateAuthUrlCtrl', 'apim/idps/partials/editAuthUrlDialog.html', {
      outerScope: function() { return $scope },
      source: function() {return ["portal"] },
      object: function() { return object }
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateAuthUrlCtrl',
      // 	templateUrl: 'apim/idps/partials/editAuthUrlDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["portal"],
        // 		object: object
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.newLocalProfile = function(evt) {
    showUserRegistryDialog(evt, 'NewLocalRegistryController', 'apim/idps/partials/new-local-registry.html', {
      outerScope: function() { return $scope; },
      object: function() { return null; }
    }
    );
    // $mdDialog.show({
      // 	controller: 'NewLocalRegistryController',
      // 	templateUrl: 'apim/idps/partials/new-local-registry.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        //         object: null
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.editLocalProfile = function(evt, object) {
    showUserRegistryDialog(evt, 'NewLocalRegistryController', 'apim/idps/partials/edit-local-registry.html', {
      outerScope: function() { return $scope; },
      object: function() {return object; }
    }
    );
    // $mdDialog.show({
      // 	controller: 'NewLocalRegistryController',
      // 	templateUrl: 'apim/idps/partials/edit-local-registry.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		object: object
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.newScimProfile = function(evt) {
    showUserRegistryDialog(evt, 'CreateSCIMCtrl', 'apim/idps/partials/createScimDialog.html', {
      outerScope: function() { return $scope},
      source: function() { return ["portal"];},
      object: function() { return null;}
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateSCIMCtrl',
      // 	templateUrl: 'apim/idps/partials/createScimDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["portal"],
        //         object: null
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.editScimProfile = function(evt, object) {
    showUserRegistryDialog(evt, 'CreateSCIMCtrl', 'apim/idps/partials/editScimDialog.html', {
      outerScope: function() { return $scope; },
      source: function() {  return ["portal"] },
      object:  function() { return object }
    }
    );
    // $mdDialog.show({
      // 	controller: 'CreateSCIMCtrl',
      // 	templateUrl: 'apim/idps/partials/editScimDialog.html',
      // 	parent: angular.element(document.body),
      // 	targetEvent: evt,
      // 	focusOnOpen: false,
      // 	locals: {
        // 		outerScope: $scope,
        // 		source: ["portal"],
        // 		object: object
        // 	}
      // }).then(function(idp) {
        // 	// Dialog will stay on screen for errors and will always follow the good path
        // 	// when the create works. We can then refresh the list of registries here
        // 	$scope.refreshContent();
        // }, function() {
          // 	// called when dialog is cancelled - nothing to do
            // });
  };

  $scope.saveIDP = function(theIDP) {
    var idp = theIDP;
    var timestamp = (new Date()).getTime();
    var messageId = "IDP_UPDATE_" + timestamp;
    $scope.$root.notifyUser('updatingIDP', [], "BUSY", false, messageId);
    // must filter out redacted passwords
    if (idp.ldapConfig && idp.ldapConfig.authenticatedBindPassword == "*****") {
      idp = angular.copy(idp);
      delete idp.ldapConfig.authenticatedBindPassword;
    }
    else if (idp.scimConfig && idp.scimConfig.scimAdminPassword == "*****") {
      idp = angular.copy(idp);
      delete idp.scimConfig.scimAdminPassword;
    }

    // HACK(david)
    // Bluemix carbon radioButton doesnt support true/false values
    // in idpsControllers its converted to str, converting back to boolean for save
    if (theIDP.ldapConfig && typeof theIDP.ldapConfig.authenticatedBind === 'string') {
      theIDP.ldapConfig.authenticatedBind = theIDP.ldapConfig.authenticatedBind === 'true' ? true : false
    }

    var saveHandler = function() {
      $scope.$root.notifyUser('updatedIDP', [], "SUCCESS", true, messageId);
      // reset save button on success
      $scope.saveDisabled = true;
      $scope.$broadcast('IDP_saved');
      $modalStack.dismissAll();
    };
    var saveErrorHandler = function(err) {
      $scope.$root.notifyUser('failedUpdateIDP', [], "ERROR", false, messageId);
      $modalStack.dismissAll(err);
    };

    if ($rootScope.context == "cmc") {
      // need to update scope first
      if(idp.scope.indexOf("portal") != -1) {
        var newScope = new CmcIDPScopes({scopes: ["portal"]});
        newScope.$update({idpId: idp.id}).then(function(){
          // then save idp and the return data will have the correct scope
          CmcIDP.update({idpId: idp.id}, idp).$promise.then(saveHandler, saveErrorHandler);
        }, saveErrorHandler);
      } else {
        CmcIDPScopes.remove({idpId: idp.id, scope: "portal"}).$promise.then(function() {
          // then save idp and the return data will have the correct scope
          CmcIDP.update({idpId: idp.id}, idp).$promise.then(saveHandler, saveErrorHandler);
        }, saveErrorHandler);
      }

    } else {
      IDP.update({orgId: $scope.orgId, idpId: idp.id}, idp).$promise.then(saveHandler, saveErrorHandler);
    }
  };


};

objects.controller('ObjectsUserRegistryController', ['$scope', 'translateFilter', ObjectsUserRegistryController]);

function ObjectsUserRegistryController($scope, translateFilter) {

  if ($scope.registry.type === 'ldap') $scope.registry.$$type = translateFilter('idpNewLdapProfile');
  if ($scope.registry.type === 'apim') $scope.registry.$$type = translateFilter('idpNewLocalRegistry');
  if ($scope.registry.type === 'authUrl') $scope.registry.$$type = translateFilter('idpNewAuthUrlRegistry');
  if ($scope.registry.type === 'scim') $scope.registry.$$type = translateFilter('idpNewScimUserRegistry');

  $scope.editUserRegistry = function(event, registry) {
    if (registry.type === 'ldap') $scope.editLdapProfile(event, registry);
    if (registry.type === 'apim') $scope.editLocalProfile(event, registry);
    if (registry.type === 'authUrl') $scope.editAuthUrlProfile(event, registry);
    if (registry.type === 'scim') $scope.editScimProfile(event, registry);
  };

};

objects.controller('ObjectsLtpaKeyController', ['$scope', '$rootScope', '$timeout', '$modalInstance', '$q', 'uiUploader', 'errorHandler', 'LtpaKey', 'SlugService', 'object', ObjectsLtpaKeyController]);

function ObjectsLtpaKeyController($scope, $rootScope, $timeout, $modalInstance, $q, uiUploader, errorHandler, LtpaKey, SlugService, object) {

  if (object) {
    $scope.ltpaKey = object;
    $scope.dialogTitle = 'objects-edit-ltpa-key';
  } else {
    $scope.ltpaKey = new LtpaKey();
    $scope.ltpaKey['ltpa-key'] = '1.0.0';
    if (!$scope.ltpaKey.info) $scope.ltpaKey.info = {};
    $scope.ltpaKey.info.version = "1.0.0";
    $scope.dialogTitle = 'objects-create-ltpa-key';
  }
  if (!$scope.ltpaKey.properties) $scope.ltpaKey.properties = {};

  if (!$scope.ltpaKey.id) {
    $scope.$watch('ltpaKey.info.title', function() {
      $scope.ltpaKey.info.name = SlugService.createName($scope.ltpaKey.info.title);
    })
  }

  $timeout(function() {
    $("#" + $scope.$id + "_ltpa_key_file").change(function() {
      var reader = new FileReader();
      reader.onload = function(event) {
        $scope.ltpaKey.properties.file = window.base64js.fromByteArray(new Uint8Array(event.target.result));
        $scope.$apply();
      }
      reader.readAsArrayBuffer($scope.files[0]);
    });
  }, 1000);

  function resetObject() {
    if ($scope.ltpaKey.id) {
      // reset the existing object
      $scope.ltpaKey.$get({
        orgId: $rootScope.orgId,
        objId: $scope.ltpaKey.id
      });
    }
  };

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.ltpaKey.$save({
      orgId: $rootScope.orgId
    }, function() {
      $modalInstance.close($scope.ltpaKey);
    }, function(error) {
      $modalInstance.dismiss(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    if ($scope.ltpaKey.properties && $scope.ltpaKey.properties.file === 'CONTENTS REDACTED') {
      delete $scope.ltpaKey.properties.file;
    }
    if ($scope.ltpaKey.properties && $scope.ltpaKey.properties.password === '*****') {
      delete $scope.ltpaKey.properties.password;
    }
    if ($scope.ltpaKey.properties && Object.keys($scope.ltpaKey.properties).length === 0) {
      delete $scope.ltpaKey.properties;
    }
    $scope.ltpaKey.$update({
      orgId: $rootScope.orgId,
      objId: $scope.ltpaKey.id
    }, function() {
      $modalInstance.close($scope.ltpaKey);
    }, function(error) {
      $modalInstance.dismiss(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.ltpaKey.id) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $modalInstance.dismiss();
    resetObject();
  };

};

objects.controller('ObjectsSharedSecretController', ['$scope', '$rootScope', '$timeout', '$mdDialog', '$q', 'uiUploader', 'errorHandler', 'SharedSecret', 'SlugService', 'object', ObjectsSharedSecretController]);

function ObjectsSharedSecretController($scope, $rootScope, $timeout, $mdDialog, $q, uiUploader, errorHandler, SharedSecret, SlugService, object) {

  if (object) {
    $scope.sharedSecret = object;
    $scope.dialogTitle = 'objects-edit-shared-secret';
  } else {
    $scope.sharedSecret = new SharedSecret();
    $scope.sharedSecret['shared-secret'] = '1.0.0';
    if (!$scope.sharedSecret.info) {
      $scope.sharedSecret.info = {};
    }
    $scope.sharedSecret.info.version = "1.0.0";
    $scope.dialogTitle = 'objects-create-shared-secret';
  }
  if (!$scope.sharedSecret.properties) $scope.sharedSecret.properties = {};

  if (!$scope.sharedSecret.id) {
    $scope.$watch('sharedSecret.info.title', function() {
      $scope.sharedSecret.info.name = SlugService.createName($scope.sharedSecret.info.title);
    })
  }

  $timeout(function() {
    $("#" + $scope.$id + "_shared_secret_file").change(function() {
      var reader = new FileReader();
      reader.onload = function(event) {
        $scope.sharedSecret.properties.file = window.base64js.fromByteArray(new Uint8Array(event.target.result));
        $scope.$apply();
      }
      reader.readAsArrayBuffer($scope.files[0]);
    });
  }, 1000);

  function resetObject() {
    if ($scope.sharedSecret.id) {
      // reset the existing object
      $scope.sharedSecret.$get({
        orgId: $rootScope.orgId,
        objId: $scope.sharedSecret.id
      });
    }
  };

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.sharedSecret.$save({
      orgId: $rootScope.orgId
    }, function() {
      $mdDialog.hide($scope.sharedSecret);
    }, function(error) {
      $mdDialog.cancel(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    if ($scope.sharedSecret.properties && $scope.sharedSecret.properties.file === 'CONTENTS REDACTED') {
      delete $scope.sharedSecret.properties.file;
    }
    if ($scope.sharedSecret.properties && $scope.sharedSecret.properties.password === '*****') {
      delete $scope.sharedSecret.properties.password;
    }
    if ($scope.sharedSecret.properties && Object.keys($scope.sharedSecret.properties).length === 0) {
      delete $scope.sharedSecret.properties;
    }
    $scope.sharedSecret.$update({
      orgId: $rootScope.orgId,
      objId: $scope.sharedSecret.id
    }, function() {
      $mdDialog.hide($scope.sharedSecret);
    }, function(error) {
      $mdDialog.cancel(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.sharedSecret.id) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $mdDialog.cancel();
    resetObject();
  };

};

objects.controller('ObjectsCertificateController', ['$scope', '$rootScope', '$timeout', '$mdDialog', '$q', 'uiUploader', 'errorHandler', 'Certificate', 'SlugService', 'object', ObjectsCertificateController]);

function ObjectsCertificateController($scope, $rootScope, $timeout, $mdDialog, $q, uiUploader, errorHandler, Certificate, SlugService, object) {

  if (object) {
    $scope.certificate = object;
    $scope.dialogTitle = 'objects-edit-certificate';
  } else {
    $scope.certificate = new Certificate();
    $scope.certificate['public-key'] = '1.0.0';
    if (!$scope.certificate.info) $scope.certificate.info = {};
    $scope.certificate.info.version = "1.0.0";
    $scope.dialogTitle = 'objects-create-certificate';
  }
  if (!$scope.certificate.properties) $scope.certificate.properties = {};

  if (!$scope.certificate.id) {
    $scope.$watch('certificate.info.title', function() {
      $scope.certificate.info.name = SlugService.createName($scope.certificate.info.title);
    })
  }

  $timeout(function() {
    $("#" + $scope.$id + "_certificate_file").change(function() {
      var reader = new FileReader();
      reader.onload = function(event) {
        $scope.certificate.properties.file = window.base64js.fromByteArray(new Uint8Array(event.target.result));
        $scope.$apply();
      }
      reader.readAsArrayBuffer($scope.files[0]);
    });
  }, 1000);

  function resetObject() {
    if ($scope.certificate.id) {
      // reset the existing object
      $scope.certificate.$get({
        orgId: $rootScope.orgId,
        objId: $scope.certificate.id
      });
    }
  };

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.certificate.$save({
      orgId: $rootScope.orgId
    }, function() {
      $mdDialog.hide($scope.certificate);
    }, function(error) {
      $mdDialog.cancel(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    if ($scope.certificate.properties && $scope.ltpaKey.properties.file === 'CONTENTS REDACTED') {
      delete $scope.certificate.properties.file;
    }
    if ($scope.certificate.properties && $scope.ltpaKey.properties.password === '*****') {
      delete $scope.certificate.properties.password;
    }
    if ($scope.certificate.properties && Object.keys($scope.certificate.properties).length === 0) {
      delete $scope.certificate.properties;
    }
    $scope.certificate.$update({
      orgId: $rootScope.orgId,
      objId: $scope.certificate.id
    }, function() {
      $mdDialog.hide($scope.certificate);
    }, function(error) {
      $mdDialog.cancel(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.certificate.id) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $mdDialog.cancel();
    resetObject();
  };

};

objects.controller('ObjectsPrivateKeyController', ['$scope', '$rootScope', '$timeout', '$mdDialog', '$q', 'uiUploader', 'errorHandler', 'PrivateKey', 'SlugService', 'object', ObjectsPrivateKeyController]);

function ObjectsPrivateKeyController($scope, $rootScope, $timeout, $mdDialog, $q, uiUploader, errorHandler, PrivateKey, SlugService, object) {

  if (object) {
    $scope.privateKey = object;
    $scope.dialogTitle = 'objects-edit-private-key';
  } else {
    $scope.privateKey = new PrivateKey();
    $scope.privateKey['private-key'] = '1.0.0';
    if (!$scope.privateKey.info) $scope.privateKey.info = {};
    $scope.privateKey.info.version = "1.0.0";
    $scope.dialogTitle = 'objects-create-private-key';
  }
  if (!$scope.privateKey.properties) $scope.privateKey.properties = {};

  if (!$scope.privateKey.id) {
    $scope.$watch('privateKey.info.title', function() {
      $scope.privateKey.info.name = SlugService.createName($scope.privateKey.info.title);
    })
  }

  $timeout(function() {
    $("#" + $scope.$id + "_private_key_file").change(function() {
      var reader = new FileReader();
      reader.onload = function(event) {
        $scope.privateKey.properties.file = window.base64js.fromByteArray(new Uint8Array(event.target.result));
        $scope.$apply();
      }
      reader.readAsArrayBuffer($scope.files[0]);
    });
  }, 1000);

  function resetObject() {
    if ($scope.privateKey.id) {
      // reset the existing object
      $scope.privateKey.$get({
        orgId: $rootScope.orgId,
        objId: $scope.privateKey.id
      });
    }
  };

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.privateKey.$save({
      orgId: $rootScope.orgId
    }, function() {
      $mdDialog.hide($scope.privateKey);
    }, function(error) {
      $mdDialog.cancel(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    if ($scope.privateKey.properties && $scope.privateKey.properties.file === 'CONTENTS REDACTED') {
      delete $scope.privateKey.properties.file;
    }
    if ($scope.privateKey.properties && $scope.privateKey.properties.password === '*****') {
      delete $scope.privateKey.properties.password;
    }
    if ($scope.privateKey.properties && Object.keys($scope.privateKey.properties).length === 0) {
      delete $scope.privateKey.properties;
    }
    $scope.privateKey.$update({
      orgId: $rootScope.orgId,
      objId: $scope.privateKey.id
    }, function() {
      $mdDialog.hide($scope.privateKey);
    }, function(error) {
      $mdDialog.cancel(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.privateKey.id) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $mdDialog.cancel();
    resetObject();
  };

};

objects.controller('ObjectsKerberosKeytabController', ['$scope', '$rootScope', '$timeout', '$mdDialog', '$q', 'uiUploader', 'errorHandler', 'KerberosKeytab', 'SlugService', 'object', ObjectsKerberosKeytabController]);

function ObjectsKerberosKeytabController($scope, $rootScope, $timeout, $mdDialog, $q, uiUploader, errorHandler, KerberosKeytab, SlugService, object) {

  if (object) {
    $scope.kerberosKeytab = object;
    $scope.dialogTitle = 'objects-edit-kerberos-keytab';
  } else {
    $scope.kerberosKeytab = new KerberosKeytab();
    $scope.kerberosKeytab['kerberos-keytab'] = '1.0.0';
    if (!$scope.kerberosKeytab.info) $scope.kerberosKeytab.info = {};
    $scope.kerberosKeytab.info.version = "1.0.0";
    $scope.dialogTitle = 'objects-create-kerberos-keytab';
  }
  if (!$scope.kerberosKeytab.properties) $scope.kerberosKeytab.properties = {};

  if (!$scope.kerberosKeytab.id) {
    $scope.$watch('kerberosKeytab.info.title', function() {
      $scope.kerberosKeytab.info.name = SlugService.createName($scope.kerberosKeytab.info.title);
    })
  }

  $timeout(function() {
    $("#" + $scope.$id + "_kerberos_keytab_file").change(function() {
      var reader = new FileReader();
      reader.onload = function(event) {
        $scope.kerberosKeytab.properties.file = window.base64js.fromByteArray(new Uint8Array(event.target.result));
        $scope.$apply();
      }
      reader.readAsArrayBuffer($scope.files[0]);
    });
  }, 1000);

  function resetObject() {
    if ($scope.kerberosKeytab.id) {
      // reset the existing object
      $scope.kerberosKeytab.$get({
        orgId: $rootScope.orgId,
        objId: $scope.kerberosKeytab.id
      });
    }
  };

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.kerberosKeytab.$save({
      orgId: $rootScope.orgId
    }, function() {
      $mdDialog.hide($scope.kerberosKeytab);
    }, function(error) {
      $mdDialog.cancel(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    if ($scope.kerberosKeytab.properties && $scope.kerberosKeytab.properties.file === 'CONTENTS REDACTED') {
      delete $scope.kerberosKeytab.properties.file;
    }
    if ($scope.kerberosKeytab.properties && $scope.kerberosKeytab.properties.password === '*****') {
      delete $scope.kerberosKeytab.properties.password;
    }
    if ($scope.kerberosKeytab.properties && Object.keys($scope.kerberosKeytab.properties).length === 0) {
      delete $scope.kerberosKeytab.properties;
    }
    $scope.kerberosKeytab.$update({
      orgId: $rootScope.orgId,
      objId: $scope.kerberosKeytab.id
    }, function() {
      $mdDialog.hide($scope.kerberosKeytab);
    }, function(error) {
      $mdDialog.cancel(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.kerberosKeytab.id) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $mdDialog.cancel();
    resetObject();
  };

};

objects.controller('TLSProfileEditorController', ['$scope', '$mdDialog', '$q', 'SSLProfile', 'SlugService', TLSProfileEditorController]);

function TLSProfileEditorController($scope, $rootScope, $mdDialog, $q, SSLProfile, SlugService) {

  $scope.onNavigateOut = function() {
    var deferred = $q.defer();
    deferred.resolve();
    return deferred.promise;
  }

};

objects.controller('ObjectsTLSProfileController', ['$scope', '$rootScope', '$modalInstance', 'SSLProfile', 'SlugService', 'object', ObjectsTLSProfileController]);

function ObjectsTLSProfileController($scope, $rootScope, $modalInstance, SSLProfile, SlugService, object) {

  $scope.permissions = $rootScope.permissions;

  $scope.performingUpload = false;

  if (object) {
    $scope.selectedSSLProfile = object;
    $scope.dialogTitle = 'objects-edit-tls-profile';
  } else {
    $scope.selectedSSLProfile = new SSLProfile();
    $scope.dialogTitle = 'objects-create-tls-profile';
    $scope.hideCertDetails = true;
  }

  if (!$scope.selectedSSLProfile.id) {
    $scope.$watch('selectedSSLProfile.title', function() {
      $scope.selectedSSLProfile.name = SlugService.createName($scope.selectedSSLProfile.title);
    })
  }

  function resetObject() {
    delete $scope.performingUpload;
    if ($scope.selectedSSLProfile.id) {
      // reset the existing object
      $scope.selectedSSLProfile.$get({
        orgId: $rootScope.orgId,
        objId: $scope.selectedSSLProfile.id
      });
    }
  };

  $scope.$on('file_upload_started', function() {
    $scope.performingUpload = true;
  });

  $scope.$on('file_upload_completed', resetObject);

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.selectedSSLProfile.$save({
      orgId: $rootScope.orgId
    }, function() {
      $modalInstance.close($scope.selectedSSLProfile);
    }, function(error) {
      $modalInstance.dismiss(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    $scope.selectedSSLProfile.$update({
      orgId: $rootScope.orgId,
      objId: $scope.selectedSSLProfile.id
    }, function() {
      $modalInstance.close($scope.selectedSSLProfile);
    }, function(error) {
      $modalInstance.dismiss(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.selectedSSLProfile.id) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $modalInstance.dismiss();
    resetObject();
  };

};

objects.controller('ObjectsOauthProviderController', ['$scope', '$rootScope', '$filter', '$modalInstance', 'Oauth', 'SlugService','object', ObjectsOauthProviderController]);

function ObjectsOauthProviderController($scope, $rootScope, $filter, $modalInstance, Oauth, SlugService, object) {
  function generateName(newVal) {
    if (object) return;
    try {
      $scope.selectedOauth.name = SlugService.createName(newVal);
    } catch (e) {
      $scope.selectOauth.name = '';
    }
  }

  $scope.$watch('selectedOauth.title', generateName);

  if (object) {
    $scope.objId = object.name;
    $scope.selectedOauth = object;
    $scope.dialogTitle = 'objects-edit-oauth-provider';
  } else {
    $scope.selectedOauth = new Oauth();
    $scope.dialogTitle = 'objects-create-oauth-provider';
    $scope.hideCertDetails = true;
  }

  $scope.$introspection = function (value) {
    if (value === undefined) {
      return $scope.selectedOauth['apic-enable-introspection'];
    }
    if (value) {
      $scope.selectedOauth['apic-enable-introspection'] = true;
      $scope.selectedOauth['apic-introspect-endpoint'] = '/oauth2/introspect';
    } else {
      $scope.selectedOauth['apic-enable-introspection'] = false;
      delete $scope.selectedOauth['apic-introspect-endpoint'];
    }
  };

  $scope.$refreshTokens = function(value) {
    if (value === undefined) {
      return $scope.selectedOauth['apic-enable-refresh-token'];
    }
    if (value) {
      $scope.selectedOauth['apic-enable-refresh-token'] = true;
      $scope.selectedOauth['apic-refresh-token-limit'] = 10;
      $scope.selectedOauth['apic-refresh-token-ttl'] = 5400;
    } else {
      $scope.selectedOauth['apic-enable-refresh-token'] = false;
      delete $scope.selectedOauth['apic-refresh-token-ttl'];
      delete $scope.selectedOauth['apic-refresh-token-limit'];
    }
  };

  function setRefreshTokenSupported() {
    $scope.grantSupportsRefreshTokens = false;
    if ($scope.selectedOauth && $scope.selectedOauth.grants) {
      $scope.grantSupportsRefreshTokens = (
        $scope.selectedOauth.grants.indexOf('password') >= 0 ||
        $scope.selectedOauth.grants.indexOf('accessCode') >= 0
      );
    }
    if ($scope.grantSupportsRefreshTokens === false) {
      $scope.$refreshTokens(false);
    }
  };

  setRefreshTokenSupported();

  $scope.grantType = function(grantType, value) {
    if (!$scope.selectedOauth ||
      !$scope.selectedOauth.grants) return;
    if (value !== undefined) {
      if ((value === true) && $scope.selectedOauth.grants.indexOf(grantType) < 0) {
        $scope.selectedOauth.grants.push(grantType);
      } else {
        if ((value === false) && $scope.selectedOauth.grants.indexOf(grantType) > -1) {
          $scope.selectedOauth.grants = $scope.selectedOauth.grants.filter(function(type) {
            return (type !== grantType);
          });
        }
      }

    setRefreshTokenSupported();
    } else {
      return ($scope.selectedOauth.grants.indexOf(grantType) > -1);
    }
  };

  $scope.$grantTypeImplicit = function(value) {
    return $scope.grantType("implicit", value);
  };

  $scope.$grantTypePassword = function(value) {
    return $scope.grantType("password", value);
  };

  $scope.$grantTypeApplication = function(value) {
    return $scope.grantType("application", value);
  };

  $scope.$grantTypeAccessCode = function(value) {
    return $scope.grantType("accessCode", value);
  };

  $scope.clientType = function(clientType, value) {
    if (!$scope.selectedOauth) {
      return;
    }
    if(!$scope.selectedOauth.clients) {
      $scope.selectedOauth.clients = [];
    }
    if (value === undefined) {
      return $scope.selectedOauth.clients.indexOf(clientType) > -1;
    }
    if ((value === true) && $scope.selectedOauth.clients.indexOf(clientType) < 0) {
      $scope.selectedOauth.clients.push(clientType);
    } else {
      if ((value === false) && $scope.selectedOauth.clients.indexOf(clientType) > -1) {
        $scope.selectedOauth.clients = $scope.selectedOauth.clients.filter(function(type) {
          return (type !== clientType);
        });
      }
    }
  };

  $scope.$clientTypeConfidential = function(value) {
    return $scope.clientType("confidential", value);
  };

  $scope.$clientTypePublic = function(value) {
    return $scope.clientType("public", value);
  };

  $scope.createScope = function() {
    var scopeNameRoot = $filter('translate')('api_oauth_new_scope');
    var suffix = 2;
    while ($scope.selectedOauth && $scope.selectedOauth[scopeNameRoot]) {
      scopeNameRoot = scopeNameRoot + '_' + suffix;
      suffix++;
    }
    $scope.selectedOauth.scopes = $scope.selectedOauth.scopes || {};
    $scope.selectedOauth.scopes[scopeNameRoot] = '';
  };

  function resetObject() {
    if ($scope.objId) {
      $scope.selectedOauth.$get({
        orgId: $rootScope.orgId,
        objId: $scope.objId
      });
    }
  };

  function saveObject() {
    $scope.modifyingObject = true;
    $scope.selectedOauth.$save({
      orgId: $rootScope.orgId
    }, function() {
      $modalInstance.close($scope.selectedOauth);
    }, function(error) {
      $modalInstance.dismiss(error);
    });
  };

  function updateObject() {
    $scope.modifyingObject = true;
    $scope.selectedOauth.$update({
      orgId: $rootScope.orgId,
      objId: $scope.objId
    }, function() {
      $modalInstance.close($scope.selectedOauth);
    }, function(error) {
      $modalInstance.dismiss(error);
      resetObject();
    });
  };

  $scope.commit = function() {
    if ($scope.objId) {
      updateObject();
    } else {
      saveObject();
    }
  }

  $scope.cancel = function() {
    $modalInstance.dismiss();
    resetObject();
  };
}

objects.controller('OAuthProviderScopeController', ['$scope', OAuthProviderScopeController]);

function OAuthProviderScopeController($scope) {
  var self = this;

  self.$oauthScopeName = function(newName) {
    if (arguments.length) {
      if(newName) {
        var updatedScopes = {};
        Object.keys($scope.selectedOauth.scopes).forEach(function(scopeName) {
          if(scopeName === $scope.oauthScopeName) {
            updatedScopes[newName] = $scope.oauthScope;
          } else {
            updatedScopes[scopeName] = $scope.selectedOauth.scopes[scopeName];
          }
        });
        $scope.selectedOauth.scopes = updatedScopes;
        $scope.oauthScopeName = newName;
      }
    } else {
      return $scope.oauthScopeName;
    }
  };

  self.removeScope = function() {
    var updatedScopes = {};
    Object.keys($scope.selectedOauth.scopes).forEach(function(scopeName) {
      if(scopeName !== $scope.oauthScopeName) {
        updatedScopes[scopeName] = $scope.selectedOauth.scopes[scopeName];
      }
    });
    $scope.selectedOauth.scopes = updatedScopes;
    if (Object.keys(updatedScopes).length === 0) {
      $scope.createScope();
    }
  };
};
