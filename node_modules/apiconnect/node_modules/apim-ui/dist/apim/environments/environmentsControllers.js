/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2015, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

/* Controllers */

var environments = angular.module('apim.environments', ['ngResource']);

environments.controller('EnvironmentsCtrl', ['$scope', '$q', '$modal', '$filter', '$mdSidenav', 'Environment', 'UserRegistry', 'GatewayCluster', 'Space', environmentsController]);

function environmentsController($scope, $q, $modal, $filter, $mdSidenav, Environment, UserRegistry, GatewayCluster, Space) {

  $scope.spacesChanged = false;

  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.registries = UserRegistry.query({orgId: $scope.currentOrg.id});
    if (!$scope.offlineMode) {
      $scope.refreshEnvironments();
    }
  });

  // Eventually this will end up querying for all the cluster types
  $scope.dataPowerGateways = GatewayCluster.query();

  // We need to end up with one giant array for convenience on the
  // new endpoints panel later
  $q.all([$scope.dataPowerGateways.$promise]).then(function(){
    $scope.gateways = $scope.dataPowerGateways

    // This is kept for existing function compatibility
    $scope.setGatewayClusters($scope.dataPowerGateways);
  });

  $scope.onNavigateOut = function() {
    var deferred = $q.defer();
    if($scope.environmentDirty) {
      $scope.confirmation = {
        titleKey: 'unsavedChanges',
        message: $filter('translate')('environmentUnsavedChanges', {environment: $scope.selectedEnvironment.name}),
        confirmed: function() {
          $scope.environmentDirty = false;
          deferred.resolve(true);
        },
        rejected: function() {
          deferred.reject();
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        scope: $scope
      });
    } else {
      deferred.resolve(true);
    }
    return deferred.promise;
  };

  $scope.getIdFromUrl = function(url) {
    return url.substring(url.lastIndexOf("/") + 1);
  };

};

environments.controller('EnvironmentCtrl', ['$scope', '$window', '$q', '$location', '$modal', '$filter', '$mdDialog', 'Environment', 'GatewayCluster', 'EnvRole', 'UserRegistry', 'CollectivesList', 'Space', 'TrackingServices', environmentController]);

function environmentController($scope, $window, $q, $location, $modal, $filter, $mdDialog, Environment, GatewayCluster, EnvRole, UserRegistry, CollectivesList, Space, TrackingServices) {
  // this is defined in app/index.html as a global variable
  $scope.isSaaS = $window.isSaaS;
  $scope.seenEnvironment = true;

  // regular expression for catalog name
  $scope.catalogNameRegEx = '[a-z0-9-]+';
  $scope.portalUrlRegEx = '^(https?:\/\/)?(([a-z0-9]|[a-z0-9][_a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][_a-z0-9\-]*[a-z0-9])(\/(([a-zA-Z0-9]|[a-zA-Z0-9][_a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][_A-Za-z0-9\-]*[A-Za-z0-9]))*\/?$';

  $scope.$on("$locationChangeStart", function (event, next, current) {
    if ($scope.$parent.environmentDirty) {
      event.preventDefault();
      $scope.confirmation = {
        titleKey: 'unsaved_changes_title',
        messageKey: 'unsaved_changes',
        confirmed: function() {
          $scope.refreshEnvironments();
          $scope.$parent.environmentDirty = false;
          $location.path($location.url(next).hash());
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        size: 'sm',
        scope: $scope
      });
    }
  });
  $scope.clusterListReady = $q.defer();
  if(!$scope.gatewayClusters) {
    // Eventually this will end up querying for all the cluster types
    $scope.dataPowerGateways = GatewayCluster.query();

    // We need to end up with one giant array for convenience on the
    // new endpoints panel later
    $q.all([$scope.dataPowerGateways.$promise]).then(function(){
      $scope.gateways = $scope.dataPowerGateways

      // This is kept for existing function compatibility
      $scope.setGatewayClusters($scope.dataPowerGateways);
      $scope.clusterListReady.resolve();
    });
  } else {
    $scope.clusterListReady.resolve();
  }

  $scope.$watch('environment', function() {
    if (!$scope.environment) return;
    $scope.selectedEnvironment = $scope.environment;
    $scope.registries = UserRegistry.query({orgId: $scope.currentOrg.id, catalog: $scope.selectedEnvironment.id, scope: 'portal'});

    if ($scope.selectedEnvironment.spaceEnabled) {
      $scope.refreshContent();
    }
  });

  $scope.refreshContent = function() {
    if (!$scope.selectedEnvironment.spaceEnabled) {
      return;
    }
    $scope.spaces = Space.query({orgId: $scope.orgId, envId: $scope.environment.id});
    $scope.spaces.$promise.then(function() {
      $scope.spacesCache = {};
      var len = $scope.spaces.length;
      for (var i=0;i<len;i++) {
        $scope.spacesCache[$scope.spaces[i].id] = $scope.spaces[i];
      } // end for
      $scope.spacesLoaded = true;
    });
  };

  $scope.envChecked = false;
  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.$watch('environments', function() {
      if (!$scope.environments) return;
      var hashArray = window.location.hash.split("/");
      var envId = hashArray[2];
      // always re-set the current environment as it's contents may have changed
      if (envId != "environments" && (!$scope.environment || $scope.environment.id != envId)) {
        var filtered = $scope.environments.filter(function(env) {
          return env.id == envId;
        });
        if (filtered.length > 0) {
          $scope.setEnvironment(filtered[0]);
        }
      }
      // make sure we setup the correct space if we land directly on this page
      if (hashArray[3] == "spaces") {
        var spaceId = hashArray[4];
        if (spaceId != $scope.spaceId) {
          $scope.setSpace(spaceId, true);
        }
      } else if ($scope.spaceId) {
        $scope.setSpace("", true);
      }
      if ($scope.environment) {
        $scope.envChecked = true;
        var queryArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id
        };
        if ($scope.spaceId) {
          queryArgs.spaces = "spaces";
          queryArgs.spaceId = $scope.spaceId;
        }
        $scope.roles = EnvRole.query(queryArgs);
        $scope.roles.$promise.then(
          function() {
            $scope.rolesLoaded = true;
            if($scope.roles.length > 0 && !$scope.selectedRoleDetails) $scope.selectRole($scope.roles[0]);
          }
        );
      }
    });
  });
  $scope.saveDisabled = true;
  $scope.advancePortalConfirmed = false;
  $scope.fetchingCollectives = true;
  $scope.collectivesLookup = {};
  $scope.appsLookup = {};
  $scope.dirtyRoles = {};
  $scope.rolesCache = {};
  $scope.dirtySpaces = {};
  $scope.spacesCache = {};
  $scope.portalTypes = [
    {name: $filter('translate')('catalog_no_portal'), value: "BASIC"},
    {name: $filter('translate')('advancedDeveloperPortal'), value: "ADVANCED"},
    {name: $filter('translate')('otherDeveloperPortal'), value: "OTHER"}
  ];
  $scope.collectives = CollectivesList.query();
  $scope.collectives.$promise.then(function(resp) {
    // create instant lookup by ID
    var len = resp.length;
    for (var i=0;i<len;i++) {
      $scope.collectivesLookup[resp[i].id] = resp[i];
    } // end for
    $scope.fetchingCollectives = false;
  }, function(err) {
    $scope.fetchingCollectives = false;
  });

  $scope.selectRole = function(role) {
    $scope.selectedRole = role;
    if (!$scope.rolesCache[role.id]) {
      var queryArgs = {
        orgId: $scope.orgId,
        envId: $scope.environment.id,
        roleId: role.id
      };
      if ($scope.spaceId) {
        queryArgs.spaces = "spaces";
        queryArgs.spaceId = $scope.spaceId;
      }
      $scope.selectedRoleDetails = EnvRole.get(queryArgs);
      $scope.rolesCache[role.id] = $scope.selectedRoleDetails;
    } else {
      $scope.selectedRoleDetails = $scope.rolesCache[role.id];
    }
  };

  // Called when role data changes
  $scope.handleSave = function(evt, canSave, changedRoleId, changedSpaceId) {
    if (Object.keys($scope.dirtyRoles).length > 0 || Object.keys($scope.dirtySpaces).length > 0) {
      // already have some dirty roles or spaces - make sure we always show the save button
      $scope.saveDisabled = false;
      $scope.$parent.environmentDirty = true;
    } else {
      $scope.saveDisabled = !canSave;
    }
    if (canSave) {
      if (changedRoleId) {
        $scope.dirtyRoles[changedRoleId] = true;
        $scope.$parent.environmentDirty = true;
      }
      if (changedSpaceId) {
        $scope.dirtySpaces[changedSpaceId] = true;
        $scope.$parent.environmentDirty = true;
      }
    }
  };

  $scope.$on("EnvRole_canSave", $scope.handleSave);
  $scope.$on("EnvSpace_canSave", $scope.handleSave);

  $scope.getIdFromUrl = function(url) {
    return url ? url.substring(url.lastIndexOf("/") + 1) : null;
  };

  $scope.userRegistryChanged = function(registry) {
    $scope.selectedEnvironment.idp = registry.id;
    if(registry.type == "scim") {
      $scope.selectedEnvironment.selfSignUpEnabled = false;
    }
    $scope.portalDelegatedRegistry = (registry.type == "portal");
  };

  var previousTestAppSetting = false;
  $scope.sandboxChanged = function() {
    $scope.showSandboxWarning = $scope.selectedEnvironment.autoDeploy;
    if ($scope.selectedEnvironment.autoDeploy) {
      $scope.selectedEnvironment.testAppEnabled = previousTestAppSetting;
    } else {
      previousTestAppSetting = $scope.selectedEnvironment.testAppEnabled;
      $scope.selectedEnvironment.testAppEnabled = false;
    }
  };

  $scope.advancePortalChanged = function() {
    if($scope.selectedEnvironment.portalType && $scope.selectedEnvironment.portalType == "ADVANCED") {
      $scope.advancePortalConfirmed = true;
      TrackingServices.track('portal', 'devPortal');
      // pre-fill the portal URL if one was not originally present
      if (!$scope.selectedEnvironment.customPortalUrl) {
        $scope.selectedEnvironment.customPortalUrl = $scope.selectedEnvironment.portalUrl;
      }
    }
  };

  $scope.clusterChanged = function() {
    $scope.envModified(true);
  };

  $scope.$overrideGatewayServices = function(enabled) {
    if (!$scope.spacesCache || !$scope.spacesCache[$scope.spaceId]) return;
    if (typeof enabled !== "undefined") {
      // Setter
      if (enabled) {
        if (!$scope.spacesCache[$scope.spaceId].gwServices) {
          $scope.spacesCache[$scope.spaceId].gwServices = [];
          $scope.$emit("EnvSpace_canSave", true, null, $scope.spaceId);
        }
      } else {
        delete $scope.spacesCache[$scope.spaceId].gwServices;
        $scope.$emit("EnvSpace_canSave", true, null, $scope.spaceId);
      }
    } else {
      // Getter
      return ($scope.spacesCache[$scope.spaceId].gwServices !== undefined);
    }
  }

  $scope.$spaceEnabled = function() {
    if (!$scope.selectedEnvironment) return;
    if(!$scope.firstSpaceToggle) {
      $scope.firstSpaceToggle = true;
      $scope.spaceStateEnabled = $scope.selectedEnvironment.spaceEnabled;
    }
    if (arguments.length) {
      // Setter
      var state = arguments[0];
      if (state) {
        $scope.confirmation = {
          titleKey: 'env_enable_spaces',
          messageKey: 'env_enable_spaces_desc',
          positiveAction: 'env_enable_spaces_button',
          confirmed: function() {
            $scope.selectedEnvironment.spaceEnabled = true;
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'sm',
          scope: $scope
        });
      } else {
        $scope.selectedEnvironment.spaceEnabled = false;
      }
    } else {
      // Getter
      var ret = false;
      if ($scope.selectedEnvironment.spaceEnabled) {
        ret = true;
      }
      return ret;
    }
  };

  $scope.$applicationLifecycleEnabled = function() {
    if (!$scope.selectedEnvironment) return;
    if (arguments.length) {
      // Setter
      if (arguments[0]) {
        $scope.confirmation = {
          titleKey: 'env_enable_application_lifecycle',
          messageKey: 'env_enable_application_lifecycle_desc',
          messageKeyList: [
            'env_enable_application_lifecycle_1',
            'env_enable_application_lifecycle_2',
            'env_enable_application_lifecycle_3',
            'env_enable_application_lifecycle_4',
          ],
          positiveAction: 'env_enable_application_lifecycle_button',
          confirmed: function() {
            $scope.selectedEnvironment.applicationLifecycleEnabled = true;
          },
          rejected: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/confirmation.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'ConfirmationController',
          size: 'md',
          scope: $scope
        });
      } else {
        $scope.selectedEnvironment.applicationLifecycleEnabled = false;
      }
      return;
    } else {
      // Getter
      return Boolean($scope.selectedEnvironment.applicationLifecycleEnabled);
    }
  };


  $scope.envModified = function(clusterUpdated) {
    $scope.showSandboxWarning = false;
    if(!$scope.selectedEnvironment) return;

    $scope.advancePortalConfirmed = false;

    $scope.originalPortalType = $scope.selectedEnvironment.portalType;

    var envClusterId, clusterId, i;
    if(!$scope.selectedGatewayCluster) {
      if ($scope.selectedEnvironment.microGateway && $scope.selectedEnvironment.microGateway.collectiveId) {
        // specified collective rather than gateway - must clear gateway value
        $scope.selectedEnvironment.gatewayClusterUrl = null;
      } else {
        // First time
        envClusterId = $scope.getIdFromUrl($scope.selectedEnvironment.gatewayClusterUrl);

        $scope.clusterListReady.promise.then(function() {
          var clusters = $scope.gatewayClusters;
          for(i=0; i<clusters.length; i++) {
            clusterId = $scope.getIdFromUrl(clusters[i].url);
            if(clusterId == envClusterId) {
              $scope.selectedGatewayCluster = clusters[i];
              break;
            }
          }
        });
      }
    } else if(clusterUpdated === true) {
      envClusterId = $scope.getIdFromUrl($scope.selectedEnvironment.gatewayClusterUrl);
      clusterId = $scope.getIdFromUrl($scope.selectedGatewayCluster.url);
      if(envClusterId != clusterId) {
        $scope.selectedEnvironment.gatewayClusterUrl = $scope.selectedGatewayCluster.url.substring($scope.selectedGatewayCluster.url.lastIndexOf("/gatewayClusters"));
      }
    }

    if($scope.selectedEnvironment.availableRoles.length > 1 && $scope.selectedEnvironment.availableRoles[0] != "viewer") {
      $scope.selectedEnvironment.availableRoles = $scope.selectedEnvironment.availableRoles.reverse();
    }

    if(!$scope.selectedEnvironment.portalType) $scope.selectedEnvironment.portalType = "BASIC";

    if ($scope.selectedEnvironment.gatewayType === 'DataPowerGateway') {
      $scope.selectedGatewayClusters = $scope.selectedEnvironment.gwServices;
      $scope.updateGatewayClusterObjects();
    } else {
      $scope.selectedGatewayClusters = [];
    }
  };

  $scope.envChanged = function(newEnv, oldEnv) {
    if (!oldEnv) {
      return;
    }
    if(!$scope.selectedEnvironment) return;
    if ($scope.spacesChanged) {
      // dont mark dirty if we made a known spaces change
      $scope.spacesChanged = false;
      $scope.$parent.environmentDirty = false;
    } else {
      if ($scope.seenEnvironment) {
        $scope.saveDisabled = false;
        $scope.$parent.environmentDirty = !!Object.keys($scope.dirtySpaces).length;
      } else {
        $scope.saveDisabled = true;
        $scope.$parent.environmentDirty = false;
      }
      $scope.seenEnvironment = true;
    }

    // fetch the collective apps for a selected collective
    if ($scope.selectedEnvironment.microGateway && $scope.selectedEnvironment.microGateway.collectiveId) {
      $scope.collectiveApps = CollectivesList.queryApps({id: $scope.selectedEnvironment.microGateway.collectiveId});
      $scope.collectiveApps.$promise.then(function(resp) {
        var len = resp.length;
        for (var i=0;i<len;i++) {
          $scope.appsLookup[resp[i].id] = resp[i];
        } // end for
      }, function(err) {
      });
    }

    if ($scope.isPortalIDP()){
      $scope.selectedEnvironment.selfSignUpEnabled = true;
    }

    // Update cluster selection
    //   var envClusterId = $scope.getIdFromUrl($scope.selectedEnvironment.gatewayClusterUrl);
    //   $scope.clusterListReady.promise.then(function() {
    //     var clusters = $scope.gatewayClusters;
    //     for(var i=0; i<clusters.length; i++) {
    //       var clusterId = $scope.getIdFromUrl(clusters[i].url);
    //       if(clusterId == envClusterId) {
    //         $scope.selectedGatewayCluster = clusters[i];
    //         break;
    //       }
    //     }
    //   });
    if ($scope.selectedEnvironment.gatewayType === "DataPowerGateway") {
      $scope.selectedGatewayClusters = $scope.selectedEnvironment.gwServices;
      $scope.updateGatewayClusterObjects();
    } else {
      $scope.selectedGatewayClusters = [];
    }
  };

  $scope.$watch('selectedGatewayCluster', $scope.clusterChanged);
  $scope.$watch('selectedEnvironment', $scope.envModified);
  $scope.$watch('selectedEnvironment', $scope.envChanged, true);

  $scope.$collaboratorRoles = function(value) {
    if (typeof value !== "undefined") {
      switch (value) {
        case "viewer":
          $scope.selectedEnvironment.availableRoles = ["viewer"];
          break;
        case "developer":
          $scope.selectedEnvironment.availableRoles = ["developer"];
          break;
        default:
          $scope.selectedEnvironment.availableRoles = ["viewer", "developer"];
      }
    } else {
      if ($scope.selectedEnvironment.availableRoles.length === 0) {
        return "";
      }
      if ($scope.selectedEnvironment.availableRoles.length > 1) {
        return "viewer_developer";
      }
      return $scope.selectedEnvironment.availableRoles[0];
    }
  };

  $scope.checkConfigAndSave = function() {
    if ($scope.environmentForm.$invalid || $scope.saveDisabled) return;
    if ($scope.selectedEnvironment.portalType !== "OTHER" &&
      $scope.selectedEnvironment.apimRestDnsHost) {
        $scope.selectedEnvironment.apimRestDnsHost = '';
    }
    if($scope.originalPortalType == "ADVANCED" && $scope.selectedEnvironment.portalType != "ADVANCED") {
      $scope.confirmation = {
        titleKey: 'confirmDeletionOfPortal',
        message: $filter('translate')('portalDeleteWarning', {environment: $scope.selectedEnvironment.name}),
        confirmed: function() {
          $scope.originalPortalType = $scope.selectedEnvironment.portalType;
          $scope.saveEnvironment();
        },
        rejected: function() {
        }
      };
      $modal.open({
        templateUrl: 'apim/partials/confirmation.html',
        windowTemplateUrl: 'apim/partials/main-template.html',
        controller: 'ConfirmationController',
        scope: $scope
      });
    } else {
      $scope.saveEnvironment();
    }
  };

  var saveRole = function(roleId) {
    var deferred = $q.defer();
    var ret = deferred.promise;
    if (roleId) {
      var roleToSave = $scope.rolesCache[roleId];
      if (roleToSave) {
        var updateArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id,
          roleId: roleId
        };
        if ($scope.spaceId) {
          updateArgs.spaces = "spaces";
          updateArgs.spaceId = $scope.spaceId;
        }
        ret = roleToSave.$update(updateArgs);
      } else {
        deferred.resolve();
      }
    } else {
      deferred.resolve();
    }
    return ret;
  };

  var saveSpace = function(spaceId) {
    var deferred = $q.defer();
    var ret = deferred.promise;
    if (spaceId) {

      var spaceToSave = $scope.spacesCache[spaceId];
      if (!spaceToSave && $scope.selectedSpace &&
        $scope.selectedSpace.id === spaceId) {
          spaceToSave = $scope.selectedSpace;
      }
      if (spaceToSave) {
        ret = spaceToSave.$update({orgId: $scope.orgId, envId: $scope.environment.id, spaceId: spaceId});
      } else {
        deferred.resolve();
      }
    } else {
      deferred.resolve();
    }
    return ret;
  };

  var saveEnvSettings = function() {
    if($scope.selectedEnvironment.customPortalUrl && $scope.selectedEnvironment.customPortalUrl.lastIndexOf("/") == $scope.selectedEnvironment.customPortalUrl.length - 1) {
      $scope.selectedEnvironment.customPortalUrl = $scope.selectedEnvironment.customPortalUrl.substring(0, $scope.selectedEnvironment.customPortalUrl.length - 1);
    }
    if (!$scope.isSaaS) {
      $scope.selectedEnvironment.advPortalUrl = "";
    }
    return $scope.selectedEnvironment.$update({orgId: $scope.orgId, envId: $scope.selectedEnvironment.id});
  };

  var chainPromises = function(masterDeferred, promises) {
    if (promises.length === 0) {
      masterDeferred.resolve();
      return;
    }
    promises[0]().then(function() {
      chainPromises(masterDeferred, promises.slice(1));
    }, function(error) {
      masterDeferred.reject(error);
    });
  };

  $scope.saveEnvironment = function() {
    $scope.showSandboxWarning = false;
    $scope.$root.notifyUser('savingEnvironment', {}, 'BUSY', true, 'savingEnvironment');
    $scope.saveDisabled = true;
    var masterDeferred = $q.defer();
    var saveFunctions = [];
    // only save main settings if at catalog level
    if (!$scope.spaceId) {
      saveFunctions.push(saveEnvSettings);
    }
    // add each dirty role to the list of save functions
    var saveFn;
    for (var key in $scope.dirtyRoles) {
      saveFn = (function() {
        var roleId = key;
        return function() {
          return saveRole(roleId);
        };
      })();
      saveFunctions.push(saveFn);
    } // end for
    // add each dirty space to the list of save functions
    for (key in $scope.dirtySpaces) {
      saveFn = (function() {
        var spaceId = key;
        return function() {
          return saveSpace(spaceId);
        };
      })();
      saveFunctions.push(saveFn);
    } // end for
    // masterDeferred will get triggered when all saves are good or when the first one fails
    masterDeferred.promise.then(function() {
      $scope.refreshPermissions();
      $scope.saveDisabled = true;
      $scope.$parent.environmentDirty = false;
      $scope.firstSpaceToggle = false;
      $scope.seenEnvironment = false;
      $scope.dirtyRoles = {};
      $scope.$broadcast("EnvRole_saved");
      $scope.refreshContent();
      $scope.notifyUser('environmentSaved', {}, 'SUCCESS', true, 'savingEnvironment');
      if($scope.originalPortalType != "ADVANCED" && $scope.selectedEnvironment.portalType == "ADVANCED" && $scope.advancePortalConfirmed) {
        $scope.originalPortalType = $scope.selectedEnvironment.portalType;
        $scope.information = {
          titleKey: 'advancedPortalCreationTitle',
          message: $filter('translate')('advancedPortalCreation', {environment: $scope.selectedEnvironment.name}),
          accepted: function() {
          }
        };
        $modal.open({
          templateUrl: 'apim/partials/information.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'InformationController',
          scope: $scope
        });
      }
      $scope.advancePortalConfirmed = false;
      $scope.setPublishableTargets();
      $scope.refreshEnvironments();
    }, function(error) {
      $scope.saveDisabled = false;
      $scope.advancePortalConfirmed = false;
      $scope.notifyUser('environmentSaveError', {}, 'ERROR', true, 'savingEnvironment');
    });
    // make the actual save
    chainPromises(masterDeferred, saveFunctions);
  };

  $scope.toggleApproval = function(action, subAction) {
    if(subAction.required) {
      // Add to list of approval requirements
      $scope.selectedEnvironment.permissions[action.required].push(subAction.name);
    } else {
      // Remove from list of approval requirements
      var index = $scope.selectedEnvironment.permissions[action.required].indexOf(subAction.name);
      $scope.selectedEnvironment.permissions[action.required].splice(index, 1);
    }
  };

  $scope.createRoleTag = function (id, roles) {
    if(!id) return null;
    for(var i=0; i<roles.length; i++) {
      if(roles[i].id == id) {
        return {
          "value": roles[i].id,
          "label": roles[i].displayName,
          "className": "orgTag"
        };
      }
    }
    return null;
  };

  $scope.newLdapProfile = function(evt) {
    $modal.open({
      controller: 'CreateLDAPCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createLdapDialog.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      focusOnOpen: false,
      resolve: {
        outerScope: function() { return $scope },
        source: function() { return ["portal"] },
        object: function() { return null; }
      }
    }).result.then(function(idp) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of registries here
      $scope.registries = UserRegistry.query({orgId: $scope.orgId});
      $scope.registries.$promise.then(function() {
        for(var i=0; i<$scope.registries.length; i++) {
          if($scope.registries[i].name == idp.name) {
            $scope.selectedEnvironment.idp = $scope.registries[i].id;
            break;
          }
        }
      });
    }, function() {
      // called when dialog is cancelled - nothing to do
    });
  };

  $scope.newAuthUrlProfile = function(evt) {
    $modal.open({
      controller: 'CreateAuthUrlCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createAuthUrlDialog.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      focusOnOpen: false,
      resolve: {
        outerScope: function() { return $scope },
        object: function() { return null },
        source: function() { return ["portal"] }
      }
    }).result.then(function(idp) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of registries here
      $scope.registries = UserRegistry.query({orgId: $scope.orgId});
      $scope.registries.$promise.then(function() {
        for(var i=0; i<$scope.registries.length; i++) {
          if($scope.registries[i].name == idp.name) {
            $scope.selectedEnvironment.idp = $scope.registries[i].id;
            break;
          }
        }
      });
    }, function() {
      // called when dialog is cancelled - nothing to do
    });
  };

  $scope.newLocalProfile = function(evt) {
    $modal.open({
      controller: 'NewLocalRegistryController',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/new-local-registry.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      focusOnOpen: false,
      resolve: {
        outerScope: function() {return $scope },
        object: function() { return null }

      }
    }).result.then(function(idp) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of registries here
      $scope.registries = UserRegistry.query({orgId: $scope.orgId});
      $scope.registries.$promise.then(function() {
        for(var i=0; i<$scope.registries.length; i++) {
          if($scope.registries[i].name == idp.name) {
            $scope.selectedEnvironment.idp = $scope.registries[i].id;
            break;
          }
        }
      });
    }, function() {
      // called when dialog is cancelled - nothing to do
    });
  };

  $scope.newScimProfile = function(evt) {
    $modal.open({
      controller: 'CreateSCIMCtrl',
      windowTemplateUrl: 'apim/partials/main-template.html',
      templateUrl: 'apim/idps/partials/createScimDialog.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      focusOnOpen: false,
      resolve: {
        outerScope: function() { return $scope },
        source: function() { return ["portal"] },
        object: function() { return null }
      }
    }).result.then(function(idp) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of registries here
      $scope.registries = UserRegistry.query({orgId: $scope.orgId});
      $scope.registries.$promise.then(function() {
        for(var i=0; i<$scope.registries.length; i++) {
          if($scope.registries[i].name == idp.name) {
            $scope.selectedEnvironment.idp = $scope.registries[i].id;
            $scope.selectedEnvironment.selfSignUpEnabled = false;
            break;
          }
        }
      });
    }, function() {
      // called when dialog is cancelled - nothing to do
    });
  };

  $scope.isScim = function() {
    if(!$scope.selectedEnvironment) return false;
    for(var i=0; i<$scope.registries.length; i++) {
      if($scope.registries[i].id == $scope.selectedEnvironment.idp) {
        if($scope.registries[i].type == "scim") {
          return true;
        }
        return false;
      }
    }
    return false;
  };

  $scope.isPortalIDP = function() {
    if(!$scope.selectedEnvironment) return false;
    for(var i=0; i<$scope.registries.length; i++) {
      if($scope.registries[i].id == $scope.selectedEnvironment.idp) {
        if($scope.registries[i].type == "portal") {
          return true;
        }
        return false;
      }
    }
    return false;
  };

  $scope.updateGatewayClusterObjects = function() {
    // set up $$name, type, description and endpointUrl for each selected cluster
    $scope.clusterListReady.promise.then(function(clusters) {
      var filteredClusters = [];
      $scope.gatewayClusters.forEach(function(cluster) {
        var clusterId = $scope.getIdFromUrl(cluster.url);
        $scope.selectedGatewayClusters.forEach(function(selectedCluster) {
          if (selectedCluster.id === clusterId) {
            selectedCluster.$$name = cluster.name;
            selectedCluster.$$type = cluster.type.sort();
            if (cluster.description) {
              selectedCluster.description = cluster.description;
            }
            if (!selectedCluster.endpointUrl) {
              selectedCluster.endpointUrl = 'https://' + cluster.hostname;
              if (cluster.port && cluster.port !== 443) {
                selectedCluster.endpointUrl += ':' + cluster.port;
              }
              selectedCluster.endpointUrl += '/' + $scope.currentOrg.name + '/' + $scope.selectedEnvironment.shortName;
            }
          }
        });
      });
    });
  }

  $scope.configureGateway = function(evt) {
    $scope.dataPowerGateways = GatewayCluster.query();
    $q.all([$scope.dataPowerGateways.$promise]).then(function(){
      $scope.gateways = $scope.dataPowerGateways
      $scope.setGatewayClusters($scope.dataPowerGateways);
      $scope.clusterListReady.resolve();
    })
    $modal.open({
      controller: 'ConfigureGatewayCtrl',
      templateUrl: 'apim/environments/partials/gatewayConfigDialog.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      scope: $scope,
      resolve: {
        outerScope: function() { return $scope; }
      }
    }).result.then(function(gw) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the view here
      if (gw) {
        if (gw.selectedGateways.length > 0) {
          $scope.selectedEnvironment.gatewayType = "DataPowerGateway";
          // user chose from gateway list - check if it changed
          if (!_.isEqual($scope.selectedGatewayClusters.sort(), gw.selectedGateways.sort())) {
            $scope.selectedGatewayClusters = gw.selectedGateways;
            $scope.selectedEnvironment.gwServices = gw.selectedGateways;
            $scope.updateGatewayClusterObjects();
          }
          // user cannot have both gateway and collective - reset the collective config
          if ($scope.selectedEnvironment.microGateway) {
            $scope.selectedEnvironment.microGateway.collectiveId = "";
            $scope.selectedEnvironment.microGateway.applicationId = "";
            $scope.selectedEnvironment.microGateway.publicKey = "";
          }
          if ($scope.selectedEnvironment.standaloneMicroGateway) {
            $scope.selectedEnvironment.standaloneMicroGateway.publicKey = null;
          }
        } else if (gw.selectedCollective) {
          // user chose a collective
          $scope.selectedEnvironment.gatewayType = "MicroGateway";
          if (!$scope.selectedEnvironment.microGateway) {
            $scope.selectedEnvironment.microGateway = {};
          }
          $scope.selectedEnvironment.microGateway.collectiveId = gw.selectedCollective;
          $scope.selectedEnvironment.microGateway.applicationId = gw.selectedApplication;
          $scope.selectedEnvironment.microGateway.publicKey = gw.publicKey;

          // user cannot have both gateway and collective - reset the gateway config
          $scope.selectedGatewayClusters = [];
          if ($scope.selectedEnvironment.standaloneMicroGateway) {
            $scope.selectedEnvironment.standaloneMicroGateway.publicKey = null;
          }

        } else if (gw.selectedStandaloneMicroGateway) {
          // user chose a standalone microgateway
          $scope.selectedEnvironment.gatewayType = "StandaloneMicroGateway";
          if (!$scope.selectedEnvironment.standaloneMicroGateway) {
            $scope.selectedEnvironment.standaloneMicroGateway = {};
          }
          $scope.selectedEnvironment.standaloneMicroGateway.publicKey = gw.publicKey;

          // Blank out other configuration.
          if ($scope.selectedEnvironment.microGateway) {
            $scope.selectedEnvironment.microGateway.collectiveId = "";
            $scope.selectedEnvironment.microGateway.applicationId = "";
            $scope.selectedEnvironment.microGateway.publicKey = "";
          }
          $scope.selectedGatewayClusters = [];
        }
      }
    });
  };

  $scope.populateDownloadConfigURL = function() {
    $scope.downloadConfigURL = "proxy/orgs/" + $scope.currentOrg.id + "/environments/" + $scope.selectedEnvironment.id + "/downloadMicroGWCatalogConfig";
  };

  $scope.endpointDropped = function(endpointToMove, destinationIndex) {

    var originalIndex;

    for (var i = 0; i < $scope.selectedEnvironment.endpoints.length; i++) {
      var endpoint = $scope.selectedEnvironment.endpoints[i];
      if (endpoint.id == endpointToMove.id) {
        originalIndex = i;
        break;
      }
    }

    // The arrow buttons don't use -1 index, so lets normalize to dnd index
    if (destinationIndex == $scope.selectedEnvironment.endpoints.length) {
      destinationIndex = -1;
    }

    $scope.selectedEnvironment.endpoints.splice(originalIndex, 1);

    // -1 means append to end
    if (destinationIndex == -1) {
      $scope.selectedEnvironment.endpoints.push(endpointToMove);
    } else {

      // This isn't _quite_right............... eg moving item 0 to item 1
      if (destinationIndex > originalIndex) {
        // The destination index will have been reduced by one as we've spliced out an ealier element.
        destinationIndex--;
      }

      $scope.selectedEnvironment.endpoints.splice(destinationIndex, 0, endpointToMove);

    }


    return;
  };

};

environments.controller('CatalogSpaceGatewayController', ['$scope', catalogSpaceGatewayController]);

function catalogSpaceGatewayController($scope) {

  $scope.$selectGatewayServiceForSpace = function(selected) {
    if (!$scope.spacesCache || !$scope.spacesCache[$scope.spaceId]) return;
    if (typeof selected !== "undefined") {
      // Setter
      if (selected === true) {
        if ($scope.spacesCache[$scope.spaceId].gwServices.indexOf($scope.gwService.id) >= 0) return;
        $scope.spacesCache[$scope.spaceId].gwServices.push($scope.gwService.id);
        $scope.$emit("EnvSpace_canSave", true, null, $scope.spaceId);
      } else {
        if ($scope.spacesCache[$scope.spaceId].gwServices.indexOf($scope.gwService.id) < 0) return;
        $scope.spacesCache[$scope.spaceId].gwServices.splice(
          $scope.spacesCache[$scope.spaceId].gwServices.indexOf($scope.gwService.id), 1);
        $scope.$emit("EnvSpace_canSave", true, null, $scope.spaceId);
      }
    } else {
      // Getter
      return $scope.spacesCache[$scope.spaceId].gwServices &&
        $scope.spacesCache[$scope.spaceId].gwServices.indexOf($scope.gwService.id) >= 0;
    }
  }
};

environments.controller('EnvironmentPoliciesController', ['$scope', '$stateParams', '$modal', 'DeployedPolicy', 'DeployedGatewayPolicy', 'RoleService', environmentPoliciesController]);

function environmentPoliciesController($scope, $stateParams, $modal, DeployedPolicy, DeployedGatewayPolicy, RoleService) {
  $scope.refreshPolicies = function() {
    $scope.xhrProcessing = true;
    if ($scope.features.multipleGatewayCatalogs) {
      $scope.policies = DeployedGatewayPolicy.query({
        orgId: $scope.orgId,
        envId: $scope.selectedEnvironment.id,
        gwServiceId: $scope.selectedGateway.id
      });
    } else {
      $scope.policies = DeployedPolicy.query({
        orgId: $scope.orgId,
        envId: $scope.selectedEnvironment.id
      });
    }
    $scope.policies.$promise.then(function() {
      $scope.xhrProcessing = false;
    });
  };
  $scope.orderProp = 'name';
  $scope.query = '';
  $scope['import'] = function() {
    $modal.open({
      templateUrl: 'apim/environments/partials/environment-policy-import.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'PolicyImportController',
      size: 'sm',
      scope: $scope,
      backdrop: 'static'
    });
  };

  $scope.$watchGroup(['selectedEnvironment', 'selecetedGateway', 'permissions'], function() {
    if (
      RoleService.hasPermission([
        'spaceSettings/manage',
        'spaceSettings/view'
      ], $scope.selectedEnvironment.id, $stateParams.spaceId) ||
      RoleService.hasPermission([
        'catalogSettings/manage',
        'catalogSettings/view'
      ], $scope.selectedEnvironment.id)
    ) {
      $scope.refreshPolicies();
    } else {
      $scope.policies = [];
    }
  });
};


environments.controller('PolicyImportController', ['$scope', '$modalInstance', '$filter', 'uiUploader', 'errorHandler', policyImportController]);

function policyImportController($scope, $modalInstance, $filter, uiUploader, errorHandler) {
  $scope.importLabelText = $filter('translate')('policyImportSelectFile');
  $scope.attachToFileInput = function() {
    $scope.policyFileInput = document.getElementById('policy_file');
    if ($scope.policyFileInput) {
      $scope.policyFileInput.addEventListener('change', function(e) {
        var files = e.target.files;
        uiUploader.removeAll();
        uiUploader.addFiles(files);
        $scope.selectedPolicyFile = uiUploader.getFiles()[0];
        $scope.importLabelText = $scope.selectedPolicyFile.name;
        $scope.$apply();
      });
    } else {
      setTimeout($scope.attachToFileInput, 500);
    }
  };
  $modalInstance.opened.then(function() {
    $scope.attachToFileInput();
  });
  $scope['import'] = function() {
    $scope.importingPlan = true;
    var url = "";
    if ($scope.features.multipleGatewayCatalogs) {
      url = 'proxy/orgs/' + $scope.orgId + '/environments/' + $scope.selectedEnvironment.id + '/gw-services/' + $scope.selecetedGateway.id + '/policies?force=true';
    } else {
      url = 'proxy/orgs/' + $scope.orgId + '/environments/' + $scope.selectedEnvironment.id + '/policies?force=true';
    }
    var messageId = $scope.$root.notifyUser('policy_importing_policy', {}, 'BUSY');
    uiUploader.startUpload({
      url: url,
      onProgress: function(file) {

      },
      onCompleted: function(file, response) {
        $scope.importingPlan = false;
        $modalInstance.dismiss('ok');
        $scope.refreshPolicies();
        var responseObject = response;
        if (typeof response == "string") {
          responseObject = JSON.parse(response);
        }
        responseObject.data = responseObject.responseText;
        responseObject.config = {url: url};
        errorHandler.checkResponse(responseObject);
        if(!responseObject.errors){
          $scope.$root.notifyUser('policy_imported_policy', {}, 'SUCCESS', true, messageId);
        } else {
          $scope.$root.notifyUser('policy_import_failed_policy', {}, 'ERROR', false, messageId);
        }
      },
      onCompletedAll: function() {
      }
    });
  };
  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };
};

environments.controller('EnvironmentPolicyController', ['$scope', environmentPolicyController]);

function environmentPolicyController($scope) {
  $scope.policy.bracketedName = "(" + $scope.policy.name + ")";
};

environments.controller('EnvironmentPolicyVersionController', ['$scope', '$modal', environmentPolicyVersionController]);

function environmentPolicyVersionController($scope, $modal) {
  $scope.remove = function() {
    $scope.confirmation = {
      titleKey: 'managePolicyConfirmRemoveTitle',
      messageKey: 'managePolicyConfirmRemove',
      confirmed: function() {
        $scope.xhrProcessing = true;
        var deleteArgs = {
          orgId: $scope.orgId,
          envId: $scope.selectedEnvironment.id,
          name: $scope.policyVersion.name,
          version: "v" + $scope.policyVersion.version
        };

        if ($scope.features.multipleGatewayCatalogs){
          deleteArgs.gwServiceId = $scope.selectedGateway.id;
        }

        $scope.policyVersion.$remove(deleteArgs, function() {
          $scope.xhrProcessing = false;
          $scope.policies.splice($scope.policies.indexOf($scope.policyVersion), 1);
        },
          function() {
            $scope.xhrProcessing = false;
          });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
};

environments.controller('EnvironmentVendorExtensionsController', ['$scope', '$stateParams', '$modal', 'VendorExtension', 'GatewayVendorExtension', 'RoleService', environmentVendorExtensionsController]);

function environmentVendorExtensionsController($scope, $stateParams, $modal, VendorExtension, GatewayVendorExtension, RoleService) {
  var refreshing = false;
  $scope.refreshExtensions = function() {
    if (refreshing) {
      return;
    }
    if (
      RoleService.hasPermission([
        'spaceSettings/manage',
        'spaceSettings/view'
      ], $scope.selectedEnvironment.id, $stateParams.spaceId) ||
      RoleService.hasPermission([
        'catalogSettings/manage',
        'catalogSettings/view'
      ], $scope.selectedEnvironment.id)
    ) {
      $scope.xhrProcessing = true;
      refreshing = true;
      if ($scope.features.multipleGatewayCatalogs) {
        $scope.extensions = GatewayVendorExtension.query({
          orgId: $scope.orgId,
          envId: $scope.selectedEnvironment.id,
          gwServiceId: $scope.selectedGateway.id
        });
      } else {
        $scope.extensions = VendorExtension.query({
          orgId: $scope.orgId,
          envId: $scope.selectedEnvironment.id
        });
      }
      $scope.extensions.$promise.finally(function() {
        $scope.xhrProcessing = false;
        refreshing = false;
      });
    }
  };
  $scope.orderProp = 'name';
  $scope.query = '';
  $scope['import'] = function() {
    $modal.open({
      templateUrl: 'apim/environments/partials/environment-vendor-extension-import.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'VendorExtensionImportController',
      size: 'sm',
      scope: $scope,
      backdrop: 'static'
    });
  };
  $scope.$watch("selectedEnvironment", function() {
    if (!$scope.selectedEnvironment || !$scope.permissions) return;
    $scope.refreshExtensions();
  });
  $scope.$watch("selectedGateway", function() {
    if (!$scope.selectedGateway || !$scope.permissions) return;
    $scope.refreshExtensions();
  });
  $scope.$watch("permissions", function() {
    if (!$scope.selectedEnvironment || !$scope.permissions) return;
    $scope.refreshExtensions();
  });
};

environments.controller('EnvironmentVendorExtensionController', ['$scope', environmentVendorExtensionController]);

function environmentVendorExtensionController($scope) {
  $scope.bracketedName = "(x-" + $scope.extension.name + ")";
};

environments.controller('VendorExtensionImportController', ['$scope', '$filter', '$modalInstance', 'uiUploader', 'errorHandler', vendorExtensionImportController]);

function vendorExtensionImportController($scope, $filter, $modalInstance, uiUploader, errorHandler) {
  $scope.importLabelText = $filter('translate')('vendorExtensionImportSelectFile');
  $scope.attachToFileInput = function() {
    $scope.extensionFileInput = document.getElementById('extension_file');
    if ($scope.extensionFileInput) {
      $scope.extensionFileInput.addEventListener('change', function(e) {
        var files = e.target.files;
        uiUploader.removeAll();
        uiUploader.addFiles(files);
        $scope.selectedExtensionFile = uiUploader.getFiles()[0];
        $scope.importLabelText = $scope.selectedExtensionFile.name;
        $scope.$apply();
      });
    } else {
      setTimeout($scope.attachToFileInput, 500);
    }
  };
  $modalInstance.opened.then(function() {
    $scope.attachToFileInput();
  });
  $scope['import'] = function() {
    $scope.importingExtension = true;
    var url = "";
    if ($scope.features.multipleGatewayCatalogs) {
      url = 'proxy/orgs/' + $scope.orgId + '/environments/' + $scope.selectedEnvironment.id + '/gw-services/' + $scope.selecetedGateway.id + '/extensions';
    } else {
      url = 'proxy/orgs/' + $scope.orgId + '/environments/' + $scope.selectedEnvironment.id + '/extensions';
    }
    var messageId = $scope.$root.notifyUser('vendor_extensions_importing', {}, 'BUSY');
    uiUploader.startUpload({
      url: url,
      onProgress: function(file) {

      },
      onCompletedAll: function() {
      },
      onCompleted: function(file, response) {
        $scope.importingExtension = false;
        $modalInstance.dismiss('ok');
        var responseObject = response;
        if (typeof response == "string") {
          responseObject = JSON.parse(response);
        }
        responseObject.data = responseObject.responseText;
        responseObject.config = {url: url};
        errorHandler.checkResponse(responseObject);
        if(!responseObject.errors){
          $scope.$root.notifyUser('vendor_extensions_imported', {}, 'SUCCESS', true, messageId);
          $scope.refreshExtensions();
        } else {
          $scope.$root.notifyUser('vendor_extensions_importing_failed', {}, 'ERROR', false, messageId);
        }
      }
    });
  };
  $scope.cancel = function() {
    $modalInstance.dismiss('cancel');
  };
};

environments.controller('EnvironmentVendorExtensionVersionController', ['$scope', '$modal', environmentVendorExtensionVersionController]);

function environmentVendorExtensionVersionController($scope, $modal) {
  $scope.remove = function() {
    $scope.confirmation = {
      titleKey: 'manageVendorExtensionConfirmRemoveTitle',
      messageKey: 'manageVendorExtensionConfirmRemove',
      confirmed: function() {
        $scope.xhrProcessing = true;
        var deleteArgs = {
          orgId: $scope.orgId,
          envId: $scope.selectedEnvironment.id,
          extId: $scope.vendorExtensionVersion.id
        };

        if ($scope.features.multipleGatewayCatalogs){
          deleteArgs.gwServiceId = $scope.selectedGateway.id;
        }

        $scope.vendorExtensionVersion.$remove(deleteArgs, function() {
          $scope.xhrProcessing = false;
          $scope.extensions.splice($scope.extensions.indexOf($scope.vendorExtensionVersion), 1);
        },
          function() {
            $scope.xhrProcessing = false;
          });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      size: 'sm',
      scope: $scope
    });
  };
  $scope.download = function() {
    var downloadUrl = 'proxy/orgs/' + $scope.orgId + '/environments/' + $scope.selectedEnvironment.id;
    if ($scope.features.multipleGatewayCatalogs){
      downloadUrl += '/gw-services/' + $scope.selectedGateway.id;
    }
    downloadUrl += '/extensions/' + $scope.vendorExtensionVersion.id + '?headers[accept]=' + encodeURIComponent('application/vnd.ibm-apim.swagger2+yaml')  + '&nocache=' + new Date().getTime();
    $scope.downloadFrame =  downloadUrl;
  };
  $scope.bracketedName = "(x-" + $scope.vendorExtensionVersion.name + ")";

};

environments.controller('EnvironmentGatewaysController', ['$scope', '$q', 'GatewayCluster', environmentGatewaysController]);

function environmentGatewaysController($scope, $q, GatewayCluster) {

};

environments.controller('EnvironmentEndpointController', ['$scope', '$filter', '$modal', '$q', 'GatewayCluster', environmentEndpointController]);

function environmentEndpointController($scope, $filter, $modal, $q, GatewayCluster) {

  $scope.types = [
    {"name": $filter('translate')('production_applications'), "value":"production"},
    {"name": $filter('translate')('test_applications'), "value":"test"},
    {"name": $filter('translate')('production_and_test_applications'), "value":"both"},
  ]

  if ($scope.endpoint.type.length == 2) {
    $scope.endpointType = "both";
  } else {
    $scope.endpointType = $scope.endpoint.type[0];
  }

  $scope.$watch('endpointType', function() {
    if (!$scope.endpointType) return;

    if ($scope.endpointType == "both") {
      $scope.endpoint.type = ["production", "test"];
    } else {
      $scope.endpoint.type = [ $scope.endpointType ];
    }
  });

  $scope.confirmDeleteGateway = function(gateway) {
    $scope.confirmation = {
      titleKey: 'confirmDeleteGatewayTitle',
      messageKey: 'confirmDeleteGateway',
      confirmed: function() {
        $scope.endpoint.gwServices.splice($scope.endpoint.gwServices.indexOf(gateway.id), 1);
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope
    });
  };

  $scope.$watchCollection('endpoint.gwServices', function(){
    var newEnvironmentServices = [];
    for (var i = 0; i < $scope.selectedEnvironment.endpoints.length; i++) {
      for (var j = 0; j < $scope.selectedEnvironment.endpoints[i].gwServices.length; j++) {
        if (newEnvironmentServices.indexOf($scope.selectedEnvironment.endpoints[i].gwServices[j]) < 0) {
          newEnvironmentServices.push($scope.selectedEnvironment.endpoints[i].gwServices[j]);
        }
      }
    }

    $scope.selectedEnvironment.gwServices = newEnvironmentServices;

  });

  $scope.showAddGatewayDialog = function(evt) {
    $modal.open({
      controller: 'ConfigureGatewayCtrl',
      templateUrl: 'apim/environments/partials/gatewayConfigDialog.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      resolve: {
        outerScope: function() { return $scope; }
      }
    }).then(function(selectedGateways) {

    });

  };

};

environments.controller('GatewaySelectorController', ['$scope', gatewaySelectorController]);

function gatewaySelectorController($scope) {
  $scope.$selected = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (!value && $scope.data.selectedGateways[$scope.gateway.id]) {
        delete $scope.data.selectedGateways[$scope.gateway.id];
      } else if (value && !$scope.data.selectedGateways[$scope.gateway.id]) {
        $scope.data.selectedGateways[$scope.gateway.id] = {id: $scope.gateway.id};
        if ($scope.gateway.name) {
          $scope.data.selectedGateways[$scope.gateway.id].$$name = $scope.gateway.name;
        }
        if ($scope.gateway.endpointUrl) {
          $scope.data.selectedGateways[$scope.gateway.id].endpointUrl = $scope.gateway.endpointUrl;
        }
        $scope.data.selectedCollective = "";
        $scope.data.selectedStandaloneMicroGateway = false;
      }
    } else {
      // getter
      return !!$scope.data.selectedGateways[$scope.gateway.id];
    }
  };
};


environments.controller('ConfigureGatewayCtrl', ['$scope', '$filter', '$modalInstance', 'outerScope', 'CollectivesList', configureGatewayController]);

function configureGatewayController($scope, $filter, $modalInstance, outerScope, CollectivesList) {

  $scope.orgId = outerScope.orgId;
  $scope.gatewayClusters = outerScope.gatewayClusters;
  $scope.currentPage = 1;
  $scope.features = outerScope.features;
  $scope.data = {
    selectedGateways: {},
    selectedCollective: "",
    selectedStandaloneMicroGateway: false,
    selectedApplication: "",
    publicKey: ""
  };
  $scope.$watch('data.selectedGateways', function() {
    $scope.hasSelectedGateways = Object.keys($scope.data.selectedGateways).length > 0;
  }, true);

  if (outerScope.selectedGatewayClusters && outerScope.selectedGatewayClusters.length > 0) {
    outerScope.selectedGatewayClusters.forEach(function(gatewayService) {
      $scope.data.selectedGateways[gatewayService.id] = gatewayService;
    });
  }
  if (outerScope.selectedEnvironment.microGateway) {
    $scope.data.selectedCollective = outerScope.selectedEnvironment.microGateway.collectiveId;
    $scope.data.selectedApplication = outerScope.selectedEnvironment.microGateway.applicationId;
    $scope.data.publicKey = outerScope.selectedEnvironment.microGateway.publicKey;
  }
  $scope.savingData = false;
  $scope.fetchingData = true;
  $scope.collectives = CollectivesList.query();
  $scope.collectives.$promise.then(function(resp) {
    $scope.fetchingData = false;
  }, function(err) {
    $scope.fetchingData = false;
  });

  $scope.populateDownloadConfigURL = outerScope.populateDownloadConfigURL;

  $scope.cancel = function() {
    $modalInstance.dismiss();
  };
  $scope.selectCollective = function(collective) {
    $scope.data.selectedCollective = collective.id;
    $scope.data.selectedGateways = {};
    $scope.data.selectedStandaloneMicroGateway = false;
    $scope.gatewayClusters.forEach(function(cluster) {
      delete cluster.$$selected;
    });
  };
  $scope.selectStandaloneMicroGateway = function() {
    $scope.data.selectedStandaloneMicroGateway = true;
    $scope.data.selectedCollective = "";
    $scope.data.selectedGateways = {};
    $scope.gatewayClusters.forEach(function(cluster) {
      delete cluster.$$selected;
    });
  };
  $scope.save = function() {
    // transform gw.selectedGateways from hash to array
    var selectedGatewayObjects = [];
    Object.keys($scope.data.selectedGateways).forEach(function(selectedId) {
      selectedGatewayObjects.push($scope.data.selectedGateways[selectedId]);
    });
    $scope.data.selectedGateways = selectedGatewayObjects;
    $modalInstance.close($scope.data);
  };
  $scope.doNext = function() {
    $scope.currentPage += 1;
    if ($scope.data.selectedCollective) {
      $scope.fetchingData = true;
      $scope.appList = CollectivesList.queryApps({id: $scope.data.selectedCollective});
      $scope.appList.$promise.then(function(resp) {
        $scope.fetchingData = false;
      }, function(err) {
        $scope.fetchingData = false;
      });
    }
  };
}

environments.controller('EnvironmentRolesController', ['$scope', environmentRolesController]);

function environmentRolesController($scope) {

};

environments.controller('EnvironmentRoleController', ['$scope', 'Permissions', environmentRoleController]);

function environmentRoleController($scope, Permissions) {

  $scope.$watch('currentOrg', function() {
    if (!$scope.currentOrg) return;
    $scope.$watch('environments', function() {
      if (!$scope.environments) return;
      var hashArray = window.location.hash.split("/");
      var envId = hashArray[2];
      if (!$scope.environment || $scope.environment.id != envId) {
        var filtered = $scope.environments.filter(function(env) {
          return env.id == envId;
        });
        if (filtered.length > 0) {
          $scope.setEnvironment(filtered[0]);
          $scope.envLoaded = true;
        }
      } else {
        $scope.envLoaded = true;
      }
      if ($scope.environment) {
        $scope.envChecked = true;
        var queryArgs = {
          orgId: $scope.orgId,
          envId: $scope.environment.id
        };
        if ($scope.spaceId) {
          queryArgs.spaces = "spaces";
          queryArgs.spaceId = $scope.spaceId;
        }

        $scope.rolesPermissions = Permissions;
        $scope.metadataLoaded = true;
      }
    });
  });

  // called from parent scope when the role has been successfully saved
  $scope.roleSaved = function() {
    // mark the form as clean again
    $scope.envRoleForm.$setPristine();
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function() {
    var canSave = true;
    if (!$scope.envRoleForm || $scope.envRoleForm.$invalid || $scope.envRoleForm.$pristine) {
      canSave = !$scope.saveDisabled;
    }
    if ($scope.selectedRole.modifiable) {
      $scope.$emit("EnvRole_canSave", canSave, $scope.selectedRole.id);
    }
  };

  $scope.handleRoleChange = function() {
    if ($scope.selectedRole.modifiable) {
      return
    }
    // put the form back into its previous state
    if ($scope.dirtyRoles[$scope.selectedRole.id]) {
      $scope.envRoleForm.$setDirty();
    } else {
      $scope.envRoleForm.$setPristine();
    }
  };

  $scope.$watch('envRoleForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('envRoleForm.$pristine', $scope.handleFormUpdate);
  $scope.$watch('selectedRole', $scope.handleRoleChange);
  $scope.$on("EnvRole_saved", $scope.roleSaved);
};

environments.controller('EnvironmentApprovalsController', ['$scope', '$filter', environmentApprovalsController]);

function environmentApprovalsController($scope, $filter) {

  $scope.approvalsList = [
    {name: "stage", displayName: $filter('translate')('env_approval_stage')},
    {name: "publish", displayName: $filter('translate')('env_approval_publish')},
    {name: "deprecate", displayName: $filter('translate')('env_approval_deprecate')},
    {name: "retire", displayName: $filter('translate')('env_approval_retire')},
    {name: "replace", displayName: $filter('translate')('env_approval_replace')},
    {name: "supersede", displayName: $filter('translate')('env_approval_supersede')}
    //	    {name: "setMigrationTarget", displayName: $filter('translate')('env_approval_set_migrate')}
  ];

  $scope.$approval = function() {
    if (!$scope.selectedEnvironment) return;
    var stateIndex = $scope.getStateIndex(this.approval.name);
    if (arguments.length) {
      // Setter
      if (stateIndex >= 0) {
        $scope.selectedEnvironment.productDeploymentApprovalRequiredStates.splice(stateIndex, 1);
      } else {
        $scope.selectedEnvironment.productDeploymentApprovalRequiredStates.push(this.approval.name);
      }
    } else {
      // Getter
      var ret = false;
      if (stateIndex >= 0) {
        ret = true;
      }
      return ret;
    }
  };

  $scope.getStateIndex = function(state) {
    if (!$scope.selectedEnvironment) return -1;
    var len = $scope.selectedEnvironment.productDeploymentApprovalRequiredStates.length;
    for (var i=0;i<len;i++) {
      if ($scope.selectedEnvironment.productDeploymentApprovalRequiredStates[i] == state) {
        return i;
      }
    } // end for
    return -1;
  };
};

environments.controller('EnvironmentSpacesController', ['$scope', '$modal', environmentSpacesController]);

function environmentSpacesController($scope, $modal) {

  $scope.addSpace = function() {
    $modal.open({
      controller: 'EnvironmentSpaceEditController',
      templateUrl: 'apim/environments/partials/environment-space-edit.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      scope: $scope,
      resolve: {
        outerScope: function() { return $scope; },
        editMode: function() { return false; },
      },
    }).result.then(function(data) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of spaces here
      $scope.refreshContent();
      // refresh the spaces list to keep that in sync
      $scope.spacesChanged = true;
      $scope.environment.spaces.push(data);
      $scope.setPublishableTargets();
    });
  };
};

environments.controller('EnvironmentSpaceController', ['$scope', '$mdDialog', '$filter', '$modal', 'Space', environmentSpaceController]);

function environmentSpaceController($scope, $mdDialog, $filter, $modal, Space) {
  $scope.orderProp = 'title';
  $scope.editSpace = function() {
    $modal.open({
      controller: 'EnvironmentSpaceEditController',
      templateUrl: 'apim/environments/partials/environment-space-edit.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      scope: $scope,
      resolve: {
        outerScope: function() { return $scope; },
        editMode: function() { return true; },
      },
    }).result.then(function(data) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of spaces here
      $scope.refreshContent();
      for (var i = 0; i < $scope.environment.spaces.length; i++) {
        if ($scope.environment.spaces[i].id == data.id) {
          $scope.environment.spaces[i] = data;
          break;
        }
      }
      $scope.setPublishableTargets();
    }, function() {
      // called when dialog is cancelled - nothing to do
    });
  };

  $scope.deleteSpace = function() {
    $scope.confirmation = {
      titleKey: 'env_confirm_space_delete',
      message: $filter('translate')('env_space_delete_msg'),
      confirmed: function() {
        var def = Space.remove({orgId: $scope.orgId, envId: $scope.environment.id, spaceId: $scope.space.id});
        def.$promise.then(function() {
          $scope.refreshContent();
          // update spaces list to keep that in sync
          $scope.spacesChanged = true;
          var len = $scope.environment.spaces.length;
          for (var i=0;i<len;i++) {
            var space = $scope.environment.spaces[i];
            if (space.id == $scope.space.id) {
              $scope.environment.spaces.splice(i, 1);
              break;
            }
          } // end for
          $scope.setPublishableTargets();
        }, function(err) {
          $scope.$root.notifyUser('env_delete_space_failed', [], "ERROR");
        });
      },
      rejected: function() {
      }
    };
    $modal.open({
      templateUrl: 'apim/partials/confirmation.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'ConfirmationController',
      scope: $scope
    });
  };

  $scope.changeSpaceOwner = function($event) {
    $modal.open({
      controller: 'AddUserDialogController',
      templateUrl: 'apim/users/partials/addUserDialog.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      scope: $scope,
      resolve: {
        addOwner: function() { return true; },
        changeOwner: function() { return true; },
        idpConfig: function() {
          return {
            id: $scope.currentUser.idpSummary.id,
            type: $scope.currentUser.idpSummary.type,
            context: $scope.currentUser.context,
          };
        },
        orgId: function() { return $scope.orgId; },
        envId: function() { return $scope.environment.id; },
        roleList: function() { return []; },
        isCatalogUsers: function() { return true; },
        spaceId: function() { return $scope.spaceId; },
      },
    }).result.then(function(owner) {
      // Dialog will stay on screen for errors and will always follow the good path
      // when the create works. We can then refresh the list of developers here
      if (owner) {
        var def = Space.transferOwner({orgId: $scope.orgId, envId: $scope.environment.id, spaceId: $scope.space.id}, {user: owner.id});
        def.$promise.then(function() {
          $scope.refreshContent();
        }, function(err) {
          $scope.$root.notifyUser('env_change_space_owner_failed', [], "ERROR");
        });
      }
    });
  };
};

environments.controller('EnvironmentSpaceEditController', ['$scope', '$modalInstance', 'Space', 'outerScope', 'editMode', environmentSpaceEditController]);

function environmentSpaceEditController($scope, $modalInstance, Space, outerScope, editMode) {

  $scope.saveDisabled = true;
  $scope.dialogTitleKey = "env_edit_space";
  if (editMode) {
    $scope.selectedSpace = {
      title: outerScope.space.title,
      name: outerScope.space.name,
      description: outerScope.space.description
    };
  } else {
    $scope.dialogTitleKey = "env_create_space";
    $scope.selectedSpace = {
      title: "",
      name: "",
      description: ""
    };
  }

  $scope.$watch('selectedSpace.title', function() {
    if (!editMode) {
      $scope.selectedSpace.name = $scope.$root.generateName($scope.selectedSpace.title);
    }
  });

  $scope.performingSave = false;
  $scope.cancel = function() {
    $modalInstance.dismiss();
  };

  $scope.save = function() {
    $scope.performingSave = true;
    if (editMode) {
      $scope.saveSpace();
    } else {
      $scope.createSpace();
    }
  };

  $scope.saveSpace = function() {
    var currentSpace = outerScope.spacesCache[outerScope.space.id];
    currentSpace.title = $scope.selectedSpace.title;
    currentSpace.name = $scope.selectedSpace.name;
    currentSpace.description = $scope.selectedSpace.description;
    var def = currentSpace.$update({orgId: outerScope.orgId, envId: outerScope.environment.id, spaceId: outerScope.space.id});
    def.then(function(response) {
      $modalInstance.close(response);
      $scope.$parent.environmentDirty = false;
    }, function(err) {
      $scope.$root.notifyUser('env_update_space_failed', [], "ERROR");
      $scope.performingSave = false;
    });
  };

  $scope.createSpace = function() {
    var timestamp = (new Date()).getTime();
    var messageId = "SPACE_CREATE_" + timestamp;
    $scope.$root.notifyUser('env_creating_space', [], "BUSY", false, messageId);
    // make the request using the local data
    var newSpace = new Space($scope.selectedSpace);
    var promise = newSpace.$save({orgId: outerScope.orgId, envId: outerScope.environment.id});
    promise.then(function(response) {
      $scope.$root.notifyUser('env_created_space', [], "SUCCESS", true, messageId);
      $modalInstance.close(response);
      $scope.$parent.environmentDirty = false;
    }, function(err) {
      $scope.performingSave = false;
      $scope.$root.notifyUser('env_create_space_failed', [], "ERROR", false, messageId);
    });
  };

  // Called when the form is either invalid or has been changed
  $scope.handleFormUpdate = function(newVal, oldVal) {
    if (!oldVal) {
      return;
    }
    var canSave = true;
    if (!$scope.envSpaceForm || $scope.envSpaceForm.$invalid || $scope.envSpaceForm.$pristine) {
      canSave = !$scope.saveDisabled;
    }
    $scope.saveDisabled = !canSave;
  };

  $scope.$watch('envSpaceForm.$invalid', $scope.handleFormUpdate);
  $scope.$watch('envSpaceForm.$pristine', $scope.handleFormUpdate);
}
