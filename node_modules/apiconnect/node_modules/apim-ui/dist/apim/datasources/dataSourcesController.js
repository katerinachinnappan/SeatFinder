/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apim-ui

'use strict';

angular.module('apim.datasources')
  .controller('DataSourceEditController', [
    '$rootScope',
    '$scope',
    '$stateParams',
    '$modal',
    '$location',
    '$q',
    '$timeout',
    '$filter',
    'DataSourceDefinition',
    'Workspace',
    'DirtyService',
    'TrackingServices',
    function dataSourceEditController(
      $rootScope, $scope, $stateParams, $modal, $location, $q, $timeout,
      $filter, DataSourceDefinition, Workspace, DirtyService, TrackingServices
    ) {
      var isDirtyOverride = false;

      $scope.dataSource = null;
      $scope.xhrProcessing = 1;
      $scope.connectorTypes = [];

      var availableConnectors = Workspace.listAvailableConnectors().$promise
        .then(function (connectors) {
          return connectors.map(function (connector) {
            if (typeof connector.installed === 'undefined') {
              connector.installed = true;
            }
            if(!connector.supportedByStrongLoop) {
              connector.description = connector.description + ' (' + $filter('translate')('providedByCommunity') + ')';
            }

            return connector;
          });
        });

      availableConnectors.then(function(connectors) {
        $scope.connectorTypes = connectors;
      })

      DataSourceDefinition.find(
        { filter: { where: { name: $stateParams.id } } },
        function (response) {
          $scope.xhrProcessing -= 1;
          $scope.dataSource = response[0];
        }
      );

      $scope.$watch('xhrProcessing', function (newVal) {
        if (newVal === 0) {
          $timeout(function () {
            $rootScope.$broadcast('update.bannerItems');
          }, 0);
        }
      });

      $scope.$watch('dataSource', function (newVal, oldVal) {
        if (isDirtyOverride) {
          isDirtyOverride = false;
          return;
        }

        if (newVal && oldVal) {
          DirtyService.setDirty('dataSourceEditController');
        }
      }, true);

      $scope.$watch('dataSource.connector', function (newVal, oldVal) {
        if (typeof newVal === 'string') {
          availableConnectors.then(function(connectorTypes) {
            var filteredTypes = connectorTypes.filter(function (type) {
              return type.name === newVal;
            });

            if (filteredTypes.length) {
              $scope.dataSource.connector = filteredTypes[0];
              isDirtyOverride = true;
            }
          });
        }
      });

      $scope.checkDirtyDataSource = function () {
        return DirtyService.isDirty('dataSourceEditController');
      };

      $scope.$on('$locationChangeStart', function (event, next, current) {
        if ($scope.checkDirtyDataSource()) {
          event.preventDefault();
          $scope.confirmation = {
            titleKey: 'unsaved_changes_title',
            messageKey: 'unsaved_changes',
            confirmed: function () {
              DirtyService.clearDirty('dataSourceEditController');
              $location.path($location.url(next).hash());
            },
            rejected: function () {
            }
          };
          $modal.open({
            templateUrl: 'apim/partials/confirmation.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'ConfirmationController',
            size: 'sm',
            scope: $scope
          });
        }
      });

      $scope.getInputType = function (setting) {
        var type = setting.display || setting.type;
        var input = 'text';
        if (type === 'boolean') {
          input = 'checkbox';
        } else if (type === 'password') {
          input = 'password';
        } else if (type === 'number') {
          input = 'number';
        }

        return input;
      };

      var testDataSourceConnection = function (dataSource) {
        var connectionErrorMsg = function (msg) {
          return $filter('translate')('dataSourceTestFailedWithError') + ': ' + msg;
        };

        $rootScope.notifyUser(
          'testingDataSourceConnection', [], 'BUSY', false, Date.now()
        );

        $scope.isTesting = true;
        DataSourceDefinition.prototype$testConnection({ id: dataSource.id },
          function (response) {
            $scope.isTesting = false;
            if (response.status === true) {
              $rootScope.notifyUser(
                'dataSourceTestSucceded', [], 'SUCCESS', false, Date.now()
              );
            } else {
              $rootScope.notifyUser(
                'dataSourceTestFailed', [], 'ERROR', false, Date.now()
              );
              $rootScope.$broadcast('event:showError', {
                titleKey: 'datasourceConnectionFailed',
                error: {
                  message: connectionErrorMsg(response.error.message)
                }
              });
            }
          },
          function (response) {
            $scope.isTesting = false;
            $rootScope.notifyUser(
              'dataSourceTestFailed', [], 'ERROR', false, Date.now(),
              response.data.error
            );
          }
        );
      };

      $scope.confirmDataSourceTest = function (dataSource) {
        if ($scope.checkDirtyDataSource()) {
          var modalScope = $scope.$new();
          modalScope.dataSource = dataSource;
          modalScope.save = $scope.save;
          modalScope.test = testDataSourceConnection;

          //  modal asking to save, test saved config, test new config
          $modal.open({
            templateUrl: 'apim/datasources/partials/dataSourceTestConfirm.html',
            windowTemplateUrl: 'apim/partials/main-template.html',
            controller: 'dataSourceTestDialogController',
            size: 'dialog',
            scope: modalScope
          });
        }
        else {
          testDataSourceConnection(dataSource);
        }
      }

      $scope.save = function () {
        if (!$scope.checkDirtyDataSource()) return;
        var promises = [];
        $rootScope.notifyUser(
          'savingDataSource', [], 'BUSY', false, Date.now()
        );

        $scope.dataSource.connector = $scope.dataSource.connector.name;
        promises.push(DataSourceDefinition.upsert($scope.dataSource));

        $q.all(promises).then(function () {
          $rootScope.notifyUser(
            'dataSourceSaved', [], 'SUCCESS', true, Date.now()
          );
          isDirtyOverride = true;
          DirtyService.clearDirty('dataSourceEditController');
          testDataSourceConnection($scope.dataSource);
          TrackingServices.track('datasource', 'saveDatasource', { connector: $scope.dataSource.connector });
        })
      };

      $scope.migrateModels = function (dataSource) {
        var modalScope = $scope.$new();
        modalScope.dataSource = dataSource;
        $modal.open({
          templateUrl: 'apim/datasources/partials/dataSourceMigrate.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'dataSourceMigrateController',
          size: 'dialog',
          scope: modalScope
        }).result.then(function () {
          $rootScope.notifyUser('modelsMigrated', [], 'SUCCESS', Date.now());
        });
      };

      $scope.showInstallConnectorModal = function(){
        var modalScope = $scope.$new();

        modalScope.connector = $scope.dataSource.connector;

        $modal.open({
          templateUrl: 'apim/datasources/partials/installConnector.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'dataSourceInstallConnectorController',
          size: 'dialog',
          backdrop: 'static',
          keyboard: false,
          scope: modalScope
        });
      };
    }
  ])
  .controller('NewDataSourceDialogController', [
    '$scope',
    '$modalInstance',
    'TrackingServices',
    function ($scope, $modalInstance, TrackingServices) {
      $scope.dataSource = {};

      $scope.cancel = function () {
        $modalInstance.dismiss();
      };

      $scope.submit = function () {
        TrackingServices.track('datasource', 'newLoopbackDatasource');
        $modalInstance.close($scope.dataSource);
      };
    }
  ])
  .controller('DataSourcesController', [
    '$rootScope',
    '$scope',
    '$state',
    '$modal',
    '$q',
    'ModalHelper',
    'ModelConfig',
    'DataSourceDefinition',
    'Workspace',
    function dataSourcesController(
      $rootScope,
      $scope,
      $state,
      $modal,
      $q,
      ModalHelper,
      ModelConfig,
      DataSourceDefinition,
      Workspace
    ) {
      $scope.dataSources = [];
      $scope.xhrProcessing = true;

      var Connectors = {};
      Workspace.listAvailableConnectors().$promise.then(function (connectors) {
        connectors.forEach(function (connector) {
          if (typeof connector.installed === undefined) {
            connector.installed = true;
          }
          Connectors[connector.name] = connector;
        });
        getDataSources();
      });

      function getDataSources () {
        DataSourceDefinition.find({}, function (data) {
          $scope.xhrProcessing = false;
          var dsNames = [];
          $scope.dataSources = data.map(function (dataSource) {
            dsNames.push(dataSource.name);
            dataSource.features = Connectors[dataSource.connector].features;
            return dataSource;
          });

          ModelConfig.find({filter: {where: {dataSource: {inq: dsNames}}}})
            .$promise.then(function (models) {
              var modelsMap = {};
              models.forEach(function(model) {
                var ds = model.dataSource;
                modelsMap[ds] = modelsMap[ds] || [];
                modelsMap[ds].push(model);
              });

              $scope.dataSources.forEach(function(dataSource) {
                dataSource.models = modelsMap[dataSource.name] || [];
              });
            });
        });
      }

      $scope.newDataSource = function () {
        var dataSourceName = null;

        $modal.open({
          templateUrl: 'apim/datasources/partials/dataSourceNew.html',
          windowTemplateUrl: 'apim/partials/main-template.html',
          controller: 'NewDataSourceDialogController'
        }).result.then(function (result) {
          DataSourceDefinition.create({
            name: result.name,
            connector: 'memory',
            facetName: 'server'
          }).$promise
            .then(function (datasource) {
              $state.go('datasource', {id: datasource.name});
            }, function (err, res) {
              if (err) {
                $rootScope.notifyUser('failedCreateDataSource', [], 'ERROR', 'DATA_SOURCE_CREATE_' + Date.now());
              } else {
                getDataSources();
              }
            });
        })
      };

      $scope.disableDelete = function(dataSources) {
        return dataSources.some(function(dataSource) {
          return Boolean(dataSource.models.length > 0);
        });
      };

      $scope.deleteDataSource = function (dataSources) {
        if (!dataSources || dataSources.length < 1) {
          return;
        }

        var plural = dataSources.length > 1 ? 's' : '';
        ModalHelper.confirm({
          title: 'confirmDeleteItem' + plural + 'Title',
          message: 'confirmDeleteItem' + plural,
          confirmation: function() {
            // Since only multiple items can only be deleted if they don't have
            // models, we can do a bulk delete. If individual, need to check for
            // models and prompt again
            var deferredCheck = $q.defer();

            if (!plural && dataSources[0].models.length > 0) {
              $modal.open({
                templateUrl: 'apim/datasources/partials/dataSourceUpdateModels.html',
                controller: 'dataSourceChangeController',
                resolve: {
                  dataSources: function (DataSourceDefinition) {
                    return $scope.dataSources.filter(function(dataSource) {
                      return dataSource.name !== dataSources[0].name;
                    });
                  }
                }
              })
                .result.then(function (dataSource) {
                  $q.all(dataSources[0].models.map(function (model) {
                    model.dataSource = dataSource.name;
                    return ModelConfig.upsert({id: model.id}, model).$promise
                  }))
                    .then(deferredCheck.resolve);
                })
            }
            else {
              deferredCheck.resolve();
            }

            deferredCheck.promise
              .then(function () {
                if (dataSources.length === $scope.dataSources.length) {
                  return oneDataSourceLeft();
                }
                else {
                  return $q.resolve();
                }
              })
              .then(function () {
                return dataSources.map(unattachedDataSource).$promise;
              })
              .then(getDataSources);
          },
          rejected: function() {}
        });

        function oneDataSourceLeft() {
          return ModalHelper.confirm({
            title: 'lastDataSourceAvailableTitle',
            message: 'lastDataSourceAvailable',
            confirmation: function() {},
            rejected: function() {}
          });
        }

        function unattachedDataSource(dataSource) {
          return DataSourceDefinition.deleteById(dataSource).$promise;
        }
      };
    }
  ])
  .controller('dataSourceChangeController', [
    '$scope',
    '$modalInstance',
    'dataSources',
    function ($scope, $modalInstance, dataSources) {
      $scope.dataSources = dataSources;
      $scope.cancel = function () {
        $modalInstance.dismiss();
      };
      $scope.submit = function () {
        $modalInstance.close($scope.selectedDs);
      };
    }
  ])
  .controller('dataSourceMigrateController', [
    '$scope',
    '$q',
    '$modalInstance',
    'ModelConfig',
    'DataSourceDefinition',
    function ($scope, $q, $modalInstance, ModelConfig, DataSourceDefinition) {
      $scope.cancel = $modalInstance.dismiss;
      $scope.models = [];
      $scope.busy = true;
      $scope.selectedModels = [];

      var migrateModel = function (model) {
        return DataSourceDefinition
          .prototype$automigrate(
            { id: $scope.dataSource.id }, { modelName: model.name }
          ).$promise;
      };

      $scope.handleSelectChange = function (selectedList) {
        $scope.selectedModels = selectedList;
      };

      $scope.migrate = function () {
        var taskQueue = [].concat($scope.selectedModels);
        var limit = 10; // maximum number of concurrent requests

        var dispatch = function(done) {
          done = done || $q.defer();

          if (taskQueue.length < 1) {
            done.resolve();
          } else {
            while (limit > 0 && taskQueue.length) {
              limit--;

              migrateModel(taskQueue.pop()).then(function() {
                limit++;
                dispatch(done);
              });
            }
          }

          return done.promise;
        };

        $scope.busy = true;
        dispatch()
          .then(function () {
            $scope.busy = false;
            $modalInstance.close();
          });
      };

      ModelConfig.find({filter: {where: {dataSource: $scope.dataSource.name}}})
        .$promise.then(function (models) {
          $scope.busy = false;
          $scope.models = models;
        });
    }
  ])
  .controller('dataSourceTestDialogController', [
    '$scope',
    '$modalInstance',
    function ($scope, $modalInstance) {
      $scope.cancel = $modalInstance.close;
      $scope.testOriginal = function () {
        $scope.test($scope.dataSource);
        $modalInstance.close()
      };
      $scope.saveTest = function () {
        $scope.save();
        $modalInstance.close();
      };
    }
  ]);

