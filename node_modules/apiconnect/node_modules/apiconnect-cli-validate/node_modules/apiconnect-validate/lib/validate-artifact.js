'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var g = require('strong-globalize')();
var path = require('path');
var validateObject = require('./validate-object');
var validateString = require('./validate-string');

module.exports = validate;

/**
 * @typedef Response
 * @type {object}
 * @property {artifact} artifact that was validated
 * @property {error[]} error any errors that were encountered
 * @property {validation[]} schema validations results
 */

/**
 * @typedef {object} validation
 * @property {string} title the title of the schema valdation that was performed
 * @property {string} path Resolved path to product or swagger file.
 * @property {err} error
 * @property {string} type
 * @property {string} status valid or not_valid
 */

/**
 * @typedef {object} artifact
 * @property {string} type `product` or `swagger`.
 * @property {string} filePath Resolved path to product or swagger file.
 * @property {string} name
 * @property {string} version
 * @property {string} raw contents of filePath
 * @property {Artifacts} refs - if( type===product ) and referenced product.apis[$ref] exist. Those will also be loaded
 * @property {Error} err optional Error
 * @property {object} data js-yaml parsed raw content
 */

/**
 * Perform validation on the provided artifacts. This function handles schema validation and semantic validation.
 * @param {artifact[]} artifacts to validate
 * @param {object} opts
 * @param {boolean} opts.productOnly validate only provided product artifacts
 * @param {boolean} opts.extensions also validate schema extensions
 *
 * @return Promise<Response> that resolves to a Response
 */
function validate(artifacts, opts) {
    opts = opts || {};
    _.defaults(opts, { extensions: true, productOnly: false });
    return Promise.map(artifacts, function(artifact) {
        return validateArtifact(artifact, opts);
    }).then(function(res) {
        var ret = {};
        // Repack the results in to filePath => result
        res.forEach(function(validationResult) {
            ret [validationResult.artifact.filePath] = validationResult;
        });
        return ret;
    });
}

function validateArtifact(artifact, opts) {
    var validateExtensions = opts.extensions;
    var validateProductOnly = opts.productOnly;
    // A couple up front sync checks. If these fail, get outta here as subsequent schema checks
    // most likely won't work.
    try {
        validateString(artifact.raw);
        // artifact.err is most likely some sort of a problem that occurred during yaml/file loading
        if (artifact.err) {
            throw artifact.err;
        }
    } catch (err) {
        return Promise.resolve(
            {
                artifact: artifact,
                error: [ err ],
                validation: []
            }
        );
    }
    var refs = Promise.resolve({ error: [], validation: [] });
    if (validateProductOnly !== true && artifact.type === 'product') {
        refs = validateApiRefs();
    }
    return Promise.join(refs, validateObject(artifact.data, artifact.filePath, validateExtensions), function(apiRefsValidations, objectValidations) {
        return {
            artifact: artifact,
            error: apiRefsValidations.error,
            validation: _.union(objectValidations, apiRefsValidations.validations)
        };
    });

    // Check to ensure that if a product.apis['$ref]' exists
    // - The referent exists
    // - It is parsable YAML
    // - It isn't referring to another product
    // - If all of above are false, run schema validation
    function validateApiRefs() {
        return new Promise(function(resolve, reject) {
            var res = { error: [], validations: [] };
            var needSchemaValidation = [];
            if (artifact.data && artifact.data.apis) {
                var apis = artifact.data.apis;
                _.values(apis).forEach(function(api) {
                    var filepath = path.resolve(path.dirname(artifact.filePath), api['$ref']);
                    var refdArtifact = _.find(artifact.refs, { filePath: filepath });
                    if (!refdArtifact || refdArtifact.err) {
                        // The parsed file has a reference to a file that isn't in refs. That means that the ref'd file
                        // doesn't exist, isn't valid YAML or it was possibly excluded via .apicignore. Either way it's an error
                        var err;
                        if (refdArtifact && refdArtifact.err && refdArtifact.err.code === 'ENOENT') {
                            err = new Error(g.f('The product file %s references a non-existent file %s.',
                                path.basename(artifact.filePath), api['$ref']));
                        } else if (refdArtifact && refdArtifact.err) {
                            err = new Error(g.f('The product file %s references an invalid file %s. Details: \n\t%s',
                                path.basename(artifact.filePath), api['$ref'], refdArtifact.err.toString()));
                        } else {
                            return;
                        }
                        err.type = 'missing-api';
                        err.extra = api;
                        res.error.push(err);
                    } else if (refdArtifact.type === 'product') {
                        res.error.push(new Error(g.f('Product %s incorrectly references another product %s as an API.',
                            path.basename(artifact.filePath), path.basename(refdArtifact.filePath))));
                    } else {
                        // We have a refdArtifact that doesn't have an error. We need to schema validate now
                        needSchemaValidation.push(refdArtifact);
                    }
                });
            }
            return Promise.map(needSchemaValidation, function(validateArtifact) {
                return validateObject(validateArtifact.data, validateArtifact.filePath, validateExtensions);
            }).then(function(validations) {
                res.validations = _.flatten(validations);
                return resolve(res);
            });
        });
    }
}
