// Licensed Materials - Property of IBM
// 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
// (C) Copyright IBM Corporation 2016, 2017
// All Rights Reserved.
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var Promise = require('bluebird');
var Sway = require('sway');
var _ = require('lodash');
var getErrorStatus = require('./error-status');
var schemaValidate = require('./schema-validate');

module.exports = function(definition, filename, validateExtension) {
    if (typeof validateExtension === 'undefined') {
        validateExtension = true;
    }
    var definitionType;
    var schemas = [];
    if (definition.policy === '1.0.0') {
        definitionType = 'policy';
        schemas.push({
            name: 'API Connect policy schema',
            content: require('../schemas/policy-document.json')
        });
    } else if (definition.swagger === '2.0') {
        definitionType = 'api';
        if (validateExtension) {
            schemas.push({
                name: 'API Connect swagger extensions schema',
                section: 'x-ibm-configuration',
                content: require('../schemas/x-ibm-configuration.json')
            });
        }
        schemas.push({
            name: 'IBM Swagger Version 2.0 schema',
            content: require('../schemas/swagger-v2.0-schema.json')
        });
    } else if (definition.product === '1.0.0') {
        definitionType = 'product';
        schemas.push({
            name: 'API Connect product schema',
            content: require('../schemas/product-document.json')
        });
    } else if (definition['vendor-extensions'] === '1.0.0') {
        definitionType = 'vendor-extension';
        schemas.push({
            name: 'API Connect vendor extensions schema',
            content: require('../schemas/vendor-extension-document.json')
        });
    }

    var results = [];
    if (definitionType === 'api') {
        results.push(swayValidate(definition, filename));
    }
    schemas.forEach(function(schema) {
        results.push(schemaValidate(definition, schema, definitionType, filename));
    });

    return Promise.all(results).then(_.flatten);
};

function swayValidate(definition, filename) {
    var definitionClone = _.cloneDeep(definition);

    return Sway.create({ definition: definitionClone }).then(function(api) {
        api.registerValidator(checkAPIEnforced);
        var swayResponse = api.validate();

        var info = definition.info || {
            version: 'unknown',
            'x-ibm-name': 'unknown-missing-info',
            title: 'unknown-missing-info'
        };
        var name = info['x-ibm-name'] || info.title;
        return {
            title: 'Swagger Version 2.0 schema',
            name: name,
            version: info.version,
            path: filename,
            error: swayResponse.errors,
            warning: swayResponse.warnings,
            type: 'api',
            status: getErrorStatus(swayResponse.errors)
        };
    });
}

function checkAPIEnforced(api) {
    var response = {
        errors: [],
        warnings: []
    };

    // Rules
    // If x-ibm-name is provided, make sure it is a string and conforms to [^A-Za-z0-9_-]+$
    // If x-ibm-name is null, error
    // If x-ibm-name is not provided, warn.
    if (api.info && api.info['x-ibm-name']) {
        if (typeof api.info['x-ibm-name'] !== 'string') {
            response.errors.push({
                message: 'x-ibm-name must be a string and conform to the regex ^[A-Za-z0-9_-]+$',
                path: [ 'info' ]
            });
        } else if (!(/^[A-Za-z0-9_-]+$/).test(api.info['x-ibm-name'])) {
            // x-ibm-name isn't required, but need to validate if it exists
            response.errors.push({
                message: 'x-ibm-name must conform to the regex ^[A-Za-z0-9_-]+$',
                path: [ 'info' ]
            });
        }
    } else if (api.info && api.info['x-ibm-name'] === null) {
        response.errors.push({
            message: 'x-ibm-name cannot be empty.',
            path: [ 'info' ]
        });
    } else if (api.info && !api.info['x-ibm-name']) {
        // Record a warning as when this API is published the server side a name will be generated.
        response.warnings.push({
            message: 'x-ibm-name is recommended.',
            path: [ 'info' ]
        });
    }

    if (api.schemes && api['x-ibm-configuration'] && api['x-ibm-configuration'].enforced) {
        // if we're enforced, then our schemes may only be "https"
        if (api['x-ibm-configuration'].gateway === 'datapower-gateway') {
            if (api.schemes.length !== 1 || api.schemes[0] !== 'https') {
                response.errors.push({
                    message: 'Enforced APIs can only use HTTPS on the DataPower Gateway',
                    path: [ 'schemes' ]
                });
            }

            // make sure refresh token ttl is longer than access_token
            if (typeof api['x-ibm-configuration'].oauth2 !== 'undefined' &&
                typeof api['x-ibm-configuration'].oauth2['refresh-token'] !== 'undefined' &&
                api['x-ibm-configuration'].oauth2['refresh-token'].count > 0) {
                var rfttl = typeof api['x-ibm-configuration'].oauth2['refresh-token'].ttl === 'undefined' ?
                    2682000 : api['x-ibm-configuration'].oauth2['refresh-token'].ttl;
                var atttl = (typeof api['x-ibm-configuration'].oauth2['access-token'] === 'undefined' || typeof api['x-ibm-configuration'].oauth2['access-token'].ttl === 'undefined') ?
                    3600 : api['x-ibm-configuration'].oauth2['access-token'].ttl;
                if (!(atttl < rfttl)) {
                    response.errors.push({
                        message: 'refresh_token lifetime must be longer than access_token lifetime',
                        path: [ 'oauth2' ]
                    });
                }
                // make sure maximum consent ttl is longer than refresh_token
                if (typeof api['x-ibm-configuration'].oauth2['maximum-consent'] !== 'undefined' &&
                    typeof api['x-ibm-configuration'].oauth2['maximum-consent'].ttl !== 'undefined' &&
                    api['x-ibm-configuration'].oauth2['maximum-consent'].ttl !== 0) {
                    var mcttl = api['x-ibm-configuration'].oauth2['maximum-consent'].ttl;
                    if (!(mcttl >= rfttl)) {
                        response.errors.push({
                            message: 'maximum_consent lifetime must be longer than refresh_token lifetime',
                            path: [ 'oauth2' ]
                        });
                    }
                }
            }
        }

        if (api['x-ibm-configuration'] && api['x-ibm-configuration'].analytics &&
            api['x-ibm-configuration'].analytics.mappings) {
            for (var i = 0; i < api['x-ibm-configuration'].analytics.mappings.length; i++) {
                var mapping = api['x-ibm-configuration'].analytics.mappings[i];
                if (mapping.schema && mapping.schema.$ref) {
                    var obj = getObjectFromRef(mapping.schema.$ref, api);
                    if (obj) {
                        if (!obj.in || !(obj.in === 'header' || obj.in === 'payload')) {
                            var ref = mapping.schema.$ref.substring(1);
                            var path = ref.substring(2).split('/');
                            response.warnings.push({
                                message: 'The \'in\' field must have the value \'header\' or \'payload\' for parameters referenced by analytics.',
                                path: path
                            });
                        }
                    }
                }
            }
        }

        if (_.isArray(api.security)) {
            api.security.forEach(function(security) {
                var names = Object.keys(security);
                names.forEach(function(securityDefName) {
                    var def = api.securityDefinitions[securityDefName];
                    if (def && def.type === 'apiKey' &&
                        ((def.in === 'header' && def.name !== 'X-IBM-Client-Id' && def.name !== 'X-IBM-Client-Secret') ||
                         (def.in === 'query' && def.name !== 'client_id' && def.name !== 'client_secret'))) {
                        response.errors.push({
                            message: 'Enforced APIs can only have one security requirement defined and can only use API Key schemes' +
                                ' that use client ID and/or client secret.',
                            path: [ 'securityDefinitions' ]
                        });
                    }
                });
            });
        }
    }
    return response;
}

function getObjectFromRef(ref, api) {
    var obj = null;
    if (ref && ref.startsWith('#')) {
        obj = api;
        ref = ref.substring(1);
        var path = ref.split('/');
        for (var i = 0; i < path.length; i++) {
            if (path[i]) {
                path[i] = path[i].trim();
                if (path[i].length === 0) {
                    // Continue
                } else if (path[i] && path[i].length > 0 && obj[path[i]]) {
                    obj = obj[path[i]];
                } else {
                    return null;
                }
            }
        }
    }
    return obj;
}

/**
* Due to performance problems with how sway processes local refs,
* if a $ref references an existing definition object and it is located
* within a definition (versus a policy or parameter, etc.), then replace the
* $ref with a type:'string'.
*/
function replaceDefinitionRefs(obj, api, context) {
    api = api || obj;
    context = context || {};
    if (!obj) {
        return;
    } else if (Array.isArray(obj)) {
        for (var j = 0; j < obj.length; j++) {
            // recurse array element
            replaceDefinitionRefs(obj[j], api, context);
        }
    } else if (typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key === '$ref' &&
                    context.inDefinitions &&
                    obj[key].indexOf('/definitions/') >= 0 &&
                    getObjectFromRef(obj[key], api)) {
                    delete obj[key];
                    obj.type = 'string';
                } else if (key === 'definitions') {
                    replaceDefinitionRefs(obj[key], api, { inDefinitions: true });
                } else {
                    replaceDefinitionRefs(obj[key], api, context);
                }
            }
        }
    }
}
