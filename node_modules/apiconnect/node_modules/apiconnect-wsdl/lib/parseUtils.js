/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const d = require('../lib/domutils.js');


/* Utilities for parsing the WSDL/XSD files for apiconnect-wsdl */

var assert = require('assert');
var _ = require('lodash');
var fs = require('fs');
var q = require('q');
var http = require('http');
var https = require('https');
var url = require('url');
var iconv = require('iconv-lite');
var soap = require('soap');
var xmldom = require('xmldom');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');


// monkey patch soap WSDL parser
soap.WSDL.prototype.processIncludes = function(callback) {
    if (this.definitions) {
        var schemas = this.definitions.schemas;
        var includes = [];
        var schemaWithoutTargetNamespace = false;

        for (var ns in schemas) {
            var schema = schemas[ns];
            if (ns == 'undefined') {
                schemaWithoutTargetNamespace = true;
            }
            includes = includes.concat(schema.includes || []);
        }
        try {
            this._processNextInclude(includes, callback);
        } catch (e) {
            // Schemas should have a targetNamespace according to WS-I
            // Normally a schema without a targetNamespace is simply used to import other schemas (which is fine)
            // But if the schema contains elements, types etc, then soap.WSDL processing may fail.
            // Continue processing in such cases to avoid regressions.
            if (schemaWithoutTargetNamespace) {
                console.log(g.http(null).f('A \'schema\' element does not have a \'targetNamespace\' attribute. This may cause errors while creating the API.  The missing targetNamespace is ignored and processing continues.  The ignored error is (%s).', e));
            } else {
                // An exception involving postProcess occurs if a wsdl:operation references a missing wsdl:message
                // Don't save the message because we do a more thorough check later.
                // Save other internal messages
                if (!e.message || e.message.indexOf('postProcess') < 0) {
                    this.internalError = e;
                }
            }
            if (callback) {
                callback(e, this);
            }
        }
    }
};

// monkey patch soap WSDL parser
soap.WSDL.prototype._fromXML = function(xml) {
    if (xml && xml.length > 0) {
        this.definitions = this._parse(xml);

        if (this.definitions) {
            this.definitions.descriptions = {
                types: {}
            };
        }
        this.xml = xml;
    }
};

/**
* Wrapper around _fromXML that ammends the error message; thus the error message
* provides contextual information for the customer.
*/
function fromXML(obj, content, context, req) {
    try {
        obj._fromXML(content);
    } catch (e) {
        var insertContent = content.length < 300 ? content : content.substring(0, 300);
        context = context.toString();
        var insertContext = context.length < 300 ? context : context.substring(0, 300);
        // The location of the error is separately translated so that it can be removed in some cases.
        let where = g.http(u.r(req)).f('An error occurred while parsing "%s".\n', escape(insertContext));
        // throw g.http(u.r(req)).Error('%s The error is (%s).\n The content starts with [%s].', where, cleanupError(e, req), escape(insertContent));
        let msg = g.http(u.r(req)).f('%s The error is (%s).\n The content starts with [%s].', where, cleanupError(e, req), escape(insertContent));
        throw new Error(msg);
    }
}

/**
* preParse the xml file content.
* Prior to parsing the file with node soap, the file is parsed with an ordinary
* DOM Parser to do some fixups.
*
* 1) Add fake targetNamespaces if a schema lacks a TargetNamespace
* 2) Add special ids to choice, sequence, etc. because node soap does not preserve their order.
*    These ids will be used in the generation pass to ensure the constructs are properly ordered.
* 3) Remove certain wsdl documentation elements.  These are unnecessary and cause problems in the node
*    soap parser.
* 4) Look for DTDs and other fatal node types
*/
function preParse(fileContent, fileName, options, checkingPass) {
    let req = options.req;
    let report = {
        warnings: [],
        errors: []
    };
    var DOMParser = require('xmldom').DOMParser;
    var doc = new DOMParser({
        errorHandler: {
            warning: function(msg) {
                report.warnings.push(msg);
            },
            error: function(msg) {
                report.errors.push(msg);
            },
            fatalError: function(msg) {
                report.errors.push(msg);
            }
        } }).parseFromString(fileContent, 'text/xml');
    if (report.errors.length > 0) {
        throw new Error(JSON.stringify(report));
    }
    if (!doc) {
        return fileContent;
    }

    // If a schema does not have a targetNamespace, add a fake one
    // Often wsdl files will have schemas without a targetnamespace simply to import other schemas.
    // These schemas can cause error messages during parsing, so we add fake namespaces to avoid
    // error messages (and other relate problems).
    var faketnsID = 0;
    var schemas = doc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'schema');
    for (var s = 0; s < schemas.length; s++) {
        var schema = schemas[s];
        if (!schema.getAttribute('targetNamespace')) {
            if (faketnsID == 0) {
                // Only add fakens if multiple schemas...updating the schema for just one instance
                // is not necessary and affects performance because we need to do a serialization
                // of this doc
                faketnsID++;
            } else {
                schema.setAttribute('targetNamespace', 'https:/APICTNS' + faketnsID++);
            }
        }
    }

    // If there are a combination of element, choice, group, and sequence within a sequence
    // then add an apicID so subsequent processing can determine the order of these constructs.
    var sequences = doc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'sequence');
    var id = 0;
    for (var j = 0; j < sequences.length; j++) {
        var seqseqs = sequences[j].getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'sequence');
        var seqchoices = sequences[j].getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'choice');
        var seqgroups = sequences[j].getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'group');
        if (seqseqs.length > 0 || seqchoices.length > 0 || seqgroups.length > 0) {
            var elements = sequences[j].getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', '*');

            for (var k = 0; k < elements.length; k++) {
                var e = elements[k];
                if (!e.getAttribute('apicID')) {
                    if (e.localName == 'sequence'  || e.localName == 'group' || e.localName == 'choice' || e.localName == 'element') {
                        e.setAttribute('apicID', id++);
                    }
                }
            }
        }
    }

    // Find wsdl documentation elements in types and definition
    var wsdlDocs = [];
    var wsdlDocs2 = [];
    var wsdlDef = doc.getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'definitions');
    if (wsdlDef && wsdlDef.length > 0) {
        // Remove wsdl:documentation within types
        var wsdlTypes = wsdlDef[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'types');
        if (wsdlTypes && wsdlTypes.length > 0) {
            wsdlDocs = wsdlTypes[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'documentation');
        }

        // Remove wsdl:documentation under definitions, but only if there is NO wsdl:service
        var wsdlService = wsdlDef[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'service');
        if (!wsdlService || wsdlService.length === 0) {
            wsdlDocs2 = wsdlDef[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'documentation');
        }
    }

    // Remove documentation elements because node/soap does not like them, but the spec says they are allowed.
    for (var i = 0; i < wsdlDocs.length; i++) {
        let wsdlDoc = wsdlDocs[i];
        wsdlDoc.parentNode.removeChild(wsdlDoc);
    }
    for (i = 0; i < wsdlDocs2.length; i++) {
        let wsdlDoc = wsdlDocs2[i];
        if (wsdlDoc.parentNode &&
            wsdlDoc.parentNode.namespaceURI === 'http://schemas.xmlsoap.org/wsdl/' &&
            wsdlDoc.parentNode.localName === 'definitions') {
            wsdlDoc.parentNode.removeChild(wsdlDoc);
        }
    }

    // Walk the DOM looking for DOCTYPE and other unrecognized node types
    let badNames = [];
    let ALLOW_NMTOKEN = {
        definitions: true,
        part: true,
        input: true,
        output: true,
        fault: true,
    };
    let elementCount = 0;
    d.traverseDOM(doc, function(node, stack) {
        let info = d.getNodeTypeInfo(node.nodeType);
        if (node.nodeType === 1) {
            elementCount++;
        }
        if (info.report) {
            throw g.http(u.r(req)).Error('Found a node type of %s within file %s.  This is not supported.', info.name, fileName);
        }
        if (node.nodeName) {
            // Don't need appinfo or comments in the backend, and we don't want to parse its contents.  So remove it.
            if (node.localName === 'appinfo') {
                node.parentNode.removeChild(node);
                node = null;
            } else if (node.nodeName === '#comment') {
                node.parentNode.removeChild(node);
                node = null;
            }
            if (node && checkingPass && node.nodeType == 1) {
                // Enforce NMTOKEN or NCNames to prevent weird problems in backend.
                let name = node.getAttribute('name');
                if (name) {
                    let valid = ALLOW_NMTOKEN[node.localName] ? u.isNMTOKEN(name) : u.isNCName(name);
                    if (!valid && _.indexOf(badNames, name) < 0) {
                        badNames.push(name);
                    }
                }

                // Make sure first node is a definitions or schema elements
                if (elementCount === 1) {
                    if (node.localName !== 'schema' && node.localName !== 'definitions') {
                        if (node.localName === 'description') {
                            throw g.http(u.r(req)).Error('Found a WSDL 2.0 description element in %s.  Only WSDL 1.1 and WSDL 1.2 are supported.', fileName);
                        } else {
                            throw g.http(u.r(req)).Error('Expected \'schema\' or \'definitions\' element but found \'%s\' in %s.  Please correct the WSDL or XSD file.', fileName);
                        }
                    }
                }
            }
        }
        return node;
    });

    if (badNames.length > 0) {
        throw g.http(u.r(req)).Error('Found xml name(s) that are not valid xml NCNames [ %s ] within file %s.  This is not supported.', badNames, fileName);
    }

    // If extra validation, the issue console messages if any interesting nodes or attribures are encountered.
    // TODO change later to saving this information and presenting it in a report.
    if (options.extraValidation && checkingPass) {
        let map = d.getNamesMap(doc);
        let errNodes = [];
        let errAttrs = [];
        for (let key in map.nodes) {
            let info = d.getNameInfo(key);
            if (!info.known) {
                console.log(g.http(u.r(req)).f('Found unknown NCName %s in file %s', key, fileName));
            } else if (!info.common) {
                console.log(g.http(u.r(req)).f('Found uncommon NCName %s in file %s.  This uncommon name is associated with %s', key, fileName, info.ns));
            }
        }
        for (let key in map.attrs) {
            let info = d.getAttrInfo(key);
            if (!info.known) {
                console.log(g.http(u.r(req)).f('Found unknown attribute %s in file %s', key, fileName));
            } else if (!info.common) {
                console.log(g.http(u.r(req)).f('Found uncommon attribute %s in file %s.  This uncommon name is associated with %s', key, fileName, info.ns));
            }
        }
    }

    // If checkingPass, return the original fileContent
    if (checkingPass) {
        return fileContent;
    } else {
        // Remove all unknown elements from the DOM
        doc = d.pruneDOM(doc);
        // Serialize the updated doc
        var serializer = new xmldom.XMLSerializer();
        fileContent = serializer.serializeToString(doc);
        // Comments are encoded by the serializer, so we need to do a replace
        fileContent = fileContent.replace(/&lt;!-/g, '<!-');
    }
    return fileContent;
}

function normaliseLocation(location, relativePath) {
    var newLocation = relativePath ? relativePath + '/' + location : location;
    var ret = newLocation;
    if (newLocation) {
        var parts = newLocation.split('/');
        if (parts.length > 1) {
            // remove . parts
            for (let i = 0; i < parts.length; i++) {
                let part = parts[i];
                if (part == '.') {
                    parts.splice(i, 1);
                    i = -1;
                }
            } // end for

            for (let i = 0; i < parts.length; i++) {
                let part = parts[i];
                if (part == '..') {
                    if (i > 0) {
                        // remove current .. and prior part
                        parts.splice(i - 1, 2);
                    } else {
                        // This is the case where the .. extend below the root.
                        // This is not a normal case, but it is needed for migration of old wsdls.
                        // Count consecutive ..
                        let count = 0;
                        for (let j = i; j < parts.length; j++) {
                            if (parts[j] == '..') {
                                count++;
                            } else {
                                break;
                            }
                        }
                        // Remove equal number of subsequent non-..
                        let remove = count;
                        for (let j = i + count; j < (parts.length - 1) && remove > 0; j++) {
                            if (parts[j] != '..') {
                                parts.splice(j, 1);
                                remove--;
                                j--;
                            }
                        }
                        // Remove ..
                        parts.splice(0, count);
                    }
                    i = -1;
                }
            } // end for
            ret = parts.join('/');
        }
    }
    return ret;
}

/**
* Return the raw content of the file.
* The file may be a location, in memory, or a path
* The context object is used to provide extra information if an error occurs.
*/
function getFileContent(location, fullPath, auth, context, req) {
    var def = q.defer();
    if (typeof location.substr === 'undefined') {
        // location is raw content
        def.resolve(location);
    } else if (location.substr(0, 7) == 'http://' || location.substr(0, 8) == 'https://') {
        // fetch from URL
        var parsedUrl = url.parse(location);
        var protocol = parsedUrl.protocol.substring(0, parsedUrl.protocol.length - 1);
        var modules = {
            http: http,
            https: https
        };
        var options = {
            hostname: parsedUrl.hostname,
            port: parsedUrl.port,
            path: parsedUrl.path
        };
        if (auth) {
            options.headers = {
                Authorization: auth
            };
        }
        modules[protocol].get(options, function(response) {
            var strings = [];
            response.on('data', function(data) {
                strings.push(data);
            });
            response.on('end', function() {
                if (response.statusCode >= 200 && response.statusCode < 300) {
                    var content = Buffer.concat(strings);
                    var encoding = 'utf8'; // start with a common default encoding
                    var left = content.toString('utf8', 0, 4);
                    if (left == 'PK\u0003\u0004') {
                        // treat as binary
                        encoding = null;
                    } else {
                        encoding = determineEncoding(content, location, req);
                    }
                    def.resolve(decode(content, encoding));
                } else {
                    // Failed to get a remote file
                    def.reject(fileContentError(context,
                      g.http(u.r(req)).f('Failed to retrieve the remote file from location %s. Ensure the remote file is available. ' +
                          'The HTTP Response code is %s.', location, response.statusCode),
                      req));
                }
            });
        }).on('error', function(e) {
            def.reject(fileContentError(context,
              g.http(u.r(req)).f('Failed to retrieve the remote file from location %s. Ensure the remote file is available. The error is (%s).', location, e),
              req));
        });
    } else if (location.substr(0, 6) == 'ftp://') {
        // fetch from FTP
        def.reject(fileContentError(context,
          g.http(u.r(req)).f('Failed to retrieve the remote file from location %s. Ensure the remote file is available. FTP is not supported.', location),
          req));
    } else if (location.substring(0, 5) == '<?xml') {
        // It appears that the location is the file content in memory
        def.resolve(location);
    } else if (location.substr(0, 6) == 'MEMORY') {
        // Special In Memory file
        try {
            def.resolve(auth.data);
        } catch (err) {
            def.reject(err);
        }
    } else {
        // perform a content sniff to get the read mode correct
        try {
            fs.readFile(fullPath, function(err, rawData) {
                if (err) {
                    // If location is sufficiently large, assume that it is the content and convert to a Buffer
                    if (location.length > 1000) {
                        def.resolve(toBuffer(location, req));
                    } else {
                        // Return an reasonable message.
                        var resolvedPath = fullPath;
                        try {
                            var path = require('path');
                            resolvedPath = path.resolve(fullPath);
                        } catch (e) {
                            // Accept
                        }

                        try {
                            if (!fs.existsSync(fullPath)) {
                                def.reject(fileContentError(context,
                                  g.http(u.r(req)).f('The local file "%s" does not exist.', resolvedPath), req));
                            } else {
                                def.reject(fileContentError(context,
                                  g.http(u.r(req)).f('The local file "%s" is not accessible. The error is %(s).', resolvedPath, err), req));
                            }
                        } catch (e) {
                            def.reject(fileContentError(context,
                              g.http(u.r(req)).f('The local file "%s" is not accessible. The error is (%s).', resolvedPath, err), req));
                        }
                    }
                } else {
                    var encoding = 'utf8'; // start with a common default encoding
                    var left = rawData.toString('utf8', 0, 4);
                    if (left == 'PK\u0003\u0004') {
                        // treat as binary
                        encoding = null;
                    } else {
                        encoding = determineEncoding(rawData, fullPath);
                    }
                    def.resolve(decode(rawData, encoding));
                }
            });
        } catch (e) {
            // If the error is an invalid fullPath, then assume location is the buffer (legacy)
            if (e.toString().indexOf('The argument \'path\' must be a string')) {
                def.resolve(toBuffer(location));
            } else {
                def.reject(e);
            }
        }
    }
    return def.promise;
}

/**
* Generates an ammended error for getFileContent
*/
function fileContentError(context, error, req) {
    if (context) {
        error = g.http(u.r(req)).f('An error occurred while processing (%s).\nThe error is (%s).\nYou may want to create a zip file containing all of your wsdl/xsd files and use the zip file as the input.', context, error);
    }
    return new Error(error);
}


// Check for oddities in the WSDL json produced by node soap
function validateWSDLJson(wsdlJson, filename, req) {
    var ret = {
        valid: true
    };
    if (wsdlJson && wsdlJson.definitions) {
        if (wsdlJson.definitions.types) {
            if (Array.isArray(wsdlJson.definitions.types)) {
                // not valid to have more than one wsdl:types entry
                ret.valid = false;
                ret.reason = g.http(u.r(req)).f('A wsdl \'document\' must not contain more than one \'wsdl:types\' element. The file is %s.', filename);
            }
        }
        var correct = checkParentage(wsdlJson.definitions.types, 'types', 'extension', [ 'simpleContent', 'complexContent' ]);
        if (!correct) {
            ret.valid = false;
            ret.reason = g.http(u.r(req)).f('An \'extension\' element must be a child of a \'simpleContent\' or \'complexContent\' element. The file is %s.', filename);
        }
    } else if (wsdlJson && !wsdlJson.definitions) {
        ret.valid = false;
        ret.reason = g.http(u.r(req)).f('A wsdl \'document\' does not contain any valid content. The file is %s.', filename);
    }
    return ret;
}

/**
* Common utility function that converts raw content (file.content)
* into node soap (file.doc and file.json).
*/
function contentToXMLorWSDL(file, options) {
    let req = options.req;

    // Do some string replace fixups (the DOM is not loaded)
    // fix some ideosyncracies with tag whitespace
    // protect documentation in CDATA
    file.content = u.fixTags(file.content);
    file.content = protectDocumentation(file.content);

    // Now do a preParse pass (which loads and checks the DOM)
    // The checkingPass parameter is set to avoid serializing the DOM (which can hide errors)
    preParse(file.content, file.filename, options, true);

    // Now use the soap node module to parse the content.  This will catch some common xsd/wsdl errors
    try {
        file.doc = new soap.WSDL('', file.filename, {});
        if (file.doc.internalError) {
            throw file.doc.internalmyError;
        }
        fromXML(file.doc, file.content, file.filename, req);
        file.json = file.doc.xmlToObject(file.content);
    } catch (e) {
        // Due to a bug in the soap parser, an 'Unmatched element nesting' error
        // is produced if a documentation occurs in the types section.
        // Ignore this error, it is corrected later in pre-parse
        let text = e.toString();
        if (text.indexOf('Unmatched element nesting') < 0 &&
            text.indexOf('assert(child instanceof SchemaElement)') < 0) {
            throw e;
        }
    }

    // Now run preParse a second time, but this time it is run with a fixup mode
    // The file content that is returned is ready for the actual node soap parse.
    file.content = preParse(file.content, file.filename, options);

    // Now convert to XML/WSDL a second time with the adjusted data.
    file.doc = new soap.WSDL('', file.filename, {});
    fromXML(file.doc, file.content, file.filename, req);
    file.json = file.doc.xmlToObject(file.content);
}

// Utility function that converts obj into a Buffer so that
// it can be processed by other functions (i.e. yauzl)
function toBuffer(obj, req) {
    if (!obj) {
        return obj;
    }

    // Try fromBuffer
    try {
        if (typeof obj == 'string') {
            return Buffer.from(obj, isBase64(obj) ? 'base64' : 'binary');
        }
        return Buffer.from(obj);
    } catch (err) {
        throw g.http(u.r(req)).Error('Error trying to convert ' + obj.constructor.name + 'to Buffer: ' + err);
        /*
        // Fallback to new Buffer
        try {
            if (typeof obj == 'string') {
                return new Buffer(obj, isBase64(obj) ? 'base64' : 'binary');
            }
            return new Buffer(obj);
        } catch (error) {
            throw g.http(u.r(req)).Error('Error trying to convert type %s to Buffer. The error is (%s).', obj.constructor.name, error);
        }
        */
    }
}

function isBase64(str) {
    var re = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    return re.test(str);
}

// Decode the content with the indicated encoding
function decode(content, encoding) {
    if (!encoding) {
        return content;
    } else {
        return iconv.decode(content, encoding);
    }
}

// Encode the content with the indicated encoding
function encode(content, encoding) {
    if (!encoding) {
        return content;
    } else {
        return iconv.encode(content, encoding);
    }
}

// Determine the encoding of the content
// The filename is used for error messages.
function determineEncoding(content, filename, req) {
    var ret = 'utf8';
    if (Buffer.isBuffer(content)) {
        // check if we have a BOM
        var bomLength = 0;
        var first = content[0];
        if (first == 0xef) {
            if (content[1] == 0xbb && content[2] == 0xbf) {
                ret = 'utf8';
                bomLength = 3;
            }
        } else if (first == 0xfe) {
            if (content[1] == 0xff) {
                if (content[2] == 0x00 && content[3] == 0x00) {
                    ret = 'ucs4';
                    bomLength = 4;
                } else {
                    ret = 'utf16be';
                    bomLength = 2;
                }
            }
        } else if (first == 0xff) {
            if (content[1] == 0xfe) {
                if (content[2] == 0x00 && content[3] == 0x00) {
                    ret = 'ucs4';
                    bomLength = 4;
                } else {
                    ret = 'utf16le';
                    bomLength = 2;
                }
            }
        } else if (first == 0x00 && content[1] == 0x00) {
            if ((content[2] == 0xfe && content[3] == 0xff) || (content[2] == 0xff && content[3] == 0xfe)) {
                ret = 'ucs4';
                bomLength = 4;
            }
        }
        if (bomLength == 0) {
            // no BOM found, try some data inspection to get the encoding
            if (first == 0x00) {
                if (content[1] == 0x00) {
                    if ((content[2] == 0x00 && content[3] == 0x3c) || (content[2] == 0x3c && content[3] == 0x00)) {
                        ret = 'ucs4';
                    }
                } else if (content[1] == 0x3c && content[2] == 0x00) {
                    if (content[3] == 0x00) {
                        ret = 'ucs4';
                    } else if (content[3] == 0x3f) {
                        ret = 'utf16be';
                    }
                }
            } else if (first == 0x3c) {
                if (content[1] == 0x00) {
                    if (content[2] == 0x00 && content[3] == 0x00) {
                        ret = 'ucs4';
                    } else if (content[2] == 0x3f && content[3] == 0x00) {
                        ret = 'utf16le';
                    }
                } else if (content[1] == 0x3f && content[2] == 0x78 && content[3] == 0x6d) {
                    ret = 'utf8';
                }
            } else if (first == 0x4c && content[1] == 0x6f && content[2] == 0xa7 && content[3] == 0x94) {
                ret = 'ebcdic';
            }
        }
        // although we have detected it, some encodings are not supported by iconv so throw here
        if (ret == 'ucs4' || ret == 'ebcdic') {
            throw g.http(u.r(req)).Error('An unsupported character encoding, %s, was found in file %s.', ret, filename);
        }
        // now convert the first part of the buffer using the encoding we already have
        if (content.length > bomLength) {
            var newBuf = new Buffer.alloc(128);
            try {
                content.copy(newBuf, 0, bomLength, 128);
                var xmlSig = decode(newBuf, ret).toString();
                var index = xmlSig.indexOf('<?xml');
                if (index != -1) {
                    var endIndex = xmlSig.indexOf('?>');
                    if (endIndex != -1) {
                        var realSig = xmlSig.substring(index, endIndex);
                        var encIndex = realSig.indexOf('encoding=');
                        if (encIndex != -1) {
                            var quote = realSig.substr(encIndex + 9, 1);
                            var endQuote = realSig.indexOf(quote, encIndex + 10);
                            if (endQuote != -1) {
                                var encoding = realSig.substring(encIndex + 10, endQuote);
                                ret = encoding.toLowerCase();
                            }
                        }
                    }
                }
            } catch (e) {
                var errMsg = g.http(u.r(req)).f('An error (%s) was caught while processing file %s.', e.message, filename);
                throw new Error(errMsg);
            }
        }
    }
    return ret;
}


// Utility to check if objects with the name (elementName) only
// has parents whose name is in the validParents array.
function checkParentage(root, rootName, elementName, validParents) {
    var ret = true;
    if (root && rootName && elementName && validParents) {
        for (var name in root) {
            if (name == elementName) {
                if (validParents.indexOf(rootName) == -1) {
                    ret = false;
                    break;
                }
            }
            var item = root[name];
            if (item && typeof item === 'object') {
                var entries = u.makeSureItsAnArray(item);
                var len = entries.length;
                for (var i = 0; i < len; i++) {
                    var entry = entries[i];
                    ret = checkParentage(entry, name, elementName, validParents);
                    if (!ret) {
                        break;
                    }
                } // end for
                if (!ret) {
                    break;
                }
            }
        } // end for
    }
    return ret;
}

/**
*  Return text with common chars replaced with escape text.
*/
function escape(text) {
    var map = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
    function chr2enc(a) {
        return map[a];
    }
    return text.replace(/[\"&<>]/g, chr2enc);
}

// wraps all documentation in CDATA sections - allows random XML content to
// exist in the doc so that the parser doesn't barf on it
function protectDocumentation(contents) {
    var ret = '';
    if (contents) {
        if (contents.toString) {
            contents = contents.toString();
        }

        // Find the raw references to documentation elements in the contents
        // and add them to the elementList
        var elementList = [];
        var regex = /documentation>/gi;
        var result;
        while ((result = regex.exec(contents))) {
            var idx = result.index - 1;
            var prepend = '';
            while (contents[idx] != '<' &&
             contents[idx] != '/') {
                prepend = contents[idx] + prepend;
                idx--;
            }
            var name = prepend + 'documentation';
            if (elementList.indexOf(name) < 0) {
                elementList.push(name);
            }
        }

        // For each elementList item, call protectDocSpecific which
        // will wrap the contents of those elements in CDATA
        var len = elementList.length;
        ret = contents;
        for (var i = 0; i < len; i++) {
            var elementName = elementList[i];
            ret = protectDocSpecific(ret, elementName);
        } // end for
    }
    return ret;
}

/**
* Wrap the indicated elementName in a CDATA
*/
function protectDocSpecific(contents, elementName) {
    var ret = '';
    var index = 0;
    var offset = 0;
    var len = contents.length;
    var elementStart = '<' + elementName + '>';
    var elementEnd = '</' + elementName + '>';
    var elementLen = elementStart.length;
    while (offset < len) {
        index = contents.indexOf(elementStart, offset);
        if (index == -1) {
            ret += contents.substring(offset);
            break;
        } else {
            ret += contents.substring(offset, index + elementLen);
            var endIndex = contents.indexOf(elementEnd, index + elementLen);
            var doc = contents.substring(index + elementLen, endIndex);
            // put doc in CDATA if not done already
            var trimmed = doc.trim();
            if (trimmed.indexOf('<![CDATA[') != -1) {
                // remove any nested CDATA and wrap with ours
                doc = trimmed.replace(/]]>/g, '');
                doc = doc.replace(/<!\[CDATA\[/g, '');
                doc = '<![CDATA[' + doc + ']]>';
                ret += doc;
            } else if (doc.indexOf('<') == -1 && doc.indexOf('>') == -1) {
                // If no element start or end token, then don't bother wrapping in CDATA
                ret += doc;
            } else {
                doc = '<![CDATA[' + doc + ']]>';
                ret += doc;
            }
            ret += elementEnd;
            offset = endIndex + elementLen + 1;
        }
    } // end for
    return ret;
}

/**
* Utility to replace certain error messages with a more consumable message
*/
function cleanupError(e, req) {
    var ret = e;
    var msg = e.message;
    if (e instanceof assert.AssertionError) {
        if (msg == 'false == true') {
            msg = g.http(u.r(req)).f('Unmatched element nesting was found.');
        }
        ret = new Error(msg);
    } else if (msg == 'Unexpected root element of WSDL or include') {
        msg = g.http(u.r(req)).f('Expected wsdl or xsd content.');
        ret = new Error(msg);
    }
    return ret;
}

exports.cleanupError = cleanupError;
exports.contentToXMLorWSDL = contentToXMLorWSDL;
exports.decode = decode;
exports.encode = encode;
exports.determineEncoding = determineEncoding;
exports.getFileContent = getFileContent;
exports.normaliseLocation = normaliseLocation;
exports.protectDocumentation = protectDocumentation;
exports.toBuffer = toBuffer;
exports.validateWSDLJson = validateWSDLJson;
