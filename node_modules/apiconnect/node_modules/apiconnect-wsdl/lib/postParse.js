/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parseUtils = require('../lib/parseUtils.js');

var q = require('q');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

/**
* Functions that are performed after the node soap parsing but before generation for the apiconnect-wsdl parser
**/

function checkForWSDLImports(files, auth, options) {
    options = options || {};
    var def = q.defer();
    var allWSDLs = [];
    var hasBeenImported = {};
    var rootWSDLs = [];
    var i, entry;
    // work out import hierarchy first
    var len = files.length;
    for (i = 0; i < len; i++) {
        entry = files[i];
        if (entry.type == 'wsdl') {
            if (entry.json.definitions.import) {
                var imports = u.makeSureItsAnArray(entry.json.definitions.import);
                var impLen = imports.length;
                for (var j = 0; j < impLen; j++) {
                    var imp = imports[j];
                    var location = imp['undefined'].location;
                    if (location) {
                        hasBeenImported[location] = true;
                    }
                } // end for
            }
        }
    } // end for
    // now work out the root WSDLs from the list
    for (i = 0; i < len; i++) {
        entry = files[i];
        if (entry.type === 'wsdl' ||
            entry.type === 'xsd'  && options.strictValidation) {
            if (!hasBeenImported[entry.fullName] && !hasBeenImported[entry.filename] ||
                entry.serviceChildren != {}) {
                rootWSDLs.push(entry);
            }
        }
    } // end for

    // now merge each root WSDL chain
    try {
        var impDefs = [];
        var rootLen = rootWSDLs.length;
        for (i = 0; i < rootLen; i++) {
            let rootWSDL = rootWSDLs[i];
            if (rootWSDL.type == 'wsdl') {
                let impDef = checkOneWSDLImport(rootWSDL, allWSDLs, files, auth, options);
                impDefs.push(impDef);
            } else if (rootWSDL.type == 'xsd') {
                let impDef = checkOneXSDImport(rootWSDL, allWSDLs, files, auth, options);
                impDefs.push(impDef);
            }
        } // end for
        q.all(impDefs).then(function(data) {
            def.resolve(allWSDLs);
        }, function(err) {
            def.reject(err);
        });
    } catch (e) {
        def.reject(e);
    }
    return def.promise;
}



function expandWSDLImports(wsdlJson, baseFilename, files, mergeList, alreadySeen, refFile, auth, options) {
    var def = q.defer();
    if (wsdlJson.definitions.import) {
        var imports = u.makeSureItsAnArray(wsdlJson.definitions.import);
        var iLen = imports.length;
        var impDefs = [];
        for (var i = 0; i < iLen; i++) {
            var imp = imports[i];
            var impDef = expandOneWSDLImport(imp, baseFilename, files, mergeList, alreadySeen, refFile, wsdlJson, auth, options);
            impDefs.push(impDef);
        } // end for
        q.all(impDefs).then(function(data) {
            def.resolve();
        }, function(err) {
            def.reject(err);
        });
    } else {
        def.resolve();
    }
    return def.promise;
}

function mergeWSDL(targetJson, sourceFile, targetFileNamespaces) {

    // Get the targetNamespace
    var sourceJson = sourceFile.json;
    var tns = '';
    if (sourceJson.definitions['undefined']) {
        if (sourceJson.definitions['undefined'].targetNamespace) {
            tns = sourceJson.definitions['undefined'].targetNamespace;
        }
    }

    // Merge the target namespaces into the local namespaces for this file.
    // The target (parent wsdl) prefixes are added first because we want to prefer those prefixes
    // in situations where we have two prefixes and the same namespace.
    var wsdlNamespaces = {};
    for (var key in targetFileNamespaces) {
        wsdlNamespaces[key] = targetFileNamespaces[key];
    }
    for (key in sourceFile.namespaces) {
        wsdlNamespaces[key] = sourceFile.namespaces[key];
    }

    // Merge the source namespaces into the global (target) namespaces
    for (key in sourceFile.namespaces) {
        if (!targetFileNamespaces[key]) {
            targetFileNamespaces[key] = sourceFile.namespaces[key];
        }
    }

    var firstEntry;
    for (key in sourceJson.definitions) {
        if (!targetJson.definitions[key]) {
            if (key == 'undefined') {
                // straight copy
                targetJson.definitions[key] = sourceJson.definitions[key];
            } else if (key == 'types') {
                // straight copy, add namespaces
                targetJson.definitions[key] = sourceJson.definitions[key];
                if (targetJson.definitions[key].schema) {
                    if (Array.isArray(targetJson.definitions[key].schema)) {
                        var schemaLen = targetJson.definitions[key].schema.length;
                        for (var k = 0; k < schemaLen; k++) {
                            var schema = targetJson.definitions[key].schema[k];
                            schema.wsdlXmlns = wsdlNamespaces;
                            schema.wsdlTns = tns;
                        } // end for
                    } else {
                        targetJson.definitions[key].schema.wsdlXmlns = wsdlNamespaces;
                        targetJson.definitions[key].schema.wsdlTns = tns;
                    }
                }
            } else {
                // array copy with metadata
                targetJson.definitions[key] = u.makeSureItsAnArray(sourceJson.definitions[key]);
                var keyLen = targetJson.definitions[key].length;
                for (var i = 0; i < keyLen; i++) {
                    var item = targetJson.definitions[key][i];
                    item.xmlns = wsdlNamespaces;
                    item.tns = tns;
                } // end for
            }
        } else {
            // merge copy, ignore root attributes
            if (key != 'undefined') {
                if (key == 'types') {
                    // types get merged one level down
                    // make sure the original schema list in the wsdl is an array
                    if (!Array.isArray(targetJson.definitions.types.schema)) {
                        firstEntry = targetJson.definitions.types.schema;
                        targetJson.definitions.types.schema = [];
                        targetJson.definitions.types.schema.push(firstEntry);
                    }
                    if (sourceJson.definitions.types) {
                        if (Array.isArray(sourceJson.definitions.types.schema)) {
                            targetJson.definitions.types.schema = targetJson.definitions.types.schema.concat(sourceJson.definitions.types.schema);
                        } else {
                            targetJson.definitions.types.schema.push(sourceJson.definitions.types.schema);
                        }
                    }
                } else {
                    // make sure the original list in the wsdl is an array
                    if (!Array.isArray(targetJson.definitions[key])) {
                        firstEntry = targetJson.definitions[key];
                        targetJson.definitions[key] = [];
                        targetJson.definitions[key].push(firstEntry);
                    }
                    if (Array.isArray(sourceJson.definitions[key])) {
                        var len = sourceJson.definitions[key].length;
                        for (var j = 0; j < len; j++) {
                            var srcItem = sourceJson.definitions[key][j];
                            try {
                                srcItem.xmlns = wsdlNamespaces;
                                srcItem.tns = tns;
                            } catch (e) {
                                // Might be prevented from adding xmlns if this is a protected like an wsdl:appinfo
                                // That is okay, just continue
                            }
                            targetJson.definitions[key].push(srcItem);
                        } // end for
                    } else {
                        var def = sourceJson.definitions[key];
                        try {
                            def.xmlns = wsdlNamespaces;
                            def.tns = tns;
                        } catch (e) {
                            // Might be prevented from adding xmlns if this is a protected like an wsdl:appinfo
                            // That is okay, just continue
                        }
                        targetJson.definitions[key].push(def);
                    }
                }
            }
        }
    } // end for
}

function checkOneWSDLImport(rootWSDL, allWSDLs, files, auth, options) {
    var def = q.defer();
    var wsdlJson = rootWSDL.json;
    var fn = rootWSDL.fullName.replace(/\\/g, '/');
    var baseFilename = '';
    var index = fn.lastIndexOf('/');
    if (index != -1) {
        baseFilename = fn.substring(0, index);
    }
    var mergeList = [];
    var alreadySeen = {};

    var impDef = expandWSDLImports(wsdlJson, baseFilename, files, mergeList, alreadySeen, rootWSDL, auth, options);
    impDef.then(function(data) {
        // now merge the fetched WSDLs into the master wsdl
        try {
            var mergeLen = mergeList.length;
            if (mergeLen > 0) {
                for (var j = 0; j < mergeLen; j++) {
                    var mergeFile = mergeList[j];
                    mergeWSDL(wsdlJson, mergeFile, rootWSDL.namespaces);
                } // end for
            }
            // also merge the schemas
            var schemaDef = checkForSchemaImports(wsdlJson, rootWSDL.fullName, files, rootWSDL, auth, options);
            schemaDef.then(function(data) {
                var allEntry = {
                    json: wsdlJson,
                    namespaces: rootWSDL.namespaces,
                    doc: rootWSDL.doc,
                    serviceChildren: rootWSDL.serviceChildren,
                    filename: rootWSDL.filename,
                    fullName: rootWSDL.fullName
                };
                allWSDLs.push(allEntry);
                def.resolve();
            }, function(e) {
                def.reject(e);
            });
        } catch (e) {
            def.reject(e);
        }
    }, function(err) {
        def.reject(err);
    });
    return def.promise;
}

function checkOneXSDImport(rootDoc, allDocs, files, auth, options) {
    var def = q.defer();
    // make the return XSD look like a WSDL types schema
    var xsdJson = {
        definitions: {
            types: {
                schema: []
            }
        }
    };
    if (!rootDoc.json) {
        def.resolve();
        return def.promise;
    }
    xsdJson.definitions.types.schema.push(rootDoc.json.schema);
    var fn = rootDoc.fullName.replace(/\\/g, '/');
    var baseFilename = '';
    var index = fn.lastIndexOf('/');
    if (index != -1) {
        baseFilename = fn.substring(0, index);
    }
    var mergeList = [];
    var alreadySeen = {};
    var impDef = expandSchemaImports(rootDoc.json.schema, baseFilename, files, mergeList, alreadySeen, rootDoc, auth, false, options);
    impDef.then(function(data) {
    // now merge the fetched schemas into the response
        var mergeLen = mergeList.length;
        if (mergeLen > 0) {
            for (var i = 0; i < mergeLen; i++) {
                var toMerge = mergeList[i];
                xsdJson.definitions.types.schema.push(toMerge.schema);
            } // end for
        }
        var allEntry = {
            json: xsdJson,
            namespaces: rootDoc.namespaces,
            doc: rootDoc.doc
        };
        allDocs.push(allEntry);
        def.resolve();
    }, function(err) {
        def.reject(err);
    });
    return def.promise;
}

function expandOneWSDLImport(imp, baseFilename, files, mergeList, alreadySeen, refFile, wsdlJson, auth, options) {
    let req = options.req;
    var def = q.defer();
    var location = imp && imp['undefined'] ? imp['undefined'].location : null;
    if (location) {
        var relativeFilename = '';
        if (!(location.substr(0, 7) == 'http://' || location.substr(0, 8) == 'https://')) {
            var fn = location.replace(/\\/g, '/');
            location = parseUtils.normaliseLocation(fn, baseFilename);
            var index = location.lastIndexOf('/');
            if (index != -1) {
                relativeFilename = location.substring(0, index);
            }
        }
        // see if we have a match in the files first
        var foundMatch = false;
        var alreadyKnown = false;
        if (!alreadySeen[location]) {
            var len = files.length;
            for (var j = 0; j < len; j++) {
                var entry = files[j];
                if (entry.fullName == location || entry.filename == location) {
                    // If errors were found in the file, throw the error
                    if (entry.error) {
                        throw entry.error;
                    }
                    foundMatch = true;
                    alreadySeen[location] = true;
                    // recurse into the referenced WSDL to check for more imports
                    var impDef = null;
                    if (entry.type == 'wsdl') {
                        mergeList.push(entry);
                        impDef = expandWSDLImports(entry.json, relativeFilename, files, mergeList, alreadySeen, refFile, auth, options);
                    } else {
                        // trying to force an XSD into a WSDL import - store it in the right place
                        var importDef = q.defer();
                        if (!wsdlJson.definitions.types) {
                            wsdlJson.definitions.types = {
                                schema: []
                            };
                        }
                        if (!wsdlJson.definitions.types.schema) {
                            wsdlJson.definitions.types.schema = [];
                        }
                        wsdlJson.definitions.types.schema.push(entry.json.schema);
                        importDef.resolve();
                        impDef = importDef.promise;
                    }
                    impDef.then(function(data) {
                        def.resolve(data);
                    }, function(err) {
                        def.reject(err);
                    });
                    break;
                }
            } // end for
        } else {
            foundMatch = true;
            alreadyKnown = true;
        }
        if (!foundMatch && refFile.context != 'zip') {
            // try the local filesystem as fallback
            var filename = location;
            if (!alreadySeen[filename]) {
                alreadySeen[filename] = true;
                var file = {
                    filename: location,
                    fullName: filename,
                    type: 'wsdl',
                    content: '',
                    context: 'cmd'
                };
                var fileDef = parseUtils.getFileContent(location, filename, auth,
                  g.http(u.r(req)).f('a \'location\' attribute with a value of "%s"', imp['undefined'].location), req);
                fileDef.then(function(content) {
                    if (content == location) {
                        file.filename = 'MEMORY';
                        file.fullName = 'MEMORY';
                    }
                    file.content = content;
                    try {
                        parseUtils.contentToXMLorWSDL(file, options);
                        if (file.doc.definitions) {
                            var namespaces = file.doc.definitions.xmlns;
                            var wsdlGood = parseUtils.validateWSDLJson(file.json, file.filename, req);
                            if (wsdlGood.valid) {
                                files.push(file);
                                file.namespaces = namespaces;
                                // have to capture the service children elements (ports) here as they get munged later
                                file.serviceChildren = captureServiceChildren(file.doc);
                                updateSchemaNamespaces(file);
                                // add to merge list
                                mergeList.push(file);
                                // and recurse into each schema to check them as well
                                var subDef = expandWSDLImports(file.json, baseFilename, files, mergeList, alreadySeen, refFile, auth, options);
                                subDef.then(function(data) {
                                    def.resolve(data);
                                }, function(e) {
                                    def.reject(e);
                                });
                            } else {
                                throw new Error(wsdlGood.reason);
                            }
                        } else {
                            throw g.http(u.r(req)).Error('Failed to parse WSDL in file %s.', file.filename);
                        }
                    } catch (e) {
                        def.reject(parseUtils.cleanupError(e, req));
                    }
                }, function(err) {
                    def.reject(err);
                });
            } else {
                def.resolve();
            }
        } else if (!foundMatch && refFile.context == 'zip') {
            def.reject(g.http(u.r(req)).Error('Failed to find the file "%s" in the zip archive.' +
            ' The reference to the file is located in file %s.' +
            ' Ensure that the file is packaged in the zip file.', location, refFile.filename));
        } else if (alreadyKnown) {
            def.resolve();
        } else if (!foundMatch) {
            def.reject(g.http(u.r(req)).Error('The file "%s" is not found. Ensure that the file is packaged in a zip file.', location));
        }
    } else {
        def.resolve();
    }
    return def.promise;
}

function expandOneSchemaImport(imp, baseFilename, files, mergeList, alreadySeen, parentNS, isInclude, refFile, auth, isWSDLTypesSchema, options) {
    let req = options.req;
    var def = q.defer();
    var location = imp && imp['undefined'] ? imp['undefined'].schemaLocation : null;
    let importNamespace = imp && imp['undefined'] ? imp['undefined'].namespace : null;
    if (location) {
        var relativeFilename = '';
        if (!(location.substr(0, 7) == 'http://' || location.substr(0, 8) == 'https://')) {
            var fn = location.replace(/\\/g, '/');
            location = parseUtils.normaliseLocation(fn, baseFilename);
            var index = location.lastIndexOf('/');
            if (index != -1) {
                relativeFilename = location.substring(0, index);
            }
        }
        // see if we have a match in the files first
        var foundMatch = false;
        var alreadyKnown = false;
        if (!alreadySeen[location]) {
            var len = files.length;
            for (var k = 0; k < len; k++) {
                var entry = files[k];
                if (entry.fullName == location || entry.filename == location) {
                    // If errors were found in the file, throw the error now
                    if (entry.error) {
                        throw entry.error;
                    }
                    foundMatch = true;
                    alreadySeen[location] = true;
                    if (entry.type == 'xsd') {
                        mergeList.push(entry.json);
                        var schemaNSOK = true;
                        if (entry.json.schema['undefined']) {
                            var tns = entry.json.schema['undefined'].targetNamespace;

                            // Add breadcrumb to the schema to indicate that it is the target of an import or include
                            if (isInclude) {
                                entry.json.schema['undefined'].fromInclude = true;
                            } else {
                                entry.json.schema['undefined'].fromImport = true;
                            }
                            entry.json.schema['undefined'].fileName = u.fileNameFromPath(location);

                            // If the targetnamespace of the schema and the namespace on the import do not match
                            // reject the wsdl.
                            if (!isInclude && tns && importNamespace && tns != importNamespace) {
                                schemaNSOK = false;
                                def.reject(g.http(u.r(req)).Error('The namespace \'%s\' referenced on the \'import\' element must match the namespace of the imported schema \'%s\'. This error was found in file %s.', importNamespace, tns, location));
                            }
                            if (!isInclude) {
                                // xsd:import check
                                // The imported schema target namespace must not match the targetNamespace of the parent.
                                if (tns === parentNS) {
                                    if (!isWSDLTypesSchema) {  // No checking if schema is in wsdl types
                                        schemaNSOK = false;
                                        def.reject(g.http(u.r(req)).Error('The namespace \'%s\' referenced on the \'import\' element must not match parent schema namespace \'%s\'. This error was found in file %s.', tns, parentNS, location));
                                    }
                                }
                            } else {
                                // xsd: include check
                                if (tns && tns !== parentNS) {
                                    // Normal schema (has namespace)
                                    if (!isWSDLTypesSchema) {  // No checking if schema is in wsdl types
                                        schemaNSOK = false;
                                        def.reject(g.http(u.r(req)).Error('The namespace \'%s\' referenced on the \'include\' element must match parent schema namespace \'%s\'. This error was found in file %s.', tns, parentNS, location));
                                    }
                                } else if (!tns) {
                                    // Chameleon include
                                }
                            }
                        }
                        if (schemaNSOK) {
                            // recurse into the referenced schema to check for more imports
                            var impDef = expandSchemaImports(entry.json.schema, relativeFilename, files, mergeList, alreadySeen, refFile, auth, false, options);
                            impDef.then(function(data) {
                                def.resolve(data);
                            }, function(err) {
                                def.reject(err);
                            });
                        }
                    } else {
                        // trying to force a WSDL into a schema import
                        mergeList.push(entry.json.definitions.types);
                        // recurse into the referenced schema to check for more imports
                        var iDef = expandSchemaImports(entry.json.definitions.types.schema, relativeFilename, files, mergeList, alreadySeen, refFile, auth, false, options);
                        iDef.then(function(data) {
                            def.resolve(data);
                        }, function(err) {
                            def.reject(err);
                        });
                    }
                    break;
                }
            } // end for
        } else {
            foundMatch = true;
            alreadyKnown = true;
        }

        // Try the local filesystem as a fallback
        if (!foundMatch && refFile.context != 'zip' && (!options || !options.selfContained)) {
            var filename = location;
            if (!alreadySeen[filename]) {
                alreadySeen[filename] = true;
                alreadySeen[location] = true;
                var file = {
                    filename: location,
                    fullName: filename,
                    type: 'xsd',
                    content: '',
                    context: 'cmd'
                };
                files.push(file);
                var fileDef = parseUtils.getFileContent(location, filename, auth,
                  g.http(u.r(req)).f('a \'schemaLocation\' attribute with a value of "%s"', imp['undefined'].schemaLocation), req);
                fileDef.then(function(content) {
                    if (content == location) {
                        file.filename = 'MEMORY';
                        file.fullName = 'MEMORY';
                    }
                    file.content = content;
                    try {
                        parseUtils.contentToXMLorWSDL(file, options);
                        file.namespaces = {};
                        file.serviceChildren = {};
                        updateSchemaNamespaces(file);
                        // add to merge list
                        mergeList.push(file.json);
                        var schemaNSOK = true;
                        if (file.json.schema['undefined']) {
                            var tns = file.json.schema['undefined'].targetNamespace;

                            // Add breadcrumb to the schema to indicate that it is the target of an import or include
                            if (isInclude) {
                                file.json.schema['undefined'].fromInclude = true;
                            } else {
                                file.json.schema['undefined'].fromImport = true;
                            }
                            file.json.schema['undefined'].fileName = u.fileNameFromPath(location);


                            // If the target namespace of the schema and the namespace on the import do not match
                            // reject the wsdl.
                            if (!isInclude && tns && importNamespace && tns != importNamespace) {
                                schemaNSOK = false;
                                def.reject(g.http(u.r(req)).Error('The namespace \'%s\' referenced on the \'import\' element must match the target schema namespace \'%s\'. This error was found in file %s.', importNamespace, tns, location));
                            }

                            if (!isInclude) {
                                // xsd:import check
                                // The imported schema target namespace must not match the targetNamespace of the parent.
                                if (tns === parentNS) {
                                    if (!isWSDLTypesSchema) {  // No checking if schema in wsdl type
                                        schemaNSOK = false;
                                        def.reject(g.http(u.r(req)).Error('The namespace \'%s\' referenced on the \'import\' element must not match parent schema namespace \'%s\'. This error was found in file %s.', tns, parentNS, location));
                                    }
                                }
                            } else {
                                // xsd: include check
                                if (tns && tns !== parentNS) {
                                    // Normal schema (has namespace)
                                    if (!isWSDLTypesSchema) {  // No checking if schema in wsdl type
                                        schemaNSOK = false;
                                        def.reject(g.http(u.r(req)).Error('The namespace \'%s\' referenced on the \'include\' element must match parent schema namespace \'%s\'. This error was found in file %s.', tns, parentNS, location));
                                    }
                                } else if (!tns) {
                                    // Chameleon include
                                }
                            }
                        }
                        if (schemaNSOK) {
                            // and recurse into each schema to check them as well
                            var subDef = expandSchemaImports(file.json.schema, relativeFilename, files, mergeList, alreadySeen, refFile, auth, false, options);
                            subDef.then(function(data) {
                                def.resolve(data);
                            }, function(e) {
                                def.reject(e);
                            });

                        }
                    } catch (e) {
                        def.reject(parseUtils.cleanupError(e, req));
                    }
                }, function(err) {
                    def.reject(err);
                });
            } else {
                def.resolve();
            }
        } else if (!foundMatch && refFile.context == 'zip') {
            def.reject(g.http(u.r(req)).Error('Failed to find the file %s in the zip archive.' +
            ' The file is referenced in file %s.' +
            ' Ensure that the file is packaged in the zip file.', location, refFile.filename));
        } else if (alreadyKnown) {
            def.resolve();
        } else if (!foundMatch) {
            def.reject(g.http(u.r(req)).Error('The file %s is not found. Ensure that the file is packaged in a zip file.', location));
        }
    } else {
        def.resolve();
    }
    return def.promise;
}

function expandSchemaImports(inSchema, baseFilename, files, mergeList, alreadySeen, refFile, auth, isWSDLTypesSchema, options) {
    var def = q.defer();
    var schemaList = u.makeSureItsAnArray(inSchema);
    var schemaLen = schemaList.length;
    var impDefs = [];
    for (var i = 0; i < schemaLen; i++) {
        var schema = schemaList[i];
        var tns = '';
        if (schema['undefined']) {
            var targns = schema['undefined'].targetNamespace;
            if (targns) {
                tns = targns;
            }
        }
        var imports = null;
        var includes = null;
        if (schema.import) {
            imports = u.makeSureItsAnArray(schema.import);
        }
        if (schema.include) {
            includes = u.makeSureItsAnArray(schema.include);
        }
        if (imports) {
            // Note: must import from a different namespace
            var iLen = imports.length;
            for (var j = 0; j < iLen; j++) {
                var imp = imports[j];
                var impDef = expandOneSchemaImport(imp, baseFilename, files, mergeList, alreadySeen, tns, false, refFile, auth, isWSDLTypesSchema, options);
                impDefs.push(impDef);
            } // end for
        }
        if (includes) {
            // Note: must import from the same namespace
            var inLen = includes.length;
            for (var k = 0; k < inLen; k++) {
                var impIn = includes[k];
                var impInDef = expandOneSchemaImport(impIn, baseFilename, files, mergeList, alreadySeen, tns, true, refFile, auth, isWSDLTypesSchema, options);
                impDefs.push(impInDef);
            } // end for
        }
    } // end for
    q.all(impDefs).then(function(data) {
        def.resolve();
    }, function(err) {
        def.reject(err);
    });
    return def.promise;

}

function checkForSchemaImports(wsdlJson, wsdlFilename, files, refFile, auth, options) {
    var def = q.defer();
    var fn = wsdlFilename.replace(/\\/g, '/');
    var baseFilename = '';
    var index = fn.lastIndexOf('/');
    if (index != -1) {
        baseFilename = fn.substring(0, index);
    }
    var mergeList = [];
    var alreadySeen = {};
    // fetch any referenced schema files
    if (wsdlJson.definitions.types && wsdlJson.definitions.types.schema) {
        var impDef = expandSchemaImports(wsdlJson.definitions.types.schema, baseFilename, files, mergeList, alreadySeen, refFile, auth, true, options);
        impDef.then(function(data) {
            // now merge the fetched schemas into the master wsdl
            var mergeLen = mergeList.length;
            if (mergeLen > 0) {
                // make sure the original schema list in the wsdl is an array
                if (!Array.isArray(wsdlJson.definitions.types.schema)) {
                    var firstEntry = wsdlJson.definitions.types.schema;
                    wsdlJson.definitions.types.schema = [];
                    wsdlJson.definitions.types.schema.push(firstEntry);
                }
                for (var i = 0; i < mergeLen; i++) {
                    var toMerge = mergeList[i];
                    wsdlJson.definitions.types.schema.push(toMerge.schema);
                } // end for
            }
            def.resolve();
        }, function(err) {
            def.reject(err);
        });
    } else {
    // no schemas to check
        def.resolve();
    }
    return def.promise;
}

function captureServiceChildren(wsdlDoc) {
    var ret = {};
    if (wsdlDoc && wsdlDoc.definitions && wsdlDoc.definitions.services) {
        var services = wsdlDoc.definitions.services;
        var svcs = {};
        for (var serviceName in services) {
            if (services[serviceName].children) {
                svcs[serviceName] = [].concat(services[serviceName].children);
            }
        } // end for
        ret = svcs;
    }
    return ret;
}

// note: recursive function
function processElementNSChildren(children, jsonSchema) {
    var len = children.length;
    for (var i = 0; i < len; i++) {
        var child = children[i];
        if (child.xmlns) {
            extendXMLNS(jsonSchema.xmlns, child.xmlns);
        }
        if (child.children) {
            processElementNSChildren(child.children, jsonSchema);
        }
    } // end for
}

// navigate the DOM to find incidental XMLNS statements
function getElementNS(jsonSchema, elements) {
    if (elements && jsonSchema) {
        for (var elemName in elements) {
            var element = elements[elemName];
            if (element.xmlns) {
                extendXMLNS(jsonSchema.xmlns, element.xmlns);
            }
            if (element.children) {
                processElementNSChildren(element.children, jsonSchema);
            }
        } // end for
    }
}

/**
* Copy the source xmlns to the target xmlns
* Each key is a prefix with a value that is a namespace.
*/
function extendXMLNS(target, source) {
    if (source) {
        for (let name in source) {
            // Detect collision
            if (target[name] && target[name] !== source[name]) {
                if (name === '__tns__'  && source[name] === 'http://schemas.microsoft.com/2003/10/Serialization/') {
                    // ignore appInfo xmlns
                } else {
                    // Redefinitions MAY mess up resolution.
                    // This warrants a log message.
                    console.log('Detected re-definition of prefix ' + name + ' from ' + target[name] + ' to ' + source[name] +
                     '. This may cause problems generating the xml schema object definitions.');
                }
            } else {
                target[name] = source[name];
            }
        }
    } // end for
    return target;
}

// The doc schemas contain the full representation of the xsd objects including the xmlns of each construct.
// The json schemas do not contains the deep xmlns objects.
// Each doc schema is walked to collect a complete local xmns object and attach it to the corresponding
// json schema.
//
// The process is then repeated with the doc messaages and the json messages.
//
function updateSchemaNamespaces(file) {
    if (file.doc.definitions && file.doc.definitions.schemas) {
        var docSchemas = file.doc.definitions.schemas;
        var jsonSchemas = null;
        if (file.json.definitions && file.json.definitions.types && file.json.definitions.types.schema) {
            jsonSchemas = u.makeSureItsAnArray(file.json.definitions.types.schema);
        } else if (file.json.schema) {
            jsonSchemas = u.makeSureItsAnArray(file.json.schema);
        }
        if (jsonSchemas) {
            // match the json schemas with the raw parse by target namespace
            var len = jsonSchemas.length;
            for (var i = 0; i < len; i++) {
                var jsonSchema = jsonSchemas[i];
                if (jsonSchema['undefined']) {
                    var tns = jsonSchema['undefined'].targetNamespace;
                    if (tns && docSchemas[tns]) {
                        var docSchema = docSchemas[tns];
                        if (docSchema.xmlns) {
                            jsonSchema.xmlns = docSchema.xmlns;
                        } else {
                            jsonSchema.xmlns = {};
                        }
                        // must also search DOM tree for incidental XMLNS entries on elements and types
                        getElementNS(jsonSchema, docSchema.elements);
                        getElementNS(jsonSchema, docSchema.complexTypes);
                        getElementNS(jsonSchema, docSchema.types);  // includes simpletypes, attributes, groups, etc.

                    }
                }
            } // end for
        }
    }
    // Repeat with wsdl messages
    updateWSDLMessageNamespaces(file);
}

function updateWSDLMessageNamespaces(file) {
    if (file.doc.definitions && file.doc.definitions) {
        let docD = file.doc.definitions;
        let jsonD = file.json.definitions;
        if (jsonD) {
            if (jsonD.message) {
                jsonD.message = u.makeSureItsAnArray(jsonD.message);
                let len = jsonD.message.length;
                for (let i = 0; i < len; i++) {
                    let j = jsonD.message[i];
                    if (j['undefined']) {
                        let name = j['undefined'].name;
                        if (docD.messages && docD.messages[name]) {
                            let d = docD.messages[name];
                            j.xmlns = j.xmlns || {};
                            if (d.xmlns) {
                                extendXMLNS(j.xmlns, d.xmlns);
                            }
                            getElementNS(j, d.children);
                        }
                    }
                }
            }
        }
    }
}


function isWSAddressing(wsdlJson) {
    let detectedWSAddressing;
    let defBindings = u.makeSureItsAnArray(wsdlJson.definitions.binding);
    let binLen = defBindings.length;
    for (let j = 0; j < binLen; j++) {
        var binding = defBindings[j];
        var bindingType = binding['undefined'].type;
        bindingType = u.stripNamespace(bindingType);
        var usingAddressing = !!binding.UsingAddressing;
        if (usingAddressing) {
            return true;
        }
    }
    return false;
}

exports.captureServiceChildren = captureServiceChildren;
exports.checkForWSDLImports = checkForWSDLImports;
exports.isWSAddressing = isWSAddressing;
exports.updateSchemaNamespaces = updateSchemaNamespaces;
