/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const copts = require('../lib/createOptions.js');
const parse = require('../lib/parse.js');
const postParse = require('../lib/postParse.js');
const dictionary = require('../lib/dictionary.js');
const genSOAP = require('../lib/generateSOAP.js');
const genDefs = require('../lib/generateDefs.js');
const postGen = require('../lib/postGenerate.js');
const example = require('../lib/generateExamples.js');
const rest = require('../lib/createRESTfromSOAP.js');

var _ = require('lodash');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

/**
* Convenience Method for v6
* @param {FileEntry} wsdlEntry - from findWSDLForServiceName
* @param {String} serviceName - Process the indicated service
* @param {String} wsdlId - often the filename
* @param {Object} createOptions
* @return {Object} swagger
*/
function generateSwaggerForWsdlProxy(wsdlEntry, serviceName, wsdlId, createOptions) {
    createOptions = copts.validate(createOptions);
    let openapi = getSwaggerForService(wsdlEntry, serviceName, wsdlId, createOptions);
    if (createOptions.defaults) {
        let defaults = u.deepClone(createOptions.defaults);
        // mergeWith is not available in lodash^3.10
        // so do a merge and assign
        // _.mergeWith(openapi, defaults, customizer);
        _.merge(openapi, defaults);
        if (defaults.securityDefinitions) {
            openapi.securityDefinitions = defaults.securityDefinitions;
        }
        if (defaults.security) {
            openapi.security = defaults.security;
        }
    }
    return openapi;
}

/**
* Convenience Method for v6
* @param {FileEntry} wsdlEntry - from findWSDLForServiceName
* @param {String} serviceName - Process the indicated service
* @param {String} wsdlId - often the filename
* @param {Object} createOptions
* @return {Object} swagger
*/
function generateSwaggerForSoapToRest(wsdlEntry, serviceName, wsdlId, createOptions) {
    createOptions = copts.validate(createOptions);
    let req = createOptions.req;
    let openapi_soap = getSwaggerForService(wsdlEntry, serviceName, wsdlId, createOptions);

    // Create a SOAP->REST api.
    //  - embeds the openapi_soap as a target
    //  - creates rest paths/operations that match the soap operations
    //  - creates an assembly operation-switch which maps the REST api to the soap proxy
    let openapi_rest = rest.getSwaggerForSOAPREST(openapi_soap, createOptions);
    if (createOptions.defaults) {
        let defaults = u.deepClone(createOptions.defaults);
        // mergeWith is not available in lodash^3.10
        // so do a merge and assign
        // _.mergeWith(openapi_rest, defaults, customizer);
        _.merge(openapi_rest, defaults);
        if (defaults.securityDefinitions) {
            openapi_rest.securityDefinitions = defaults.securityDefinitions;
        }
        if (defaults.security) {
            openapi_rest.security = defaults.security;
        }
    }
    return openapi_rest;
}

/**
 * Get the Swagger for the service
 * @method getSwaggerForService
 * @param {FileEntry} wsdlEntry - from findWSDLForServiceName
 * @param {String} serviceName - Process the indicated service
 * @param {String} wsdlId
 * @param {Object} createOptions
 * @return {Object} swagger
 **/
function getSwaggerForService(wsdlEntry, serviceName, wsdlId, createOptions) {
    createOptions = copts.create(createOptions);
    if (typeof wsdlId == 'undefined') {
        wsdlId = 'undefined';
    }
    let req = createOptions.req;

    if (wsdlEntry == null) {
        // This will occur if findWSDLForServiceName did not find any wsdlEntry objects for serviceName
        // Throw an error that will be useful for the customer.
        throw g.http(u.r(req)).Error('A wsdl \'service\' named "%s" was not found in the wsdl. Please specify a \'service\' that is present in the wsdl. ' +
           'You may need to change the \'title\' of your api to match the name of a \'service\' in the wsdl file.', serviceName);
    }

    // The wsldEntry contains the preparsed and merged information from node soap (see parse.js for details)

    let wsdlJson = wsdlEntry.json;
    let namespaces = wsdlEntry.namespaces;

    let schemaList = [];
    if (wsdlJson.definitions.types && wsdlJson.definitions.types.schema) {
        schemaList = u.makeSureItsAnArray(wsdlJson.definitions.types.schema);
    }
    let tns = '';
    if (wsdlJson.definitions['undefined'] && wsdlJson.definitions['undefined'].targetNamespace) {
        tns = wsdlJson.definitions['undefined'].targetNamespace;
    }

    // Build a dictionary.
    // Each schema type, element or attribute has an nsName, which is its dictionary index
    // The node soap object, qualification, and namespace information is stored and is accessible
    // from the dictionary.  For example dict.dictEntry[nsName].schema is the node soap object
    let dict = dictionary.buildDictionary(schemaList, postParse.isWSAddressing(wsdlJson), namespaces, tns, req);

    // Now start the generation of the Open API (Swagger) document by generating the SOAP/WSDL
    // information.  While processing a refMap is produced which records the references to the
    // objects in the dictionary
    let refMap = {};
    let swagger = genSOAP.generateSOAP(serviceName, wsdlId, wsdlJson, namespaces, wsdlEntry.serviceChildren, dict, refMap, createOptions);
    swagger = u.checkAndSetGateway(swagger, req, createOptions.gateway);

    // If in getDefinitionsForXSD mode, add references to the xsd elements.
    if (createOptions.fromGetDefinitionsForXSD) {
        addXSDElementReferences(refMap, dict, createOptions);
        if (swagger.definitions['Security']) {
            delete swagger.definitions['Security'];
        }
    }

    // Now generate the definitions for each of the references in the refMap
    let totalRefMap = u.deepClone(refMap);
    genDefs.generateSwaggerDefinitions(swagger.definitions, refMap, dict, namespaces, {}, totalRefMap);

    // The path information generated during generateSOAP is incomplete and requires
    // patching after the swagger definitions are generated.
    genSOAP.patchPaths(swagger, dict);

    // Now consider polymorphism.
    // For example,
    //        a) Ext type extends Base type.
    //        b) There is a reference to Base type
    // The code above will generate the swagger definition for Base, but now must find
    // and generate the swagger definition of Ext because it extends Base.
    let limit = 0;
    do {
        // Get additional definitions for subtypes of referenced base types.
        refMap = genDefs.getExtraReferencesForSubTypes(dict.subTypes, swagger, namespaces, totalRefMap);

        // Generate definitions for the new types
        genDefs.generateSwaggerDefinitions(swagger.definitions, refMap, dict, namespaces, {}, totalRefMap);

        // Add refMap to totalRefMap
        let list = u.disjointKeysToArray(refMap, totalRefMap);
        if (list) {
            for (let i = 0; i < list.length; i++) {
                let item = list[i];
                for (let j = 0; j < item.value.referencingContexts.length; j++) {
                    genDefs.addReference(totalRefMap, item.name, item.value.referencingContexts[j]);
                }
            }
        }
        // Rinse and repeat.  Adding a type may have resulted in new references.
        limit++;
    } while (Object.keys(refMap).length > 0 && limit < 10);

    // Add friendly definitions for header insertion
    if (createOptions.fromGetDefinitionsForXSD) {
        addHeaderDefinitionsForXSD(swagger, dict);
    }

    // Finally add the special reserved type if we detect that messages were added to it
    if (dict.dictEntry[dictionary.RESERVED_DEF] &&
        dict.dictEntry[dictionary.RESERVED_DEF].schema &&
        dict.dictEntry[dictionary.RESERVED_DEF].schema.annotation) {
        let refMap = {};
        genDefs.addReference(refMap, dictionary.RESERVED_DEF, {});
        genDefs.generateSwaggerDefinitions(swagger.definitions, refMap, dict, namespaces, {}, totalRefMap);
    }

    // Do a check for invalid cycles
    for (let nsName in swagger.definitions) {
        u.getAncestorRefs(swagger.definitions, nsName, req);
    }

    // Each basetype needs a discriminator
    for (let baseType in dict.subTypes) {
        if (swagger.definitions[baseType]) {
            swagger.definitions[baseType]['x-ibm-discriminator'] = true;
        }
    }

    // Add xml objects to all xso objects in case some were not produced.
    postGen.c14nXMLObjects(swagger);

    // The UI doesn't support $ref for attributes because it doesn't
    // follow the $ref to see if it is an attribute.  So inline the
    // attributes.
    if (createOptions.inlineAttributes) {
        postGen.inlineSwaggerAttributes(swagger);
    }

    // Remove Occurence Arrays of sequence, group, all and choice
    postGen.removeUnnamedOccurrence(swagger, req);

    // Remove anyOfs
    postGen.removeAnyOfs(swagger, req);

    // Remove removeOneOfs for choice mapping
    postGen.removeOneOfs(swagger);

    // Squash allOf
    postGen.squashAllOfs(swagger);

    // Reprocess complexContent + restriction
    postGen.processComplexContentRestriction(swagger);

    // If a non-default reference is made to a portion of a polymorhic hierarchy,
    // then the entire polymorphic hierarchy must be reproduced with the reference.
    postGen.duplicatePolyHierarchy(swagger, dict);

    // A type is normally only referenced with either nillable=true or nillable=false.
    // Though uncommon, we could have a situation where a type is referenced sometimes
    // with nillable=true and sometimes with nillable=false.  In though circumstances
    // we must duplicate the type definitions (so that we have one for nill and one for not nill)
    // and patch the references.
    postGen.fixupForNilAndNonNil(swagger, dict.req);

    // Make sure default values match the type of the object
    postGen.adjustDefaults(swagger);

    // The algorithms to add definitions may result in unreferenced definitions.
    // These can be removed.
    postGen.removeUnreferencedDefinitions(swagger, createOptions.fromGetDefinitionsForXSD);

    // Remove redundant prefixes
    swagger = postGen.removeRedundantPrefixes(swagger);

    // now generate the example XML for all required types
    if (!createOptions.suppressExamples) {
        example.generateExamples(swagger, dict);
    }
    // Add xml objects to all xso objects in case some were not produced.
    postGen.c14nXMLObjects(swagger, true);
    postGen.c14nxso(swagger, req);
    moveMessages(swagger, createOptions);
    copts.persistOptions(createOptions, swagger);
    return u.checkAndFix(swagger);
}

/**
* Add raw element references
*/
function addXSDElementReferences(refMap, dict, createOptions) {
    // Walk all of the root elements in the dictEntry.
    for (let nsName in dict.elementNS) {
        // Get the original name of the element (not the mangled definition name)
        let originalName = dict.originalNames[nsName].name;

        // If the name is in the list (or there is no list), then process it
        if ((!createOptions.rootElementList || createOptions.rootElementList.length == 0) ||
            createOptions.rootElementList.indexOf(originalName) > -1 ||
            createOptions.rootElementList.indexOf(nsName) > -1) {

            // Add the xmlName to the reference
            genDefs.addReference(refMap, nsName, {
                xmlName: originalName
            });

            // Find and add a reference to the type
            if (dict.dictEntry[nsName] &&
                dict.dictEntry[nsName].schema &&
                dict.dictEntry[nsName].schema['undefined'] &&
                dict.dictEntry[nsName].schema['undefined'].linkup) {
                genDefs.addReference(refMap,
                  dict.dictEntry[nsName].schema['undefined'].linkup,
                  {});
            }
        }
    }
}

/**
* add friendly header definitions that wrap the element
*/
function addHeaderDefinitionsForXSD(swagger, dict) {
    // Walk all of the root elements.
    for (let nsName in dict.elementNS) {
        if (dict.originalNames[nsName]) {
            let elementNSName = nsName + '_of_' + dict.originalNames[nsName].name;
            if (swagger.definitions[elementNSName]) {
                // Get the original name of the element (not the mangled definition name)
                let origElementName = swagger.definitions[elementNSName].xml.name;
                let headerNsName = nsName + '_Header';
                swagger.definitions[headerNsName] = {};
                swagger.definitions[headerNsName].xml = {};

                swagger.definitions[headerNsName].xml.namespace = swagger.definitions[elementNSName].xml.namespace;
                swagger.definitions[headerNsName].xml.prefix = swagger.definitions[elementNSName].xml.prefix;
                swagger.definitions[headerNsName].type = 'object';
                swagger.definitions[headerNsName].properties = {};
                swagger.definitions[headerNsName].properties[origElementName] = {};
                swagger.definitions[headerNsName].properties[origElementName]['$ref'] = '#/definitions/' + elementNSName;
            }
        }
    }
}

/**
* moveMessages
* All messages were applied as description text inside the definitions.
* These messages are moved to the options object.
* @param swagger
* @param options (createOption struct)
*/
function moveMessages(swagger, options) {
    u.traverse(swagger, null, function(obj, path) {
        if (obj && typeof obj === 'object') {
            let description = obj.description;
            if (typeof description == 'string') {
                // Get the list of descriptions
                let list = null;
                if (description.startsWith('[')) {
                    try {
                        list = JSON.parse(description);
                    } catch (e) {
                        //
                    }
                } else if (description.startsWith('((APIC_MESSAGE: ')) {
                    list = [ description ];
                }
                if (list) {
                    let newDescription = [];
                    for (let i = 0; i < list.length; i++) {
                        let message = list[i];
                        if ((typeof message == 'string') && message.startsWith('((APIC_MESSAGE: ')) {
                            let ref = '#/' + _.join(path, '/');
                            copts.addMessage(options, ref, message);
                        } else {
                            newDescription.push(message);
                        }
                    }
                    if (newDescription.length == 0) {
                        delete obj.description;
                    } else if (newDescription.length == 1) {
                        obj.description = newDescription[0];
                    } else {
                        obj.description = JSON.stringify(newDescription);
                    }
                }
            }
        }
        return obj;
    });
    if (swagger.definitions[u.RESERVED_DEF]) {
        // The RESERVED_DEF definition is only a placeholder for global messages.
        delete swagger.definitions[u.RESERVED_DEF];
    }
}

exports.generateSwaggerForSoapToRest = generateSwaggerForSoapToRest;
exports.generateSwaggerForWsdlProxy = generateSwaggerForWsdlProxy;
exports.getSwaggerForService = getSwaggerForService;
