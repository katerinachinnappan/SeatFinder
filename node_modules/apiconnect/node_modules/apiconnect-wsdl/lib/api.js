/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const copts = require('../lib/createOptions.js');
const parse = require('../lib/parse.js');
const generate = require('../lib/generateSwagger.js');
const openapiv3 = require('../lib/openApiV3.js');
const validate = require('../lib/validate.js');
const extraXSD = require('../lib/extraXSD.js');

var q = require('q');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

/**
 * Create an openapi from wsdl
 * @param {Buffer or String file location or String url} wsdl or zip content
 * @param {String} serviceName name of the wsdl service
 * @param {String} wsdlId id to use in the generated swagger.  Often this is the filename
 * @param options
 *     type: 'wsdl' (default) or 'wsdl-to-rest'
 *     openapiVersion: '2.0' (default) or '3.0'
 *     wssecurity: true (default) or false
 *     gateway: datapower-gateway (default) or datapower-api-gateway or micro-gateway
 *     req: request or null (used for i18n negotiation)
 *     allowExtraFiles: false (default) or true
 *     defaults: object to merge into openapi after generation.  Same shape as openapi
 *     auth: auth object if wsdl is protected url
 *     badgerfishDefs: true (default) or false.  Json definitions in badgerfish form
 *     port: (optional) port name.  If not specified, first soap port is used.
 *     mapOptions: setting to use for autogenerated assembly map. The default is no map.options
 *         mapOptions.includeEmptyXMLElements
 *         mapOptions.namespaceInheritance
 *         mapOptions.inlineNamespaces
 *     mapSOAPFaults: true (if wsdl-to-rest) or false.  Catch block for SOAPFaults
 * @return {
 *              openapi: <openapi>
 *              statistics: { various stats}
 *              messages: [ {message: <info message>}* ]
 *         }
 */
function createOpenApi(wsdl, serviceName, wsdlId, options) {
    let def = q.defer();
    try {
        let defaults = {
            mapSOAPFaults: options.type === 'wsdl-to-rest',
        };
        let createOptions = copts.create(options, defaults);
        let req = createOptions.req;

        // Parse the wsdl
        parse.getJsonForWSDL(wsdl, createOptions.auth, createOptions).then(function(allWSDLs) {
            try {
                // If a configuration file was found, apply it to createOptions
                if (createOptions.config) {
                    createOptions = copts.create(createOptions, createOptions.config);
                }

                // Locate the wsld entry for the indicated service
                let wsdlEntry = parse.findWSDLForServiceName(allWSDLs, serviceName, null);

                // Create a 2.0 wsdl proxy or wsdl to rest open api
                let openapi = (createOptions.type === 'wsdl-to-rest') ?
                    generate.generateSwaggerForSoapToRest(wsdlEntry, serviceName, wsdlId, createOptions) :
                    generate.generateSwaggerForWsdlProxy(wsdlEntry, serviceName, wsdlId, createOptions);

                let convertDef = q.defer();
                // Convert to 3.0 if necessary
                if (createOptions.openapiVersion === '2.0') {
                    convertDef.resolve(openapi);
                } else {
                    openapiv3.getOpenApiV3(openapi, createOptions).then(function(openapi) {
                        convertDef.resolve(openapi);
                    }, function(err) {
                        convertDef.reject(err);
                    });
                }
                // Add statistics and warning messages
                convertDef.promise.then(function(openapi) {
                    try {
                        let result = validate.inspectOpenApi({ openapi: openapi });
                        def.resolve(result);
                    } catch (err) {
                        def.reject(u.convertToValidationErr(err));
                    }
                }, function(err) {
                    def.reject(u.convertToValidationErr(err));
                });
            } catch (e) {
                def.reject(u.convertToValidationErr(e));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

/**
* addTargetOpenApi
* @param openApi - existing openApi
* @param wsdl - Buffer containing the wsdl/zip or location of the wsdl/zip
* @param wsdlServiceName - Service
* @param createOptions
*   wssecurity
*   port: (optional) port name.  If not specified, first soap port is used.
*   req: request or null (used for i18n negotiation)
* @return promise openApi
*/
function addTargetOpenApi(openapi, wsdl, wsdlServiceName, options) {
    let _defaults = {
        openapiVersion: (openapi.openapi) ? '3.0' : '2.0',
    };
    let createOptions = copts.create(options, _defaults);
    let def = q.defer();
    try {
        createOpenApi(wsdl, wsdlServiceName, wsdlServiceName, createOptions).then(function(result) {
            try {
                // Update the references to point at the target definitions/schemas
                let tgtOpenApi = updateRefs(result.openapi, wsdlServiceName);
                result.messages = updateRefs(result.messages, wsdlServiceName);

                openapi['x-ibm-configuration'].targets = openapi['x-ibm-configuration'].targets || {};
                openapi['x-ibm-configuration'].targets[wsdlServiceName] = tgtOpenApi;
                def.resolve(openapi);
            } catch (err) {
                def.reject(u.convertToValidationErr(err));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

/**
* addXSDToTargetOpenApi
* @param openApi - existing openApi
* @param xsd - Buffer containing the xsd or location of the xsd
* @param wsdlServiceName - Service
* @param createOptions
*   req: request or null (used for i18n negotiation)
* @return promise openApi
*/
function addXSDToTargetOpenApi(openapi, xsd, wsdlServiceName, options) {
    let createOptions = copts.create(options);
    let def = q.defer();
    try {
        extraXSD.getDefinitionsForXSD(xsd, null, null, createOptions).then(function(definitions) {
            try {
                definitions = updateRefs(definitions, wsdlServiceName);
                // Find the definition section of the target schema
                let tgt = openapi['x-ibm-configuration'].targets[wsdlServiceName];
                if (openapi.openapi) {
                    tgt = tgt.components.schemas;
                } else {
                    tgt = tgt.definitions;
                }
                // Add the new definitions
                for (let definition in definitions) {
                    tgt[definition] = u.deepClone(definitions[definition]);
                }
                def.resolve(openapi);
            } catch (err) {
                def.reject(u.convertToValidationErr(err));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

function updateRefs(json, serviceName) {
    let jsonString = JSON.stringify(json);
    let src = '#/';
    let tgt = '#/x-ibm-configuration/targets/' + serviceName + '/';
    jsonString = jsonString.replace(new RegExp(src, 'g'), tgt);
    return JSON.parse(jsonString);
}

/**
* Validates wsdl and rejects with error containing messages.
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth, req and other options.
* @returns promise of serviceData
*/
function validateWSDL(locationOrContent, options) {
    options = copts.create(options);
    var def = q.defer();
    let req = options.req;
    var valErr = g.http(u.r(req)).Error('Validation Error');
    const opts = u.deepClone(options);
    opts.validate = true;
    try {
        // Parse the wsdl
        parse.getJsonForWSDL(locationOrContent, options.auth, opts).then(function(allWsdls) {
            try {
                // Extra validation of the wsdl definition
                let errs = [];
                for (let i = 0; i < allWsdls.length; i++) {
                    errs = errs.concat(parse.sanityCheckDefinition(allWsdls[i].json.definitions, req));
                }
                for (let i = 0; i < errs.length; i++) {
                    u.addValidationErr(valErr, errs[i], req);
                }
                // Get the list of services, ports, and bindings
                let serviceData = parse.getWSDLServices(allWsdls, options);

                // Validate the serviceData
                if (!serviceData ||
                    !serviceData.bindings || serviceData.bindings.length == 0 ||
                    !serviceData.portTypes || serviceData.bindings.portTypes == 0) {
                    u.addValidationErr(valErr, g.http(u.r(req)).f('A wsdl \'definition\' was not found.'), req);
                } else if (!serviceData || !serviceData.services || serviceData.services.length == 0) {
                    u.addValidationErr(valErr, g.http(u.r(req)).f('No wsdl \'services\' were found.'), req);
                } else {
                    for (let service of serviceData.services) {
                        if (!service.portName) {
                            u.addValidationErr(valErr,
                               g.http(u.r(req)).f('The wsdl \'service\' %s does not contain a \'port\'.', service.service),
                               req);
                        }
                    }
                }
                if (valErr.messages && valErr.messages.length > 0) {
                    def.reject(valErr);
                } else {
                    def.resolve(serviceData);
                }
            } catch (e) {
                u.addValidationErr(valErr, e, req);
                def.reject(valErr);
            }
        }, function(e) {
            u.addValidationErr(valErr, e, req);
            def.reject(valErr);
        });
    } catch (e) {
        u.addValidationErr(valErr, e, req);
        def.reject(valErr);
    }
    return def.promise;
}

/**
* Validates xsd and rejects with error containing messages.
* @param locationOrContent location of XSD or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth, req, and other options.
* @returns promise
*/
function validateXSD(locationOrContent, options) {
    options = copts.create(options, { strictValidation: true });

    var def = q.defer();
    let req = options.req;
    var valErr = g.http(u.r(req)).Error('Validation Error');
    let opts = u.deepClone(options);
    opts.validate = true;
    try {
        // Parse the wsdl
        parse.getJsonForWSDL(locationOrContent, options.auth, opts).then(function(allWsdls) {
            try {
                parse.getWSDLServices(allWsdls, options);
                def.resolve();
            } catch (e) {
                u.addValidationErr(valErr, e, req);
                def.reject(valErr);
            }
        }, function(e) {
            u.addValidationErr(valErr, e, req);
            def.reject(valErr);
        });
    } catch (e) {
        u.addValidationErr(valErr, e, req);
        def.reject(valErr);
    }
    return def.promise;
}

/**
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth and other options.
* @returns promise of serviceData
*/
function introspectWSDL(locationOrContent, options) {
    return validateWSDL(locationOrContent, options);
}


exports.addTargetOpenApi = addTargetOpenApi;
exports.addXSDToTargetOpenApi = addXSDToTargetOpenApi;
exports.createOpenApi = createOpenApi;
exports.introspectWSDL = introspectWSDL;
exports.validateWSDL = validateWSDL;
exports.validateXSD = validateXSD;
