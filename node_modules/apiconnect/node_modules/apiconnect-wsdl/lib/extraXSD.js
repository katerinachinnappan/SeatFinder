/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parse = require('../lib/parse.js');
const generateSwagger = require('../lib/generateSwagger.js');
const parseUtils = require('../lib/parseUtils.js');
const postParse = require('../lib/postParse.js');
const copts = require('../lib/createOptions.js');

var q = require('q');
var yauzl = require('yauzl');
var path = require('path');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

/**
 * Get the Swagger for additional xsd schema.
 * @method getDefinitionsForXSD
 * @param {String[]} filename - xsd file(s)
 * @param {Object[]} auth - auth info for accessing xsd file(s)
 * @param {String[]} rootElementList - if set only process the rootElements in the list (and referencedDefs)
 * @param {Object} createOperationDesc
 * @return {Object} swagger.definitions
 **/
function getDefinitionsForXSD(filename, auth, rootElementList, options) {
    rootElementList = u.makeSureItsAnArray(rootElementList);

    let createOptions = copts.create({
        fromGetDefinitionsForXSD: true,
        rootElementList: rootElementList
    }, options);
    // Force arrays
    var filenameList = u.makeSureItsAnArray(filename);
    var authList = u.makeSureItsAnArray(auth, true);
    var swaggerDef = q.defer();
    var jsonDef = q.defer();

    let serviceName = 'TEMPLATE';
    let wsdlId = 'TEMPLATE';
    let req = createOptions.req;

    // Creates a temporary wsdl file containing xsd:imports for each
    // of the schemas
    let def = createTemporaryWSDL(filenameList, authList, req);

    function errhandler(error) {
        swaggerDef.reject(error);
    }

    // Add the temporary wsdl file to the filenameList and call getJsonForWSDL
    def.then(function(wsdlContent) {
        // The filename is set to the special scheme (MEMORY)
        // to indicate that the authItem contains the wsdl content
        filenameList.push('MEMORY');
        var authItem = {
            data: wsdlContent
        };
        authList.push(authItem);

        try {
            parse.getJsonForWSDL(filenameList, authList, createOptions).then(function(data) {
                jsonDef.resolve(data);
            }, errhandler);
        } catch (e) {
            swaggerDef.reject(e);
        }
    }, errhandler);

    jsonDef.promise.then(function(allWSDLs) {
        try {
            // Get the WSDLEntry for the serviceName
            var wsdlEntry = parse.findWSDLForServiceName(allWSDLs, serviceName);

            // Get the swagger for the service.  This will be the template service with
            // a definition section that contains our extra xsd definitions.
            var swagger = generateSwagger.getSwaggerForService(wsdlEntry, serviceName, wsdlId, createOptions);
            swaggerDef.resolve(swagger.definitions); // Just return the definitions
        } catch (e) {
            swaggerDef.reject(e);
        }
    }, errhandler);
    return swaggerDef.promise;
}

function createTemporaryWSDL(filenames, auths, req) {
    let def = q.defer();

    // The template wsdl is "just enough" wsdl to make a swagger document.
    let templateWSDL = path.resolve(__dirname, '../src/template.wsdl');
    let serviceName = 'TEMPLATE';
    let wsdlId = 'TEMPLATE';

    function errhandler(error) {
        def.reject(error);
    }

    getTargetNamespacesForXSD(filenames, auths, req).then(function(fileEntryList) {
        parseUtils.getFileContent(templateWSDL, templateWSDL, null, null, req).then(function(wsdlContent) {
            // wsdlContent is the template wsdl content
            // Add xsd:imports for each of the files in the fileEntryList
            wsdlContent = wsdlContent.replace(/{SERVICE}/gi, serviceName);
            var stmts = '';
            for (var j = 0; j < fileEntryList.length; j++) {

                var stmt = '<xsd:import namespace="{TNS}" schemaLocation="{FILENAME}" {XMLNS} />\n';
                stmt = stmt.replace(/{FILENAME}/gi, fileEntryList[j].filename);
                stmt = stmt.replace(/{TNS}/gi, fileEntryList[j].targetNamespace);
                var xmlns = '';
                if (fileEntryList[j].prefix) {
                    xmlns = 'xmlns:' + fileEntryList[j].prefix + '="' + fileEntryList[j].targetNamespace + '"';
                }
                stmt = stmt.replace(/{XMLNS}/gi, xmlns);


                stmts += stmt;
            }
            wsdlContent = wsdlContent.replace(/{IMPORTS}/gi, stmts);
            def.resolve(wsdlContent);
        }, errhandler);
    }, errhandler);

    return def.promise;
}
/**
 * Get the targetnamespaces for the indicated files
 * @method getTargetNamespacesForXSD
 * @param {String[]} filename - file name[s]
 * @param {Object[]} auth - authorization information
 * @param {Promise}  promise containing fileEntry(s) with targetnamepaces field set
 */
function getTargetNamespacesForXSD(filenames, auths, req) {
    var def = q.defer();
    var files = [];
    var promiseList = [];
    filenames = u.makeSureItsAnArray(filenames);
    auths = u.makeSureItsAnArray(auths);

    for (var i = 0; i < filenames.length; i++) {
        promiseList.push(_getTargetNamespacesForXSD(filenames[i], auths[i], req));
    }
    // Once all of the files are done, combine together
    Promise.all(promiseList).then(values => {
        for (i = 0; i < values.length; i++) {
            files = files.concat(values[i]);
        }
        def.resolve(files);
    }).catch(reason => {
        def.reject(reason);
    });

    return def.promise;
}

/**
 * Get the targetnamespaces for the indicated file
 * @method getTargetNamespacesForXSD
 * @param {String} filename - file name
 * @param {Object} auth - authorization information
 * @param {Promise}  promise containing fileEntry (with targetNamespace and prefix)
 */
function _getTargetNamespacesForXSD(filename, auth, req) {
    var def = q.defer();
    var files = [];
    var fetchDef = parseUtils.getFileContent(filename, filename, auth, null, req);
    fetchDef.then(function(rawContent) {
        var left = rawContent.toString('utf8', 0, 4);
        if (left == 'PK\u0003\u0004') {
            // it's a ZIP file - go fetch all the content
            rawContent = parseUtils.toBuffer(rawContent);
            yauzl.fromBuffer(rawContent, {
                lazyEntries: true
            }, function(err, zipFile) {
                if (err) {
                    def.reject(err);
                } else {
                    zipFile.readEntry();
                    zipFile.on('error', function(err) {
                        def.reject(err);
                    });
                    zipFile.on('entry', function(entry) {
                        if (/\/$/.test(entry.fileName) || (/__MACOSX/).test(entry.fileName)) {
                            // ignore directories and MAC archives
                            zipFile.readEntry();
                        } else {
                            var strings = [];
                            zipFile.openReadStream(entry, function(err, readStream) {
                                if (err) {
                                    def.reject(err);
                                } else {
                                    readStream.on('data', function(chunk) {
                                        strings.push(chunk);
                                    });
                                    readStream.on('end', function() {
                                        var nameLen = entry.fileName.length;
                                        if (entry.fileName.indexOf('.wsdl', nameLen - 5) != -1 || entry.fileName.indexOf('.xsd', nameLen - 4) != -1) {
                                            // only discover WSDLs and XSDs
                                            var shortName = entry.fileName;
                                            var index = shortName.lastIndexOf('/');
                                            if (index != -1) {
                                                shortName = shortName.substr(index + 1);
                                            }
                                            var file = {
                                                filename: shortName,
                                                fullName: entry.fileName,
                                                type: 'xsd', // temp for now determined later when we actually parse it
                                                content: '',
                                                context: 'zip'
                                            };
                                            file.content = Buffer.concat(strings);
                                            var encoding = parseUtils.determineEncoding(file.content, file.fullName, req);
                                            file.content = parseUtils.decode(file.content, encoding);
                                            try {
                                                parseUtils.contentToXMLorWSDL(file, { req: req });
                                                if (file.json.definitions) {
                                                    // This is WSDL, skip it.

                                                } else if (file.json.schema) {
                                                    postParse.updateSchemaNamespaces(file);
                                                    // Get namespaces
                                                    files.push(file);
                                                    file.namespaces = {};
                                                    if (file.json.schema['undefined'] && file.json.schema['undefined'].targetNamespace) {
                                                        file.targetNamespace = file.json.schema['undefined'].targetNamespace;
                                                        file.prefix = u.getPrefixForNamespace(file.targetNamespace,
                                                            file.json.schema.xmlns);
                                                    }
                                                } else {
                                                    // Ignore other files
                                                }
                                            } catch (e) {
                                                def.reject(parseUtils.cleanupError(e));
                                            }
                                        }
                                        zipFile.readEntry();
                                    });
                                }
                            });
                        }
                    });
                    zipFile.on('end', function() {
                        def.resolve(files);
                    });
                }
            });
        } else {
            var file = {
                filename: filename,
                fullName: filename,
                type: 'xsd',
                content: rawContent,
                context: 'cmd'
            };
            try {
                if (rawContent == filename) {
                    file.filename = 'MEMORY';
                    file.fullName = 'MEMORY';
                }
                parseUtils.contentToXMLorWSDL(file, { req: req });
                if (file.json.definitions) {
                    // This is WSDL, skip it.

                } else if (file.json.schema) {
                    postParse.updateSchemaNamespaces(file);
                    files.push(file);
                    file.namespaces = {};
                    if (file.json.schema['undefined'] && file.json.schema['undefined'].targetNamespace) {
                        file.targetNamespace = file.json.schema['undefined'].targetNamespace;
                        file.prefix = u.getPrefixForNamespace(file.targetNamespace, file.json.schema.xmlns);
                    }
                } else {
                    // Ignore other files
                }
                def.resolve(files);
            } catch (e) {
                def.reject(parseUtils.cleanupError(e, req));
            }
        }
    }, function(fileErr) {
        def.reject(fileErr);
    });
    return def.promise;
}

exports.createTemporaryWSDL = createTemporaryWSDL;
exports.getDefinitionsForXSD = getDefinitionsForXSD;
