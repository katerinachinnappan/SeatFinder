/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parseUtils = require('../lib/parseUtils.js');
const postParse = require('../lib/postParse.js');
const flattener = require('../lib/flatten.js');
const jsyaml = require('js-yaml');

var q = require('q');
var yauzl = require('yauzl');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

/**
* Main entry point for accessing the files and returning the
* parsed content (allWSDLs).
* @param locations (usually 1) of wsdl/zip files/urls
* If array item is a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param auths (for access if locations is protected url)
* @param options
*   req: request or null (used for i18n negotiation)
*   flatten: dev only
*   allowExtraFiles: default true (legacy behavior)
* @return allWSDLs, which is a array of wsdlEntry object representing
* the parsed information.
*/
function getJsonForWSDL(locations, auths, options) {
    var def = q.defer();
    var files = [];
    var promiseList = [];
    var flatten = false;
    if (options) {
        flatten = options.flatten;
    } else {
        // Allow extra files in zip files...this is the legacy behavior
        options = {
            allowExtraFiles: true
        };
    }
    let req = options.req;

    // Get JsonForWSDL for each file
    locations = u.makeSureItsAnArray(locations);
    auths = u.makeSureItsAnArray(auths, true);

    for (var i = 0; i < locations.length; i++) {
        promiseList.push(_getJsonForWSDL(locations[i], auths[i], options));
    }

    // Once all of the files are done, combine together
    Promise.all(promiseList).then(values => {
        // Combine the files into one array
        for (i = 0; i < values.length; i++) {
            files = files.concat(values[i]);
        }

        // check for internal errors
        for (i = 0; i < files.length; i++) {
            let file = files[i];
            if (file.doc && file.doc.internalError) {
                // If an internal is caught during parsing, throw it now.
                if (file.doc.internalError.message) {
                    file.doc.internalError.message = g.http(u.r(req)).f('The wsdl file is incorrect (%s).', file.doc.internalError.message);
                }
                def.reject(file.doc.internalError);
            }
        }

        // Now post process the files and return the allWSDLs array
        var checkDef = postParse.checkForWSDLImports(files, auths[0], options);
        checkDef.then(function(allWSDLs) {
            // Flattening takes extra resources, so you need to request it.
            if (flatten) {
                flattener.flatten(files, allWSDLs);
            }
            def.resolve(allWSDLs);
        }, function(e) {
            def.reject(e);
        });
    }).catch(reason => {
        def.reject(reason);
    });
    return def.promise;
}

/**
* Do some simple checking of the wsdl definition object and return an array of the problems found
*/
function sanityCheckDefinition(definitions, req) {
    let errs = [];
    // Make sure each portType.operation references a defined message
    let portTypes = u.makeSureItsAnArray(definitions.portType);
    let messages = u.makeSureItsAnArray(definitions.message);
    let bindings = u.makeSureItsAnArray(definitions.binding);
    let services = u.makeSureItsAnArray(definitions.service);


    // Make sure each operation references a message
    for (let i = 0; i < portTypes.length; i++) {
        let portType = portTypes[i];
        let operations = u.makeSureItsAnArray(portType.operation);
        for (let j = 0; j < operations.length; j++) {
            let operation = operations[j];
            let opName = operation['undefined'].name;
            let children = [ 'input', 'output', 'fault' ];
            for (let c = 0; c < children.length; c++) {
                let key = children[c];
                if (operation[key] && operation[key]['undefined'] && operation[key]['undefined'].message) {
                    let message = u.stripNamespace(operation[key]['undefined'].message);
                    let found = false;
                    for (let m = 0; m < messages.length  && !found; m++) {
                        if (messages[m]['undefined'] && messages[m]['undefined']) {
                            if (messages[m]['undefined'].name === message) {
                                found = true;
                            }
                        }
                    }
                    if (!found) {
                        errs.push(g.http(u.r(req)).f('Could not find wsdl \'message\' "%s" referenced in wsdl \'operation\' "%s".', message, opName));
                    }
                }
            }
        }
    }
    // Make sure every binding operation has a matching portType operation
    for (let i = 0; i < bindings.length; i++) {
        let binding = bindings[i];
        let bindingName = binding['undefined'].name;
        let bOperations = u.makeSureItsAnArray(binding.operation);
        let portTypeName = u.stripNamespace(binding['undefined'].type);
        for (let j = 0; j < portTypes.length; j++) {
            let portType = portTypes[j];
            if (portType['undefined'].name === portTypeName) {
                let pOperations = u.makeSureItsAnArray(portType.operation);
                if (pOperations.length !== bOperations.length) {
                    errs.push(g.http(u.r(req)).f('The number of wsdl \'operations\' in \'binding\' "%s" does not match the number of \'operations\' in its \'portType\' "%s".',
                      bindingName, portTypeName));
                }
                for (let k = 0; k < bOperations.length; k++) {
                    let bOpName = bOperations[k]['undefined'].name;
                    let found = false;
                    for (let l = 0; l < pOperations.length && !found; l++) {
                        let pOpName = pOperations[l]['undefined'].name;
                        if (pOpName === bOpName) {
                            found = true;
                        }
                    }
                    if (!found) {
                        errs.push(g.http(u.r(req)).f('The wsdl \'operation\' "%s" in \'binding\' "%s" does not match any \'operations\' in its \'portType\' "%s".',
                        bOpName, bindingName, portTypeName));
                    }
                }
            }
        }
    }
    // Make sure the services have bindings
    for (let i = 0; i < services.length; i++) {
        let service = services[i];
        let serviceName = service['undefined'].name;
        let ports = u.makeSureItsAnArray(service.port);
        for (let j = 0; j < ports.length; j++) {
            let port = ports[j];
            let portName = port['undefined'].name;
            let bindingName = u.stripNamespace(port['undefined'].binding);
            let found = false;
            for (let k = 0; k < bindings.length && !found; k++) {
                let binding = bindings[k];
                if (binding['undefined'].name === bindingName) {
                    found = true;
                }
            }
            if (!found) {
                errs.push(g.http(u.r(req)).f('The wsdl \'binding\' "%s" referenced by \'service\' "%s" cannot be found.',
                  bindingName, serviceName));
            }
        }
    }
    return errs;
}


/**
* Get the services from allWSDLs.  Primarily used by the UI to display the services found
* in the parsed information (allWSDLs) so that the user can choose which service to generate.
* @param allWSDLs (from getJsonForWSDL)
* @param options
*   req: request or null (used for i18n negotiation)
* @returns data object that contains the names of the services, portTypes, bindings, serviceOperations
*/
function getWSDLServices(allWSDLs, options) {
    options = options || {};
    let req = options.req;
    var data = {
        portTypes: {},
        bindings: {},
        services: []
    };
    try {
        var wLen = allWSDLs.length;
        var operations, operation, ops;
        var serviceMap = {};
        for (var x = 0; x < wLen; x++) {
            var wsdlJson = allWSDLs[x].json;
            var portTypes = u.makeSureItsAnArray(wsdlJson.definitions.portType);
            var typeLen = portTypes.length;
            for (var i = 0; i < typeLen; i++) {
                var portType = portTypes[i];
                operations = u.makeSureItsAnArray(portType.operation);
                ops = [];
                var len = operations.length;
                for (var p = 0; p < len; p++) {
                    operation = operations[p];
                    ops.push({
                        name: operation['undefined'].name,
                        description: u.cleanupDocumentation(operation.documentation, req)
                    });
                } // end for
                data.portTypes[portType['undefined'].name] = ops;
            } // end for
            var bindings = u.makeSureItsAnArray(wsdlJson.definitions.binding);
            var binLen = bindings.length;
            for (var j = 0; j < binLen; j++) {
                var binding = bindings[j];
                var bindingType = binding['undefined'].type;
                bindingType = u.stripNamespace(bindingType);
                operations = u.makeSureItsAnArray(binding.operation);
                ops = [];
                var operLen = operations.length;
                for (var n = 0; n < operLen; n++) {
                    operation = operations[n];
                    ops.push(operation['undefined'].name);
                } // end for
                var bind = {
                    type: bindingType,
                    operations: ops
                };
                // Only store soap bindings
                if (binding.binding && binding.binding['undefined'] &&
                   (binding.binding['undefined'].transport ||
                    binding.binding['undefined'].style == 'document' ||
                    binding.binding['undefined'].style == 'rpc')) {
                    data.bindings[binding['undefined'].name] = bind;
                }
            } // end for
            var services = u.makeSureItsAnArray(wsdlJson.definitions.service);
            var servLen = services.length;
            for (var k = 0; k < servLen; k++) {
                var service = services[k];
                var ports = u.makeSureItsAnArray(service.port);
                ports = onlySoapPorts(ports, data.bindings);
                service.port = ports;
                var portLen = ports.length;
                if (ports.length == 0) {
                    continue;
                }

                let serv = {
                    service: service['undefined'].name,
                    filename: allWSDLs[x].filename,
                };

                // Process the ports
                for (let l = 0; l < portLen; l++) {
                    let port = ports[l];
                    let portName = port['undefined'].name;
                    let obj;
                    if (l == 0) {
                        // This is the default port, and is set at the top level
                        serv.portName = portName;
                        obj = serv;
                    } else {
                        // Other ports are put in the port map
                        serv.ports = serv.ports || {};
                        serv.ports[portName] = {};
                        obj = serv.ports[portName];
                    }
                    obj.bindingName = u.stripNamespace(port['undefined'].binding);
                    let endpoint = '';
                    if (portLen > 0) {
                        if (ports[0].address &&
                            ports[0].address['undefined']) {
                            endpoint = ports[0].address['undefined'].location;
                        }
                    }
                    obj.endpoint = endpoint;
                    let type = data.bindings[obj.bindingName] ? data.bindings[obj.bindingName].type : null;
                    obj.operations = [];
                    if (type) {
                        let ops = data.portTypes[type];
                        for (let m = 0; m < ops.length; m++) {
                            let opObj = {
                                operation: ops[m].name
                            };
                            if (ops[m].description) {
                                opObj.description = ops[m].description;
                            }
                            obj.operations.push(opObj);
                        }
                    }
                }

                // Add service if there are actual serviceChildren
                // and the service in this first time that the service for this
                // file is encountered.
                // (The tns is checked because a service will occur multiple times in
                // allWSDLs for circular wsdl imports, so we use the tns to ensure that only
                // one of these is used).
                if (allWSDLs[x].serviceChildren && allWSDLs[x].serviceChildren != {}) {
                    if (!serviceMap[serv.service]) {
                        serviceMap[serv.service] = [];
                    }
                    var found = false;
                    for (var ss = 0; !found && ss < serviceMap[serv.service].length; ss++) {
                        let s = serviceMap[serv.service][ss];
                        if (s.fullName === allWSDLs[x].fullName ||
                            s.endpoint === serv.endpoint) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        serviceMap[serv.service].push(
                          {
                              serv: serv,
                              fullName: allWSDLs[x].fullName,
                              endpoint: serv.endpoint
                          });
                        data.services.push(serv);
                    }
                }
            } // end for
        } // end for

        // Find duplicates and disambiguate the names
        // <serviceName>-from-<slugifyfullname>
        for (var s in serviceMap) {
            if (serviceMap[s].length > 1) {
                for (var z = 0; z < serviceMap[s].length; z++) {
                    serviceMap[s][z].serv.service += '-from-' + u.slugifyName(serviceMap[s][z].fullName);
                }
            }
        }
        return u.checkAndFix(data);
    } catch (error) {
        console.log(g.http(u.r(req)).f('Error occurred parsing wsdl.'));
        console.log(error);
        return u.checkAndFix(data);
    }
}

/**
* @param ports is service.ports
* @param bindings is object containing keys that are soap bindings
* @return port array with just soap ports
*/
function onlySoapPorts(ports, bindings) {
    let ret = [];
    let portLen = ports.length;
    for (var i = 0; i < portLen; i++) {
        if (ports[i].address  && ports[i]['undefined']  && ports[i]['undefined'].binding) {
            let bindingName = u.stripNamespace(ports[i]['undefined'].binding);
            if (bindings[bindingName]) {
                ret.push(ports[i]);
            }
        }
    }
    return ret;
}

/**
* @param allWSDLs (from getJsonForWSDL)
* @param serviceName (wsdl service name)
* @param servieFileName (used as a differentiator if multiple services with the same name)
* @returns WSDLEntry object for the indicated service.
*/
function findWSDLForServiceName(allWSDLs, serviceName, serviceFilename) {
    var ret = null;
    var len = allWSDLs.length;
    // If multiple services of the same name were detected,
    // then the serviceName was changed to disambiguate the services
    // <serviceName>-from-<slugifiedpath>
    var slugifyServiceFullName;
    var mangleIndex = serviceName.indexOf('-from-');
    if (mangleIndex > 0) {
        slugifyServiceFullName = serviceName.substring(mangleIndex + 6);
        serviceName = serviceName.substring(0, mangleIndex);
        serviceFilename = null;
    }
    for (var i = 0; i < len; i++) {
        var wsdlEntry = allWSDLs[i];
        if (wsdlEntry.serviceChildren && wsdlEntry.serviceChildren[serviceName]) {
            if (slugifyServiceFullName && wsdlEntry.fullName) {
                if (slugifyServiceFullName == u.slugifyName(wsdlEntry.fullName)) {
                    ret = wsdlEntry;
                    break;
                }
            } else if (serviceFilename && wsdlEntry.filename) {
                if (serviceFilename == wsdlEntry.filename) {
                    ret = wsdlEntry;
                    break;
                }
            } else {
                ret = wsdlEntry;
                break;
            }
        }
    } // end for
    return ret;
}

/**
 * Get allWSDLS for a single wsdl file (or zip)
 */
function _getJsonForWSDL(filename, auth, options) {
    let opts = options || {};
    let req = opts.req;
    var totalProcessed = 0;
    var reject = false;  // Necessary to help halt distributed process of zip entries
    var def = q.defer();
    var files = [];
    try {
        // Get the rawContent of the files
        var fetchDef = parseUtils.getFileContent(filename, filename, auth, null, req);
        fetchDef.then(function(rawContent) {
            var left = rawContent.toString('utf8', 0, 4).substr(0, 4);
            if (left == 'PK\u0003\u0004') {
                // it's a ZIP file - go fetch all the content
                let rawContentObjectName = u.getObjectName(rawContent);
                rawContent = parseUtils.toBuffer(rawContent, req);
                yauzl.fromBuffer(rawContent, {
                    lazyEntries: true
                }, function(err, zipFile) {
                    if (err) {
                        reject = true;
                        if (err.message.indexOf('relative path') >= 0) {
                            def.reject(g.http(u.r(req)).Error('The zip file format is incorrect (%s).', err));
                        } else {
                            let detail = g.http(u.r(req)).f('The content may have been uploaded with a wrong encoding (i.e. utf8). ' +
                              'Here are the first 50 base64 characters of the content [%s].', rawContent.toString('base64', 0, 50));
                            def.reject(g.http(u.r(req)).Error('The zip file format is incorrect (%s). Found while processing %s. A possible is reason is (%s).', err, rawContentObjectName, detail));
                        }
                    } else if (!reject) {
                        zipFile.readEntry();
                        zipFile.on('error', function(err) {
                            reject = true;
                            if (err.message.indexOf('relative path') >= 0) {
                                def.reject(g.http(u.r(req)).Error('The zip file format is incorrect (%s).', err));
                            } else {
                                let detail = g.http(u.r(req)).f('The content may have been uploaded with a wrong encoding (i.e. utf8). ' +
                                  'Here are the first 50 base64 characters of the content [%s].', rawContent.toString('base64', 0, 50));
                                def.reject(g.http(u.r(req)).Error('The zip file format is incorrect (%s). Found while processing %s. A possible is reason is (%s).', err, rawContentObjectName, detail));
                            }
                        });
                        zipFile.on('entry', function(entry) {
                            /* jslint bitwise: true */
                            // Get the mode from the externalFileAttributes
                            let mode = entry.externalFileAttributes >>> 16;
                            let isFile = (mode & 0o100000);
                            let isSymlink = isFile && (mode & 0o020000);
                            let isExecutableFile = isFile && (mode & 0o000111);

                            if (isSymlink) {
                                // This file is a symlink, ALWAYS and IMMEDIATELY reject since we don't know how the zip will be used in the future
                                // and could be an attempt to access files.
                                reject = true;
                                def.reject(g.http(u.r(req)).Error('A file for a symbolic link was encountered in the zip.  Remove the file %s.', entry.fileName));
                            }

                            if (/\/$/.test(entry.fileName) || (/__MACOSX/).test(entry.fileName)) {
                                // ignore directories and MAC archives
                                if (isExecutableFile) {
                                    // This is an executable file and could be a problem if the zip is unzipped.
                                    reject = true;
                                    def.reject(g.http(u.r(req)).Error('An unexpected executable file was encountered in the zip.  Remove the file %s.', entry.fileName));
                                }
                                zipFile.readEntry();
                            } else {
                                var strings = [];
                                zipFile.openReadStream(entry, function(err, readStream) {
                                    if (err) {
                                        reject = true;
                                        def.reject(err);
                                    } else {
                                        readStream.on('data', function(chunk) {
                                            strings.push(chunk);
                                        });
                                        readStream.on('end', function() {
                                            var nameLen = entry.fileName.length;
                                            let isXMLSuffix = entry.fileName.indexOf('.xml', nameLen - 4) != -1;
                                            let isXSDSuffix = entry.fileName.indexOf('.xsd', nameLen - 4) != -1;
                                            let isWSDLSuffix = entry.fileName.indexOf('.wsdl', nameLen - 5) != -1;
                                            let isConfig = entry.fileName == 'apiconnect.yaml';

                                            // Throw an error if only allowing xsd and wsdl files
                                            // and this is an extra file
                                            if (!isWSDLSuffix && !isXSDSuffix && !isConfig) {
                                                if (!opts.allowExtraFiles) {
                                                    reject = true;
                                                    def.reject(parseUtils.cleanupError(
                                                      g.http(u.r(req)).Error('Only .xsd and .wsdl files are allowed in the zip.  Remove the file %s.', entry.fileName), req));
                                                } else if (isExecutableFile) {
                                                    // This is an executable file and could be a problem if the zip is unzipped.
                                                    reject = true;
                                                    def.reject(g.http(u.r(req)).Error('An unexpected executable file was encountered in the zip.  Remove the file %s.', entry.fileName));
                                                }
                                            }
                                            // Save the configuration data:
                                            if (isConfig) {
                                                try {
                                                    let content = Buffer.concat(strings);
                                                    let opts = jsyaml.safeLoad(content, 'utf8');
                                                    options.config = opts;
                                                } catch (e) {
                                                    reject = true;
                                                    def.reject(parseUtils.cleanupError(e, req));
                                                }
                                            }
                                            // An .xml file may contain xsd or it may contain random
                                            // xml information.  Try to read .xml files but don't report
                                            // errors.
                                            if (isWSDLSuffix || isXSDSuffix || isXMLSuffix) {
                                                // only discover WSDLs and XSDs
                                                var shortName = entry.fileName;
                                                var index = shortName.lastIndexOf('/');
                                                if (index != -1) {
                                                    shortName = shortName.substr(index + 1);
                                                }
                                                var file = {
                                                    filename: shortName,
                                                    fullName: entry.fileName,
                                                    type: 'wsdl', // temp for now determined later when we actually parse it
                                                    content: '',
                                                    context: 'zip'
                                                };
                                                file.content = Buffer.concat(strings);
                                                var encoding = parseUtils.determineEncoding(file.content, file.fullName, req);
                                                file.content = parseUtils.decode(file.content, encoding);
                                                totalProcessed += file.content.length;
                                                try {
                                                    // If the customer proviced a very, very large zip file containing
                                                    // many large xsds that are unreferenced, the zip file processing
                                                    // will run out of memory and the designer will hang.
                                                    // An error message is better than a hang.
                                                    // An alternative is to do mult-passes through the zip collecting
                                                    // only the schema that is needed, but that is slow and error prone.
                                                    if (totalProcessed > 64000000) {
                                                        throw g.http(u.r(req)).Error('The zip file contains too many large xsd/wsdl files. ' +
                                                           'Please remove unnecessary xsd/wsdl files and try again.');
                                                    }
                                                    try {
                                                        parseUtils.contentToXMLorWSDL(file, options);
                                                    } catch (e) {
                                                        // If the file is not a wsdl, then save the error
                                                        // and rethrow later only if it is is included or imported
                                                        // We do this for migration reasons.
                                                        // However if the file appears to be an executable file, fail fast.
                                                        if (isWSDLSuffix || isExecutableFile) {
                                                            throw e;
                                                        } else {
                                                            file.error = e;
                                                            file.type = 'xsd';
                                                        }
                                                    }
                                                    let valid = false;
                                                    if (file.error) {
                                                        files.push(file);
                                                    } else if (file.json.definitions) {
                                                        var wsdlGood = parseUtils.validateWSDLJson(file.json, file.filename);
                                                        if (wsdlGood.valid) {
                                                            files.push(file);
                                                            file.type = 'wsdl';
                                                            var namespaces = file.doc.definitions.xmlns;
                                                            file.namespaces = namespaces;
                                                            valid = true;
                                                        } else {
                                                            throw new Error(wsdlGood.reason);
                                                        }
                                                    } else if (file.json.schema) {
                                                        files.push(file);
                                                        file.type = 'xsd';
                                                        file.namespaces = {};
                                                        valid = true;
                                                    } else {
                                                        // Cannot parse the wsdl or xsd file.
                                                        // If this is a wsdl or has executable permissions, then fail fast.
                                                        // Else the error is saved and only issued if this file is needed (due to migration)
                                                        let e = g.http(u.r(req)).Error('Failed to parse wsdl or xsd in file %s.', file.filename);
                                                        if (isWSDLSuffix || isExecutableFile) {
                                                            throw e;
                                                        } else {
                                                            file.error = e;
                                                            file.type = 'xsd';
                                                            files.push(file);
                                                        }
                                                    }
                                                    // have to capture the service children elements (ports) here as they get munged later
                                                    if (valid) {
                                                        file.serviceChildren = postParse.captureServiceChildren(file.doc);
                                                        postParse.updateSchemaNamespaces(file);
                                                    }
                                                } catch (e) {
                                                    if (!isXMLSuffix) {
                                                        reject = true;
                                                        def.reject(parseUtils.cleanupError(e, req));
                                                    }
                                                }
                                            }
                                            zipFile.readEntry();

                                        });
                                    }
                                });
                            }
                        });
                        // End of all zip files
                        zipFile.on('end', function() {
                            def.resolve(files);
                        });
                    }
                });
            } else {
                var file = {
                    filename: filename,
                    fullName: filename,
                    type: 'wsdl',
                    content: rawContent,
                    context: 'cmd'
                };
                try {
                    if (rawContent == filename) {
                        file.filename = 'MEMORY';
                        file.fullName = 'MEMORY';
                    }
                    if (file.content == null || file.content.length == 0) {
                        throw g.http(u.r(req)).Error('The file %s has no content.', file.filename);
                    }
                    parseUtils.contentToXMLorWSDL(file, options);
                    if (file.json.definitions) {
                        var wsdlGood = parseUtils.validateWSDLJson(file.json, file.filename, req);
                        if (wsdlGood.valid) {
                            files.push(file);
                            file.type = 'wsdl';
                            var namespaces = file.doc.definitions.xmlns;
                            file.namespaces = namespaces;
                        } else {
                            throw new Error(wsdlGood.reason);
                        }
                    } else if (file.json.schema) {
                        files.push(file);
                        file.type = 'xsd';
                        file.namespaces = {};
                    } else {
                        throw g.http(u.r(req)).Error('Failed to parse wsdl or xsd in file %s.', file.filename);
                    }
                    // have to capture the service children elements (ports) here as they get munged later
                    file.serviceChildren = postParse.captureServiceChildren(file.doc);
                    postParse.updateSchemaNamespaces(file);
                    def.resolve(files);
                } catch (e) {
                    def.reject(parseUtils.cleanupError(e, req));
                }
            }
        }, function(fileErr) {
            def.reject(fileErr);
        });
    } catch (e) {
        def.reject(e);
    }
    return def.promise;
}

exports.getJsonForWSDL = getJsonForWSDL;
exports.getWSDLServices = getWSDLServices;
exports.findWSDLForServiceName = findWSDLForServiceName;
exports.sanityCheckDefinition = sanityCheckDefinition;
