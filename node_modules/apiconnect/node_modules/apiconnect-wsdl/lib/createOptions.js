/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';
var _ = require('lodash');
const u = require('../lib/utils.js');
var g = require('../lib/strong-globalize-fake.js');

var NEVER = 'NEVER';
var IFNOTDEFAULT = 'IF-NOT-DEFAULT';
var ALWAYS = 'ALWAYS';

var OPTIONS = {
    type: {
        default: 'wsdl',
        allowed: [ 'wsdl', 'wsdl-to-rest' ],
        description: 'The type of api, either \'wsdl\' or \'wsdl-to-rest\'',
        persist: NEVER, // Don't need to persist because information is persisted in wsdl-definition
    },
    openapiVersion: {
        default: '2.0',
        allowed: [ '2.0', '3.0' ],
        description: 'The open api version, either \'2.0\' or \'3.0\'',
        persist: NEVER, // Don't need to persist because information is in the api
    },
    gateway: {
        default: 'datapower-gateway',
        allowed: [ 'datapower-gateway', 'datapower-api-gateway', 'micro-gateway' ],
        description: 'The target gateway',
        persist: NEVER // Don't need to persist because information is in the api
    },
    defaults: {
        default: undefined,
        description: 'Overrides to that are patched onto the created api',
        persist: NEVER,        // Used to merge values into the generated swagger
    },
    req: {
        default: undefined,
        description: 'The language information for the request or operating system',
        persist: NEVER,   // This is the i18n language information
    },
    messages: {
        default: undefined,
        description: 'Messages generated during the creation of the api',
        persist: ALWAYS,     // These are the messages found during processing
    },
    config: {
        default: undefined,
        description: 'Create options that were injected via a configuration file',
        persist: IFNOTDEFAULT,  // This is config file (possibly injected in the zip)
    },
    port: {
        default: undefined,
        description: 'The name of the port within the service that should be used to generate the api',
        persist: IFNOTDEFAULT,
    },
    wssecurity: {
        default: true,
        description: 'Should wssecurity definitions be included within the api',
        persist: IFNOTDEFAULT,
    },
    inlineAttributes: {
        default: true,
        description: 'Should root attributes be inlined instead of referenced',
        persist: IFNOTDEFAULT,   // development option, currently hidden
    },
    suppressExamples: {
        default: false,
        description: 'Should auto generated examples be suppressed',
        persist: IFNOTDEFAULT
    },
    allowExtraFiles: {
        default: false,
        description: 'Should files other than wsdl, xsd, and configuration files be allowed in the input zip',
        persist: NEVER,  // Only used during parsing
    },
    selfContained: {
        default: true,
        description: 'Should all files be contained within the input, or should the generator look for them on the file system or using remote urls.',
        persist: NEVER,  // Only used during parsing
    },
    strictValidation: {
        default: false,
        description: 'Should unreferenced schemas in a zip file be validated for correctness.',
        persist: NEVER,  // Only used during parsing
    },
    extraValidation: {
        default: false,
        description: 'Extra checking looking for names and attributes that are interesting or unrecognized.',
        persist: NEVER,  // Only used during parsing
    },
    badgerfishDefs: {
        default: true,
        description: 'Use badgerfish syntax when creating apis for \'wsdl-to-rest\'',
        persist: IFNOTDEFAULT,  // hidden, development option
    },
    decodeGatewayScript: {
        default: false,
        description: 'Development Option: generate a decode gateway script during \'wsdl-to-rest\' api generation',
        persist: IFNOTDEFAULT, // hidden, development option
    },
    mapSOAPFaults: {
        default: false,
        description: 'Create a catch for soap faults within the \'wsdl-to-rest\' api',
        persist: IFNOTDEFAULT, // used for wsdl-to-rest
    },
    mapOptions: {
        default: undefined,
        description: 'For \'wsdl-to-rest\' api, these are the overrides for the assembly map options (mapOptions.includeEmptyXMLElements, mapOptions.namespaceInheritance, mapOptions.inlineNamespaces) ',
        persist: IFNOTDEFAULT, // used for wsdl-to-rest, these are the map options added to the assembly
    },
    fromGetDefinitionsForXSD: {
        default: false,
        description: 'Development Only: Indicates if process xsd input (versus wsdl input)',
        persist: NEVER,      // Used only for extra xsd schemas
    },
    rootElementList: {
        default: undefined,
        description: 'Development Only: Elements to consider if fromGetDefinitionsForXSD is set',
        persist: NEVER       // hidden, development option used with formGetDefinitionsForXSD
    },
};

var DEFAULTS = _getDefaults();

/**
* create
* Creates a createOptions struct
* @param _options (createOptions struct passed in via an api)
* @param _defaults (optinal context defaults)
* @return createOptions struct with all defaults applied and validated
*
*/
function create(_options, _defaults) {
    _options = _options || {};
    _defaults = _defaults || {};
    let options = _.merge({}, DEFAULTS, _defaults, _options);

    let req = options.req;
    return validate(options);
}

/**
* Validates the options. Removes unrecognized properties.
* @param options
* @return clone of options
*/
function validate(options) {
    options = u.deepClone(options);
    let req = options.req;
    let expectedKeys = Object.keys(DEFAULTS);
    for (let key in options) {
        if (expectedKeys.indexOf(key) < 0) {
            delete options[key];
            addMessage(options, null, g.http(u.r(req)).f('Unexpected option found %s.', key));
        } else {
            if (OPTIONS[key].allowed) {
                if (OPTIONS[key].allowed.indexOf(options[key]) < 0) {
                    throw new Error(g.http(u.r(req)).f('Expected %s to have a value in %s, but found %s.', key, OPTIONS[key].allowed, options.openapiVersion));
                }
            }
        }
    }
    return options;
}

/**
* Persists the option by putting it into the open api
* @param swagger open api
* @param options
*/
function persistOptions(options, swagger) {
    swagger['x-ibm-configuration'] = swagger['x-ibm-configuration'] || {};
    swagger['x-ibm-configuration']['x-ibm-apiconnect-wsdl'] = {
        'package-version': u.getVersion(),
        options: {},
        messages: []
    };
    let o = swagger['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].options;
    for (let key in options) {
        if (OPTIONS[key]) {
            if (key === 'messages') {
                // Messages are persisted outside of options
                if (options.messages) {
                    swagger['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages = options.messages;
                }
            } else if (OPTIONS[key].persist == NEVER) {
                // Some options are not persisted
            } else if (OPTIONS[key].persist == IFNOTDEFAULT) {
                // Too reduce complexity, some options are only persisted if their values are different than the default
                if (options[key] !== OPTIONS[key].default) {
                    o[key] = options[key];
                }
            } else {
                // Some options are always persisted.
                o[key] = options[key];
            }
        }
    }
}

/**
* Add a message to the options object
* @param options createOptions
* @param path (optional) path to the context of the message
* @param message
*/
function addMessage(options, path, message) {
    options.messages = options.messages || [];
    if (message.startsWith('((APIC_MESSAGE: ')) {
        message = message.substring('((APIC_MESSAGE: '.length);
        message = message.substring(0, message.length - 2);
    }
    let messageObj = {
        message: message
    };
    if (path && !path.endsWith(u.RESERVED_DEF)) {
        messageObj.$path = path;
    }
    options.messages.push(messageObj);
}

function _getDefaults() {
    let defaults = {};
    for (let key in OPTIONS) {
        defaults[key] = OPTIONS[key].default;
    }
    return defaults;
}

exports.addMessage = addMessage;
exports.create = create;
exports.persistOptions = persistOptions;
exports.validate = validate;
