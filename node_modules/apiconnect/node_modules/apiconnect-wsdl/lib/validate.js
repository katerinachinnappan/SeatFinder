/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Valiate functions for the apiconnect-wsdl parser
**/

var u = require('../lib/utils.js');
var openApiV3 = require('../lib/openApiV3');
var rest = require('../lib/createRESTfromSOAP');

var q = require('q');
var swaggerParser = require('swagger-parser');
var util = require('util');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');
var _ = require('lodash');

/**
 * Inspects a result produced by createOpenApi and adds messages and statistics
 */
function inspectOpenApi(result) {
    result.statistics = result.statistics || {};
    result.messages = result.messages || [];
    try {
        let text = util.inspect(result.openapi, {
            depth: null
        });
        let isSoapRest = result.openapi['x-ibm-configuration'].type === 'wsdl-to-rest';

        result.statistics.referenceCount = (text.match(/\$ref/g) || []).length;
        result.statistics.definitionCount = Object.keys(definitionsOrSchemas(result.openapi)).length;

        let regex = /(APIC_MESSAGE[^)]*)/gi;
        let matches = text.match(regex);
        let total;
        if (matches) {
            for (let i = 0; i < matches.length; i++) {
                let message = matches[i].substring(14);
                if (total.indexOf('(' + message + ')') < 0) {
                    total += '(' + message + ')';
                    result.messages.push({ message: message });
                }
            }
        }
        if (result.openapi['x-ibm-configuration'] &&
            result.openapi['x-ibm-configuration']['x-ibm-apiconnect-wsdl']) {
            let messages = result.openapi['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages;
            if (messages) {
                for (let i = 0; i < messages.length; i++) {
                    let message = messages[i].message;
                    if (messages[i].$path) {
                        message = '(' + messages[i].$path + ')' + message;
                    }
                    result.messages.push({ message: message });
                }
            }
        }
    } catch (err) {
        result.messages.push(err.message);
    }
    return result;
}

/**
 * Checks the (open api) swagger object for various problems.
 * Used in automated testing to help ensure that only valid swagger objects are produced.
 * Also used to analyze customer provided swaggers (which could be from old products or hand generated)
 * Return a promise
 */
function sniffSwagger(swagger, flags) {
    flags = flags ? u.deepClone(flags) : {};
    let req = flags.req;
    var def = q.defer();
    var promiseList = [];
    // Check the whole swagger (root)
    flags.context = 'Root:';
    promiseList.push(_sniffSwagger(u.deepClone(swagger), u.deepClone(flags)));

    // Independently check each embedded target swagger
    if (swagger['x-ibm-configuration'] && swagger['x-ibm-configuration'].targets) {
        for (let target in swagger['x-ibm-configuration'].targets) {
            flags.context = 'Target: ' + target;
            let targetSwagger = u.deepClone(swagger['x-ibm-configuration'].targets[target]);
            u.replaceRefs(targetSwagger,
              [ { target: '#/',
                  source: '#/x-ibm-configuration/targets/' + target + '/' } ]);
            promiseList.push(_sniffSwagger(targetSwagger, u.deepClone(flags)));
        }
    }

    // Once all of the files are done, combine together
    Promise.all(promiseList).then(values => {
        let errorText = '';
        for (let i = 0; i < values.length; i++) {
            if (values[i]) {
                errorText += values[i];
            }
        }
        if (errorText.length > 0) {
            def.reject(new Error(errorText));
        } else {
            def.resolve();
        }
    }).catch(reason => {
        def.reject(reason);
    });
    return def.promise;
}
function _sniffSwagger(swagger, flags) {
    var def = q.defer();
    let req = flags.req;
    try {
        let isSoapRest = swagger['x-ibm-configuration'].type === 'wsdl-to-rest';
        var errorText = '';

        // Look for the words in the swagger.
        // This is an indication that there is a problem.
        var text = util.inspect(swagger, {
            depth: null
        });
        var words = [
            'https://www.w3.org/2003/05/soap-envelope/', // Bad namespace
            'https://www.w3.org/2003/05/soap-envelope' // Bad namespace
        ];
        for (var w = 0; w < words.length; w++) {
            var word = words[w];
            var index = text.indexOf(word);
            if (index >= 0) {
                errorText += g.http(u.r(req)).f('Error: Found illegal text (%s) in this substring (%s).\n', word, text.substring(index - 100, index + 200));
            }
        }

        // Check for very large files
        // Note this is in JSON format versus YAML format
        // The management node max size is about 16M
        if (text.length > 10000000) {
            errorText += g.http(u.r(req)).f('Warning: The openapi file is %s characters long.\n', text.length);
        }

        // Count $ref, exceeding 4000 probably means that this won't publish
        let countRefs = (text.match(/\$ref/g) || []).length;
        if (countRefs > 4000) {
            errorText += g.http(u.r(req)).f('Warning: The number of refs is %s.\n', countRefs);
        }

        // Excessive number of definitions may prevent publishing
        let numDefs = Object.keys(definitionsOrSchemas(swagger)).length;
        if (numDefs > 1000) {
            errorText += g.http(u.r(req)).f('Warning: The number of openapi \'definition\' objects is %s.\n', numDefs);
        }

        // Detect excessive number of paths
        let numPaths = Object.keys(swagger.paths).length;
        if (numPaths > 100) {
            errorText += g.http(u.r(req)).f('Warning: The number of openapi \'path\' objects is %s.\n', numPaths);
        }

        // Check unique names
        if (flags && flags.checkMessages) {
            let defs = definitionsOrSchemas(swagger);
            for (let nsName in defs) {
                let d = defs[nsName];
                let uniq = d['x-xsi-type-uniquename'];
                if (uniq && !defs[uniq] && (d.allOf || d['x-ibm-discriminator'])) {
                    errorText += g.http(u.r(req)).f('Error: \'x-xsi-type-uniquename\' %s for %s is not found.\n', uniq, nsName);
                }
            }
        }
        if (!isSoapRest) {
            let missingPropErrs = findMissingPropertyIssues(swagger, req);
            if (missingPropErrs) {
                errorText += missingPropErrs;
            }
        }
        let polyErrs = findPolyHierarchyProblems(definitionsOrSchemas(swagger, req));
        if (polyErrs && polyErrs.length > 0) {
            errorText += polyErrs;
        }

        // Look for the APICMessages in the swagger.
        // This is an indication that there is a problem.
        if (flags && flags.checkMessages) {
            var regex = /(APIC_MESSAGE[^)]*)/gi;
            var matches = text.match(regex);
            if (matches) {
                for (var i = 0; i < matches.length; i++) {
                    errorText = errorText + matches[i] + '\n';
                }
            }
            if (swagger['x-ibm-configuration'] &&
                swagger['x-ibm-configuration']['x-ibm-apiconnect-wsdl']) {
                let messages = swagger['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages;
                for (let i = 0; i < messages.length; i++) {
                    let message = messages[i].message;
                    if (messages[i].$path) {
                        message = '(' + messages[i].$path + ')' + message;
                    }
                    errorText = errorText + message + '\n';
                }
            }
        }

        // Check example xml to ensure it is valid
        var exampleErrs = validateExampleXML(swagger, req);
        if (exampleErrs) {
            errorText += exampleErrs;
        }

        // Check for inconsistencies with array xmls
        var misMatchedArrayErrs = findMismatchedArrays(swagger, req);
        if (misMatchedArrayErrs) {
            errorText += misMatchedArrayErrs;
        }

        // Check for missing or extra xml objects
        var xmlCheckErrors = checkXMLObjects(swagger, req);
        if (xmlCheckErrors) {
            errorText += xmlCheckErrors;
        }

        // Find very deep inlines, which could indicate a problem.
        var context = {};
        findDeepInlines(swagger, context, isSoapRest, req);
        if (context.list) {
            for (var nsName in context.list) {
                if (!nsName.endsWith('Fault') &&
                    !nsName.endsWith('Input') &&
                    !nsName.endsWith('Output') &&
                     nsName != 'SubCode__SOAP12' &&
                     nsName != 'Security') {
                    errorText += g.http(u.r(req)).f('Info: The \'definition\' %s has an inline depth of %s.\n', nsName, context.list[nsName]);
                }
            }
        }
        if (context.errMsgs) {
            errorText += context.errMsgs;
        }

        // Check gateway
        try {
            u.checkAndSetGateway(swagger, req);
        } catch (e) {
            errorText += e.message;
        }

        // Make sure each prefix is defined to a single namespace.
        var map = getNamespaces(swagger);
        for (var s in map) {
            for (var p in map[s]) {
                if (map[s][p].length > 1) {
                    errorText += g.http(u.r(req)).f('Warning: prefix %s has multiple namespaces %s.\n', p, map[s][p]);
                }
                // Look for inresting namespaces.
                for (let i = 0; i < map[s][p].length; i++) {
                    let ns = map[s][p][i];
                    // OASIS is an organization that defines industry schemas.
                    // Often these schemas use outlier schema constructs.
                    // And since OASIS defines industry schemas, these schemas are often used
                    // across companies.  Thus any strange constructs found in these schemas
                    // could not only span companies but also limit communication in an industry.
                    if (!u.wseRelatedNamespace(ns) &&
                        ns.indexOf('oasis') >= 0) {
                        errorText += 'INFO: prefix ' + p + ' is bound to an OASIS namespace ' + ns + ' \n';
                    }
                }
            }
        }

        validateSwagger(swagger).then(function() {
            if (errorText.length > 0) {
                def.resolve('\n' + flags.context + '\n' + errorText);
            } else {
                def.resolve();
            }
        }, function(err) {
            errorText += err;
            def.resolve('\n' + flags.context + '\n' + errorText);
        });
    } catch (e) {
        let emsg = e.stack;
        def.resolve('\n' + flags.context + '\n' + emsg);
    }
    return def.promise;
}

/**
* Runs a validator against the swagger and returns a promise.
*/
function validateV3(swagger, options) {

    swagger = u.deepClone(swagger);
    replaceRefsWithStringType(swagger);


    if (swagger.openapi) {
        return openApiV3.validate(swagger, options);
    }
    // In production, no validator is available
    let validateDef = q.defer();
    validateDef.resolve();
    return validateDef.promise;
}

/**
* Utility to replace refs with a string so that we can validate it quickly with sway.
*/
function replaceRefsWithStringType(swagger) {
    return u.traverse(swagger, function(obj) {
        if (obj && obj.$ref) {
            delete obj.$ref;
            obj.type = 'string';
        }
        return obj;
    });
}

/**
* Build a namespaces map of prefix->namespace for
* definitions and embedded services.
*/
function getNamespaces(swagger) {
    let service;
    let map = {};

    u.traverseSwagger(swagger, function(swagger) {
        service = swagger['x-ibm-configuration'] && swagger['x-ibm-configuration']['wsdl-definition'] ?
            swagger['x-ibm-configuration']['wsdl-definition'].service : undefined;
        return u.traverseXSO(swagger, function(xso) {
            if (service) {
                map[service] = map[service] || {};
                if (xso.xml && xso.xml.prefix) {
                    if (!map[service][xso.xml.prefix]) {
                        map[service][xso.xml.prefix] = [];
                    }
                    if (map[service][xso.xml.prefix].indexOf(xso.xml.namespace) < 0) {
                        map[service][xso.xml.prefix].push(xso.xml.namespace);
                    }
                }
            }
            return xso;
        });
    });
    return map;
}

/**
* Walk the object and find deep nestings of xso (xml schema objects).
* Deep nestings may indicate a problem with the generator or might indicate
* an usual shape of the input schema.
* While walking the object, other validation checks are also performed.
*/
function findDeepInlines(obj, context, isSoapRest, req) {
    if (Array.isArray(obj)) {
        for (var j = 0; j < obj.length; j++) {
            // recurse array element
            findDeepInlines(obj[j], context, isSoapRest, req);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                // allOf at the nsName level should be limited to 2.
                // Currently we only squash allOfs that are directly conained in the nsName definition
                if (key == 'allOf' && context.nsName && context.properties === 0) {
                    if (obj.allOf.length >= 3) {
                        if (!context.errMsgs) {
                            context.errMsgs = '';
                        }
                        context.errMsgs += g.http(u.r(req)).f('Info: allOf with length: %s found in %s.  There are issues in the assembly tool with allOf with length greater than 2.\n', obj.allOf.length,  context.nsName);
                    }
                }
                if (key == '$ref' && context.nsName) {
                    // There should be no other keys except for description
                    let keysExpected = obj.description ? 2 : 1;
                    let keys = Object.keys(obj);
                    if (keys.length > keysExpected) {
                        if (!context.errMsgs) {
                            context.errMsgs = '';
                        }
                        let msg = g.http(u.r(req)).f('ERROR: Conflicting keys with \'$ref\': %s for %s.  Only \'description\' is allowed with \'$ref\'.\n', keys, context.nsName);
                        if (context.errMsgs.indexOf(msg) < 0) {
                            context.errMsgs += msg;
                        }
                    }
                }
                if (key == 'x-ibm-group' && context.nsName) {
                    let msg = g.http(u.r(req)).f('INFO: Detected x-ibm-group occurrence : %s within %s. ' +
                      'The occurrence of group, sequence, choice and all is only partially supported.\n', obj[key], context.nsName);
                    if (!context.errMsgs) {
                        context.errMsgs = '';
                    }
                    if (context.errMsgs.indexOf(msg) < 0) {
                        context.errMsgs += msg;
                    }
                }
                if (key == 'x-ibm-complex-restriction' && context.nsName) {
                    let msg = 'INFO: Detected x-ibm-complex-restriction : ' + obj[key] + ' within ' + context.nsName + '.\n';
                    if (!context.errMsgs) {
                        context.errMsgs = '';
                    }
                    if (context.errMsgs.indexOf(msg) < 0) {
                        context.errMsgs += msg;
                    }
                }
                if (key == 'definitions'  || key == 'schemas') {
                    context.definitions = obj[key];
                    context.inDefinitions = true;
                    var ref = obj[key];
                    findDeepInlines(obj[key], context, isSoapRest, req);
                    context.inDefinitions = false;
                } else if (context.inDefinitions  && !context.nsName) {
                    context.nsName = key;
                    context.properties = 0;
                    // Make sure this definition has a xml construct
                    if (!isSoapRest && !obj[key].xml) {
                        // The parser probably should put out an xml construct for
                        // definitions for SOAP constructs, but it currently does not.
                        if (!(key.endsWith('Header') ||
                            key.endsWith('HeaderOut') ||
                            key.endsWith('Output') ||
                            key.endsWith('Input') ||
                            key.endsWith('Fault')  ||
                            key == 'APIC__RESERVED')) {
                            if (!context.errMsgs) {
                                context.errMsgs = '';
                            }
                            context.errMsgs += g.http(u.r(req)).f('Warning: No \'xml\' element found for definition %s.\n', key);
                        }
                    }
                    findDeepInlines(obj[key], context, isSoapRest, req);
                    context.nsName = false;
                } else if (context.nsName && key == 'properties') {
                    if (Object.keys(obj[key]).length > 0) {
                        if (context.nsName) {
                            context.properties++;
                            if (context.properties >= 5) {
                                if (!context.list) {
                                    context.list = {};
                                }
                                context.list[context.nsName] = context.properties;
                            }
                        }
                        findDeepInlines(obj[key], context, isSoapRest, req);

                        // Look for malformed properties
                        for (var key2 in obj[key]) {
                            if (obj[key][key2] && typeof obj[key][key2] === 'object') {
                                if (!obj[key][key2].type  && !obj[key][key2]['$ref'] &&  !obj[key][key2]['allOf']  && !obj[key][key2]['x-anyType']) {
                                    if (!context.errMsgs) {
                                        context.errMsgs = '';
                                    }
                                    context.errMsgs += g.http(u.r(req)).f('Error: No \'type\', \'$ref\', \'allof\' or \'x-anyType\' for \'property\' %s in openapi \'definition\' %s.\n', key2, context.nsName);
                                }
                                if (obj[key][key2].type  && obj[key][key2]['$ref'] ||
                                    obj[key][key2].type  && obj[key][key2]['allOf'] ||
                                    obj[key][key2]['$ref'] && obj[key][key2]['allOf'])  {
                                    if (!context.errMsgs) {
                                        context.errMsgs = '';
                                    }
                                    context.errMsgs += g.http(u.r(req)).f('Error: Conflicting \'type\', \'$ref\', and \'allof\' for \'property\' %s in openapi \'definition\' %s.\n', key2, context.nsName);
                                }
                            }
                        }

                        if (context.nsName) {
                            context.properties--;
                        }

                    }
                } else {
                    findDeepInlines(obj[key], context, isSoapRest, req);
                }
            }
        }
    }
}

function checkXMLObjects(swagger, req) {
    let errorText = '';
    let defs;
    let type = swagger['x-ibm-configuration'].type;
    u.traverseXSO(swagger, function(xso, nsName, isRootXSO, path, stack) {
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        let key2 = path.length > 1 ? path[path.length - 2] : undefined;

        if (type === 'wsdl' && xso.type === 'array') {
            let special = key.endsWith('Header') ||
                key.endsWith('HeaderOut') ||
                key.endsWith('Output') ||
                key.endsWith('Input') ||
                key.endsWith('Fault')  ||
                key == 'APIC__RESERVED';
            if (isRootXSO) {
                if (special) {
                    // No check
                } else if (xso.type === 'array') {
                    // Allow but not necessary according to spec.
                    if (xso.xml && !xso.xml.name) {
                        errorText += g.http(u.r(req)).f('Info: Extra xml found for array definition at root of %s.\n',
                          nsName);
                    }
                } else if (xso.$ref) {
                    // Unexpected
                    errorText += g.http(u.r(req)).f('Warning: A $ref was found at the root of %s.\n',
                      nsName);
                } else {
                    if (!xso.xml) {
                        errorText += g.http(u.r(req)).f('Error: Missing xml at root of %s.\n',
                          nsName);
                    }
                }
            } else if (key2 === 'properties' || key === 'items') {
                if (xso.type === 'array') {
                    // Allow but not necessary according to spec.
                    if (xso.xml && !xso.xml.name) {
                        errorText += g.http(u.r(req)).f('Info: Extra xml found for array definition embedded in %s.\n',
                          nsName);
                    }
                } else if (xso.$ref) {
                    // Acceptable
                } else {
                    if (!xso.xml) {
                        errorText += g.http(u.r(req)).f('Error: Missing xml embedded in %s.\n',
                          nsName);
                    }
                }
            } else {
                // Add message if there is an xml
                if (xso.xml && !xso.xml.name) {
                    errorText += g.http(u.r(req)).f('Info: Extra xml found for %s embedded in %s.\n',
                      key, nsName);
                }
            }
        }
        return xso;
    }, function(xso, nsName, isRootXSO, path, stack) {
        let key = path.length > 1 ? path[path.length - 2] : undefined;
        if (isRootXSO) {
            defs = stack[stack.length - 1];
            if (!key) {
                type = swagger['x-ibm-configuration'].type;
            } else if (key === 'definitions') {
                type = stack[stack.length - 2]['x-ibm-configuration'].type;
            } else {
                type = stack[stack.length - 3]['x-ibm-configuration'].type;
            }
        }
        return xso;
    });
    return errorText;
}

function findMismatchedArrays(swagger, req) {
    let errorText = '';
    let defs;
    let type = swagger['x-ibm-configuration'].type;
    u.traverseXSO(swagger, function(xso, nsName, isRootXSO, path, stack) {
        let key = path[path.length - 1];
        if (type === 'wsdl' && xso.type === 'array') {
            let xso2;
            if (xso.items) {
                if (xso.items.$ref) {
                    let nsName2 = u.getDefNameFromRef(xso.items.$ref);
                    xso2 = defs[nsName2];
                } else {
                    xso2 = xso.items;
                }
                // Expect to find an xml object within the items object since that is the xml
                // that is used for array namespaces.
                // However, in some situations the xml object is also repeated (for clarity)
                // at the same level as the items object.  In those cases, xml object must
                // be the same information.
                if (!xso2.xml) {
                    errorText += g.http(u.r(req)).f('Warning: Expected xml object within items while processing %s.\n',
                      nsName);
                }
                if (xso.xml && xso2.xml &&
                    xso2.xml.namespace !== xso.xml.namespace) {
                    errorText += g.http(u.r(req)).f('Error: Expected items namespace %s to be the same as the array namespace %s while processing %s in %s.\n',
                      xso2.xml.namespace, xso.xml.namespace, key, nsName);
                }
                if (xso.xml && xso.xml.wrapped) {
                    errorText += g.http(u.r(req)).f('The \'wrapped\' property is not supported.  The \'wrapped\' property was found while examining %s.\n',
                      nsName);
                }
            } else {
                errorText += g.http(u.r(req)).f('Warning: Expected items while processing %s.\n', nsName);
            }
        }
        return xso;
    }, function(xso, nsName, isRootXSO, path, stack) {
        let key = path.length > 1 ? path[path.length - 2] : undefined;
        if (isRootXSO) {
            defs = stack[stack.length - 1];
            if (!key) {
                type = swagger['x-ibm-configuration'].type;
            } else if (key === 'definitions') {
                type = stack[stack.length - 2]['x-ibm-configuration'].type;
            } else {
                type = stack[stack.length - 3]['x-ibm-configuration'].type;
            }
        }
        return xso;
    });
    return errorText;
}

function findMissingPropertyIssues(swagger, req) {
    let defs = definitionsOrSchemas(swagger);
    let errorText = '';
    for (let nsName in defs) {
        let def = defs[nsName];
        if (def.allOf && def.allOf.length > 0 && def.allOf[0].$ref) {
            let nsName2 = u.getDefNameFromRef(def.allOf[0].$ref);
            let def2 = defs[nsName2];
            if (!def.xml) {
                errorText += g.http(u.r(req)).f('Warning: Missing xml object on %s.\n', nsName);
            }
            if (!def2.xml) {
                errorText += g.http(u.r(req)).f('Warning: Missing xml object on %s.\n', nsName2);
            }
            // Make sure all of the def2 properties have an xml
            if (def2.properties) {
                for (let propName in def2.properties) {
                    let prop = def2.properties[propName];
                    if (prop.type === 'array') {
                        prop = prop.items;
                    }
                    if (!prop.$ref && !prop.xml) {
                        if (def.xml.namespace != def2.xml.namespace) {
                            errorText += g.http(u.r(req)).f('Error: Property %s in %s has no xml and this could be a problem because it is referenced in %s .\n', propName, nsName2, nsName);
                        } else {
                            // errorText += g.http(u.r(req)).f('Info: Property %s in %s has no xml.\n', propName, nsName2, nsName);
                        }
                    }
                }
            }
            if (def2.allOf) {
                for (let i = 0; i < def2.allOf.length; i++) {
                    let allOf = def2.allOf[i];
                    if (allOf.properties) {
                        for (let propName in allOf.properties) {
                            let prop = allOf.properties[propName];
                            if (prop.type === 'array') {
                                prop = prop.items;
                            }
                            if (!prop.$ref && !prop.xml) {
                                if (def.xml.namespace != def2.xml.namespace) {
                                    errorText += g.http(u.r(req)).f('Error: Property %s in %s has no xml and this could be a problem because it is referenced in %s .\n', propName, nsName2, nsName);
                                } else {
                                    // errorText += g.http(u.r(req)).f('Info: Property %s in %s has no xml.\n', propName, nsName2, nsName);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errorText;
}

/**
* ValidateSwagger with the swaggerParser
*/
function validateSwagger(swagger) {
    if (swagger.openapi) {
        return validateV3(swagger);
    }
    var validateDef = q.defer();

    // Unfortunately the parser can hang if there are certain kinds of circular references.
    // Disabling circular references does not seem to work.
    // As a work around replace refs with string types.
    swagger = u.deepClone(swagger);
    replaceRefsWithStringType(swagger);
    swaggerParser.validate(swagger, {
        allow: {
            unknown: false,
            empty: false
        },
        $refs: {
            external: false
        },
        validate: {
            // spec: true
        }
    }).then(function(api) {
        validateDef.resolve();
    }, function(err) {
        var returnError = '';
        var lines = err.message.match(/[^\r\n]+/g);
        for (var i = 1; i < lines.length; i++) {
            // Prune silly stuff
            var line = lines[i];
            if (line.indexOf('Expected type number but found type string') >= 0 ||
                line.indexOf('JSON_OBJECT_VALIDATION_FAILED') >= 0 ||
                line === ' ') {
                // Accept
            } else {
                returnError = returnError + line + '\n';
            }
        }
        if (returnError.length > 0) {
            returnError = lines[0] + '\n' + returnError; // Add error message header line
            validateDef.reject(new Error(returnError));
        } else {
            validateDef.resolve();
        }
    });
    return validateDef.promise;
}

/**
* Find the examples (which are xml) and validate them with a DOMParser.
* Errors in the examples may indicate problems in the generation code
* because the example generator walks the swagger to produce the example.
*/
function validateExampleXML(swagger, req) {
    var errorText = '';
    let totalLength = 0;
    try {
        let ds = definitionsOrSchemas(swagger);
        if (ds) {
            for (var nsName in ds) {
                var def = ds[nsName];
                var xml = def.example;
                if (xml) {
                    if (xml.length < 10000) {
                        try {
                            var DOMParser = require('xmldom').DOMParser;
                            var doc = new DOMParser().parseFromString(xml);
                        } catch (err) {
                            errorText += err + '\n';
                        }
                    } else {
                        // errorText += g.http(u.r(req)).f('Error: Large example %s encountered for %s.\n', xml.length, nsName);
                        totalLength += xml.length;
                    }
                }
            }
            if (totalLength > 1000000) {
                errorText += g.http(u.r(req)).f('Error: Excessive number of example characters %s.\n', totalLength);
            }
        }
    } catch (e) {
        return e + '\n' + errorText;
    }
    return errorText;
}

/**
* @returns definitions (V2) or components.schemas (V3)
*/
function definitionsOrSchemas(swagger) {
    let d;
    if (swagger.openapi) {
        d = swagger.components ? swagger.components.schemas : null;
    } else {
        d = swagger.definitions;
    }
    return d || {};
}

function findPolyHierarchyProblems(definitions, req) {
    // Get ref counts
    let map = u.findRefs(definitions);
    let uniqueNames = {};
    let errorText = '';
    let subTypes = u.getSubTypes(definitions);

    for (let nsName in definitions) {
        let def = definitions[nsName];
        let anc = u.getAncestorRefs(definitions, nsName, req);
        if (u.inPolyHierarchy(definitions, nsName, anc, map)) {
            // If in a poly hierchy than the unique name must be unique to that hierarchy
            if (!def['x-xsi-type-uniquename']) {
                // Some SOAP generated items (faults) may lack a x-xsi-type-uniquename...try to distinguish
                // by looking for a generated example
                if (!def.example) {
                    errorText += g.http(u.r(req)).f('ERROR: x-xsi-type-uniquename of %s is not set.\n', nsName);
                }
            } else if (anc) {
                // If not a root, calculate a name form unique name and parent name.
                let name = def['x-xsi-type-uniquename'] + ':' + u.getDefNameFromRef(anc[0]);
                if (uniqueNames[name]) {
                    // if (nsName.endsWith('_nil')  || uniqueNames[name].endsWith('_nil')) {
                    //  errorText += 'WARNING: Hierachy Collision between ' + nsName + ' and ' + uniqueNames[name] + '.  Known issue with nillable/non-nillable patchup.\n';
                    // } else {
                    errorText += g.http(u.r(req)).f('ERROR: Hierachy Collision between %s and %s.\n', nsName, uniqueNames[name]);
                    // }
                } else {
                    uniqueNames[name] = nsName;
                }
            }
            let descendents = u.getDescendents(nsName, subTypes);
            if (descendents.length > 20) {
                errorText += g.http(u.r(req)).f('INFO: Large Hierarchy for %s containing %s.\n', nsName, descendents);
            }
        }
    } return errorText;
}


exports.getNamespaces = getNamespaces;
exports.inspectOpenApi = inspectOpenApi;
exports.sniffSwagger = sniffSwagger;
exports.replaceRefsWithStringType = replaceRefsWithStringType;
