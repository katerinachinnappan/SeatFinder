/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Utility functions to generate SwaggerDefinition the apiconnect-wsdl parser
**/
const u = require('../lib/utils.js');
const dictionary = require('../lib/dictionary.js');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

var assert = require('assert');
var util = require('util');
var _ = require('lodash');

// Context of referencing element or attribute
var UNQUALNS = 'UNQUALIFIED_NAME_SPACE';

// Child descriptions place on parent or on Child
var CHILD_DESCRIPTION_PLACED_ON_PARENT = false;

/**
*  The dictionary contains the node.soap schema for each ns name.
*  For example, dict.dictEntry['foo_ns1'].schema is the schema for the foo element or type
*  in ns1.
*
*  An ns name is referenced by other types and elements.  The referencing context
*  determines the namespace qualification (or no namespace qualification..aka unqualified) of
*  the referencing type.  (And the defining context defines the namespace qualification of the inner types, extensions, etc).
*  Thus if foo_ns1 is referenced in a qualified schema, ns2, then the code needs to generate a
*  swagger definition unique for that context  (foo_ns1_ns2).  Or if foo_ns1 is referenced in an unqualified schema,
*  then the code needs to generate a foo_ns1_unqual definition.  (Note that there are some optimizations to
*  help reduce the number of definitions...thus we might generate foo_ns1 instead of foo_ns_unqual).
*
*  Summary: The swagger definition is the product of a (nsName, referencingContext).
*/

/**
* Add a reference to the reference map.
* The dictionary item being referenced is nsName and the referencingContext is the information about the reference
* @param refMap is the reference map
* @param nsName is target name
* @param referencingContext
*/
function addReference(refMap, nsName, referencingContext) {
    referencingContext = u.deepClone(referencingContext);
    if (!refMap[nsName]) {
        refMap[nsName] = {
            offset: 0,
            referencingContexts: [ referencingContext ]
        };
    } else {
        // Add the referencing context if not found
        let found = false;
        let len = refMap[nsName].referencingContexts.length;
        for (let i = 0; i < len; i++) {
            if (referencingContext.ns == refMap[nsName].referencingContexts[i].ns &&
                referencingContext.xmlName == refMap[nsName].referencingContexts[i].xmlName &&
                referencingContext.attribute == refMap[nsName].referencingContexts[i].attribute) {
                found = true;
                break;
            }
        }
        if (!found) {
            refMap[nsName].referencingContexts.push(referencingContext);
        }
    }
}

/**
* @return the definition name for a (nsName + referencingContext)
*/
function getDefinitionName(nsName, referencingContext, namespaces) {
    let definitionName = nsName;
    let contextSuffix = '';

    if (referencingContext && referencingContext.attribute) {
        contextSuffix += '_attr';
    }
    if (referencingContext && referencingContext.ns) {
        if (referencingContext.ns == UNQUALNS) {
            contextSuffix += '_unqual';
        } else {
            contextSuffix += '_' + u.getPrefixForNamespace(referencingContext.ns, namespaces);
        }
    }

    if (referencingContext && referencingContext.xmlName) {
        contextSuffix += '_of_' + referencingContext.xmlName;
    }

    definitionName = (contextSuffix == '') ? definitionName : definitionName + contextSuffix;

    return definitionName;
}

/*
* Create the Swagger Definitions for the references in refMap.
*/
function generateSwaggerDefinitions(definitions, refMap, dict, namespaces, oldRefMap, totalRefMap) {

    // Create a clone of the refMap.
    // New references will be added to the cloned refMap by the generateSwaggerDefinition function
    let cloneRefMap = u.extendObject({}, refMap);

    // Compare the refMap to the old refMap and create a list
    // of the name value pairs that need to be processed.
    oldRefMap = oldRefMap || {};
    let refList = u.disjointKeysToArray(refMap, oldRefMap);

    let len = refList.length;
    for (var i = 0; i < len; i++) {
        // The refList has a name (which is the nsName)
        // and a value (which is the referencingContext array and an offset)
        // The offset indicates which referencingContexts have already been processed.
        // For example name (foo_ns) might have 1 referencingContext, but additional
        // referencingContexts are discovered during this recursive generation code.
        // The offset is the indicator of which referencingContexts have been processed
        // and which have not.
        let nameValue = refList[i];
        let nsName = nameValue.name;
        let value = nameValue.value;

        let rcLen = value.referencingContexts.length;
        for (var j = value.offset; j < rcLen; j++) {
            addReference(totalRefMap, nsName, value.referencingContexts[j]);
            generateSwaggerDefinition(nsName, value.referencingContexts[j], definitions, cloneRefMap, dict, namespaces);
        } // end for
        // track how far we are through the array
        refMap[nsName].offset = rcLen;
    }

    // Find the newly added references and generate those swagger definitions.
    if (len > 0) {
        generateSwaggerDefinitions(definitions, cloneRefMap, dict, namespaces, refMap, totalRefMap);
    }
}

/**
* Create a Swagger Definitions for the nsName + referencingContext
*/
function generateSwaggerDefinition(nsName, referencingContext, definitions, refMap, dict, namespaces) {
    var definition;
    var definitionName;
    var updated = false;
    let uniqueSuffix = '';


    // Type is the name of the root element, root attribute or root type
    // A root attribute will have attribute appended to the end
    // Example:
    //    Stock_s1
    //    Stock_s1_attr
    //
    // The referencing context provides additional information.
    // For example, the reference to a (simple) type might be from an attribute
    // For example, the reference to the type might be from a different or unqualified namespace.
    // The referencing information causes a new definition to be created.
    // Example:
    //     Stock_s1_unqual  means that the Stock_s1 type is referenced in an unqualified context
    //     Stock_s1_attr_s2 means that the Stock_s1 type is referenced by an attribute in a namespace corresponding to s2
    //
    let dictEntry = dict.dictEntry[nsName];
    if (dictEntry) {

        // Create the definition name from the nsName and the referencingContext information
        definitionName = getDefinitionName(nsName, referencingContext, namespaces);
        let originalReferencingContext = u.deepClone(referencingContext);
        if (referencingContext.ns) {
            uniqueSuffix += (referencingContext.ns == UNQUALNS) ? '_unqual' : '_' + u.getPrefixForNamespace(referencingContext.ns, namespaces);
        }

        // Create the definition
        if (!definitions[definitionName]) {
            if (!referencingContext.ns) {
                // If the name is used as an element, then set the reference to the namespace of the element.
                // otherwise set it to the tns if qualified or UNQUAL if not qualified
                if (dict.elementNS[nsName]) {
                    referencingContext.ns = dict.elementNS[nsName].xml.ns;
                } else {
                    referencingContext.ns = dictEntry.qualified ? dictEntry.tns : UNQUALNS;
                }
            }

            definition = generateSwaggerXSO(dictEntry, dict, refMap, namespaces, referencingContext, originalReferencingContext);
            definitions[definitionName] = definition;
            updated = true;
        }
    }

    // Add xmlname and attribute
    if (updated && definition.xml) {
        if (referencingContext && referencingContext.xmlName) {
            definition.xml.name = referencingContext.xmlName;
        }
        if (referencingContext && referencingContext.attribute) {
            definition.xml.attribute = true;
        }
    }

    // Generate xsi type for types/elements but not for attributes
    if (updated && dictEntry && dictEntry.schema &&
       !dictEntry.isAttribute && !(referencingContext && referencingContext.attribute)) {
        if (dict.originalNames[nsName]) {
            // XSI type is the original type name...which is either the name from the original schema or the original name.
            if (dictEntry.suppressXSIType) {
                // (If the schema has suppressXSIType, then this must be a root element that was not overwritten with its type schema:
                //   <element name="example" type="string" />
                //  in such cases we don't need an x-xsi-type...if we did it must be created from the type= value)
            } else if (dictEntry.schema['undefined'] && dictEntry.schema['undefined'].name) {
                // (If the original type is an element, then the name on the schema is its type name due to the way schema object is replicated)
                definition['x-xsi-type'] = dictEntry.schema['undefined'].name;
            } else if (dict.originalNames[nsName]) {
                definition['x-xsi-type'] = dict.originalNames[nsName].name;
            }
        }
        if (definition['x-xsi-type']) {
            let isAbstract = dictEntry && dictEntry.schema['undefined'] && dictEntry.schema['undefined'].abstract &&
                dictEntry.schema['undefined'].abstract.toLowerCase()  === 'true';

            // If x-xsi-type is set, then check for the following case:
            //  <element name="foo" type="abstractbase" />
            //
            // In such cases, abstractbase_ns1 will be marked with an x-ibm-descriminator, but we
            // also need to make sure that foo_ns1 is marked. Use the linkup field to get the type
            // and then check subTypes to see if the type is a base.
            if (dictEntry &&
                dictEntry.schema['undefined'] &&
                dictEntry.schema['undefined'].linkup) {
                var linkup = dictEntry.schema['undefined'].linkup;
                if (dict.subTypes[linkup]) {
                    definition['x-ibm-discriminator'] = true;
                }

                let typeDictEntry = dict.dictEntry[linkup];
                if (typeDictEntry && typeDictEntry.schema['undefined'] &&
                    typeDictEntry.schema['undefined'].abstract &&
                    typeDictEntry.schema['undefined'].abstract.toLowerCase()  === 'true') {
                    isAbstract = true;
                }
            }

            if (isAbstract) {
                definition['x-xsi-type-abstract'] = true;
            }

            // In addition, also set the x-xsi-type-xml object from the location of the original type
            if (dictEntry && dictEntry.tns) {
                definition['x-xsi-type-xml'] = {
                    namespace: dictEntry.tns
                };
                definition['x-xsi-type-xml'].prefix = u.getPrefixForNamespace(dictEntry.tns, namespaces);
                if (dictEntry.hiddenType) {
                    // If hidden type use the mangled name
                    definition['x-xsi-type-uniquename'] = dictEntry.hiddenType + uniqueSuffix;
                } else {
                    definition['x-xsi-type-uniquename'] =  definition['x-xsi-type'] + '_' +
                     definition['x-xsi-type-xml'].prefix + uniqueSuffix;
                }
            }
        }
    }
}


// Generate a Open API (Swagger) XML Schema Object (aka XSO)
// An XML Schema Object is defined by Open API as the represntation of an XML construct.
// Each definition in the definitions section is an XML Schema Object.
// And definitions may have embedded, inlined XMLSchma Object.
// The generateSwaggerXSO is the common code for all XSO generation
function generateSwaggerXSO(dictEntry, dict, refMap, namespaces, referencingContext, originalReferencingContext) {
    let req = dict.req;
    dictionary.complexityLimitCheck(dict);
    if (dictEntry.schemaType == 'predefined') {
        if (dictEntry.schema.annotation) {
            if (dictEntry.schema.annotation.documentation) {
                dictEntry.definition.description = u.cleanupDocumentation(dictEntry.schema.annotation.documentation, req);
            }
        }
        return dictEntry.definition;
    } else if (dictEntry.schemaType == 'anyType') {
        let xso = {};
        setXSOxml(xso, referencingContext, namespaces, dictEntry.tns, dictEntry.isAttribute);
        if (dictEntry.schema && dictEntry.schema.annotation) {
            if (dictEntry.schema.annotation.documentation) {
                xso.description = u.cleanupDocumentation(dictEntry.schema.annotation.documentation, req);
            }
        }
        return xso; // An anyType will have no type
    } else {
        let xso;
        if (dictEntry.schemaType == 'simple') {
            xso = generateSwaggerXSO_forSimpleType(dictEntry, dict, refMap, namespaces, referencingContext, originalReferencingContext);
        } else {
            xso = generateSwaggerXSO_forComplexType(dictEntry, dict, refMap, namespaces, referencingContext, originalReferencingContext);
        }
        return u.squashAllOf(xso);
    }
}

/**
* Set the xml object on the xso using the referencing context
*/
function setXSOxml(xso, referencingContext, namespaces, tns, isAttribute) {
    xso.xml = {};
    if (referencingContext && referencingContext.ns) {
        if (referencingContext.ns == UNQUALNS) {
            xso.xml.namespace = '';
            xso.xml.prefix = '';
        } else {
            xso.xml.namespace = referencingContext.ns;
            xso.xml.prefix = u.getPrefixForNamespace(referencingContext.ns, namespaces);
        }
    } else {
        xso.xml.namespace = tns;
        xso.xml.prefix = u.getPrefixForNamespace(tns, namespaces);
    }
    xso.xml.attribute = isAttribute;
}

// Generate a Open API (Swagger) XML Schema Object (aka XSO) for a simpleType
function generateSwaggerXSO_forSimpleType(dictEntry, dict, refMap, namespaces, referencingContext, originalReferencingContext) {
    let req = dict.req;
    let xso = {};
    setXSOxml(xso, referencingContext, namespaces, dictEntry.tns, dictEntry.isAttribute);

    // schema will contain a restriction, list or union
    if ('list' in dictEntry.schema) {
        // xsd:list is a whitespace delimited string of the types defined in the itemType attribute.
        // This is an uncommon usage, and the best approach is to map to a string
        xso.type = 'string';
    } else if (dictEntry.schema.restriction) {
        processSchemaSimpleRestriction(dictEntry.schema.restriction, xso, dict, dictEntry, refMap, namespaces);
    } else if ('union' in dictEntry.schema) {
        handleUnionRef(dictEntry.schema.union, dictEntry, dict, refMap, xso, namespaces, dictEntry.tns);
    }

    // Convert the annotations after processing the other elements because that processing may add additional annotations.
    if (dictEntry.schema.annotation) {
        // include annotation as description
        if (dictEntry.schema.annotation.documentation) {
            xso.description = u.cleanupDocumentation(dictEntry.schema.annotation.documentation, req);
        }
    }
    return xso;
}

function handleUnionRef(union, dictEntry, dict, refMap, xso, namespaces, tns) {
    let req = dict.req;
    xso.anyOf = [];

    if (union.simpleType) {
        union.simpleType = u.makeSureItsAnArray(union.simpleType);
        for (let i = 0; i < union.simpleType.length; i++) {
            let simpleSchema = {
                tns: tns,
                schemaType: 'simple',
                schema: union.simpleType[i],
                xmlns: dictEntry.xmlns,
                qualified: dictEntry.qualified,
                qualifiedAttr: dictEntry.qualifiedAttr
            };
            let referencingContext = {};
            var simpleXSO = generateSwaggerXSO(simpleSchema, dict, refMap, namespaces, {});
            xso.anyOf.push(simpleXSO);
        }
    }
    if (union['undefined'] && union['undefined'].memberTypes) {
        let memberTypes = _.split(union['undefined'].memberTypes, ' ');
        for (let i = 0; i < memberTypes.length; i++) {
            let nsName = dictionary.bestMatch(memberTypes[i], dictEntry, dict, namespaces, false, false, false, true);
            let isXSD = dictionary.isXSDType(memberTypes[i], namespaces, dictEntry.xmlns);
            if (dict.dictEntry[nsName]) {
                let refNSName = getDefinitionName(nsName, {}, namespaces);
                addReference(refMap, nsName, {});
                xso.anyOf.push({
                    $ref: '#/definitions/' + refNSName
                });
            } else if (isXSD) {
                let xsdXSO = mapXSDTypeToSwagger(u.stripNamespace(memberTypes[i]), dict);
                xso.anyOf.push(xsdXSO);
            } else {
                dictionary.annotateWithParserMessage(dictEntry.schema,
                  g.http(u.r(req)).f('The \'memberType\' %s of the \'union\' element cannot be found.', memberTypes[i]));
            }
        }
    }
    return xso;
}


// Generate a Open API (Swagger) XML Schema Object (aka XSO) for a complexType
function generateSwaggerXSO_forComplexType(dictEntry, dict, refMap, namespaces, referencingContext, originalReferencingContext) {
    originalReferencingContext = originalReferencingContext || {};
    let req = dict.req;
    var xso = {};
    var contextFlags = {};
    setXSOxml(xso, referencingContext, namespaces, dictEntry.tns);

    if (dictEntry.schema.complexContent) {
        contextFlags.originalReferencingContext = originalReferencingContext;
        handleComplexContentRef(dictEntry.schema.complexContent, dictEntry, dict, refMap, xso,
          namespaces, dictEntry.tns, contextFlags);
        handleAnnotationRef(dictEntry.schema, xso, req);
        return xso;
    } else if (dictEntry.schema.simpleContent) {
        contextFlags.originalReferencingContext = originalReferencingContext;
        handleSimpleContentRef(dictEntry.schema.simpleContent, dictEntry, dict, refMap, xso,
          namespaces, dictEntry.tns, contextFlags);
        handleAnnotationRef(dictEntry.schema, xso, req);
        return xso;
    }

    // The construct mixed=true is not supported for the general case,
    // but if there are no elements in the complexType, then we map the mixed content to a string.
    var mixedContentMappedToString = false;
    if (dictEntry.schemaType === 'complex' && dictEntry.schema['undefined'] && dictEntry.schema['undefined'].mixed === 'true') {
        if (dictEntry.schema.sequence ||
            dictEntry.schema.all ||
            dictEntry.schema.choice ||
            dictEntry.schema.group) {
            // Allow sequence with just an any element
            if (dictEntry.schema.sequence) {
                let s = dictEntry.schema.sequence;
                if (s.any &&
                    !(s.element || s.group || s.sequence || s.all || s.choice || s.list)) {
                    mixedContentMappedToString = true;
                }
            }
        } else {
            mixedContentMappedToString = true;
        }
        if (!mixedContentMappedToString) {
            dictionary.annotateWithParserMessage(dictEntry.schema, g.http(u.r(req)).f('The \'mixed=true\' attribute is ignored.'));
        }
    }

    // Only a single sequence, group, all or choice reference is allowed.
    detectMultipleSGAC(dictEntry.schema, dictEntry, req);

    xso.allOf = [ {
        xml: u.deepClone(xso.xml),
        type: 'object',
        properties: {}
    } ];
    handleSGACRef(dictEntry.schema, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns, contextFlags);

    // attributes can appear in addition to other entries
    if (dictEntry.schema.attribute) {
        handleAttributeRef(dictEntry.schema.attribute, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
    }
    if (dictEntry.schema.attributeGroup) {
        handleAttributeGroupRef(dictEntry.schema.attributeGroup, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
    }

    if (mixedContentMappedToString) {
        // Put the attributes in an allOf and then add a string for the mixed content
        xso = {
            xml: u.deepClone(xso.xml),
            allOf: [
                u.deepClone(xso),
                {
                    xml: u.deepClone(xso.xml),
                    type: 'string'
                }
            ]
        };
    }
    handleAnnotationRef(dictEntry.schema, xso, req);

    // Remove unnecessary property object
    if (xso.properties && _.isEmpty(xso.properties) && xso.type && xso.type !== 'object') {
        delete xso.properties;
    }
    return xso;
}

/**
* Detect multiple sequence, group, all or choice references and issue a message if a violation is found.
*/
function detectMultipleSGAC(schema, dictEntry, req) {
    // Alert if multiple constructs defined
    let countConstructs = 0;
    if (schema.sequence) {
        countConstructs += Array.isArray(schema.sequence) ? schema.sequence.length : 1;
    }
    if (schema.all) {
        countConstructs += Array.isArray(schema.all) ? schema.all.length : 1;
    }
    if (schema.choice) {
        countConstructs += Array.isArray(schema.choice) ? schema.choice.length : 1;
    }
    if (schema.group) {
        countConstructs += Array.isArray(schema.group) ? schema.group.length : 1;
    }
    if (countConstructs > 1) {
        dictionary.annotateWithParserMessage(dictEntry.schema, g.http(u.r(req)).f('A \'complexType\' may contain only one \'sequence\', one \'choice\', one \'group\', or one \'all\'. Please correct the schema.'));
    }
}

/**
* Add the annotation documentation to the xso.desciption
*/
function handleAnnotationRef(schema, xso, req) {
    if (schema.annotation) {
        // include annotation as description
        if (schema.annotation.documentation) {
            xso.description = u.cleanupDocumentation(schema.annotation.documentation, req);
        }
    }
}

/**
* handle simpleContent reference within the xso
*/
function handleSimpleContentRef(simpleContent, dictEntry, dict, refMap, xso, namespaces, tns, contextFlags) {
    let req = dict.req;
    if (simpleContent['undefined'] && simpleContent['undefined'].mixed === 'true') {
        dictionary.annotateWithParserMessage(dictEntry.schema, 'The mixed=true attribute on simpleContent is ignored.');
    }
    // look for extension of primitive type
    let extension = dictEntry.schema.simpleContent.extension;
    let restriction = dictEntry.schema.simpleContent.restriction;
    if (extension) {
        delete xso.type;
        delete xso.properties;
        xso.allOf = [ {
            xml: u.deepClone(xso.xml),
            type: 'object',
            properties: {}
        } ];
        let baseType = dictionary.resolveNameInNamespace(extension['undefined'].base, dictEntry.xmlns, namespaces, null, dict, false, null, true);
        if (baseType) {
            if (dict.dictEntry[baseType]) {
                let baseNSName = getDefinitionName(baseType, contextFlags.originalReferencingContext, namespaces);
                addReference(refMap, baseType, contextFlags.originalReferencingContext);
                newXSO(xso.allOf);
                xso.allOf[0] = { $ref: '#/definitions/' + baseNSName };
            } else {
                var simpleType = mapXSDTypeToSwagger(u.stripNamespace(extension['undefined'].base), dict);
                u.extendObject(lastXSO(xso.allOf), simpleType);
            }
        }
        // attributes can appear on extensions
        if (extension.attribute) {
            handleAttributeRef(extension.attribute, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
        }
        if (extension.attributeGroup) {
            handleAttributeGroupRef(extension.attributeGroup, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
        }
    } else if (restriction) {
        processSchemaSimpleRestriction(restriction, xso, dict, dictEntry, refMap, namespaces);
    }
    return xso;
}

/**
* handle contentContent reference within the xso
*/
function handleComplexContentRef(complexContent, dictEntry, dict, refMap, xso, namespaces, tns, contextFlags) {
    let req = dict.req;
    if (complexContent['undefined'] && complexContent['undefined'].mixed === 'true') {
        dictionary.annotateWithParserMessage(dictEntry.schema, 'The mixed=true attribute on complexContent is ignored.');
    }
    xso.type = 'object';
    xso.properties = {};
    let restriction = complexContent.restriction;
    let extension = complexContent.extension;
    if (restriction) {
        let baseType = u.stripNamespace(restriction['undefined'].base);
        if (baseType) {
            baseType = baseType.toLowerCase();
            if (baseType == 'array') {
                dictionary.annotateWithParserMessage(dictEntry.schema, g.http(u.r(req)).f('A \'restriction\' of a \'soap-enc\' array is not fully supported.'));
                // deal with array types
                let attribute = restriction.attribute;
                if (attribute) {
                    for (var attr in attribute['undefined']) {
                        var attrName = u.stripNamespace(attr).toLowerCase();
                        if (attrName == 'arraytype') {
                            var rawArrayType = attribute['undefined'][attr];
                            if (rawArrayType.indexOf('[]', rawArrayType.length - 2) != -1) {
                                rawArrayType = rawArrayType.substr(0, rawArrayType.length - 2);
                            }
                            var arrayType = dictionary.getNsName(rawArrayType);
                            xso.type = 'array';
                            delete xso.properties;
                            xso.items = {};
                            if (dict.dictEntry[arrayType]) {
                                // reference is to another type - recurse
                                // only include if we've not already seen it as a parent type
                                addReference(refMap, arrayType, {});
                                xso.items['$ref'] = '#/definitions/' + arrayType;
                            } else {
                                let swaggerType = mapXSDTypeToSwagger(u.stripNamespace(rawArrayType), dict);
                                u.extendObject(xso.items, swaggerType);
                            }
                            break;
                        }
                    } // end for
                }
            } else {
                // Restriction of complexContent is rare
                // Add the elements in the embedded sequence.
                // The base is read, and used to set up the xml information
                let baseType = dictionary.bestMatch(restriction['undefined'].base, dictEntry, dict, namespaces, false, false, false, true);
                if (!baseType || !dict.dictEntry[baseType] || !dict.dictEntry[baseType].schema) {
                    dictionary.annotateWithParserMessage(dictEntry.schema,
                      g.http(u.r(req)).f('The \'base\' %s of the \'restriction\' element cannot be found.', restriction['undefined'].base));
                } else {
                    let baseSchema = dict.dictEntry[baseType];
                    let baseNSName = getDefinitionName(baseType, contextFlags.originalReferencingContext, namespaces);
                    addReference(refMap, baseType, contextFlags.originalReferencingContext);
                    // use an allOf so that we can separate the xml stanza
                    // of the caller from the xml of the restriction base
                    // The x-ibm-complex-restriction flag is used in post
                    // generate to insert the attributes from the base definition
                    delete xso.type;
                    delete xso.properties;
                    xso.allOf = [];
                    xso['x-ibm-complex-restriction'] = baseNSName;
                    contextFlags.inAllOf = true;

                    xso.allOf.push({
                        $ref: '#/definitions/' + baseNSName
                    });

                    // Create properties for the restricted sequence
                    let xsoContent = {
                        xml: {},
                        type: 'object',
                        properties: {}
                    };
                    xso.allOf.push(xsoContent);

                    // For a restriction, the referencing context is not this schema it is the
                    // the schema of the base type.
                    if (baseSchema.qualified) {
                        xsoContent.xml.namespace = baseSchema.tns;  // Changed to restriction base
                        xsoContent.xml.prefix = u.getPrefixForNamespace(baseSchema.tns, namespaces);
                    } else {
                        xsoContent.xml.namespace = '';
                        xsoContent.xml.prefix = '';
                    }
                    handleSGACRef(restriction, baseSchema, dict, refMap, xso.allOf, namespaces, baseSchema.tns, contextFlags);
                    // attributes can appear on restriction
                    if (restriction.attribute) {
                        handleAttributeRef(restriction.attribute, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
                    }
                    if (restriction.attributeGroup) {
                        handleAttributeGroupRef(extension.attributeGroup, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
                    }
                }
            }
        }
    }
    // look for extension of existing type
    if (extension) {
        delete xso.type;
        delete xso.properties;
        xso.allOf = [ {
            xml: u.deepClone(xso.xml),
            type: 'object',
            properties: {}
        } ];
        let baseType = dictionary.bestMatch(extension['undefined'].base, dictEntry, dict, namespaces, false, false, false, true);
        if (baseType) {
            if (dict.dictEntry[baseType]) {
                // Adjust the name per the referencingContext
                // Example, if we are generating Ext_S1_unqual then the baseType will
                // be something like Base_S1_unqual
                let baseNSName = getDefinitionName(baseType, contextFlags.originalReferencingContext, namespaces);
                addReference(refMap, baseType, contextFlags.originalReferencingContext);
                newXSO(xso.allOf);
                xso.allOf[0] = { $ref: '#/definitions/' + baseNSName };
                if (isSGAC(extension)) {
                    handleSGACRef(extension, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns, contextFlags);
                }
            }
        }
        // attributes can appear on extensions
        if (extension.attribute) {
            handleAttributeRef(extension.attribute, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
        }
        if (extension.attributeGroup) {
            handleAttributeGroupRef(extension.attributeGroup, dictEntry, dict, refMap, xso.allOf, namespaces, dictEntry.tns);
        }
    }
}


/**
* Process restriction containedWithin simpleType or simpleContent
*/
function processSchemaSimpleRestriction(restriction, inXSO, dict, dictEntry, refMap, namespaces) {
    delete inXSO.type;
    delete inXSO.properties;
    inXSO.allOf = [ {
        xml: u.deepClone(inXSO.xml),
        type: 'object',
        properties: {}
    } ];

    let xso = lastXSO(inXSO.allOf);

    if (!restriction['undefined']) {
        // might be nested restriction
        if (restriction.simpleType && restriction.simpleType.restriction) {
            restriction = restriction.simpleType.restriction;
        }
    }
    var isXSD;
    if (restriction && restriction['undefined']) {
        isXSD = dictionary.isXSDType(restriction['undefined'].base, namespaces);
        let baseType = dictionary.bestMatch(restriction['undefined'].base, dictEntry, dict, namespaces, false, false, false, true);
        if (baseType) {
            xso.type = baseType;
        } else {
            xso.type = 'string';
        }
        delete xso.properties;
    } else {
        dictionary.annotateWithParserMessage(dictEntry.schema, g.http(u.r(dict.req)).f('The \'base\' of a restriction is missing.  The schema object is mapped to a string.'));
        xso.type = 'string';
        return;
    }

    // Set the facetxso to the type where facets are added.
    let facetxso = xso;
    if (!isXSD && dict.dictEntry[xso.type]) {
        if (dictEntry.schema['undefined'] && dictEntry.schema['undefined'].name == xso.type) {
            // stop hard cycles due to weird schema name clashes
            let swaggerType = mapXSDTypeToSwagger(xso.type, dict);
            u.extendObject(xso, swaggerType);
        } else {
            addReference(refMap, xso.type, {});
            if (isPrimitiveType(dict.dictEntry[xso.type], namespaces)) {
                // If directly referenced base is just a type whose base is an xsd type, them set it directly.
                let primitiveRef = generateSwaggerXSO(dict.dictEntry[xso.type], dict, refMap, namespaces);
                delete xso.type;
                if (primitiveRef.properties && _.isEmpty(primitiveRef.properties) &&
                    primitiveRef.type && primitiveRef.type !== 'object') {
                    // Remove unnecessary properties field
                    delete primitiveRef.properties;
                }
                delete primitiveRef.xml; // existing obj will already have its namespace
                u.extendObject(xso, primitiveRef);
            } else if (dict.dictEntry[xso.type]) {
                // Generate the referenced base and copy it into the current object
                let baseXSO = generateSwaggerXSO(dict.dictEntry[xso.type], dict, refMap, namespaces);
                delete xso.type;
                if (baseXSO.properties && _.isEmpty(baseXSO.properties) &&
                    baseXSO.type && baseXSO.type !== 'object') {
                    // Remove unnecessary properties field
                    delete baseXSO.properties;
                }
                delete baseXSO.xml; // existing obj will already have its namespace
                u.extendObject(xso, baseXSO);
                // If the new xso has an allOf, we might need to repeat to get the actual type (uncommon)
                if (xso.allOf) {
                    facetxso = xso.allOf[xso.allOf.length - 1];
                    if (facetxso.type == 'object'  && xso.allOf[0]['$ref']) {
                        let nsName = u.getDefNameFromRef(xso.allOf[0]['$ref']);
                        if (dict.dictEntry[nsName]) {
                            let base2XSO = generateSwaggerXSO(dict.dictEntry[nsName], dict, refMap, namespaces);

                            if (base2XSO.type || base2XSO.allOf && base2XSO.allOf[0].type) {
                                if (base2XSO.allOf && base2XSO.allOf[0].type) {
                                    base2XSO = base2XSO.allOf[0];
                                }
                                delete facetxso.type;
                                delete base2XSO.xml; // existing obj will already have its namespace
                                delete base2XSO.properties;  // Remove properties because they available in the base
                                delete base2XSO.required;
                                u.extendObject(facetxso, base2XSO);
                            } else {
                                facetxso = xso;
                            }
                        }
                    }
                }
            } else {
                // Fallback...may not ever get here
                var ref = '#/definitions/' + xso.type;
                delete xso.type;
                xso.allOf = [];
                xso.allOf[0] = { $ref: ref };
                xso.allOf[1] = { type: 'string' };  // Guess
                facetxso = xso.allOf[1];  // set the facetxso to the allOf object containing the type.
            }
        }
    } else {
        let swaggerType = mapXSDTypeToSwagger(u.stripNamespace(restriction['undefined'].base), dict);
        u.extendObject(xso, swaggerType);
    }

    // Now process the facets
    if (restriction.pattern) {
        var patterns = u.makeSureItsAnArray(restriction.pattern);
        var patLen = patterns.length;
        if (patLen == 1) {
            facetxso.pattern = patterns[0]['undefined'].value;
        } else {
            // in odd cases where more than one pattern is supplied, we must combine into one regex
            facetxso.pattern = '(' + patterns[0]['undefined'].value + ')';
            for (let i = 1; i < patLen; i++) {
                var pat = patterns[i];
                facetxso.pattern += '|(' + pat['undefined'].value + ')';
            } // end for
        }
    }

    if (restriction.whiteSpace) {
        if (typeof restriction.whiteSpace['undefined'].value !== 'undefined') {
            facetxso['x-ibm-whiteSpace'] = restriction.whiteSpace['undefined'].value;
        }
    }
    if (restriction.fractionDigits) {
        if (typeof restriction.fractionDigits['undefined'].value !== 'undefined') {
            let value = parseInt(restriction.fractionDigits['undefined'].value);
            facetxso['x-ibm-fractionDigits'] = value;
        }
    }
    if (restriction.totalDigits) {
        if (typeof restriction.totalDigits['undefined'].value !== 'undefined') {
            let value = parseInt(restriction.totalDigits['undefined'].value);
            facetxso['x-ibm-totalDigits'] = value;
        }
    }
    if (restriction.maxLength) {
        if (typeof restriction.maxLength['undefined'].value !== 'undefined') {
            let value = parseInt(restriction.maxLength['undefined'].value);
            facetxso.maxLength = value;
        }
    }
    if (restriction.minLength) {
        if (typeof restriction.minLength['undefined'].value !== 'undefined') {
            let value = parseInt(restriction.minLength['undefined'].value);
            facetxso.minLength = value;
        }
    }
    if (restriction['length']) {
        if (typeof restriction['length']['undefined'].value !== 'undefined') {
            let value = parseInt(restriction['length']['undefined'].value);
            facetxso.minLength = value;
            facetxso.maxLength = value;
        }
    }
    if (restriction.enumeration) {
        let enums = u.makeSureItsAnArray(restriction.enumeration);
        facetxso['enum'] = [];
        var enumsLen = enums.length;
        for (let i = 0; i < enumsLen; i++) {
            let enm = enums[i];
            // render as string and will adjust value in post processing
            let value = enm['undefined'].value;
            facetxso['enum'].push(value);
        } // end for
    }

    // map min and max after we've put the default limits in per type so that the schema can override
    if (restriction.minInclusive) {
        if (facetxso.type != 'integer' || facetxso.type != 'number') {
            facetxso.minimum = u.parseToPrimitive(restriction.minInclusive['undefined'].value);
        } else if (facetxso.type == 'number' && (facetxso.format == 'float' || facetxso.format == 'double')) {
            facetxso.minimum = parseFloat(restriction.minInclusive['undefined'].value);
        } else {
            facetxso.minimum = parseInt(restriction.minInclusive['undefined'].value);
        }
    }
    if (restriction.minExclusive) {
        if (facetxso.type != 'integer' || facetxso.type != 'number') {
            facetxso.minimum = u.parseToPrimitive(restriction.minExclusive['undefined'].value);
        } else if (facetxso.type == 'number' && (facetxso.format == 'float' || facetxso.format == 'double')) {
            facetxso.minimum = parseFloat(restriction.minExclusive['undefined'].value);
        } else {
            facetxso.minimum = parseInt(restriction.minExclusive['undefined'].value);
        }
        facetxso.exclusiveMinimum = true;
    }
    if (restriction.maxInclusive) {
        if (facetxso.type != 'integer' || facetxso.type != 'number') {
            facetxso.maximum = u.parseToPrimitive(restriction.maxInclusive['undefined'].value);
        } else if (facetxso.type == 'number' && (facetxso.format == 'float' || facetxso.format == 'double')) {
            facetxso.maximum = parseFloat(restriction.maxInclusive['undefined'].value);
        } else {
            facetxso.maximum = parseInt(restriction.maxInclusive['undefined'].value);
        }
    }
    if (restriction.maxExclusive) {
        if (facetxso.type != 'integer' || facetxso.type != 'number') {
            facetxso.maximum = u.parseToPrimitive(restriction.maxExclusive['undefined'].value);
        } else if (facetxso.type == 'number' && (facetxso.format == 'float' || facetxso.format == 'double')) {
            facetxso.maximum = parseFloat(restriction.maxExclusive['undefined'].value);
        } else {
            facetxso.maximum = parseInt(restriction.maxExclusive['undefined'].value);
        }
        facetxso.exclusiveMaximum = true;
    }

    if (restriction.attribute) {
        handleAttributeRef(restriction.attribute, dictEntry, dict, refMap, inXSO.allOf, namespaces, dictEntry.tns);
    }
    if (restriction.attributeGroup) {
        handleAttributeGroupRef(restriction.attributeGroup, dictEntry, dict, refMap, inXSO.allOf, namespaces, dictEntry.tns);
    }
}

/**
* return the occurrence information for a construct
*/
function processOccurrence(schema) {
    let occur = { minOccurs: 1, maxOccurs: 1 };
    if (schema && schema['undefined']) {
        occur.minOccurs = getOccurrence(schema['undefined'].minOccurs);
        occur.maxOccurs = getOccurrence(schema['undefined'].maxOccurs);
    }
    return occur;
}

function lastXSO(list) {
    return list[list.length - 1];
}

function newXSO(list) {
    let last = lastXSO(list);
    list.push({
        xml: u.deepClone(last.xml),
        type: 'object',
        properties: {}
    });
    return lastXSO(list);
}

/**
* handle a sequence ref
*/
function handleSequenceRef(sequence, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    let occur = processOccurrence(sequence);
    let currXSOList = xsoList;
    if (occur.minOccurs != 1 || occur.maxOccurs != 1) {
        let xso = lastXSO(xsoList);
        xso.allOf = [ {
            type: 'array',
            items: {
                allOf: [ u.deepClone(xso) ]
            },
            minItems: (occur.minOccurs === -1  || occur.minOccurs === 0) ? undefined : occur.minOccurs,
            maxItems: (occur.maxOccurs === -1) ? undefined : occur.maxOccurs,
            'x-ibm-group': [ 'sequence' ]
        } ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf[0].items.allOf;
    } else {
        let xso = lastXSO(xsoList);
        xso.allOf = [ u.deepClone(xso) ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf;
    }
    return handleSequenceContent(sequence, dictEntry, dict, refMap, currXSOList, namespaces, tns, contextFlags);
}

/**
*  handle the content of a sequence
*/
function handleSequenceContent(sequence, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    let xso = lastXSO(xsoList);
    if ('any' in sequence) {
        xso.additionalProperties = true;
    }
    var items = [];
    var id = 0;
    var i;
    var order;
    let kinds = 0;

    /**
    * We want to process the element, choice, sequence, and group constructs in the
    * declared order so that the properties have the same order as the schema.
    * Put the constructs into an items map using the apicID key (which we added during preParse)
    */
    if (sequence.element) {
        kinds++;
        var elements = u.deepClone(u.makeSureItsAnArray(sequence.element));
        for (i = 0; i < elements.length; i++) {
            if (elements[i]['undefined'].apicID) {
                order = parseInt(elements[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'element', order: order, value: [ elements[i] ] });
        }
    }

    if (sequence.choice) {
        var choices = u.deepClone(u.makeSureItsAnArray(sequence.choice));
        for (i = 0; i < choices.length; i++) {
            kinds++;
            if (choices[i]['undefined'].apicID) {
                order = parseInt(choices[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'choice', order: order, value: choices[i] });
        }
    }

    if (sequence.group) {
        var groups = u.deepClone(u.makeSureItsAnArray(sequence.group));
        for (i = 0; i < groups.length; i++) {
            kinds++;
            if (groups[i]['undefined'].apicID) {
                order = parseInt(groups[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'group', order: order, value: groups[i] });
        }
    }

    if (sequence.sequence) {
        var sequences = u.deepClone(u.makeSureItsAnArray(sequence.sequence));
        for (i = 0; i < sequences.length; i++) {
            kinds++;
            if (sequences[i]['undefined'].apicID) {
                order = parseInt(sequences[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'sequence', order: order, value: sequences[i] });
        }
    }

    // If different kinds, then use an allOf to model the nesting

    // Now sort the keys so that we process the constructs in the declared order
    items = items.sort(function(a, b) {
        return a.order - b.order;
    });

    // Process the constructs
    let len = items.length;
    let lastItem = null;
    for (var k = 0; k < len; k++) {
        if (!lastItem ||
            lastItem === 'element'  &&
            items[k].type === 'element' &&
            lastXSO(xsoList).properties) {
            // Reuse last xso
        } else {
            newXSO(xsoList);
        }
        if (items[k].type == 'element') {
            processElements(items[k].value, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
        } else if (items[k].type == 'choice') {
            handleChoiceRef(items[k].value, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
        } else if (items[k].type == 'group') {
            handleGroupRef(items[k].value, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
        } else if (items[k].type == 'sequence') {
            handleSequenceRef(items[k].value, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
        }
        lastItem = items[k].type;
    }
}

/*
* handle a choice reference
*/
function handleChoiceRef(choice, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    let occur = processOccurrence(choice);
    let currXSOList = xsoList;
    if (occur.minOccurs != 1 || occur.maxOccurs != 1) {
        let xso = lastXSO(xsoList);
        xso.allOf = [ {
            type: 'array',
            items: {
                allOf: [ u.deepClone(xso) ]
            },
            minItems: (occur.minOccurs === -1  || occur.minOccurs === 0) ? undefined : occur.minOccurs,
            maxItems: (occur.maxOccurs === -1) ? undefined : occur.maxOccurs,
            'x-ibm-group': [ 'choice' ]
        } ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf[0].items.allOf;
    } else {
        let xso = lastXSO(xsoList);
        xso.allOf = [ u.deepClone(xso) ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf;
    }
    return handleChoiceContent(choice, dictEntry, dict, refMap, currXSOList, namespaces, tns, contextFlags);
}

/**
*  Handle the contents of a choice
*/
function handleChoiceContent(choice, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    // Use a oneOf to represent the choice.
    // The oneOf construct is not supported in openAPI 2.0, so it is removed during postGeneration
    let xso = lastXSO(xsoList);
    xso.allOf = [ u.deepClone(xso),
        {
            xml: u.deepClone(xso.xml),
            oneOf: []
        } ];
    delete xso.type;
    delete xso.properties;
    let oneOf = xso.allOf[1].oneOf;
    oneOf.push({
        xml: u.deepClone(xso.xml),
        type: 'object',
        properties: {},
    });
    if ('any' in choice) {
        xso.additionalProperties = true;
        lastXSO(oneOf).additionalProperties = true;
    }
    if (choice.element) {
        var elements = u.deepClone(u.makeSureItsAnArray(choice.element));
        for (let i = 0; i < elements.length; i++) {
            newXSO(oneOf);
            processElements([ elements[i] ], dictEntry, dict, refMap, oneOf, namespaces, tns, contextFlags);
        }
    }

    if (choice.sequence) {
        let sequence = u.deepClone(u.makeSureItsAnArray(choice.sequence));
        for (let i = 0; i < sequence.length; i++) {
            newXSO(oneOf);
            handleSequenceRef(sequence[i], dictEntry, dict, refMap, oneOf, namespaces, tns, contextFlags);
        }
    }

    if (choice.group) {
        let group = u.deepClone(u.makeSureItsAnArray(choice.group));
        for (let i = 0; i < group.length; i++) {
            newXSO(oneOf);
            handleGroupRef(group[i], dictEntry, dict, refMap, oneOf, namespaces, tns, contextFlags);
        }
    }

    if (choice.choice) {
        choice.choice = u.deepClone(u.makeSureItsAnArray(choice.choice));
        for (let i = 0; i < choice.choice.length; i++) {
            newXSO(oneOf);
            handleChoiceRef(choice.choice[i], dictEntry, dict, refMap, oneOf, namespaces, tns, contextFlags);
        }
    }
}

/**
*  Handle the all reference
*/
function handleAllRef(all, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    let occur = processOccurrence(all);
    let currXSOList = xsoList;
    if (occur.minOccurs != 1 || occur.maxOccurs != 1) {
        let xso = lastXSO(xsoList);
        xso.allOf = [ {
            type: 'array',
            items: {
                allOf: [ u.deepClone(xso) ]
            },
            minItems: (occur.minOccurs === -1  || occur.minOccurs === 0) ? undefined : occur.minOccurs,
            maxItems: (occur.maxOccurs === -1) ? undefined : occur.maxOccurs,
            'x-ibm-group': [ 'all' ]
        } ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf[0].items.allOf;
    } else {
        let xso = lastXSO(xsoList);
        xso.allOf = [ u.deepClone(xso) ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf;
    }
    return handleAllContent(all, dictEntry, dict, refMap, currXSOList, namespaces, tns, contextFlags);
}

/**
*  Handle the all construct content
*/
function handleAllContent(all, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags) {

    // Only elements are allowed within an all construct.
    // The choice, sequence, and group contructs are not allowed.
    var elements = [];
    if (all.element) {
        elements = u.deepClone(u.makeSureItsAnArray(all.element));
    }

    let xso = lastXSO(xsoList);

    if ('any' in all) {
        xso.additionalProperties = true;
    }

    // for an all condition we set the implied minOccurs value to 1 unless already switched off
    var required = true;
    if (all['undefined']) {
        // can have a minOccurs at the "all" level to switch the logic
        var minOccurs = all['undefined'].minOccurs;
        if (minOccurs === 0) {
            required = false;
        }
    }
    if (required) {
        var len = elements.length;
        for (var i = 0; i < len; i++) {
            var element = elements[i];
            // only set the required flag if no minimum already set
            if (typeof element['undefined'].minOccurs === 'undefined') {
                element['undefined'].minOccurs = 1;
            }
        } // end for
    }
    processElements(elements, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags);
}

/**
* @return true if sequence group all or choice
*/
function isSGAC(obj) {
    return obj && (obj.sequence || obj.group || obj.all || obj.choice);
}

/**
* handle a sequence group all or choice reference
*/
function handleSGACRef(obj, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags) {
    if (obj.sequence) {
        handleSequenceRef(obj.sequence, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags);
    } else if (obj.group) {
        handleGroupRef(obj.group, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags);
    } else if (obj.all) {
        handleAllRef(obj.all, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags);
    } else if (obj.choice) {
        handleChoiceRef(obj.choice, dictEntry, dict, typesFound, xsoList, namespaces, tns, contextFlags);
    }
}

/**
* handle a group reference
*/
function handleGroupRef(group, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    let req = dict.req;
    if (!group['undefined'] || !group['undefined'].ref) {
        return;  // There is no such thing as a group without a ref
    }
    let isXSD = dictionary.isXSDType(group['undefined'].ref, namespaces);
    let groupType = dictionary.resolveNameInNamespace(group['undefined'].ref, dictEntry.xmlns, namespaces, dictEntry.tns, dict, false, dict.groups, false);
    if (!dict.groups[groupType]) {
        groupType = u.stripNamespace(group['undefined'].ref);
    }
    if (!isXSD && !dict.groups[groupType]) {
        dictionary.annotateWithParserMessage(dictEntry.schema, g.http(u.r(req)).f('The \'ref\' of \'group\' %s could not be found.  The group refererence is ignored', groupType));
    }
    let occur = processOccurrence(group);
    let currXSOList = xsoList;
    if (occur.minOccurs != 1 || occur.maxOccurs != 1) {
        let xso = lastXSO(xsoList);
        xso.allOf = [ {
            type: 'array',
            items: {
                allOf: [ u.deepClone(xso) ]
            },
            minItems: (occur.minOccurs === -1  || occur.minOccurs === 0) ? undefined : occur.minOccurs,
            maxItems: (occur.maxOccurs === -1) ? undefined : occur.maxOccurs,
            'x-ibm-group': [ groupType ]
        } ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf[0].items.allOf;
    } else {
        let xso = lastXSO(xsoList);
        xso.allOf = [ u.deepClone(xso) ];
        delete xso.type;
        delete xso.properties;
        currXSOList = xso.allOf;
    }
    if (dict.groups[groupType]) {
        handleGroupContent(dict.groups[groupType].group, dict.groups[groupType], dict, refMap, currXSOList, namespaces, dict.groups[groupType].tns, contextFlags);
    }
}

/**
*  Handle the content of a group.
*/
function handleGroupContent(group, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {

    // Only sequence, group or all is allowed within a group.
    // And only one of them is allowed.

    let req = dict.req;
    if (contextFlags) {
        contextFlags = u.deepClone(contextFlags); // ContextFlags are only propogated downwards
    } else {
        contextFlags = {};
    }

    let countConstructs = 0;
    if (group.choice) {
        group.choice = u.makeSureItsAnArray(group.choice);

        countConstructs += group.choice.length;
        handleChoiceRef(group.choice[0], dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
    }
    // look for nested sequences
    if (group.sequence) {
        let sequences = [];
        sequences = u.makeSureItsAnArray(group.sequence);
        countConstructs += sequences.length;
        handleSequenceRef(sequences[0], dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
    } // end for

    // look for nested all
    if (group.all) {
        let alls = u.makeSureItsAnArray(group.all);
        let allLen = alls.length;
        countConstructs += allLen;
        handleSequenceRef(alls[0], dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags);
    }
    if (countConstructs > 1) {
        dictionary.annotateWithParserMessage(dictEntry.schema, g.http(u.r(req)).f('A \'group\' may only contain one \'sequence\', one \'choice\', or one \'all\' element. Each is processed, but this not compliant with the schema specification.'));
    }
}

/**
*  Called during XSO generation to process an attributeGroup
*/
function handleAttributeGroupRef(inGroup, dictEntry, dict, refMap, xsoList, namespaces, tns) {
    var attrGroups = u.makeSureItsAnArray(inGroup);
    for (var i = 0; i < attrGroups.length; i++) {
        var attrGroup = attrGroups[i];
        var attrRef = attrGroup['undefined'].ref;
        if (attrRef) {
            var nsName = dictionary.bestMatch(attrRef, dictEntry, dict, namespaces, false, true, true, false);
            if (dict.attrGroups[nsName]) {
                var tgtGroup = dict.attrGroups[nsName];
                if (tgtGroup.attrGroup.attribute) {
                    handleAttributeRef(tgtGroup.attrGroup.attribute, dictEntry, dict, refMap, xsoList, namespaces, tns);
                }
                if (tgtGroup.attrGroup.attributeGroup) {
                    handleAttributeGroupRef(tgtGroup.attrGroup.attributeGroup, dictEntry, dict, refMap, xsoList, namespaces, tns);
                }
            }
        }
    }
}

/**
*  Called during XSO generation to process an attribute reference
*/
function handleAttributeRef(inAttr, dictEntry, dict, refMap, xsoList, namespaces, tns) {
    var attributes = u.makeSureItsAnArray(inAttr);
    var len = attributes.length;
    let xso = newXSO(xsoList);
    xso.xml = { namespace: '' };
    for (var i = 0; i < len; i++) {
        var attribute = attributes[i];
        var qualifiedAttr = dictEntry.qualifiedAttr;
        if (attribute['undefined'].form) {
            qualifiedAttr = (attribute['undefined'].form == 'qualified');
        }
        var newProp = {
            xml: {
                namespace: '',
                attribute: true
            },
            type: 'string'  // This is the default if the type/ref is not found.
        };

        var name = attribute['undefined'].name;

        // There are four choices
        // 1. Attribute can be defined by a ref
        // 2. Attribute is a built-in type
        // 3. Attribute is defined inlineRet
        // 4. Attribute is defined by a non-built-in type

        var attrRef = attribute['undefined'].ref;
        var nsName = null;
        var isXSD = false;
        let attributeDefaultValue = null;
        if (attrRef) {
            nsName = dictionary.bestMatch(attribute['undefined'].ref, dictEntry, dict, namespaces, true, true, false, false);
            attributeDefaultValue = (dict.attributeNS[nsName] && dict.attributeNS[nsName].default);
        } else if (attribute['undefined'].type) {
            nsName = dictionary.bestMatch(attribute['undefined'].type, dictEntry, dict, namespaces, false, false, false, true);
            isXSD = dictionary.isXSDType(attribute['undefined'].type, namespaces, dictEntry.xmlns);
        }
        if (attrRef) {
            // 1. Attribute ref
            name = u.stripNamespace(attrRef); // The name is defined by the ref
            if (dict.dictEntry[nsName]) {
                newProp = {
                    $ref: '#/definitions/' + nsName
                };
                addReference(refMap, nsName, {});
            }
        } else if (isXSD) {
            // 2. Attribute is a built-in type
            var swaggerType = mapXSDTypeToSwagger(u.stripNamespace(attribute['undefined'].type), dict);
            newProp.type = swaggerType.type;
            if (qualifiedAttr) {
                if (tns) {
                    newProp.xml.namespace = tns;
                    newProp.xml.prefix = u.getPrefixForNamespace(tns, namespaces);
                }
            }
            u.extendObject(newProp, swaggerType);
        } else if (!nsName) {
            // 3. Attribute is defined inline
            newProp.type = 'string'; // Assume string
            if (attribute.simpleType) {
                var simpleSchema = {
                    tns: '',
                    schemaType: 'simple',
                    schema: attribute.simpleType,
                    xmlns: dictEntry.xmlns
                };
                var inlineRet = generateSwaggerXSO(simpleSchema, dict, refMap, namespaces);
                newProp.type = inlineRet.type;
                if (qualifiedAttr) {
                    if (tns) {
                        newProp.xml.namespace = tns;
                        newProp.xml.prefix = u.getPrefixForNamespace(tns, namespaces);
                    }
                }
                extendXSO(newProp, inlineRet);
            }
        } else {
            // 4. Attribute is defined by a type that is not a built-in
            // An attribute is referencing a simple type.  We need to generate a definition that is suitable for an attribute.
            if (dict.dictEntry[nsName]) {
                addReference(refMap, nsName, {});
                let referencingContext = {
                    ns: (qualifiedAttr) ? tns : UNQUALNS,
                    attribute: true
                };
                addReference(refMap, nsName, referencingContext);
                newProp = {
                    $ref: '#/definitions/' + getDefinitionName(nsName, referencingContext, namespaces)
                };
            }
        }

        // Add default if either default or fixed is specified.
        if ('default' in attribute['undefined']) {
            newProp.default = attribute['undefined'].default;
        }
        if ('fixed' in attribute['undefined']) {
            newProp.default = attribute['undefined'].fixed;
        }
        if (attributeDefaultValue) {
            newProp.default = attributeDefaultValue;
        }

        if (xso.properties[name] || xso.properties[name] === {}) {
            xso = newXSO(xsoList);
        }

        // If required, then add it to the required list
        // (Note we could add a default, but the mapper has code to pick a reasonable default for each type)
        if (attribute['undefined'].use == 'required') {
            if (!xso.required) {
                xso.required = [];
            }
            xso.required = xso.required.concat(name);
        }

        // If prohibited, add it and it will be marked for removal during postProcessing
        if (attribute['undefined'].use == 'prohibited') {
            newProp['x-prohibited'] = true;
        }

        if (attribute.annotation) {
            // include annotation as description
            if (attribute.annotation.documentation) {
                var doc = u.cleanupDocumentation(attribute.annotation.documentation, dict.req);
                if (attrRef && CHILD_DESCRIPTION_PLACED_ON_PARENT) {
                    // if the attr is a reference we cant use description at the element level
                    // move it up to the parent container
                    if (xso.description) {
                        xso.description += ';\n' + name + ': ' + doc;
                    } else {
                        xso.description = name + ': ' + doc;
                    }
                } else if (newProp.description) {
                    newProp.description += ';\n' + doc;
                } else {
                    newProp.description = doc;
                }
            }
        }
        xso.properties[name] = newProp;
    } // end for
}

/**
 * Process the child elements of a sequence, choice, all, etc.
 * @param elements is the list of schema elements
 * @param dictEntry is the referencing dictionary entry
 * @param dict is the global "dictionary" object
 * @param refMap is the map of the references.  Any discovered references are added to the map
 * @param xsoList is the swagger.definition containing child element (properties)
 * @param namespaces is the namespace list
 * @param tns is the namespace of the referencing type
 * @param contextFlags additional context (i.e. within allof)
 */
function processElements(elements, dictEntry, dict, refMap, xsoList, namespaces, tns, contextFlags) {
    let req = dict.req;
    let xso = lastXSO(xsoList);
    if (u.useAsserts) {
        assert(tns == null || typeof tns == 'string',
        'expected typeNamespace of string, not ' + util.inspect(tns));
    }
    if (elements.length > 0) {
        var refType, rawRefType, lastSlash;
        var elemLen = elements.length;
        contextFlags = contextFlags ? contextFlags : {};

        // Determine if the schema is qualified or not qualified
        var schemaQualified = false;
        if (dictEntry && dictEntry.qualified) {
            schemaQualified = true;
        }
        for (var i = 0; i < elemLen; i++) {
            var element = elements[i];
            var elemName = element['undefined'].name;

            // Now determine if the child is qualified
            var childQualified = schemaQualified;
            var elemQualified = element['undefined'].form;
            if (elemQualified) {
                if (elemQualified == 'qualified') {
                    childQualified = true;
                } else if (elemQualified == 'unqualified') {
                    childQualified = false;
                }
            }
            var elemNillable = false;
            var elemNillableAttr = element['undefined'].nillable;
            if (elemNillableAttr && elemNillableAttr.toLowerCase() === 'true') {
                elemNillable = true;
            }
            var elemType = '';
            var isXSD = false;
            var isElemRef = false;
            let isAbstractElement = false;
            let elementDefaultValue = null;
            if (elemName) {
                isXSD = dictionary.isXSDType(element['undefined'].type, namespaces, dictEntry.xmlns);
                elemType = dictionary.bestMatch(element['undefined'].type, dictEntry, dict, namespaces, false, false, false, true);
            } else {
                // might be a direct reference to another type
                if (element['undefined'].ref) {
                    elemType = dictionary.bestMatch(element['undefined'].ref, dictEntry, dict, namespaces, false, true, false, false);
                    elemName = u.stripNamespace(element['undefined'].ref);
                    isElemRef = true;
                    // The referenced root element may have the nillable attribute
                    if (dict.elementNS[elemType] && dict.elementNS[elemType].nillable) {
                        elemNillable = true;
                    }
                    isAbstractElement = (dict.elementNS[elemType] && dict.elementNS[elemType].abstract);
                    elementDefaultValue = (dict.elementNS[elemType] && dict.elementNS[elemType].default);
                }
            }
            var isReference = false;
            let propXSO = {};
            propXSO[elemName] = xso;

            if ('unique' in element) {
                dictionary.annotateWithParserMessage(element, g.http(u.r(req)).f('The \'unique\' element is ignored.'));
            }

            if ('nillable' in element['undefined'] && element['undefined'].ref) {
                dictionary.annotateWithParserMessage(element, g.http(u.r(req)).f('An element cannot have \`ref\' and \'nillable\'.'));
            }

            if (!isXSD && elemType && dict.dictEntry[elemType]) {
                // Flow to here indicates that the child element has a type or ref that
                // locates a type or element that is defined in a schema (but is not an xsd primitive).
                refType = dict.dictEntry[elemType];

                // In schema, it is legal to have a root element and root complexType/simpleType to have the same
                // NS name.   For example:
                // <element name="foo" type="foo" />
                // <completype name="foo" ....
                // In such case the definition foo_ns1 is generated for the element
                // and we need to generate a separate definition if the type is referenced (i.e. foo_ns1_unqual)
                var refTypeElementCollision = !isElemRef && dict.elementNS[elemType];

                // The referenced definition will contain an xml that matches the refType's qualified setting.
                // If the referencing qualification (childQualified) is different, then we need to create a
                // a duplicate definition.
                // We also need to a duplicate definition if both refrenced and referencing qualifications are qualified
                // but they are using different namespaces.
                // We only need to do this when the child element references a type (uses type attribute)
                // because element refeferences (uses ref attribute) will always use the referenced definitions xml.
                if (!isElemRef &&
                    ((refType.qualified != childQualified) ||
                     (refTypeElementCollision && !childQualified) ||
                     ((refType.qualified || refTypeElementCollision) && tns && refType.tns != tns))) {

                    // Check the special case that this is a simpleType, and then set up the property has the primitive
                    if (isPrimitiveType(refType, namespaces)) {
                        var primitiveRef = generateSwaggerXSO(refType, dict, refMap, namespaces);
                        // primitive types can be inlined directly
                        detectPropertyCollision(elemName, xso.properties, element, dict.req);
                        xso.properties[elemName] = primitiveRef;
                        if (childQualified) {
                            xso.properties[elemName].xml = {
                                namespace: tns,
                                prefix: u.getPrefixForNamespace(tns, namespaces)
                            };
                        } else {
                            xso.properties[elemName].xml = {
                                namespace: '',
                                prefix: ''
                            };
                        }
                    } else {
                        // Add the referenced type to the list of found types and add the referencing namespace
                        var referencingNS = (childQualified) ? tns : UNQUALNS;
                        addReference(refMap, elemType, {});
                        addReference(refMap, elemType, {
                            ns: referencingNS
                        });

                        // Now indicate that we need a duplicate definition that will have the proper qualification
                        detectPropertyCollision(elemName, xso.properties, element, dict.req);
                        let dupType = getDefinitionName(elemType, { ns: referencingNS }, namespaces);
                        xso.properties[elemName] = {
                            $ref: '#/definitions/' + dupType
                        };
                        isReference = true;
                    }
                } else {
                    // reference is to another type - recurse
                    addReference(refMap, elemType, {});
                    detectPropertyCollision(elemName, xso.properties, element, dict.req);
                    if (!dict.substitutions[elemType]) {
                        xso.properties[elemName] = {
                            $ref: '#/definitions/' + elemType
                        };
                    } else {
                        xso = newXSO(xsoList); // Create a new xso for the substitution group
                        delete xso.type;
                        delete xso.properties;
                        delete xso.xml;
                        xso.oneOf = [ {
                            type: 'object',
                            properties: {}
                        } ];
                        let origXSO = xso.oneOf[0];
                        origXSO.properties[elemName] = {
                            $ref: '#/definitions/' + elemType
                        };
                        propXSO[elemName] = origXSO;
                        var subs = dict.substitutions[elemType];
                        var subLen = subs.length;
                        // add all possible substitutes for this element
                        for (var j = 0; j < subLen; j++) {
                            let subXSO = newXSO(xso.oneOf);
                            var sub = subs[j];
                            var subName = sub.name;
                            if (subName == elemName) {
                                // The substituted element is the same name as the
                                // original element.  Therefore we must mangle both property names
                                // and the xml.name field is added to the reference.
                                var propertyName;
                                if (origXSO.properties[elemName]) {
                                    propertyName = uniquePropertyName(elemType);
                                    origXSO.properties[propertyName] = u.deepClone(origXSO.properties[elemName]);
                                    delete origXSO.properties[elemName];
                                    addReference(refMap, elemType, { xmlName: elemName });
                                    origXSO.properties[propertyName].$ref = '#/definitions/' +
                                      getDefinitionName(elemType, { xmlName: elemName }, namespaces);
                                    dict.dictEntry[elemType].preventOptimize = true;
                                    delete propXSO[elemName];
                                    elemName = propertyName; // The new element name is the mangled property name
                                    propXSO[elemName] = origXSO;
                                }
                                propertyName = uniquePropertyName(subs[j].nsName);
                                addReference(refMap, subs[j].nsName, { xmlName: subName });
                                subXSO.properties[propertyName] = {
                                    $ref: '#/definitions/' + getDefinitionName(subs[j].nsName, { xmlName: subName }, namespaces)
                                };
                                dict.dictEntry[subs[j].nsName].preventOptimize = true;
                                propXSO[propertyName] = subXSO;
                            } else {
                                // Normal Case: The new substituted element has a different name
                                // than the original element
                                // detectPropertyCollision(subName, xso.properties, element, dict.req);
                                subXSO.properties[subName] = {
                                    $ref: '#/definitions/' + subs[j].nsName
                                };
                                addReference(refMap, subs[j].nsName, {});
                                propXSO[subName] = subXSO;
                            }
                        } // end for
                        xso = origXSO;
                    }
                    isReference = true;
                }
            } else {
                var swaggerType = mapXSDTypeToSwagger(u.stripNamespace(element['undefined'].type), dict);
                detectPropertyCollision(elemName, xso.properties, element, dict.req);
                xso.properties[elemName] = swaggerType;
                if (!isElemRef) {
                    if (childQualified) {
                        // If within an allOf, then generate the xml object even though this is redundant.
                        // The runtime munges the allOf ref and these properties together and this extra xml is necessary
                        // for the runtime algorithm to work correctly.
                        if (tns && (contextFlags.inAllOf || !xso.xml || tns !== xso.xml.namespace)) {
                            xso.properties[elemName].xml = {
                                namespace: tns,
                                prefix: u.getPrefixForNamespace(tns, namespaces)
                            };
                        }
                    } else {
                        xso.properties[elemName].xml = {
                            namespace: '',
                            prefix: ''
                        };
                    }
                }
            }


            // inner anonymous type
            if ('complexType' in element) {

                if (!element.complexType) {
                    element.complexType = {};
                }

                var complexSchema = {
                    tns: tns,
                    schemaType: 'complex',
                    schema: element.complexType,
                    xmlns: dictEntry.xmlns,
                    qualified: dictEntry.qualified,
                    qualifiedAttr: dictEntry.qualifiedAttr
                };
                var referencingContext = {
                    ns: UNQUALNS
                };
                if (childQualified) {
                    referencingContext.ns = tns;
                }
                var typeRef = generateSwaggerXSO(complexSchema, dict, refMap, namespaces, referencingContext);

                xso.properties[elemName] = typeRef;
                if (xso.properties[elemName]['$ref']) {
                    isReference = true;
                } else if (!xso.properties[elemName].type  && !xso.properties[elemName].allOf) {
                    // If there is no type then this is a special case of a complexType with no content
                    xso.properties[elemName].type = 'object';
                    xso.properties[elemName].properties = {};
                }
            }
            if (element.simpleType) {
                var simpleSchema = {
                    tns: tns,
                    schemaType: 'simple',
                    schema: element.simpleType,
                    xmlns: dictEntry.xmlns,
                    qualified: dictEntry.qualified,
                    qualifiedAttr: dictEntry.qualifiedAttr
                };
                let referencingContextSimple = {
                    ns: UNQUALNS
                };
                if (childQualified) {
                    referencingContextSimple.ns = tns;
                }
                var simpleTypeRef = generateSwaggerXSO(simpleSchema, dict, refMap, namespaces, referencingContextSimple);
                xso.properties[elemName] = simpleTypeRef;
                if (xso.properties[elemName]['$ref']) {
                    isReference = true;
                }
            }

            processElementOccurrence(element, propXSO, elemNillable, dict, contextFlags);

            // Map default or fixed to the swagger default property
            var item = (xso.properties[elemName].items != null) ? xso.properties[elemName].items : xso.properties[elemName];
            if ('fixed' in element['undefined']) {
                item.default = element['undefined'].fixed;
            }
            if ('default' in element['undefined']) {
                item.default = element['undefined'].default;
            }
            if (elementDefaultValue) {
                item.default = elementDefaultValue;
            }
            // If default and ref collision, then inline the ref
            if (item.default && item['$ref']) {
                // Get the xso of the ref and extend the item
                let defaultValue = item.default;
                delete item.default;
                let referencingContextSimple = {
                    ns: UNQUALNS
                };
                if (childQualified) {
                    referencingContextSimple.ns = tns;
                }
                let xso = generateSwaggerXSO(dict.dictEntry[u.getDefNameFromRef(item['$ref'])],
                     dict, refMap, namespaces, referencingContextSimple);
                delete item['$ref'];
                isReference = false;
                u.extendObject(item, xso);
                item.default = defaultValue;
            }

            if (element.annotation) {
                // include annotation as description
                if (element.annotation.documentation) {
                    var doc = u.cleanupDocumentation(element.annotation.documentation, req);
                    if (isReference && CHILD_DESCRIPTION_PLACED_ON_PARENT) {
                        if (xso.description) {
                            xso.description += ';\n' + elemName + ': ' + doc;
                        } else {
                            xso.description = elemName + ': ' + doc;
                        }
                    } else if (xso.properties[elemName].description) {
                        xso.properties[elemName].description += ';\n' + doc;
                    } else {
                        xso.properties[elemName].description = doc;
                    }
                }
            }

            // If abstract element, then remove the property.
            // Also remove from the required list
            if (isAbstractElement) {
                if (xso.properties[elemName]) {
                    delete xso.properties[elemName];
                }
                if (xso.required && xso.required.length > 0) {
                    let i = xso.required.indexOf(elemName);
                    if (i >= 0) {
                        xso.required.splice(i, 1);
                    }
                }
            }
            if (xso.required && xso.required.length === 0) {
                delete xso.required;
            }
        } // end for
    }
}

/**
* Process Occurrence attributes on the element
* @param element is the schema elements
* @param propXSO is an object of propNames to xsos
* @param elemNillable indicates if the element is nillable
* @param dict is the schema dictionary
* @param contextFlags contains contextural flags (for example if we are nested in a group)
**/
function processElementOccurrence(element, propXSO, elemNillable, dict, contextFlags) {
    // check required existence
    let minElement = getOccurrence(element['undefined'].minOccurs);
    let maxElement = getOccurrence(element['undefined'].maxOccurs);

    // If the property is required add it to the required list
    if (minElement != 0) {
        for (let propName in propXSO) {
            let xso = propXSO[propName];
            xso.required = xso.required || [];
            xso.required.push(propName);
        }
    }

    // See if the properties need to be rendered as an array with min and max items
    let maxItems = maxElement;
    let minItems = minElement;

    if (maxItems == -1 || maxItems > 1) {
        // we have an array type - switch out the content
        for (let propName in propXSO) {
            let xso = propXSO[propName];
            var existingContent = xso.properties[propName];
            xso.properties[propName] = {
                type: 'array',
                items: existingContent
            };
            if (maxItems > 1) {
                xso.properties[propName].maxItems = maxItems;
            }
            if (minItems > 0) {
                xso.properties[propName].minItems = minItems;
            }

            // For a child A, the namespace information for A is:
            //  i) if a non-array
            //     a) in the definition of the $ref -or
            //     b) in the xml construct -or
            //     c) the namespace in scope if neither (a or b)
            //  ii) if an array
            //     a) in the definition of the items.$ref -or
            //     b) in the items.xml construct -or
            //     c) the namespace in scope if neither (a or b)
            //
            // This can be confusing for an observer of arrays because it
            // seems that the xml should be directly under the A (not within the A.items object).
            // Also there could be hard to find bugs in the map runtime that assume
            // that the xml is directly under the A object.
            // So even though this is redundant, the code duplicates (boosts) the xml
            // information for the "uncommon" case that the items is an inlined object.
            if (xso.properties[propName].items.type &&
                xso.properties[propName].items.type == 'object' &&
                xso.properties[propName].items.xml) {
                xso.properties[propName].xml = u.deepClone(xso.properties[propName].items.xml);
            }
        }
    }

    // add nillable tag if found
    for (let propName in propXSO) {
        let xso = propXSO[propName];
        var rawRefType, lastSlash, refType;
        if (xso.properties && xso.properties[propName]) {
            if (elemNillable) {
                if (xso.properties[propName]['$ref']) {
                    // Even though this is a ref, add the x-nullable tag.
                    // The fixupForNilAndNonNil function in postGenerate
                    // will remove this tag and patch up the ref if necessary.
                    xso.properties[propName]['x-nullable'] = true;
                } else {
                    // plain property - can take extension tag directly
                    xso.properties[propName]['x-nullable'] = true;
                }
            } else if (xso.properties[propName]['$ref']) {
                // made reference to type when not nullable
                // If a definition is referenced in a nillable and not nillable
                // context, this will be detected and cleaned up in fixupForNilAndNonNil.
            }
        }
    }
    return;
}

/**
* Detect and issue a message if a property collision
*/
function detectPropertyCollision(key, properties, schema, req) {
    if (properties[key] || properties[key] === {}) {
        if (typeof properties[key] !== 'function') {
            // Indicate that a property collision occured and that the new property overrides the previous one.
            // Currently a message is annotated on the swagger, we could add code to resolve the collision by
            // mangling names.
            dictionary.annotateWithParserMessage(schema, g.http(u.r(req)).f('Multiple \'property\' fields with the name %s detected. The \'property\' is overwritten.', key));
        }
    }
}

/**
* Return the occurrence (or -1 if unbounded)
*/
function getOccurrence(occurs) {
    if (occurs === undefined || occurs === null) {
        return 1;
    } else if (typeof occurs === 'number') {
        return occurs;
    } else if (typeof occurs === 'string' && occurs.toLowerCase() == 'unbounded') {
        return -1;
    } else {
        return parseInt(occurs);
    }
}

/**
* Return the xso object for a built-in XSD Type
*/
function mapXSDTypeToSwagger(xsdType, dict) {
    dictionary.complexityLimitCheck(dict);
    var xso = dictionary.getXSDMapping(xsdType);
    if (!xso) {
        if (xsdType) {
            // Default is to fallback to string
            xso = {
                type: 'string'
            };
        } else {
            // special case for anyType - dont supply a type field at all
            xso = {
                'x-anyType': true,
            };
        }
    }
    return xso;
}

/**
* Determine if the dictionary entry represents a primitive type
*/
function isPrimitiveType(dictEntry, namespaces) {
    let ret = false;
    if (dictEntry && dictEntry.schemaType && dictEntry.schema) {
        if (dictEntry.schemaType == 'simple' && dictEntry.schema.restriction) {
            var restriction = dictEntry.schema.restriction;
            if (restriction['undefined']) {
                if (dictionary.isXSDType(restriction['undefined'].base, namespaces)) {
                    ret = true;
                }
            }
        } else if (dictEntry.schema.simpleContent) {
            var extension = dictEntry.schema.simpleContent.extension;
            if (extension && extension['undefined']) {
                if (dictionary.isXSDType(extension['undefined'].base, namespaces)) {
                    ret = true;
                }
            }
        }
    }
    return ret;
}


// Only merge properties that won't change the core properties of the target
var extensionProperties = {
    enum: true,
    pattern: true,
    format: true,
    default: true,
    minimum: true,
    maximum: true,
    exclusiveMinimum: true,
    exclusiveMaximum: true,
    minLength: true,
    maxLength: true,
    'x-ibm-whiteSpace': true,
    'x-ibm-fractionDigits': true,
    'x-ibm-totalDigits': true,
    description: true
};

/**
* @param source is an XSO object
* @param target is an XSO object that needs to new information from the source
*
* Only certain properties (decorations) are copied over.
*/
function extendXSO(target, source) {
    for (var name in source) {
        if (extensionProperties[name]) {
            target[name] = source[name];
        }
    }
    return target;
}

/**
* Generate a unique property name in the cases where we have a collision (ie. subgroups)
*/
function uniquePropertyName(ref) {
    var words = ref.split('_');
    return words[1] + ':' + words[0];
}

/**
 * Return new references for subtypes whose base is
 * in swagger
 */
function getExtraReferencesForSubTypes(subTypes, swagger, namespaces, totalRefMap) {
    var refMap = {};
    for (var baseType in subTypes) {
        if (totalRefMap[baseType]) {
            let refContexts = totalRefMap[baseType].referencingContexts;
            for (let j = 0; j < refContexts.length; j++) {
                let referencingContext = refContexts[j];
                // For each base that has subtypes, get the
                // NSName representing the different kinds of references
                // For example Base, you may have Base_S1, Base_S1_unqual, and Base_S1_S2
                let baseNSName = baseType;
                if (referencingContext && referencingContext.ns) {
                    if (referencingContext.ns == UNQUALNS) {
                        baseNSName += '_unqual';
                    } else {
                        baseNSName += '_' + u.getPrefixForNamespace(referencingContext.ns, namespaces);
                    }
                }
                let subTypeList = subTypes[baseType];

                for (var i = 0; i < subTypeList.length; i++) {
                    let subType = subTypeList[i];

                    // For each subtype, create a reference representing the references.
                    // For example if Ext extends Base then you might have
                    // Ext_S1, Ext_S1_unqual and Ext_S1_S2
                    let subNSName = subType;
                    if (referencingContext && referencingContext.ns) {
                        if (referencingContext.ns == UNQUALNS) {
                            subNSName += '_unqual';
                        } else {
                            subNSName += '_' + u.getPrefixForNamespace(referencingContext.ns, namespaces);
                        }
                    }

                    // If the subtype NSName does not exist, then add a reference.
                    if (!swagger.definitions[subNSName]) {
                        addReference(refMap, subType, { ns: referencingContext.ns });
                    }
                }
            }
        }
    }
    return refMap;
}

exports.addReference = addReference;
exports.extendXSO = extendXSO;
exports.generateSwaggerDefinitions = generateSwaggerDefinitions;
exports.generateSwaggerXSO = generateSwaggerXSO;
exports.getExtraReferencesForSubTypes = getExtraReferencesForSubTypes;
exports.mapXSDTypeToSwagger = mapXSDTypeToSwagger;
exports.UNQUALNS = UNQUALNS;
