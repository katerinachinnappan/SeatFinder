/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parseUtils = require('../lib/parseUtils.js');


var q = require('q');
var yauzl = require('yauzl');
var xmldom = require('xmldom');
const JSZip = require('jszip');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');

var LOCATION = 'location';
var WSDL = 'wsdl';
var SOAP = 'soap';
var PORT = 'port';
var SERVICE = 'service';
var ADDRESS = 'address';
var PORT_QN = WSDL + ':' + PORT;
var ADDRESS_QN = SOAP + ':' + ADDRESS;

/**
* @param inContent wsdl or zip content (Buffer or String)
* @param serviceEndpoints single or array of endpoint strings
* @param serviceName the wsdl-definition.service string.
* @param options
*   req: request or null (used for i18n negotiation)
* @return (Promise)
*   outContent: wsdl or zip content in a Buffer
*   filename: if zip mode, this is the full name of first wsdl modified within the zip
*   stringContent: in zip mode, this is the string content of filename.
*                  in wsdl mode, this is the string content of the wsdl file
*/
function injectServiceEndpointsIntoWSDLorZIP(inContent, serviceEndpoints, serviceName, options) {
    options = options || {};
    let def = q.defer();
    function errHandler(e) {
        def.reject(e);
    }
    try {
        serviceEndpoints = u.makeSureItsAnArray(serviceEndpoints);
        inContent = parseUtils.toBuffer(inContent, options.req);
        let isZip = inContent.toString('utf8', 0, 4).substr(0, 4) === 'PK\u0003\u0004';
        if (isZip) {
            JSZip.loadAsync(inContent).then(function(outZip) {
                setServiceEndpoint(inContent, serviceEndpoints, null, serviceName, options).then(function(data) {
                    let result;
                    if (!data || data.length === 0) {
                        // Nothing modified (?), just return input content
                        result = {
                            outContent: inContent
                        };
                        def.resolve(result);
                    } else {
                        // Update each file in the zip and generate a new Buffer
                        for (let i = 0; i < data.length; i++) {
                            outZip.file(data[i].filename, data[i].content);
                        }
                        outZip.generateAsync({
                            type: 'nodebuffer',
                            compression: 'DEFLATE'
                        }).then(function(buffer) {
                            result = {
                                outContent: buffer,
                                filename: data[0].filename,
                                stringContent: data[0].content
                            };
                            def.resolve(result);
                        }, errHandler);
                    }
                }, errHandler);
            }, errHandler);
        } else {
            setServiceEndpoint(inContent.toString(), serviceEndpoints, null, null, options).then(function(data) {
                let stringContent = data[0].content;
                let result = {
                    outContent: parseUtils.toBuffer(stringContent, options.req),
                    stringContent: stringContent
                };
                def.resolve(result);
            }, errHandler);
        }
    } catch (e) {
        def.reject(e);
    }
    return def.promise;
}

/**
* Replaces and Creates serviceEndpoints in the wsdl (filename)
* If the serviceEndpointList is one item, then the port addresses are replaced.
* If the serviceEndpointList is multiple items, then new service ports are created for
* for the subsequent endpoints.

*/
function setServiceEndpoint(filenameOrContent, serviceEndpoints, auth, serviceName, options) {
    options = options || {};
    let req = options.req;
    serviceEndpoints = u.makeSureItsAnArray(serviceEndpoints);
    var def = q.defer();
    var fileDef = q.defer();
    var fetchDef = parseUtils.getFileContent(filenameOrContent, filenameOrContent, auth, null, req);
    fetchDef.then(function(rawContent) {
        var left = rawContent.toString('utf8', 0, 4).substr(0, 4);
        var data = [];

        if (left == 'PK\u0003\u0004') {
            // it's a ZIP file - go fetch all the content
            rawContent = parseUtils.toBuffer(rawContent, req);
            yauzl.fromBuffer(rawContent, {
                lazyEntries: true
            }, function(err, zipFile) {
                if (err) {
                    fileDef.reject(err);
                } else {

                    zipFile.readEntry();
                    zipFile.on('error', function(err) {
                        def.reject(err);
                    });
                    zipFile.on('entry', function(entry) {
                        if (/\/$/.test(entry.fileName) || (/__MACOSX/).test(entry.fileName)) {
                            // ignore directories and MAC archives
                            zipFile.readEntry();
                        } else {
                            var strings = [];
                            zipFile.openReadStream(entry, function(err, readStream) {
                                if (err) {
                                    fileDef.reject(err);
                                } else {
                                    readStream.on('data', function(chunk) {
                                        strings.push(chunk);
                                    });
                                    readStream.on('end', function() {
                                        var nameLen = entry.fileName.length;
                                        if (entry.fileName.indexOf('.wsdl', nameLen - 5) != -1 || entry.fileName.indexOf('.xsd', nameLen - 4) != -1) {
                                            try {
                                                var fileContent = Buffer.concat(strings);
                                                var encoding = parseUtils.determineEncoding(fileContent, entry.fileName, req);
                                                fileContent = parseUtils.decode(fileContent, encoding);

                                                var DOMParser = require('xmldom').DOMParser;
                                                var wsdlDoc = new DOMParser().parseFromString(fileContent, 'text/xml');
                                                var lookForPorts = (typeof wsdlDoc == 'object');
                                                if (lookForPorts && serviceName) {
                                                    // Make sure the document has a service matching the service name
                                                    lookForPorts = false;
                                                    var serviceEls = wsdlDoc.documentElement.getElementsByTagNameNS(
                                                      'http://schemas.xmlsoap.org/wsdl/', SERVICE);
                                                    if (serviceEls) {
                                                        for (let s = 0; s < serviceEls.length; s++) {
                                                            if (serviceEls[s].getAttribute('name') === serviceName) {
                                                                lookForPorts = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                if (lookForPorts) {
                                                    var portEls = wsdlDoc.documentElement.getElementsByTagNameNS(
                                                      'http://schemas.xmlsoap.org/wsdl/', PORT);
                                                    var isModified = false;

                                                    var portLen = portEls.length;
                                                    for (var i = 0; i < portLen; i++) {
                                                        if (adjustPort(portEls.item(i), serviceEndpoints)) {
                                                            isModified = true;
                                                        }
                                                    } // end for

                                                    if (isModified) {
                                                        var serializer = new xmldom.XMLSerializer();
                                                        let str = serializer.serializeToString(wsdlDoc);
                                                        if (!isUTF8(encoding)) {
                                                            str = parseUtils.encode(str, encoding);
                                                        }
                                                        var file = {
                                                            filename: entry.fileName,
                                                            content: str
                                                        };
                                                        data.push(file);
                                                    }
                                                }
                                            } catch (e) {
                                                fileDef.reject(parseUtils.cleanupError(e, req));
                                            }
                                        }
                                        zipFile.readEntry();
                                    });
                                }
                            });
                        }
                    });
                    zipFile.on('end', function() {
                        fileDef.resolve(data);
                    });
                }
            });
        } else {
            try {
                var DOMParser = require('xmldom').DOMParser;
                let encoding = parseUtils.determineEncoding(rawContent, filenameOrContent);
                let content = (encoding === 'utf8') ? rawContent : parseUtils.decode(rawContent, encoding);
                var wsdlDoc = new DOMParser().parseFromString(content.toString(), 'text/xml');
                var isModified = false;
                var portEls = wsdlDoc.documentElement.getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', PORT);
                var portLen = portEls.length;
                for (var i = 0; i < portLen; i++) {
                    if (adjustPort(portEls.item(i), serviceEndpoints)) {
                        isModified = true;
                    }
                } // end for
                if (isModified) {
                    var serializer = new xmldom.XMLSerializer();
                    let str = serializer.serializeToString(wsdlDoc);
                    if (!isUTF8(encoding)) {
                        str = parseUtils.encode(str, encoding);
                    }
                    var file = {
                        filename: filenameOrContent.length > 200 ? 'IN_MEMORY' : filenameOrContent,
                        content: str
                    };
                    data.push(file);
                }
                fileDef.resolve(data);
            } catch (e) {
                fileDef.reject(parseUtils.cleanupError(e, req));
            }
        }
        fileDef.promise.then(function(wsdlStr) {
            def.resolve(wsdlStr);
        }, function(e) {
            def.reject(e);
        });
    }, function(fileErr) {
        def.reject(fileErr);
    });
    return def.promise;
}

function isUTF8(encoding) {
    return encoding.toLowerCase() === 'utf8' || encoding.toLowerCase() === 'utf-8';
}

/**
 * Change the addresses in the port to the first service endpoint.
 * For subsequent addresses, create and add new ports
 * @method adjustPort
 * @param Node port - port Port that requires adjustment and possible duplication
 * @param String[] - serviceEndpoints - Service Endpoints
 * @return boolean - true if any modifications are made
 */
function adjustPort(port, serviceEndpoints) {
    var isModified = false;
    if (serviceEndpoints.length > 0) {

    // Get children of port
        var children = port.getElementsByTagName('*');
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            // If this is an address element (an kind soap, wsdl, etc) then replace the location
            if (child.localName == ADDRESS) {
                if (child.hasAttribute(LOCATION)) {
                    child.setAttribute(LOCATION, serviceEndpoints[0]);
                    isModified = true;
                }
            }
        }

        // If there is more than one endpoint then duplicate the port and addresses
        if (isModified && serviceEndpoints.length > 1) {
            for (var j = 1; j < serviceEndpoints.length; j++) {
                var serviceEndpoint = serviceEndpoints[j];
                // Clone the port and change the name
                var newPort = port.cloneNode(true);
                var portName = port.getAttribute('name') + '_' + (j + 1);
                newPort.setAttribute('name', portName);

                // Add the node
                // (best practice is to use the node returned from appendChild because DOM is allowed to return a different Object
                // but in practice it usually returns the same object).
                newPort = port.parentNode.appendChild(newPort);

                // Adjust the locations
                children = newPort.getElementsByTagName('*');
                for (i = 0; i < children.length; i++) {
                    var newChild = children[i];
                    // If this is an address element (an kind soap, wsdl, etc) then replace the location
                    if (newChild.localName == ADDRESS) {
                        if (newChild.hasAttribute(LOCATION)) {
                            newChild.setAttribute(LOCATION, serviceEndpoint);
                        }
                    }
                } // for children
            } // for endpoints
        }
    }
    return isModified;
}

exports.setServiceEndpoint = setServiceEndpoint;
exports.injectServiceEndpointsIntoWSDLorZIP = injectServiceEndpointsIntoWSDLorZIP;
