/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';
const jsyaml = require('js-yaml');
var _ = require('lodash');
// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');
var q = require('q');


// NSName Reserved for global messages
var RESERVED_DEF = 'APIC__RESERVED';

/**
* Utility functions for the apiconnect-wsdl parser
**/

/**
* Return an array representation of the object
*/
function makeSureItsAnArray(obj, addNilObjects) {
    var ret = obj;
    if (!Array.isArray(obj)) {
        ret = [];
        if (obj || addNilObjects) {
            ret.push(obj);
        }
    }
    return ret;
}

/**
* Strip the prefix and return just the xsd name (aka xsd nsName)
*/
function stripNamespace(name) {
    var localName = name;
    if (name) {
        var index = name.indexOf(':');
        if (index != -1) {
            localName = name.substr(index + 1);
        }
    }
    return localName;
}

/**
* @return slugified name
*/
function slugifyName(title) {
    var name = title;
    if (name) {
    // multiple spaces replaced by single hyphen
        name = name.replace(/ +/gi, '-');
        // multiple hyphens replaced by single hyphen
        name = name.replace(/-+/gi, '-');
        // anything not a-z 0-9 A-Z hyphen removed
        name = name.replace(/[^A-Za-z0-9\\-]/gi, '');
        // remove all start hyphens
        name = name.replace(/^[-]+/, '');
        // remove all end hyphens
        name = name.replace(/[-]+$/, '');
        // remove all start numbers
        name = name.replace(/^[0-9]+/, '');
        // only lower case
        name = name.toLowerCase();
    }
    return name;
}

/**
* @return random apha name of the indicate maxLength
*/
function randomAlphaString(length) {
    var chars = 'abcdefghijklmnopqrstuvwxyz';
    var charLen = chars.length;
    var ret = '';
    for (var i = 0; i < length; i++) {
        ret += chars[Math.floor(Math.random() * charLen)];
    } // end for
    return ret;
}

/**
* @return a deep clone of obj
*/
function deepClone(obj) {
    if (obj === null) {
        return null;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    var child, cloned;
    if (obj instanceof Array) {
        child = [];
        var len = obj.length;
        for (var i = 0; i < len; i++) {
            cloned = deepClone(obj[i]);
            child.push(cloned);
        } // end for
    } else {
        child = {};
        for (var key in obj) {
            cloned = deepClone(obj[key]);
            child[key] = cloned;
        } // end for
    }
    return child;
}

/**
* @param obj
* @param ignore keys to ignore
* @return a deep clone of obj
*/
function deepCloneWithIgnoreKeys(obj, ignore) {
    if (obj === null) {
        return null;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    var child, cloned;
    if (obj instanceof Array) {
        child = [];
        var len = obj.length;
        for (var i = 0; i < len; i++) {
            cloned = deepCloneWithIgnoreKeys(obj[i], ignore);
            child.push(cloned);
        } // end for
    } else {
        child = {};
        for (var key in obj) {
            if (ignore.indexOf(key) < 0) {
                cloned = deepCloneWithIgnoreKeys(obj[key], ignore);
                child[key] = cloned;
            }
        } // end for
    }
    return child;
}

/**
* Add objects within source to target
*/
function extendObject(target, source, deep) {
    for (var name in source) {
        if (deep) {
            target[name] = deepClone(source[name]);
        } else {
            target[name] = source[name];
        }
    } // end for
    return target;
}

function getObjectName(o) {
    return o && o.constructor && o.constructor.name;
}

/**
* Get a prefix for the indicated namespace, create a new prefix if not found
*/
function getPrefixForNamespace(ns, namespaces, noAutogen) {
    var ret = '';
    var tempPrefix = '';
    if (!ns || ns === '') {
        return '';
    }
    if (ns && namespaces != null && typeof namespaces === 'object') {
        for (var prefix in namespaces) {
            var namespace = namespaces[prefix];
            if (ns == namespace) {
                if (prefix.substr(0, 1) == '_') {
                    // try not to use underscored prefixes if we can avoid it
                    tempPrefix = prefix;
                } else {
                    ret = prefix;
                    break;
                }
            }
        } // end for
        if (!ret && tempPrefix) {
            ret = tempPrefix;
        }
        if (!ret && ns  && !noAutogen) {
            // didn't find a match - need to add a new auto generated one
            var index = 1;
            var newPrefix = 'ns' + index;
            while (namespaces[newPrefix]) {
                index += 1;
                newPrefix = 'ns' + index;
            } // end while
            namespaces[newPrefix] = ns;
            ret = newPrefix;
        }
    }
    return ret;
}

/**
* Return a string representation of the value.
*/
function parseToPrimitive(value) {
    // Remove leading +
    if (value.startsWith('+')) {
        value = value.substring(1);
    }
    // Remove leading 0's
    value = value.replace(/^0+(?=\d)/, '');
    try {
        return JSON.parse(value);
    } catch (e) {
        return value.toString();
    }
}

// list the keys not shared by two objects or those amended since last processed
function disjointKeysToArray(obj, oldObj) {
    var ret = [];
    for (var key in obj) {
        if (!oldObj[key]) {
            ret.push({
                name: key,
                value: deepClone(obj[key])
            });
        } else {
            var previous = oldObj[key];
            if (previous && previous.offset != previous.referencingContexts.length) {
                ret.push({
                    name: key,
                    value: deepClone(obj[key])
                });
            }
        }
    } // end for
    return ret;
}


/**
* @param documentation is a node.soap documentation object
* The documentation element may have 'undefined' or '$value' keys.
* These are removed or changed so that the documentation object is
* either a string or an array of strings.
* @return a string representing the entire text of the documentation.
* The returned string is often used to set a description field in the
* swagger document.
*/
function cleanupDocumentation(documentation, req) {
    var ret = documentation;
    if (documentation) {
        if (typeof documentation === 'string') {
            ret = documentation;
        } else {
            // Convert to array and remove attributes from the documentation element
            documentation = makeSureItsAnArray(documentation);
            for (var i = 0; i < documentation.length; i++) {
                if (documentation[i]) {
                    if (documentation[i]['undefined']) {
                        delete documentation[i]['undefined'];
                    }
                    if (documentation[i]['$value']) {
                        documentation[i] = documentation[i]['$value'];
                    }
                }
            }
            // Return the single document or a string representation of all the documents
            if (documentation.length == 1 && documentation[0] && typeof documentation[0] === 'string') {
                ret = documentation[0];
            } else {
                ret = JSON.stringify(documentation);
            }
        }
    }
    ret = removeNonUTF8Chars(ret);
    if (ret && ret.length > 20000) {
        ret = ret.substring(0, 20000) + g.http(r(req)).f('(Documentation limit exceeded. The text is pruned.)');
    }
    return ret;
}

/**
* return the apiconnect-wsdl getVersion
*/
function getVersion() {
    return require('./../package.json').version;
}

// Don't trigger asserts in production code.
var useAsserts = false;
function setAsserts(val) {
    useAsserts = val;
}

/**
* Create a validation compliant error
*/
function makeValidationErr(message) {
    let valError = new Error(message);
    return convertToValidationErr(valError);
}
/**
* Add text message to the error using the validator format
* { messages: [ {message: <message>}]}
* @param valError the validator style error
* @param stringOrErr the new error to add to valError
*/
function addValidationErr(valError, stringOrErr, req) {
    // Add the messages array
    if (!valError.messages) {
        valError.messages = [];
    }
    // Get the new message
    let message = 'no message';
    try {
        if (typeof stringOrErr === 'string') {
            message = stringOrErr;
        } else {
            if (stringOrErr.message) {
                message = stringOrErr.message;
            } else {
                message = JSON.stringify(stringOrErr);
            }
        }
        let subText = g.http(_(req)).f('An error occurred while parsing "%s".\n', 'MEMORY');
        message = message.replace(subText, '');
    } catch (e) {
        message = 'no message';
    }
    // Add the new message to the messages array
    valError.messages.push({
        message: message
    });
    // Update the error message to be the combined text of all messages.
    valError.message = '';
    let nl = '';
    for (let i = 0; i < valError.messages.length; i++) {
        valError.message += nl + valError.messages[i].message;
        nl = '\n';
    }
    return valError;
}

/**
* Convert the error to the validation error format
*/
function convertToValidationErr(err) {
    if (!err.messages || !(err.messages instanceof Array)) {
        err.messages = [ { message: err.message } ];
    }
    return err;
}

/**
* Load and store from yaml as a quick validation and fixup for any encoding or other common issues.
**/
function checkAndFix(object) {
    try {
        // Use safedump to validate the object
        let s = jsyaml.safeDump(object);
        return object;
    } catch (e) {
        try {
            return jsyaml.load(jsyaml.safeDump(object,
               { skipInvalid: true } // Suppress dumping of keys with undefined values without error
            ));
        } catch (e) {
            throw e;
        }
    }
}


/**
* Detect and remove non-UTF8 characters
*/
function removeNonUTF8Chars(text) {
    // Put the text in a json object
    let s = {
        data: text
    };
    // Convert to yaml.  Any non utf chars are converted to hex escapes
    let yaml = jsyaml.dump(s);

    // Now remove the hex escapes
    yaml = yaml.replace(/\\x[0-9A-E][0-9A-E]/g, '');
    return jsyaml.load(yaml).data;
}

/**
* Find all of the $refs deeply nested in obj and return
* a map of refs -> count infomation.
* @param obj
* @return map object: ref string -> { count: number, allOfCount: number}
*/
function findRefs(obj) {
    let map = { refs: {} };
    traverse(obj, function(curr, path, stack) {
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        let isAllOf = path.length > 2 ? path[path.length - 3] === 'allOf' : false;
        if (curr && key === '$ref') {
            let ref = curr;
            map.refs[ref] = map.refs[ref] || { count: 0, allOfCount: 0 };
            map.refs[ref].count += 1;
            if (isAllOf) {
                map.refs[ref].allOfCount += 1;
            }
        }
        return curr;
    });
    return map;
}

/**
* Traverse the object
* @param obj source object
* @param post function called during postFix pass (most common)
* @param pre (optional) function called during the prefix pass.
* @param stack for recursion
*/
function traverse(obj, post, pre, path, stack) {
    path = path || [];
    stack = stack || [];

    if (pre) {
        obj = pre(obj, path, stack);
    }
    if (Array.isArray(obj)) {
        let len = obj.length;
        for (let i = 0; i < obj.length; i++) {
            path.push(i);
            stack.push(obj);
            obj[i] = traverse(obj[i], post, pre, path, stack);
            stack.pop();
            path.pop();
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                path.push(key);
                stack.push(obj);
                obj[key] = traverse(obj[key], post, pre, path, stack);
                stack.pop();
                path.pop();
            }
        }
    }
    if (post) {
        obj = post(obj, path, stack);
    }
    return obj;
}

/**
* Traverse the xso objects.
* Same as traverse, but the postfixFunction and prefixFunction are only called for each xso (xml schema object)
* @param obj source object
* @param postfixFunction function called during postFix pass (most common)
* @param prefixFunction (optional) function called during the prefix pass.
*/
function traverseXSO(swagger, postfixFunction, prefixFunction) {
    var nsName;
    return traverse(swagger, function(curr, path, stack) {
        // Postfix call
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        let key2 = path.length > 1 ? path[path.length - 2] : undefined;
        let key3 = path.length > 2 ? path[path.length - 3] : undefined;
        let isRootXSO = (key2 === 'definitions' || key3 === 'components' && key2 === 'schemas');
        if (postfixFunction && curr &&
            (isRootXSO ||
            [ 'properties', 'allOf', 'oneOf', 'anyOf' ].includes(key2) ||
            key === 'items')) {
            // Check to see if there are one or more of the expected keys in object just
            // in case the keywords above collide with a schema name.
            if (curr.type || curr.xml || curr.properties || curr.$ref || curr.allOf || curr.oneOf || curr.anyOf || curr['x-anyType']) {
                return postfixFunction(curr, nsName, isRootXSO, path, stack);
            }
        }
        return curr;
    }, function(curr, path, stack) {
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        let key2 = path.length > 1 ? path[path.length - 2] : undefined;
        let key3 = path.length > 2 ? path[path.length - 3] : undefined;
        let isRootXSO = (key2 === 'definitions' || key3 === 'components' && key2 === 'schemas');

        if (curr &&
            (key2 === 'definitions' || key3 === 'components' && key2 === 'schemas')) {
            // Check to see if there are one or more of the expected keys in object just
            // in case the keywords above collide with a schema name.
            if (curr.type || curr.xml || curr.properties || curr.$ref || curr.allOf || curr.oneOf || curr.anyOf || curr['x-anyType']) {
                nsName = key;
            }
        }
        if (prefixFunction && curr &&
            (isRootXSO ||
            [ 'properties', 'allOf', 'oneOf', 'anyOf' ].includes(key2) ||
            key === 'items')) {
            // Check to see if there are one or more of the expected keys in object just
            // in case the keywords above collide with a schema name.
            if (curr.type || curr.xml || curr.properties || curr.$ref || curr.allOf || curr.oneOf || curr.anyOf || curr['x-anyType']) {
                return prefixFunction(curr, nsName, isRootXSO, path, stack);
            }
        }
        return curr;
    });
}

/**
* Traverse the swagger objects.
* Same as traverse, but the postfixFunction is called for each swagger or embedded swagger
* @param obj source object
* @param postfixFunction function called during postFix pass (most common)
*/
function traverseSwagger(swagger, postfixFunction) {
    var nsName;
    return traverse(swagger, function(curr, path, stack) {
        // Postfix call
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        let key2 = path.length > 1 ? path[path.length - 2] : undefined;
        if (key === undefined || key2 === 'targets') {
            if (postfixFunction && (curr.swagger || curr.openapi)) {
                return postfixFunction(curr, path, stack);
            }
        }
        return curr;
    });
}

function selfReferences(swagger) {
    let list = [];
    traverseXSO(swagger, function(obj, nsName) {
        if (obj && obj.$ref) {
            let words = obj.$ref.split('/');
            let refName = words[words.length - 1];
            console.log(refName);
            if (refName === nsName && _.indexOf(list, nsName) < 0) {
                list.push(nsName);
            }
        }
        return obj;
    });
    return list;
}

/**
* Squash redundant allOfs in an xso (xml schema object)
*/
function squashAllOf(xso) {
    if (xso.allOf) {
        for (let i = 0; i < xso.allOf.length; i++) {
            xso.allOf[i] = squashAllOf(xso.allOf[i]);
        }
    }
    if (xso.allOf) {

        // Try to merge consecutive allOf items
        let allOf = [];
        for (let i = 0; i < xso.allOf.length; i++) {
            allOf.push(xso.allOf[i]);
            if (allOf.length >= 2) {
                let b = allOf.pop();
                let a = allOf.pop();
                if (a.$ref) {
                    allOf.push(a);
                    allOf.push(b);
                } else {
                    let m = mergeXSO(a, [ b ]);
                    if (m) {
                        allOf.push(m);
                    } else {
                        allOf.push(a);
                        allOf.push(b);
                    }
                }
            }
        }
        if (allOf[0].$ref) {
            // Make sure there is one and only two allOf items when there is a ref
            if (allOf.length === 1) {
                allOf.push({
                    type: 'object',
                    properties: {}
                });
            } else if (allOf.length >= 3) {
                allOf = [
                    allOf[0],
                    {
                        xml: {
                            namespace: '',
                            prefix: ''
                        },
                        allOf: allOf.slice(1)
                    } ];
            }
        }
        xso.allOf = allOf;
        // If only one allOf remains, then remove the allOf
        // Don't do this if the allOf is a ref, because that indicates hierarchy.
        // Don't do this if the allOf is an array, because that indicates occurrence of a unnamed construct (i.e. sequence with maxOccurs)
        if (xso.allOf.length == 1 && !xso.allOf[0].$ref  && !xso.allOf[0].items) {
            let target = deepClone(xso);
            let source = deepClone(xso.allOf[0]);
            delete target.allOf;
            delete source.xml;
            xso = _.merge(target, source);
        }
    }
    return xso;
}

/**
* merge xso into xso
* @param target target xso
* @param sources source xsos
* @param new xso or null if not able to merge
*/
function mergeXSO(target, sources) {

    // Create the new xso
    let xso = deepClone(target);
    if (target.allOf || target.oneOf || target.anyOf || target.$ref || target.type === 'array') {
        return null;
    }
    let propertiesCount = target.properties ? Object.keys(target.properties).length : 0;
    let simpleType = target.type === 'object' ? undefined : target.type;
    for (let i = 0; i < sources.length; i++) {
        let source = deepClone(sources[i]);
        if (source.allOf || source.oneOf || source.anyOf || source.$ref || source.type === 'array') {
            return null;
        }
        simpleType = source.type === 'object' ? simpleType : source.type;

        // Add xml if missing on a property
        if (source.properties) {
            for (let propName in source.properties) {
                let prop = source.properties[propName];
                if (prop.type === 'array') {
                    prop = prop.items;
                }
                if (!prop.xml && !prop.$ref) {
                    prop.xml = deepClone(source.xml);
                }
            }
        }
        delete source.xml;
        // Don't lose any required information
        if (source.required && xso.required) {
            source.required = _.union(xso.required, source.required);
        }
        propertiesCount += source.properties ? Object.keys(source.properties).length : 0;
        xso = _.merge(xso, source);
    }
    xso.type = simpleType || xso.type;  // Use simple type if found

    if (propertiesCount === 0) {
        if (xso.type !== 'object') {
            delete xso.properties;
        }
    }
    // Don't do the merge if a property collision occurred
    let xsoPropertiesCount = xso.properties ? Object.keys(xso.properties).length : 0;
    if (propertiesCount === xsoPropertiesCount) {
        return xso;
    } else {
        return null;
    }
}

/**
* Return true if the nsName is in a polymorphic hierarchy which is referenced.
* @param definitions
* @param nsName: name of definition in definitions object
* @param anc: ancestor array (output of getAncestorRefs)
* @paran map: Reference map array (output of findRefs)
* @return true or false
*/
function inPolyHierarchy(definitions, nsName, anc, map) {
    let def = definitions[nsName];
    if (anc) {
        // In a poly hierachy if any of the ancestors is referenced in a non-allOf context.
        for (let i = 0; i < anc.length; i++) {
            let mapRef = map.refs[anc[i]];
            if (mapRef && (mapRef.count - mapRef.allOfCount > 0)) {
                return true;
            }
        }
    }
    // Root of poly hierachy if no ancestors and referenced and x-ibm-discriminator
    if (def && def['x-ibm-discriminator']) {
        let ref = '#/definitions/' + nsName;
        let mapRef = map.refs[ref];
        if (mapRef && (mapRef.count - mapRef.allOfCount > 0)) {
            return true;
        }
    }
    return false;
}

/**
* Return map of subTypes
* @param definitions
* @param subTypes: initially not set, map of subTypes
* @return subTypes map (key:base, value array of subTypes)
*/
function getSubTypes(definitions, subTypes) {
    subTypes = subTypes || {};
    for (let nsName in definitions) {
        let def = definitions[nsName];
        if (def.allOf && def.allOf.length > 0 && def.allOf[0].$ref) {
            let base = getDefNameFromRef(def.allOf[0].$ref);
            if (definitions[base]) {
                if (!subTypes[base]) {
                    subTypes[base] = [];
                }
                subTypes[base].push(nsName);
            }
        }
    }
    return subTypes;
}

function getDescendents(nsName, subTypes) {
    if (!subTypes[nsName]) {
        return [];
    }
    let descendents = deepClone(subTypes[nsName]);
    for (let i = 0; i < subTypes[nsName].length; i++) {
        descendents = _.union(descendents, getDescendents(subTypes[nsName][i], subTypes, _.isEqual));
    }
    return descendents;
}

/**
* Return array or ancestor references
* @param definitions
* @param nsName: name of definition in definitions object
* @return array of reference strings
*/
function getAncestorRefs(definitions, nsName, req, anc) {
    let def = definitions[nsName];
    // The first ref in an allOf is always a reference to the ancestor definition
    if (def && def.allOf && def.allOf.length > 0 && def.allOf[0]['$ref']) {
        let ref = def.allOf[0]['$ref'];
        anc = anc || [];
        if (anc.includes(ref)) {
            throw g.http(r(req)).Error('Reference cycle detected in extension or restriction hierarchy: %s', anc);
        }
        anc = anc.concat([ ref ]);
        anc = getAncestorRefs(definitions, getDefNameFromRef(ref), req, anc);
    }
    return anc;
}

/**
* Convience method
*/
function getDefNameFromRef(ref) {
    return ref.substring(ref.lastIndexOf('/') + 1);
}

/**
* String replacement on each ref
*/
function replaceRefs(obj, list) {
    let map = { refs: {} };
    traverse(obj, function(curr, path, stack) {
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        if (curr && key === '$ref') {
            let ref = curr;
            for (let i = 0; i < list.length; i++) {
                if (ref.indexOf(list[i].source >= 0)) {
                    curr = ref.replace(list[i].source, list[i].target);
                    return curr;
                }
            }
        }
        return curr;
    });
    return map;
}

function wseRelatedNamespace(ns) {
    return ns === 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd' ||
           ns === 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd';
}

/**
* Due to a bug in the node soap parser, the whitespace
* in end tags is not ignored.  This leads to random bugs during
* the processing of the soap parser output.  The whitespace
* in the end tags is removed.
*/
function fixTags(contents) {
    if (contents) {
        if (contents.toString) {
            contents = contents.toString();
        }
        contents = _.replace(contents, /<\/\w+:\w+\s+>/g, function(s) {
            let t = _.replace(s, /\s+/, '');
            return t;
        });
    }
    return contents;
}

/**
* Remove all of the description objects from the xml schema objects
*/
function removeDescription(swagger) {
    return traverseXSO(swagger, function(s) {
        if (s) {
            delete s.description;
        }
        return s;
    });
}

/*
* Default request to Operating system or english if a
* reqest object is not provided.
*/
function r(req) {
    if (!req && !require('../src/wsdl.js').DEFAULT_GLOBALIZE_USE_OS) {
        req = {
            headers: {
                'accept-language': 'en',
            },
        };
    }
    return req;
}

/**
* @return the file name from a path
*/
function fileNameFromPath(path) {
    return path.replace(/^.*[\\\/]/, '');
}


/**
* @return true if NMTOKEN
**/
function isNMTOKEN(name) {
    // Approximation of NMTOKEN

    let regexp = /^[^\b\t\n\f$ \r'\\\",!#$%&()+;<=>?@{}|]*$/;
    return regexp.test(name);
}

/**
* @return true if NCName
**/
function isNCName(name) {
    // Approximation of NCName (non-colon name)
    // The first character must be a letter or underscore, remaining characters must be letter, digit, underscore or period.
    // Note that non-latin letters are permitted.
    // let regexp = /[^1-9\.:\b\t\n\f$ \r'\\\",!#$%&()+;<=>?@{}|]+[^:\b\t\n\f$ \r'\\\",!#$%&()+;<=>?@{}|]*/;
    // let regexp = /[^:\b\t\n\f$ \r'\\\",!#$%&()+;<=>?@{}|]+/;

    let regexp = /^[^1-9\.:\b\t\n\f$ \r'\\\",!#$%&()+;<=>?@{}|]+[^:\b\t\n\f$ \r'\\\",!#$%&()+;<=>?@{}|]*$/;
    return regexp.test(name);
}

/**
* @return true if QName
*/
function isQName(name) {
    let names = name.split(':');
    if (names.length === 1) {
        // non-prefixed qname
        return isNCName(names[0]);
    } else if (names.length === 2) {
        // prefixed qname
        return isNCName(names[0]) && isNCName(names[1]);
    } else {
        return false;
    }
}

/**
* If gateway provided, then the swagger is chagned to conform to the gateway (i.e. correct policy versions).
* If gateway is not provided, then throw an error if the swagger is not compliant
* @param swagger
* @param gateway (optional)
*/
function checkAndSetGateway(swagger, req, gateway) {

    let check = !gateway;
    let ibmConfig = swagger['x-ibm-configuration'];
    let allowed = [ 'datapower-gateway', 'datapower-api-gateway', 'micro-gateway' ];
    if (check) {
        gateway = ibmConfig.gateway;
    } else {
        ibmConfig.gateway = gateway;
    }

    if (allowed.indexOf(gateway) < 0) {
        throw g.http(r(req)).Error('The gateway %s is incorrect.  Expected %s.', gateway, allowed);
    }

    let isV6 = (gateway === 'datapower-api-gateway');

    let execute = swagger['x-ibm-configuration'].assembly.execute;

    // Use invoke or proxy
    for (let i = 0; i < execute.length; i++) {
        let x = execute[i];
        if (x.proxy) {
            if (isV6) {
                if (check) {
                    throw g.http(r(req)).Error('A \'proxy\' was found but expected \'invoke\' for gateway %s.', gateway);
                } else {
                    x.invoke = x.proxy;
                    x.invoke.title = x.invoke.title === 'proxy' ? 'invoke' : x.invoke.title;
                    delete x.proxy;
                    x.invoke.version = '2.0.0';
                }
            }
        } else if (x.invoke) {
            if (!isV6) {
                if (check) {
                    throw g.http(r(req)).Error('An \'invoke\' was found but expected \'proxy\' for gateway %s.', gateway);
                } else {
                    x.proxy = x.invoke;
                    x.proxy.title = x.proxy.title === 'invoke' ? 'proxy' : x.poryx.title;
                    delete x.invoke;
                    delete x.proxy.version;
                }
            }
        }
    }
    traverse(ibmConfig, function(obj, path) {
        let name = path.length > 0 && path[path.length - 1];

        // Check and fix invoke version
        if (name == 'invoke') {
            if (obj.version === '2.0.0') {
                if (!isV6) {
                    if (check) {
                        throw g.http(r(req)).Error('The invoke version %s conflicts with the gateway %s.', obj.version, gateway);
                    } else {
                        delete obj.version;
                    }
                }
            } else {
                if (isV6) {
                    if (check) {
                        throw g.http(r(req)).Error('The invoke version %s conflicts with the gateway %s.', obj.version, gateway);
                    } else {
                        obj.version = '2.0.0';
                    }
                }
            }
        }
        // Check and fix map version
        if (name == 'map') {
            if (obj.version === '2.0.0') {
                if (!isV6) {
                    if (check) {
                        throw g.http(r(req)).Error('The map version %s conflicts with the gateway %s.', obj.version, gateway);
                    } else {
                        obj.version = '1.0.0';
                    }
                }
            } else {
                if (isV6) {
                    if (check) {
                        throw g.http(r(req)).Error('The map version %s conflicts with the gateway %s.', obj.version, gateway);
                    } else {
                        obj.version = '2.0.0';
                    }
                }
            }
        }
        // Check and fix map operation-switch
        if (obj['operation-switch']) {
            if (isV6) {
                if (check) {
                    throw g.http(r(req)).Error('The \'operation-switch\' policy conflicts with the gateway %s.  Expected \'switch\'.', gateway);
                } else {
                    obj.switch = obj['operation-switch'];
                    obj.switch.version = '2.0.0';
                    delete obj['operation-switch'];
                    if (obj.switch.case) {
                        for (let i = 0; i < obj.switch.case.length; i++) {
                            let operations = obj.switch.case[i].operations;
                            obj.switch.case[i] = {
                                condition: '',
                                execute: obj.switch.case[i].execute
                            };
                            let conditions = [];
                            // Exampl condition: (($httpVerb() = 'POST' and $operationPath() = '/Add'))
                            if (operations) {
                                for (let j = 0; j < operations.length; j++) {
                                    let op = operations[j];
                                    let terms = [];
                                    if (op.verb) {
                                        terms.push('$httpVerb() = \'' + op.verb.toUpperCase() + '\'');
                                    }
                                    if (op.path) {
                                        terms.push('$operationPath() = \'' + op.path + '\'');
                                    }
                                    conditions.push('(' + _.join(terms, ' and ') + ')');
                                }
                            }
                            obj.switch.case[i].condition = '(' + _.join(conditions, '||') + ')';
                        }
                    }
                }
            }
        }
        // Check and fix map switch

        if (obj['switch']) {
            if (!isV6) {
                if (check) {
                    throw g.http(r(req)).Error('The \'switch\' policy conflicts with the gateway %s.  Expected \'operation-switch\'.', gateway);
                } else {
                    obj['operation-switch'] = obj.switch;
                    obj['operation-switch'].version = '1.0.0';
                    delete obj.switch;
                    if (obj['operation-switch'].case) {
                        for (let i = 0; i < obj['operation-switch'].case.length; i++) {
                            let condition = obj['operation-switch'].case[i].condition;
                            // This is heuristic to get the verb and path
                            let words = _.words(condition, /'[^']+'/g);
                            let operations = [];
                            for (let j = 0; j < words.length - 1; j += 2) {
                                let verb = _.trim(words[j], '\'').toLowerCase();
                                let path = _.trim(words[j + 1], '\'');
                                operations.push({
                                    verb: verb,
                                    path: path
                                });
                            }
                            obj['operation-switch'].case[i] = {
                                operations: operations,
                                execute: obj['operation-switch'].case[i].execute
                            };
                        }
                    }
                }
            }
        }
        return obj;
    });

    // Repeat for targets
    if (ibmConfig.targets) {
        for (let service in ibmConfig.targets) {
            ibmConfig.targets[service] = checkAndSetGateway(ibmConfig.targets[service], req, gateway);
        }
    }
    return swagger;
}

/**
* iterate async function 'f(...args)' for (limit) times
*/
function iterate(limit, f, ...args) {
    let count = 0;
    let def = q.defer();

    function doIt(i, promise) {
        let myDef = q.defer();
        promise.then(function() {
            // console.log('count ' + i);
            f(...args).then(function(data) {
                if (i >= (limit - 1)) {
                    def.resolve(data);
                } else {
                    myDef.resolve();
                }
            }, function(err) {
                def.reject(err);
            });
        }, function(err) {
            def.reject(err);
        });
        return myDef.promise;
    }

    try {
        let firstDef = q.defer();
        let priorPromise = firstDef.promise;
        // Chain
        for (let i = 0; i < limit; i++) {
            priorPromise = doIt(i, priorPromise);
        }
        // Trigger
        firstDef.resolve();
    } catch (e) {
        console.log(e);
        throw e;
    }

    return def.promise;
}



exports.r = r;
exports.addValidationErr = addValidationErr;
exports.checkAndSetGateway = checkAndSetGateway;
exports.cleanupDocumentation = cleanupDocumentation;
exports.convertToValidationErr = convertToValidationErr;
exports.deepClone = deepClone;
exports.deepCloneWithIgnoreKeys = deepCloneWithIgnoreKeys;
exports.disjointKeysToArray = disjointKeysToArray;
exports.extendObject = extendObject;
exports.findRefs = findRefs;
exports.fileNameFromPath = fileNameFromPath;
exports.findRefs = findRefs;
exports.fixTags = fixTags;
exports.checkAndFix = checkAndFix;
exports.getAncestorRefs = getAncestorRefs;
exports.getDescendents = getDescendents;
exports.getSubTypes = getSubTypes;
exports.getDefNameFromRef = getDefNameFromRef;
exports.getObjectName = getObjectName;
exports.getVersion = getVersion;
exports.getPrefixForNamespace = getPrefixForNamespace;
exports.inPolyHierarchy = inPolyHierarchy;
exports.isNMTOKEN = isNMTOKEN;
exports.isNCName = isNCName;
exports.isQName = isQName;
exports.makeSureItsAnArray = makeSureItsAnArray;
exports.makeValidationErr = makeValidationErr;
exports.parseToPrimitive = parseToPrimitive;
exports.randomAlphaString = randomAlphaString;
exports.removeDescription = removeDescription;
exports.removeNonUTF8Chars = removeNonUTF8Chars;
exports.replaceRefs = replaceRefs;
exports.traverse = traverse;
exports.traverseSwagger = traverseSwagger;
exports.traverseXSO = traverseXSO;
exports.selfReferences = selfReferences;
exports.setAsserts = setAsserts;
exports.slugifyName = slugifyName;
exports.squashAllOf = squashAllOf;
exports.stripNamespace = stripNamespace;
exports.useAsserts = useAsserts;
exports.wseRelatedNamespace = wseRelatedNamespace;
exports.RESERVED_DEF = RESERVED_DEF;
