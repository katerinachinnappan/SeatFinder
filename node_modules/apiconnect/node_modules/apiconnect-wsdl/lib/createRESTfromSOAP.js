/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Utilities to create SOAP->REST
**/

const u = require('../lib/utils.js');
const util = require('util');
const copts = require('../lib/createOptions.js');
const soapGen = require('../lib/generateSOAP.js');
const postGen = require('../lib/postGenerate.js');

// var g = require('strong-globalize')();
var g = require('../lib/strong-globalize-fake.js');


/**
* Migrate a SOAP-Proxy or SOAP-REST from v5 to v6
* @param swaggerV5
* @param options (currently not used)
* @return swaggerv6
*/
function migrateFromV5(swaggerV5, options) {
    let swaggerV6 = u.deepClone(swaggerV5);
    return swaggerV6;
}

/**
* Migrate a SOAP-Proxy or SOAP-REST from velox(v6) to v5
* @param swaggerV6
* @param options (currently not used)
* @return swaggerv5
*/
function migrateToV5(swaggerV6, options) {
    let swaggerV5 = u.deepClone(swaggerV6);
    let embedService = null;

    if (swaggerV5['x-ibm-configuration']['wsdl-definition']) {
        embedService = swaggerV5['x-ibm-configuration']['wsdl-definition'].service;
        if (swaggerV5['x-ibm-configuration'].type === 'wsdl-proxy') {
            swaggerV5['x-ibm-configuration'].type = 'wsdl';
        } else if (swaggerV5['x-ibm-configuration'].type === 'wsdl-to-rest') {
            swaggerV5['x-ibm-configuration'].targets[embedService]['x-ibm-configuration']['wsdl-definition'] =
              u.deepClone(swaggerV5['x-ibm-configuration']['wsdl-definition']);
            swaggerV5['x-ibm-configuration'].targets[embedService]['x-ibm-configuration'].type = 'wsdl';
            delete swaggerV5['x-ibm-configuration'].type;
            delete swaggerV5['x-ibm-configuration']['wsdl-definition'];
        }
    }

    return swaggerV5;
}

/**
* Create a SOAP->REST swagger from the soapSwagger
* @param soapSwagger (open api created from getSwaggerForService)
* @param options
*   badgerfishDefs: default true.  Json definitions in badgerfish form
*   mapOptions: setting to use for autogenerated assembly map. The default is no map.options
*       mapOptions.includeEmptyXMLElements
*       mapOptions.namespaceInheritance
*       mapOptions.inlineNamespaces
*   mapSOAPFaults: default true
*   decodeGatewayScript : default false
*   req: request or null (used for i18n negotiation)
* @return restSwagger (SOAP->REST swagger)
*/
function getSwaggerForSOAPREST(soapSwagger, createOptions) {
    createOptions = copts.validate(createOptions);

    let service = soapSwagger['x-ibm-configuration']['wsdl-definition'].service;

    // Initialize the rest swagger
    let restSwagger = initRESTSwagger(service, createOptions.type, soapSwagger['x-ibm-configuration']['wsdl-definition']);

    // Embed the soap swagger as a target
    restSwagger = addTargetService(soapSwagger, restSwagger);

    // Add REST paths and post operations for each soap operation
    addRESTPaths(soapSwagger, restSwagger);

    // Add the assembly operation-switch
    addAssemblySwitch(restSwagger, service, createOptions);

    // Create a description of each operation
    let operationDesc = createOperationDesc(soapSwagger, createOptions);

    // Add the definitions for th operation request, response, fault
    addRESTOperationDefinitions(operationDesc, restSwagger, service, createOptions);

    // Add the request and response mappings into the assembly
    addAssemblyIO(restSwagger);

    // Add json definitions to the api for each soap definition
    addRESTDefinitions(soapSwagger, restSwagger, createOptions);

    // Add the wiring of the request and response mappings
    addAssemblyWiring(restSwagger, operationDesc, createOptions.req);

    // Add the SOAPFault _catch
    if (createOptions.mapSOAPFaults) {
        addAssemblyCatchSOAPError(restSwagger, service, operationDesc, createOptions);
    }

    // Modify to comply with the gateway
    restSwagger = u.checkAndSetGateway(restSwagger, createOptions.req, createOptions.gateway);


    // Add xml objects to all xso objects in case some were not produced.
    postGen.c14nXMLObjects(restSwagger, true);
    postGen.c14nxso(restSwagger, createOptions.req);


    return restSwagger;
}

/**
* Initialize the REST swagger with reasonable defaults
**/
function initRESTSwagger(service, type, wsdlDef) {
    let ibmName = u.slugifyName(service);
    let swagger = {
        swagger: '2.0',
        info: {
            'x-ibm-name': ibmName,
            title: service,
            version: '1.0.0',
        },
        schemes: [ 'https' ],
        host: '$(catalog.host)',
        basePath: '/' + service,
        consumes: [ 'application/json' ],
        produces: [ 'application/json' ],
        securityDefinitions: {
            clientIdHeader: {
                type: 'apiKey',
                in: 'header',
                name: 'X-IBM-Client-Id',
            }
        },
        security: [ {
            clientIdHeader: []
        } ],
        'x-ibm-configuration': {
            type: type,
            testable: true,
            enforced: true,
            gateway: 'datapower-gateway',  // This is the default. It will be adjusted.
            cors: {
                enabled: true
            },
            'wsdl-definition': u.deepClone(wsdlDef),
            assembly: {
                execute: []
            },
            phase: 'realized',
            targets: {}
        },
        paths: {},
        definitions: {},
        tags: []
    };
    return swagger;
}

/**
* Embed the soap swagger into the REST swagger
* (Ensure all references are properly updated)
* @param soapSwagger
* @param restSwagger
*/
function addTargetService(soapSwagger, restSwagger) {
    let service = soapSwagger['x-ibm-configuration']['wsdl-definition'].service;

    restSwagger['x-ibm-configuration'].targets[service] = u.deepClone(soapSwagger);
    delete restSwagger['x-ibm-configuration'].targets[service]['x-ibm-configuration']['wsdl-definition'];
    delete restSwagger['x-ibm-configuration'].targets[service]['x-ibm-configuration'].type;
    let jsonString = JSON.stringify(restSwagger);
    let srcRef = '#/definitions/';
    let tgtRef = '#/x-ibm-configuration/targets/' + service + '/definitions/';
    jsonString = jsonString.replace(new RegExp(srcRef, 'g'), tgtRef);
    return JSON.parse(jsonString);
}

/**
* Add REST paths and post operations for each soap operation
* @param soapSwagger
* @param restSwagger
*/
function addRESTPaths(soapSwagger, restSwagger) {
    for (let soapPath in soapSwagger.paths) {
        restSwagger.paths[soapPath] = {
            post: {
                responses: {
                    200: {
                        description: '200 OK'
                    }
                },
                parameters: []
            }
        };
        if (soapSwagger.paths[soapPath].rest && soapSwagger.paths[soapPath].rest.description) {
            restSwagger.paths[soapPath].rest.description = soapSwagger.paths[soapPath].rest.description;
        }
    }
}

/**
* Add assembly switch with a case statement for each operation
* @param restSwagger with embedded SOAP soapProxy
* @param service wsdl service name
* @param mapOptions map.options setting
*/
function addAssemblySwitch(restSwagger, service, options) {
    // The root of the assembly is an operation switch
    // and each case is an request map, invoke, response map
    let operationSwitch = {
        title: 'operation-switch',
        case: [],
        otherwise: [],
        version: '1.0.0'
    };
    restSwagger['x-ibm-configuration'].assembly.execute.push({
        'operation-switch': operationSwitch
    });

    if (options.decodeGatewayScript) {
        restSwagger['x-ibm-configuration'].assembly.execute.push({
            gatewayscript: deBadgerfishGatewayScript('Decode: script')
        });
    }

    let soapDefPath = '#/x-ibm-configuration/targets/' + service + '/definitions/';
    let isSOAP12 = restSwagger['x-ibm-configuration']['wsdl-definition']['soap-version'] === '1.2';

    for (let pathKey in restSwagger['x-ibm-configuration'].targets[service].paths) {
        let name = pathKey.substring(1);
        let path = restSwagger['x-ibm-configuration'].targets[service].paths[pathKey];
        let proxyInvoke =
          restSwagger['x-ibm-configuration'].targets[service]['x-ibm-configuration'].assembly.execute[0].proxy ||
          restSwagger['x-ibm-configuration'].targets[service]['x-ibm-configuration'].assembly.execute[0].invoke;
        let soapProxyURL = proxyInvoke['target-url'];

        let _case = {
            operations: [ {
                verb: 'post',
                path: pathKey
            } ],
            execute: [ {
                map: {
                    title: name + ': input',
                    inputs: {},
                    outputs: {
                        'content-type': {
                            schema: {
                                type: 'string'
                            },
                            variable: 'message.headers.content-type'
                        }
                    },
                    actions: []
                }
            }, {
                invoke: {
                    title: name + ': invoke',
                    'target-url': soapProxyURL,
                    timeout: 60,
                    verb: 'POST',
                    'cache-response': 'protocol',
                    'cache-ttl': 900,
                    output: 'InvokeOut',
                    'stop-on-error': [ 'SOAPError' ]
                }
            }, {
                map: {
                    title: name + ': output',
                    inputs: {},
                    outputs: {},
                    actions: []
                }
            } ]
        };

        let contentType = isSOAP12 ?
            'application/soap+xml;charset=UTF-8;action="' + path.post['x-ibm-soap']['soap-action'] + '"' :
            'text/xml';

        // Set soap input if present
        let soapInputRef = soapDefPath + name + 'Input';
        if (refExists(restSwagger, soapInputRef)) {
            _case.execute[0].map.outputs.body = {
                schema: {
                    $ref: soapDefPath + name + 'Input'
                },
                variable: 'message.body',
                content: contentType
            };
        }

        // Set soap output if present
        let soapOutputRef = soapDefPath + name + 'Output';
        if (refExists(restSwagger, soapOutputRef)) {
            _case.execute[2].map.inputs.input = {
                schema: {
                    $ref: soapDefPath + name + 'Output'
                },
                variable: 'InvokeOut.body',
                content: 'application/xml'
            };
        }

        // Add default mapOptions if specified
        if (options.mapOptions) {
            _case.execute[0].map.options = options.mapOptions;
            _case.execute[2].map.options = options.mapOptions;
        }

        // The SOAP-ACTION header is only present for SOAP 1.1
        // The content-type is different for SOAP 1.1 vs SOAP 1.2
        if (!isSOAP12) {
            _case.execute[0].map.outputs.SOAPAction = {
                schema: {
                    type: 'string'
                },
                variable: 'message.headers.SOAPAction'
            };
            _case.execute[0].map.actions = [ {
                set: 'content-type',
                default: contentType
            }, {
                set: 'SOAPAction',
                default: path.post['x-ibm-soap']['soap-action']
            } ];
        } else {
            _case.execute[0].map.actions = [ {
                set: 'content-type',
                default: contentType
            } ];
        }
        operationSwitch.case.push(_case);
    }
}

/**
* Create an description of each operation's inputs and outputs.
* This will be used to wire the REST <-> SOAP
* @return opDesc
*/
function createOperationDesc(soapSwagger, options) {
    let opDesc = {};
    // Rename attribute names, remove xml etc.
    let s = jsonifySwagger(soapSwagger, options.badgerfishDefs, options.req);
    for (let soapPath in s.paths) {
        let opName = soapPath.substring(1);
        // Create a definition for the input and output
        opDesc[opName] = {};
        opDesc[opName].request = createOperationDescInfo(s, opName + 'Input', options);
        opDesc[opName].response = createOperationDescInfo(s, opName + 'Output', options);
        opDesc[opName].fault = createOperationDescInfo(s, opName + 'Fault', options);
    }
    return opDesc;
}

/**
* Create the schema for an operation's input or output
* @param s (jsonified soapswagger)
* @param name of the definition defining the input or output or fault
* @return info object
*/
function createOperationDescInfo(s, name, options) {

    let payloadName;
    let isFault;
    if (name.endsWith('Input')) {
        payloadName = 'request';
    } else if (name.endsWith('Output')) {
        payloadName = 'response';
    } else {
        payloadName = name;
        isFault = true;
    }
    let soapDef = s.definitions[name];
    let info = {};
    if (soapDef) {
        info = {
            wrapped: false,
            def: {
                type: 'object',
                properties: {}
            }
        };
        let hdrProps = headerProperties(s, soapDef, options.req);
        let bodyProps = bodyProperties(s, soapDef);

        // Need a wrapper if headers or multiple body parts
        info.wrapped = isFault || Object.keys(hdrProps).length > 0 ||
           Object.keys(bodyProps).length > 1;

        // Add an extra property to store the error message
        if (isFault) {
            info.def.properties.error = {
                type: 'string'
            };
        }

        if (Object.keys(hdrProps).length > 0) {
            info.def.properties.header = {
                type: 'object',
                properties: u.deepClone(hdrProps)
            };
        }
        for (let key in bodyProps) {
            if (info.wrapped) {
                info.def.properties[key] = u.deepClone(bodyProps[key]);
            } else {
                info.def = u.deepClone(bodyProps[key]);
                break;
            }
        }
    }
    return info;
}

/**
* Convenience method that returns the SOAP header hdrProperties
* that should be mapped to REST.
*/
function headerProperties(soapSwagger, soapDef, req) {
    let hdrProperties = {};
    if (soapDef &&
        soapDef.properties &&
        soapDef.properties.Envelope &&
        soapDef.properties.Envelope.properties &&
        soapDef.properties.Envelope.properties.Header &&
        soapDef.properties.Envelope.properties.Header) {
        let hdr = soapDef.properties.Envelope.properties.Header;
        if (hdr['$ref']) {
            hdr = getRef(soapSwagger, hdr['$ref'], req);
        }
        hdrProperties = hdr.properties ? u.deepClone(hdr.properties) : hdrProperties;
        let ignore = {
            Security: true,
            Action: true,
            To: true,
            ReplyTo: true,
            FaultTo: true,
            MessageID: true
        };
        for (let key in ignore) {
            if (hdrProperties[key]) {
                delete hdrProperties[key];
            }
        }
    }
    return hdrProperties;
}

/**
* Convenience method used to get the SOAP body properties
* that are mapped to REST.
*/
function bodyProperties(soapSwagger, soapDef) {
    if (soapDef &&
        soapDef.properties &&
        soapDef.properties.Envelope &&
        soapDef.properties.Envelope.properties &&
        soapDef.properties.Envelope.properties.Body &&
        soapDef.properties.Envelope.properties.Body &&
        soapDef.properties.Envelope.properties.Body.properties) {
        return u.deepClone(soapDef.properties.Envelope.properties.Body.properties);
    } else {
        return {};
    }
}

/**
* Convenience method used to get the SOAP body Fault properties
* that are mapped to REST.
*/
function faultProperties(soapSwagger, soapDef) {
    if (soapDef &&
        soapDef.properties &&
        soapDef.properties.Envelope &&
        soapDef.properties.Envelope.properties &&
        soapDef.properties.Envelope.properties.Body &&
        soapDef.properties.Envelope.properties.Body &&
        soapDef.properties.Envelope.properties.Body.properties &&
        soapDef.properties.Envelope.properties.Body.properties.Fault &&
        soapDef.properties.Envelope.properties.Body.properties.Fault.properties) {
        return u.deepClone(soapDef.properties.Envelope.properties.Body.properties.Fault.properties);
    } else {
        return {};
    }
}

/**
* Add the input/output parameter definition and paths information
*/
function addRESTOperationDefinitions(operationDesc, restSwagger, service, options) {
    let isSOAP12 = restSwagger['x-ibm-configuration']['wsdl-definition']['soap-version'] === '1.2';
    for (let opKey in operationDesc) {
        let ref;
        let op = operationDesc[opKey];
        if (op.request.def) {
            if (op.request.def['$ref']) {
                ref = op.request.def['$ref'];
            } else {
                restSwagger.definitions[opKey + 'Input'] = u.deepClone(op.request.def);
                ref = '#/definitions/' + opKey + 'Input';
            }
            let parameter = {
                name: 'request',
                required: true,
                in: 'body',
                schema: {
                    $ref: ref,
                }
            };
            restSwagger.paths['/' + opKey].post.parameters.push(parameter);
        }
        if (op.response.def) {
            if (op.response.def['$ref']) {
                ref = op.response.def['$ref'];
            } else {
                restSwagger.definitions[opKey + 'Output'] = u.deepClone(op.request.def);
                ref = '#/definitions/' + opKey + 'Output';
            }
            restSwagger.paths['/' + opKey].post.responses['200'] = {
                description: '200 OK',
                schema: {
                    $ref: ref,
                }
            };
        }
        if (options.mapSOAPFaults) {
            if (op.fault.def) {
                // Create one CommonFault
                let opFault = getDef(restSwagger, op.fault.def, options.req);
                if (!restSwagger.definitions.CommonFault) {
                    restSwagger.definitions.CommonFault =
                      jsonifyDefinition(opFault, options.badgerfishDefs, options.req);
                } else {
                    // TBD Merge in defined body and header faults
                }
                restSwagger.paths['/' + opKey].post.responses['500'] = {
                    description: '',
                    schema: {
                        $ref: '#/definitions/CommonFault',
                    }
                };

                // Create one CommonFault in the target
                let target = restSwagger['x-ibm-configuration'].targets[service];
                if (!target.definitions.CommonFault) {
                    target.definitions.CommonFault =
                    soapGen.getEnvelopeBodyFaultTemplate(isSOAP12,
                        { type: 'object', properties: {} }
                    );
                    target.paths['/' + opKey].post.responses['500'] = {
                        description: '',
                        schema: {
                            $ref: '#/x-ibm-configuration/targets/' + service + '/definitions/CommonFault',
                        }
                    };
                }
                // TBD Merge in defined body and header faults
            }
        }
    }
}

function deBadgerfishGatewayScript(title) {
    let script = {
        title: title,
        source: 'var json = apim.getvariable(\'message.body\');\n' +
                'json = adjust(json);\n' +
                'apim.setvariable(\'message.body\', json);\n' +
                'function adjust(json) {\n' +
                '    if (json && typeof json === \'object\') {\n' +
                '        var keys = Object.keys(json);\n' +
                '        if (keys.length === 1 && keys[0] === \'$\') {\n' +
                '            json = json[\'$\'];\n' +
                '        } else {\n' +
                '           for (var i = 0; i < keys.length; i++) {\n' +
                '                var key = keys[i];\n' +
                '                json[key] = adjust(json[key]);\n' +
                '            }\n' +
                '        }\n' +
                '    }\n' +
                '    if (json && typeof json === \'string\') {\n' +
                '        try {\n' +
                '            json = JSON.parse(json); // dynamic decode\n' +
                '        } catch(e) {};\n' +
                '    }\n' +
                '    return json;\n' +
                '}'
    };
    return script;
}

/**
* Add json REST definitions for each SOAP definition
* @param soapSwagger
* @param restSwagger
*/
function addRESTDefinitions(soapSwagger, restSwagger, options) {
    let ignore = {
        Security: true,
        Action__WSA: true,
        To__WSA: true,
        ReplyTo__WSA: true,
        FaultTo__WSA: true,
        MessageID__WSA: true
    };
    ignore[u.RESERVED_DEF] = true;

    for (let soapPath in soapSwagger.paths) {
        let opName = soapPath.substring(1);

        // Ignore the definitions that are just for the soap
        // specification pieces
        ignore[opName + 'Input'] = true;
        ignore[opName + 'Header'] = true;
        ignore[opName + 'Output'] = true;
        ignore[opName + 'Fault'] = true;
        ignore[opName + 'HeaderOut'] = true;
        ignore[opName + 'HeaderFault'] = true;
    }

    // Convert the SOAP definitions to equivalent json definitions
    let s = jsonifySwagger(soapSwagger, options.badgerfishDefs, options.req);

    for (let nsName in s.definitions) {
        if (!ignore[nsName]) {
            // Get an json version of the xml definition
            restSwagger.definitions[nsName] = s.definitions[nsName];
        }
    }
}

/**
* @param swagger
* @param badgerfish
*
* If badgerfish:true then the definitions are converted to:
*   - full badgerfish schema
*   - each scalar (which is always a string) has a format to communicate the type
*   - each scalar has an example that matches the type
*
* If badgerfish:false then the definitions are convert to:
*   - pseudo badgerfish format
*     - attributes are renamed to '@'<name> to match badgerfish
*     - but no '$' and types are the same as xml
*/
function jsonifySwagger(soapSwagger, badgerfishDefs, req) {
    let s = renameAttributes(soapSwagger, soapSwagger, req);
    return jsonifyDefinitions(s, badgerfishDefs, req);
}

function jsonifyDefinition(def, badgerfishDefs, req) {
    let swagger = {
        definitions: {
            temp: u.deepClone(def)
        }
    };
    swagger = jsonifyDefinitions(swagger, badgerfishDefs, req);
    return swagger.definitions.temp;
}

function jsonifyDefinitions(swagger, badgerfishDefs, req) {
    let ignoreKeys = [ 'xml', 'example' ];
    swagger = u.deepCloneWithIgnoreKeys(swagger, ignoreKeys);
    if (badgerfishDefs) {
        swagger = badgerfishDefinitions(swagger);
    }
    return swagger;
}

/**
* @return a badgerfish schema of the object
*/
function badgerfishDefinitions(swagger) {
    return u.traverseXSO(swagger, function(xso, nsName, isRootXSO, path) {
        let key = path.length > 0 ? path[path.length - 1] : undefined;
        if (key && typeof key === 'string' && key.startsWith('@')) {
            let format = getScalarFormat(xso);
            convertToBadgerfishScalar(xso, format);
        } else if (key && typeof key === 'string' && key.startsWith('$') || isBadgerfishScalar(xso)) {
            // No processing needed
        } else if (isScalar(xso)) {
            let format = getScalarFormat(xso);
            xso = {
                type: 'object',
                properties: {
                    $: xso
                }
            };
            convertToBadgerfishScalar(xso.properties['$'], format);
        }
        return xso;
    });
}

/**
* @return true if scalar
*/
function isScalar(obj) {
    return obj.type &&
      (obj.type === 'string' || obj.type === 'number' || obj.type == 'boolean' || obj.type === 'integer');
}

function isBadgerfishScalar(obj) {
    return obj.type === 'object' && obj.properties && obj.properties['$'];
}

/**
* Convert obj into a bagerfish scalar (type string etc.)
* @param obj scalar object
* @param format of scalar object
*/
function convertToBadgerfishScalar(obj, format) {
    // The badgerfish scalar is always a string with no format
    obj.type = 'string';
    delete obj.format;

    let formatDetail = format || '';
    // Massage default to string
    if (obj.default) {
        obj.default = '' + obj.default;
    }
    addExample(obj, format);
    if (formatDetail) {
        obj.description = obj.description ? '; ' + formatDetail : formatDetail;
    }
}

/**
* Get the format of obj
*/
function getScalarFormat(obj) {
    if (obj.format) {
        return obj.format;
    } else if (obj.type === 'boolean') {
        return 'boolean';
    } else {
        return undefined;
    }
}

/**
* Add an example into the xso object
*/
function addExample(xso, format) {
    switch (format) {
    case 'int32':
    case 'int64':
    case 'byte':
        xso.example = '3';
        break;
    case 'float':
    case 'double':
        xso.example = '3.14';
        break;
    case 'boolean':
        xso.example = 'true';
        break;
    case 'binary':
        xso.example = 'abcd';
        break;
    case 'date':
        xso.example = '2016-04-18';
        break;
    case 'date-time':
        xso.example = '2016-04-18T14:07:37';
        break;
    default:
        // No example
    }

    if (typeof xso.maximum !== 'undefined') {
        xso.example = '' + (xso.maximum - 3);
    } else if (typeof xso.minimum !== 'undefined') {
        xso.example = '' + (xso.minimum + 3);
    }

    if (xso.enum && xso.enum.length > 0) {
        xso.example = '' + xso.enum[0];
    }

    if (typeof xso.default !== 'undefined') {
        xso.example = '' + xso.default;
    }
}

function addAssemblyCatchSOAPError(swagger, service, operationDesc, options) {
    let isSOAP12 = swagger['x-ibm-configuration']['wsdl-definition']['soap-version'] === '1.2';
    let textField = isSOAP12 ? 'Reason.Text' : 'faultstring';
    // Create the catch for a SOAPError
    let _catch = [ {
        errors: [ 'SOAPError' ],
        execute: [ {
            map: {
                title: 'SOAPFault map',
                inputs: {
                    CommonFault: {
                        schema: {
                            $ref: '#/x-ibm-configuration/targets/' + service + '/definitions/CommonFault'
                        },
                        variable: 'InvokeOut.body',
                        content: 'application/xml'
                    }
                },
                outputs: {
                    response: {
                        schema: {
                            $ref: '#/definitions/CommonFault'
                        },
                        variable: 'message.body',
                        content: 'application/json'
                    }
                },
                actions: [ {
                    set: 'response.Fault',
                    from: 'CommonFault.Envelope.Body.Fault'
                }, {
                    set: 'response.error',
                    from: 'CommonFault.Envelope.Body.Fault.' + textField
                } ],
                version: '1.0.0'
            }
        } ]
    }, {
        default: []
    } ];

    if (options.decodeGatewayScript) {
        _catch.execute.push({
            gatewayscript: deBadgerfishGatewayScript('Decode Fault script')
        });
    }
    swagger['x-ibm-configuration'].assembly.catch = _catch;
}

/**
* Prepend @ to all attribute names.
* @return a deep clone of obj
*/
function renameAttributes(swagger, obj, req) {
    return u.traverseXSO(swagger, function(xso) {
        if (xso.properties) {
            let properties = {};
            for (let key in xso.properties) {
                let prop = xso.properties[key];
                if (key.startsWith('@')) {
                    properties[key] = prop;
                } else if (prop.xml && prop.xml.attribute) {
                    properties['@' + key] = prop;
                } else {
                    properties[key] = prop;
                }
            }
            xso.properties = properties;
        }
        return xso;
    });
}

/**
* Add the assembly mapping inputs and outputs for operation (path)
*/
function addAssemblyIO(restSwagger) {
    // Find operation-switch
    let opSwitch = restSwagger['x-ibm-configuration'].assembly.execute[0]['operation-switch'];
    for (let i = 0; i < opSwitch.case.length; i++) {
        let _case = opSwitch.case[i];
        let path = _case.operations[0].path;
        let inputMap = _case.execute[0].map;
        let outputMap = _case.execute[2].map;
        if (restSwagger.paths[path].post.parameters && restSwagger.paths[path].post.parameters[0]) {
            inputMap.inputs = {
                request: {
                    schema: {
                        $ref: restSwagger.paths[path].post.parameters[0].schema['$ref']
                    },
                    variable: 'request.body',
                    content: 'application/json'
                }
            };
        }
        if (restSwagger.paths[path].post.responses &&
            restSwagger.paths[path].post.responses['200'] &&
            restSwagger.paths[path].post.responses['200'].schema) {
            outputMap.outputs = {
                response: {
                    schema: {
                        $ref: restSwagger.paths[path].post.responses['200'].schema['$ref']
                    },
                    variable: 'message.body',
                    content: 'application/json'
                }
            };
        }
    }
}


/**
 * Add the assembly map actions for the requests/responses of SOAP/Rest
 */
function addAssemblyWiring(swagger, operationDesc, req) {
    // Find operation-switch
    let opSwitch = swagger['x-ibm-configuration'].assembly.execute[0]['operation-switch'];
    for (let i = 0; i < opSwitch.case.length; i++) {
        let _case = opSwitch.case[i];
        let path = _case.operations[0].path;
        let inputMap = _case.execute[0].map;
        let outputMap = _case.execute[2].map;
        let actions = isWrapped(path, operationDesc, 'request') ?
            getWireActionsWrapped(swagger, inputMap.inputs, inputMap.outputs, req) :
            getWireActions(swagger, inputMap.inputs, inputMap.outputs, req);
        inputMap.actions = inputMap.actions.concat(actions);
        actions = isWrapped(path, operationDesc, 'response') ?
            getWireActionsWrapped(swagger, outputMap.inputs, outputMap.outputs, req) :
            getWireActions(swagger, outputMap.inputs, outputMap.outputs, req);
        outputMap.actions = outputMap.actions.concat(actions);
    }
}

/**
* @return true if REST request/response is wrapped
*/
function isWrapped(path, operationDesc, io) {
    let opName = path.substring(1);
    let op = operationDesc[opName];
    return op && op[io] && op[io].wrapped;
}

/**
* Get the Wire Actions for an input output pair.
* Only one wire action (the topmost one) should be needed because
* the names and shape of the data is the same between REST and SOAP.
* @param swagger
* @param map.inputs
* @param map.outputs
**/
function getWireActions(swagger, inputs, outputs, req) {
    let inPath, inDef, outPath, outDef;
    if (inputs.request) {
        inDef = getDef(swagger, inputs.request.schema, req);
        inPath = 'request';
    } else if (inputs.input) {
        let schema = getDef(swagger, inputs.input.schema, req);
        let body = schema.properties['Envelope'].properties['Body'];
        let name = getKey(body.properties);
        inDef = getDef(swagger, body.properties[name], req);
        inPath = 'input.Envelope.Body.' + name;
    }

    if (outputs.response) {
        outDef = getDef(swagger, outputs.response.schema, req);
        outPath = 'response';
    } else if (outputs.body) {
        let schema = getDef(swagger, outputs.body.schema, req);
        let body = schema.properties['Envelope'].properties['Body'];
        let name = getKey(body.properties);
        outDef = getDef(swagger, body.properties[name], req);
        outPath = 'body.Envelope.Body.' + name;
    }
    let actions = [];
    if (inPath && outPath) {
        actions = actions.concat(getActions(swagger, inPath, inDef, outPath, outDef));
    }
    // getWireActionsForObject(swagger, inPath, inDef, outPath, outDef, actions, {});
    return actions;
}

/**
* Get the Wire Actions for an input output pair.
* Only one wire action (the topmost one) should be needed because
* the names and shape of the data is the same between REST and SOAP.
* @param swagger
* @param map.inputs
* @param map.outputs
**/
function getWireActionsWrapped(swagger, inputs, outputs, req) {
    let actions = [];
    if (inputs.request) {
        let inDef = getDef(swagger, inputs.request.schema, req);
        let schema = getDef(swagger, outputs.body.schema, req);
        let body = schema.properties['Envelope'].properties['Body'];
        let header = schema.properties['Envelope'].properties['Header'];

        // Action for header
        if (inDef.properties && inDef.properties.header) {
            actions.push(getAction('request.header',
                                   getDef(swagger, inDef.properties.header, req),
                                  'body.Envelope.Header',
                                   getDef(swagger, header, req)));
        }
        // Action for body
        actions.push(getAction('request',
                     inDef,
                     'body.Envelope.Body',
                     getDef(swagger, body, req)));
    } else if (outputs.response) {
        let outDef = getDef(swagger, outputs.response.schema, req);
        let schema = getDef(swagger, inputs.input.schema, req);
        let body = schema.properties['Envelope'].properties['Body'];
        let header = schema.properties['Envelope'].properties['Header'];

        // Action for header
        if (outDef.properties && outDef.properties.header) {
            actions.push(getAction('input.Envelope.Header',
                                   getDef(swagger, header, req),
                                   'response.header',
                                   getDef(swagger, outDef.properties.header, req)));
        }
        // Action for body
        actions = actions.concat(getActions(swagger,
                    'input.Envelope.Body',
                    getDef(swagger, body, req),
                    'response',
                    outDef));
    }
    return actions;
}

/**
* @return the referenced definitions
*/
function getRef(swagger, ref, req) {
    let keys = ref.split('/');
    let def = swagger;
    for (let i = 0; i < keys.length; i++) {
        if (keys[i] !== '#') {
            def = def[keys[i]];
            if (!def) {
                throw g.http(u.r(req)).Error('The reference %s does not exist.', ref);
            }
        }
    }
    return def;
}

function refExists(swagger, ref) {
    let keys = ref.split('/');
    let def = swagger;
    for (let i = 0; i < keys.length; i++) {
        if (keys[i] !== '#') {
            def = def[keys[i]];
            if (!def) {
                return false;
            }
        }
    }
    return true;
}

/**
* @return the definition, automatically processes $ref
*/
function getDef(swagger, obj, req) {
    if (obj['$ref']) {
        return getRef(swagger, obj['$ref'], req);
    }
    return obj;
}

/**
* Generate an actions
*/
function getActions(swagger, inPath, inDef, outPath, outDef) {
    let actions = [];

    actions.push(getAction(inPath, inDef, outPath, outDef));

    return actions;
}

/**
* Generate an actions
*/
function getAction(inPath, inDef, outPath, outDef) {
    return {
        set: isPath(outPath) ? outPath : '$item',
        from: isPath(inPath) ? inPath : '$item'
    };
}

/**
* Utility method to append a name to an action path
*/
function appendPath(path, name) {
    if (isPath(path)) {
        return path + '.' + name;
    } else {
        return name;
    }
}

function isPath(path) {
    return path && path.length > 0;
}

function isRootPath(path) {
    return isPath(path) && path.indexOf('.') < 0;
}

function isObject(def) {
    return def.allOf ||  def.type === 'object';
}

function isArray(def) {
    return def.type === 'array';
}


function getKey(obj) {
    for (let key in obj) {
        return key;
    }
    return null;
}

exports.getSwaggerForSOAPREST = getSwaggerForSOAPREST;
exports.migrateFromV5 = migrateFromV5;
exports.migrateToV5 = migrateToV5;
