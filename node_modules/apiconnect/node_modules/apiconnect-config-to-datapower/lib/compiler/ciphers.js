/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-config-to-datapower


'use strict';

const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const YAML = require('yamljs');

const CIPHERS_PATH = path.resolve(__dirname, 'ciphers.yaml');
const CIPHERS_YAML = fs.readFileSync(CIPHERS_PATH, 'utf8');
const CIPHERS = _.reduce(
  YAML.parse(CIPHERS_YAML),
  (ciphers, array, version) => ciphers.set(version, array), new Map());

const filterCiphers = (c, dpversion) => {
  let pattern = c.replace(/^(SSL|TLS)_/, '')
    .replace(/(RSA(_EXPORT)?|DHE_(DSS|RSA)(_EXPORT)?|ECDHE_(RSA|ECDSA))/,
        '(RSA(_EXPORT)?|DHE_(DSS|RSA)(_EXPORT)?|ECDHE_(RSA|ECDSA))')
    .replace(/(CBC|GCM)/, '(CBC|GCM)');
  let regexp = new RegExp(pattern);
  return CIPHERS.get(dpversion).filter(dpc => regexp.test(dpc));
};

const sorter = (a, b) => {
  const calculate = c => {
    let parts = c.split('_');
    let keyexchg = parts[0] !== 'RSA' ? parts[0] : '';
    let blkmode  = parts.slice(-2, -1)[0];
    let shasize  = parts.slice(-1)[0];
    let sigalg   = parts[0] === 'RSA' ? parts[0] : parts[1];

    let keyexchgScore = keyexchg === 'ECDHE' ?
      3 : keyexchg === 'DHE' ?
      2 : 1;
    let blkmodeScore = blkmode === 'GCM' ? 2 : 1;
    let shasizeScore = shasize === 'SHA384' ?
      3 : shasize === 'SHA256' ?
      2 : 1;
    let sigalgScore  = sigalg === 'ECDSA' || sigalg === 'DSS' ? 2 : 1;
    return 1000 * keyexchgScore +
           100  * blkmodeScore  +
           10   * shasizeScore  +
           1    * sigalgScore;
  };
  return calculate(b) - calculate(a);
};

const collectCiphers = (ciphers, dpversion) => ciphers.reduce((accum, c) => {
  return accum.concat(filterCiphers(c, dpversion).sort(sorter));
}, []);

module.exports = function getCiphers(reqciphers, dpversion) {
  // TODO need more robust version handling
  dpversion = dpversion || '7.2';
  if (!reqciphers)
    return CIPHERS.get(dpversion).slice().sort(sorter);
  if (typeof reqciphers === 'string')
    return collectCiphers([reqciphers], dpversion);
  return collectCiphers(reqciphers, dpversion);
};

module.exports.defaults = function getVersionDefaults(dpversion) {
  // TODO need more robust version handling
  dpversion = dpversion || '7.2';
  return CIPHERS.get(`${dpversion}-defaults`).slice();
};

