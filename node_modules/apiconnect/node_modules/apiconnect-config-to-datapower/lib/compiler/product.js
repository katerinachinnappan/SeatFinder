/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

// Node module: apiconnect-config-to-datapower

'use strict';

const _ = require('lodash');
const coname = require('./coname');
const util = require('../util');

module.exports = exports = function(product, options) {
  function APIPlan(name, props) {
    this._name = coname.plan(options, product, name);
    Object.assign(this, props);
    // set default rate-limit as unlimited
    if (!this['rate-limit'] && !this['rate-limits'])
      this['rate-limit'] = {value: 'unlimited'};
    this.excludes = [];
    this.overrides = [];
    if (!this.apis || (this.apis && _.isEmpty(this.apis))) {
      this.apis = product.apis;
    } else {
      // for operation override
      Object.keys(this.apis).forEach(apiName => {
        if (!product.apis[apiName] || !product.apis[apiName].name)
          throw new Error(
            `Referened API of '${apiName}' not defined in 'apis'`);
        let key = product.apis[apiName].name;
        let swagger = options.apis[key];
        if (!swagger)
          throw new Error(
            `API of ${key} not exist in 'options.apis'!`);
        if (this.apis[apiName].operations) {
          let allOperations = Object.keys(swagger.paths).reduce((r, path) => {
            let props = swagger.paths[path];
            Object.keys(props).reduce((r, m) => {
              if (util.isValidRestMethod(m)) {
                let method = m.toUpperCase();
                let k = `${method} ${path}`;
                r[k] = new APIOperation(swagger, path, method);
              }
              return r;
            }, r);
            return r;
          }, {});
          let excludes = _.clone(allOperations);
          this.apis[apiName].operations.forEach(props => {
            let opKey = `${props.operation.toUpperCase()} ${props.path}`;
            delete excludes[opKey];
            if (!props['rate-limits']) return;
            this.overrides.push(
              new OperationRateLimit(swagger, allOperations, props));
          });
          this.excludes = this.excludes.concat(_.values(excludes));
        }
      });
    }
    let apis = [];
    Object.keys(this.apis).forEach(name => {
      let key = product.apis[name].name;
      let info = key.split(':');
      apis.push(new API(info[0], info[1]));

      // Add OAuthProvider API to the plans that have API referenced
      let swagger = options.apis[key];
      if (!swagger)
        throw new Error(
          `API of ${key} not exist in 'options.apis'!`);
      if (swagger.securityDefinitions) {
        Object.keys(swagger.securityDefinitions).forEach(secdName => {
          let props = swagger.securityDefinitions[secdName];
          if (props.type !== 'oauth2') return;
          apis.push(
            new API(`oauth-provider-settings-${props['x-provider']}`, '1.0.0'));
        });
      }
    });
    this.apis = apis;
  }

  function API(name, version) {
    this._name = coname.api(options, {info: {name: name, version: version}});
  }

  function APIOperation(swagger, path, method) {
    this._name = coname.operation(options, swagger, path, method);
    this.path = path;
    this.method = method;
  }

  function OperationRateLimit(swagger, allOperations, props) {
    Object.assign(this, props);
    let key = `${this.operation.toUpperCase()} ${this.path}`;
    this._operation = allOperations[key];
    if (!this._operation) {
      throw new Error(`The override operation is not defined in the swagger: \
"${key}"`);
    }
    this._name =
      coname.operationRateLimit(options, swagger, this._operation);
  }

  return Object.keys(product.plans).reduce((plans, name) => {
    let props = product.plans[name];
    plans.push(new APIPlan(name, props));
    return plans;
  }, []);
};
