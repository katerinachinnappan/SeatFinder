/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-config-to-datapower

'use strict';

const hbs = require('handlebars');
const fs = require('fs');
const compiler = require('./compiler');
const template = require('./template');
const action = require('./action');
const debug = require('debug')('apic2dp');
const YAML = require('yamljs');

const BAIL_ON_COMPILE_ERROR =
  process.env.IBM_APICONNECT_APIC2DP_BAIL_ON_COMPILE_ERROR !== 'false';

function onCompileError(type, artifact, err) {
  let msg;
  artifact = artifact || {};
  if (type === 'API' || type === 'Product') {
    let info = artifact.info;
    let name = `${info.name || info['x-ibm-name']}:${info.version}`;
    msg = `Failed to compile ${type} ${name}: ${err.message}`;
  } else {
    let name = artifact.name;
    msg = `Failed to compile ${type}${name ? ' ' + name : ''}: ${err.message}`;
  }
  debug(msg);
  if (BAIL_ON_COMPILE_ERROR === true)
    throw err;
  return '';
};

function initOptions(options) {
  options = options || {};
  options.catalog = options.catalog ||
    {name: 'cat0', organization: {name: 'org0'}};
  options.gatewayName = options.gatewayName || 'apigw0';
  options.routingPrefix = options.routingPrefix ||
    `/${options.catalog.organization.name}/${options.catalog.name}`;
  return options;
}

/* eslint-disable */
/**
 * The result of compileTLSProfile()
 * @typedef {Object} CompileTLSProfileResult
 * @property {String} cfg - The DataPower configurations
 * @property {Object} privateKey - Array of the private key
 * @property {string} privateKey.key - The content of the key
 * @property {string} privateKey.url - The URL to store in the DataPower
 * @property {Object} publicCert - The public certificate
 * @property {string} publicCert.cert - The content of the certificate
 * @property {string} publicCert.url - The URL to store in the DataPower
 * @property {Object[]} trustStores - Array of the certificate for the validation credentials
 * @property {string} trustStores[].cert - The content of the certificate
 * @property {string} trustStores[].url - The URL to store in the DataPower
 */
/**
 * Convert the apiconnect artitacts into the DataPower configurations
 * @param {Object} tls - The tls-profile artifact
 * @param {Object} options - The options to compile the artifact
 * @param {Object} options.catalog - The catalog object
 * @param {String} options.catalog.name - The catalog name
 * @param {String} options.catalog.organization.name - The org name
 * @param {String} options.gatewayName - The API gateway name
 * @return {CompileTLSProfileResult}
 */
/* eslint-enable */
module.exports.compileTLSProfile = function compileTLSProfile(tls, options) {
  let profile = compiler.compileTLSProfile(tls, options);
  return {
    cfg: template['tls-profile'](profile),
    sslclient: {
      protocols: profile.protocols,
      ciphers: profile.ciphers,
      mutualAuth: profile.mutualAuth,
      useSNI: profile.useSNI,
    },
    privateKey: profile.privateKey,
    publicCert: profile.publicKeyCert,
    trustStores: profile.trustStores,
  };
};

/* eslint-disable */
/**
 * The result of compileOAuthProvider()
 * @typedef {Object} CompileOAuthProviderResult
 * @property {String} cfg - The DataPower configurations
 * @property {String} api - The generated swagger of the OAuth provider
 * @property {String} tokenSecret.name - The name of the token secret
 * @property {String} tokenSecret.url - The URL to store in the DataPower
 * @property {String} tokenSecret.key - The content of the token secret
 */
/**
 * Convert the apiconnect artitacts into the DataPower configurations
 * @param {Object} oauthp - The OAuth provider artifact
 * @param {Object} options - The options to compile the artifact
 * @param {Object} options.catalog - The catalog object
 * @param {String} options.catalog.name - The catalog name
 * @param {String} options.catalog.organization.name - The org name
 * @return {CompileOAuthProviderResult}
 */
 /* eslint-enable */
module.exports.compileOAuthProvider = function(oauthp, options) {
  let p = compiler.compileOAuthProvider(oauthp, options);
  return {
    name: oauthp.name,
    cfg: template['oauth-provider'](p),
    api: template['oauth-provider-api'](p),
    tokenSecret: p._tokenSecret,
  };
};

module.exports.getDefaultConfigs = function(options) {
  return template['defaults']();
};

/* eslint-disable */
/**
 * The result of compileAPI()
 * @typedef {Object} CompileAPIResult
 * @property {String} cfg - The DataPower configurations
 * @property {Object[]} files - The files to store in the DataPower, e.g. gatewayscript/xslt action
 * @property {String} files[].content - The content of the file
 * @property {String} files[].location - The URL to store in the DataPower
 * @property {String[]} protocols - The protocol used in the API
 */
/**
 * Convert the swagger into the DataPower configurations
 * @param {Object} api - The swagger artifact
 * @param {Object} options - The options to compile the artifact
 * @param {Object} options.catalog - The catalog object
 * @param {String} options.catalog.name - The catalog name
 * @param {String} options.catalog.organization.name - The org name
 * @return {CompileAPIResult}
 */
 /* eslint-enable */
module.exports.compileAPI = function(api, options) {
  try {
    let r = compiler.compileAPI(api, options);
    return {
      cfg: template.api(r),
      files: r.files,
      protocols: r.protocols,
    };
  } catch (err) {
    return onCompileError('API', api, err);
  }
};

/* eslint-disable */
/**
 * The result of compileProduct()
 * @typedef {Object} CompileProductResult
 * @property {String} cfg - The DataPower configurations
 * @property {Object[]} plans - The config object name of plans used
 */
/**
 * Convert the product artifact into the DataPower configurations
 * @param {Object} product - The product artifact to convert
 * @param {Object} options - The options to compile the artifacts
 * @param {Object} options.catalog - The catalog object
 * @param {String} options.catalog.name - The catalog name
 * @param {String} options.catalogs.organization.name - The org name
 * @param {Object} options.apis - The api artifacts used in the product
           keyed by the '${api-name}:${api-version}'
 * @return {CompileProductResult}
 */
/* eslint-enable */
module.exports.compileProduct = function(product, options) {
  try {
    let r = compiler.compileProduct(product, options);
    return {
      cfg: template.plans(r),
      plans: r.map(p => p._name),
    };
  } catch (err) {
    return onCompileError('Product', product, err);
  }
};

/* eslint-disable */
/**
 * The result of compileSubscription()
 * @typedef {Object} APISubscription
 */
/**
 * Convert the subscription artifact into the DataPower configurations
 * @param {Object} product - The product artifact to convert
 * @param {Object} options - The options to compile the artifacts
 * @param {Object} options.catalog - The catalog object
 * @param {String} options.catalog.name - The catalog name
 * @param {String} options.catalogs.organization.name - The org name
 * @param {Object} options.apis - The api artifacts used in the product
           keyed by the '${api-name}:${api-version}'
 * @return {APISubscription}
 */
/* eslint-enable */
module.exports.compileSubscription = function(sub, options) {
  try {
    return compiler.compileSubscription(sub, options);
  } catch (err) {
    return onCompileError('Subscription', sub, err);
  }
};

/* eslint-disable */
/**
 * The result of compileGateway()
 * @typedef {Object} CompileGatewayResult
 * @property {String} cfg - The DataPower configurations
 * @property {Object} privateKey - Array of the private key
 * @property {string} privateKey.key - The content of the key
 * @property {string} privateKey.url - The URL to store in the DataPower
 * @property {Object} publicCert - The public certificate
 * @property {string} publicCert.cert - The content of the certificate
 * @property {string} publicCert.url - The URL to store in the DataPower
 */
/**
 * Convert the product artifact into the DataPower configurations
 * @param {Object} options - The options to generate the gateway configs
 * @param {String} options.gatewayName - The API gateway name
 * @param {String[]} [options.collections] - API collections
 * @param {String[]} [options.protocols] - The APIs protocols
 * @param {Object} [options.http] - The http FSH related configuration, mandantory if the http protocol exists in the protocols
 * @param {String|Number} [options.http.port=2090] - The port for the HTTP server of the gateway
 * @param {Object} [options.https] - The https FSH related configuration, mandantory if the https protocol exists in the protocols
 * @param {String|Number}[options.https.port=2091] - The port for the HTTPS server of the gateway
 * @param {String} options.https.key - The private key for the HTTPS server of the gateway
 * @param {String} options.https.cert - The public cert for the HTTPS server of the gateway
 * @return {CompileGatewayResult}
 */
/* eslint-enable */
module.exports.compileGateway = function(options) {
  try {
    let gateway = compiler.compileGateway(options);
    let result = {cfg: template.gateway(gateway)};

    if (gateway.fshHttps) {
      result.privateKey = gateway.fshHttps.key;
      result.publicCert = gateway.fshHttps.cert;
    }

    return result;
  } catch (err) {
    onCompileError('Gateway', {}, err);

    throw err;
  }
};

/* eslint-disable */
/**
 * The result of compileGateway()
 * @typedef {Object} CompileGatewayResult
 * @property {String} cfg - The DataPower configurations
 */
/**
 * Convert the product artifact into the DataPower configurations
 * @param {Object[]} plans - The plans returned from compileProduct()
 * @param {Object[]} subscriptions - The subscriptions returned from compileSubscription()
 * @param {Object} options - The options to generate the gateway configs
 * @param {Object} options.catalog - The catalog object
 * @param {String} options.catalog.name - The catalog name
 * @param {String} options.catalog.organization.name - The org name
 * @param {String} options.routingPrefix The routing prefix of the catalog, i.e. the collection in terms of DataPower
 * @return {CompileGatewayResult}
 */
/* eslint-enable */
module.exports.compileCollection = function(plans, subscriptions, options) {
  try {
    plans = plans.map(p => { return {_name: p}; });

    let collection = compiler.compileCollection(options, plans, subscriptions);

    return {
      cfg: template.collection(collection),
      name: collection._name,
    };
  } catch (err) {
    onCompileError('Collection', {}, err);

    throw err;
  }
};

/* eslint-disable */
/**
 * The result of compileArtifacts()
 * @typedef {Object} CompileArtifactsResult
 * @property {String} cfg - The DataPower configurations
 * @property {Object[]} privateKeys - Array of the private key
 * @property {string} privateKeys[].key - The content of the key
 * @property {string} privateKeys[].url - The URL to store in the DataPower
 * @property {Object[]} publicCerts - Array of the public certificate
 * @property {string} publicCerts[].cert - The content of the certificate
 * @property {string} publicCerts[].url - The URL to store in the DataPower
 * @property {Object[]} trustStores - Array of the certificate for the validation credentials
 * @property {string} trustStores[].cert - The content of the certificate
 * @property {string} trustStores[].url - The URL to store in the DataPower
 * @property {Object[]} files - The files to store in the DataPower, e.g. gatewayscript/xslt action
 * @property {string} files[].content - The content of the file
 * @property {string} files[].location - The URL to store in the DataPower
 */
/**
 * Convert the apiconnect artitacts into the DataPower configurations
 * @param {Object} artifacts - The artifacts to convert
 * @param {Object[]} artifacts.apis - Array of the API artifacts
 * @param {Object[]} artifacts.products - Array of the product artifacts
 * @param {Object[]} [artifacts.subscriptions] - Array of the subscription artifact
 * @param {Object[]} [artifacts.tls-profiles] - Array of the tls-profile artifact
 * @param {Object[]} [artifacts.registries] - Array of the registry artifact
 * @param {Object} [options] - The options to compile the artifacts
 * @param {Object} [options.catalog] - The catalog object
 * @param {String} [options.catalog.name=cat0] - The catalog name
 * @param {String} [options.catalog.organization.name=org0] - The org name
 * @param {String} [options.gatewayName=apigw0] - The API gateway name
 * @param {String} [options.routingPrefix=/${options.catalog.organization.name}/${options.catalog.name}] The routing prefix of the catalog, i.e. the collection in terms of DataPower
 * @param {String|Number} [options.http.port=2090] - The port for the HTTP server of the gateway
 * @param {Object} [options.https] - The https FSH related configuration, mandantory if the https scheme exists in the APIs
 * @param {String|Number}[options.https.port=2091] - The port for the HTTPS server of the gateway
 * @param {String} options.https.key - The private key for the HTTPS server of the gateway
 * @param {String} options.https.cert - The public cert for the HTTPS server of the gateway
 * @return {CompileArtifactsResult}
 */
/* eslint-enable */
module.exports.compileArtifacts = function(artifacts, options) {
  options = initOptions(options);
  options.catalog = artifacts.catalog || options.catalog;
  let result = {
    cfg: '',
    privateKeys: [],
    publicCerts: [],
    trustStores: [],
    files: [],
  };

  let defaultCfgs = template['defaults']();

  let tlsProfileCfgs = '';
  if (artifacts['tls-profiles']) {
    tlsProfileCfgs = artifacts['tls-profiles'].map(t => {
      try {
        let p = compiler.compileTLSProfile(t, options);
        if (p.privateKey) result.privateKeys.push(p.privateKey);
        if (p.publicKeyCert) result.publicCerts.push(p.publicKeyCert);
        if (p.trustStores && p.trustStores.length > 0) {
          result.trustStores = result.trustStores.concat(p.trustStores);
        }
        return template['tls-profile'](p);
      } catch (err) {
        return onCompileError('TLS Profile', t, err);
      }
    }).filter(t => t !== '').join('\n\n');
  }

  options.registries = {};
  let registryCfgs = '';
  if (artifacts.registries) {
    registryCfgs = artifacts.registries.map(reg => {
      // does user registry other than ldap type?
      if (reg.type !== 'ldap')
        return '';
      try {
        let r = compiler.compileRegistry(reg, options);
        options.registries[reg.name] = r;
        return template.registry(r);
      } catch (err) {
        return onCompileError('Registry', reg, err);
      }
    }).filter(cfg => cfg !== '').join('\n\n');
  }

  let protocols = {};
  // options.oauthAPIs = {};
  options.apis = {};  // map for all apis needed when generating
                      //  override/exclude operations
  let apiCfgs = '';
  if (artifacts.apis) {
    apiCfgs = artifacts.apis.map(api => {
      try {
        let r = compiler.compileAPI(api, options);
        options.apis[r.api._api] = api;
        // if (r.api._OAuthProvider)
        //   options.oauthAPIs[r.api._OAuthProvider] = r.api;
        r.protocols.forEach(p => protocols[p] = p);
        if (r.files && r.files.length > 0)
          result.files = result.files.concat(r.files);
        return template.api(r);
      } catch (err) {
        return onCompileError('API', api, err);
      }
    }).filter(api => api !== '').join('\n');
  }
  options.protocols = Object.keys(protocols);

  let plans = [];
  let planCfgs = '';
  if (artifacts.products) {
    planCfgs = artifacts.products.map(p => {
      try {
        let r = compiler.compileProduct(p, options);
        plans = plans.concat(r);
        return template.plans(r);
      } catch (err) {
        return onCompileError('Product', p, err);
      }
    }).filter(p => p !== '').join('\n\n');
  }

  let subscriptions = null;
  if (artifacts.subscriptions) {
    subscriptions = artifacts.subscriptions.map(s => {
      try {
        return compiler.compileSubscription(s, options);
      } catch (err) {
        return onCompileError('Subscription', s, err);
      }
    });
  }

  try {
    let collection = compiler.compileCollection(options, plans, subscriptions);
    let collectionCfg = template.collection(collection);
    options.collections = [collection._name];
    let gateway = compiler.compileGateway(options);
    let gatewayCfg = template.gateway(gateway);
    if (gateway.fshHttps) {
      result.privateKeys.push(gateway.fshHttps.key);
      result.publicCerts.push(gateway.fshHttps.cert);
    }
    result.cfg = [
      defaultCfgs,
      tlsProfileCfgs,
      registryCfgs,
      apiCfgs,
      planCfgs,
      collectionCfg,
      gatewayCfg]
        .filter(cfg => cfg !== '').join('\n');
  } catch (err) {
    onCompileError('Gateway', {}, err);
    // Always bail on gateway compile error
    throw err;
  }
  return result;
};

module.exports.listActions = function() {
  return action.list();
};
