/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-config-to-datapower

'use strict';

const hbs = require('handlebars');
const util = require('../util');

hbs.registerHelper('-uppercase', (str) => {
  return (str && typeof str === 'string') ?
    str.toUpperCase() : '';
});

hbs.registerHelper('-lowercase', (str) => {
  return (str && typeof str === 'string') ?
    str.toLowerCase() : '';
});

hbs.registerHelper('-onoff', (value) => {
  return value ? 'on' : 'off';
});

hbs.registerHelper('-default', (lhs, value) => {
  return lhs ? lhs : value;
});

hbs.registerHelper('-deref-action', (action) => {
  return action._type;
});

hbs.registerHelper('-if-valid-swagger-method', function(method, options) {
  if (util.isValidRestMethod(method.toLowerCase())) {
    return options.fn(this);
  } else {
    return options.inverse(this);
  }
});

hbs.registerHelper('-formatted-rate-limit-value', (value) => {
  var formattedValue;
  if (value === 'unlimited') {
    formattedValue = '0 1 second';
  } else {
    var valueArray = value.split('/');
    if (valueArray.length == 2) {
      var per = parseInt(valueArray[1]);
      var unit = valueArray[1].split(/[0-9]+/)[1];
      // for "1000/hour"" case
      if (isNaN(per)) {
        per = 1;
        unit = valueArray[1];
      }
      // explicit checking on unit
      if (unit.match(/^(sec(ond)?|minute|hour|day|week)$/)) {
        if (unit === 'sec') unit = 'second';
        formattedValue = valueArray[0] + ' ' + per + ' ' + unit;
      } else {
        throw new Error('unsupported rate limit format');
      }
    } else {
      throw  new Error('unsupported rate limit format');
    }
  }
  return formattedValue;
});

hbs.registerHelper('-variable-type-by-value', (value) => {
  var valueType = typeof value;
  if (valueType == 'number') {
    return 'type number';
  } else if (valueType == 'boolean') {
    return 'type boolean';
  } else if (valueType == 'string') {
    return 'type string';
  }
  // default type
  return 'type string';
});

hbs.registerHelper('-add-escape', (value) => {
  var valueType = typeof value;
  if (valueType !== 'string') {
    return value;
  } else {
    var escapeValue;
    escapeValue = value.replace(/(\\|\")/g, '\\$1');
    return escapeValue;
  }
});

// LISP-like logic operators
hbs.registerHelper({
  eq: (v1, v2) => { return v1 === v2; },
  ne: (v1, v2) => { return v1 !== v2; },
  lt: (v1, v2) => { return v1 < v2; },
  gt: (v1, v2) => { return v1 > v2; },
  lte: (v1, v2) => { return v1 <= v2; },
  gte: (v1, v2) => { return v1 >= v2; },
});

hbs.registerHelper('and', function() {
  let args = Array.prototype.slice.call(arguments);
  args.pop(); // pop out options
  if (args.length == 0) return false;
  let idx = -1;
  while (++idx < args.length) {
    if (!args[idx]) return false;
  }
  return true;
});

hbs.registerHelper('or', function() {
  let args = Array.prototype.slice.call(arguments);
  args.pop(); // pop out options
  let idx = -1;
  while (++idx < args.length) {
    if (args[idx]) return true;
  }
  return false;
});

/**
 * string concat helper
 *
 * the 1st argument is the delimiter for the strings
 * the last argument is the options object passed from the handlebars
 * the rest are the targets to concat, can be string or array of strings
*/
hbs.registerHelper('-join', function() {
  let args = Array.prototype.slice.call(arguments);
  let options = args.pop() || {};
  let sep = args.shift() || '';
  let items = args.reduce((a, b) => { return a.concat(b); }, []);
  if (options.fn) {
    return items.map((item) => {
      return options.fn(item);
    }).join(sep);
  } else {
    return items.join(sep);
  }
});

// convert dash-separated string to upper camel case,
// e.g. time-to-live => TimeToLive
hbs.registerHelper('-dash-to-upper-camel', (value) => {
  return value.replace(/(^|-)([a-z])/g, function(m, g1, g2) {
    return g2.toUpperCase();
  });
});

// check if a value is contained in an array
hbs.registerHelper('-contains', (value, array) => {
  array = (array instanceof Array) ? array : [array];
  return array.indexOf(value) > -1;
});
