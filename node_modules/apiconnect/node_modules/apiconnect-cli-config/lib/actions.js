/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-config

'use strict';

var _ = require('lodash');
var conf = require('apiconnect-config');
var g = require('strong-globalize')();
var logger = require('apiconnect-cli-logger');

var config = conf.loadConfig({ shouldParseUris: false });

var validConfigNames = [
  'accessibility-mode',
  'app',
  'catalog',
  'concurrency',
  'microgateway',
  'log-level',
  'org',
  'template-path',
  'template-default-api',
  'template-default-product',
  'trust-store',
  'client-certificate',
  'client-certificate-password',
  'space',
];

var localOnlyNames = [
  'datapower-api-gateway-experimental',
  'oauth-redirect-uri',
  'oauth-client-type',
];

module.exports.list = function(options) {
  var store = _getStore(options);
  var data = config.get(/.*/, store);
  print(data, store);
};

function print(data, store) {
  _.forEach(data, function(v, k) {
    if (_isValidName(k, store)) {
      logger.writeln(g.f('%s: %s', k, v));
    }
  });
};

module.exports.getConfig = function(name, options) {
  var store = _getStore(options);
  if (!_isValidName(name, store)) {
    throw new Error(g.f('%s is not a valid configuration variable', name));
  }
  var data = config.get(name, store);
  if (!data.hasOwnProperty(name)) {
    throw new Error(g.f('Configuration %s is not set', name));
  }
  logger.writeln(g.f('%s: %s', name, data[name]));
};

function _argsToObject(kv, otherKVs, store) {
  kv = _.concat([], kv, otherKVs);
  kv = _.fromPairs(_.map(kv, function(v) {
    var param = v.split('=');
    if (param.length === 1) {
      throw new Error(g.f('Invalid argument format `name=value`'));
    }
    if (!param[1]) {
      throw new Error(g.f('Invalid argument value specified.'));
    }
    return param;
  }));

  var invalidConfigNames = _.remove(_.keys(kv), function(name) {
    return !_isValidName(name, store);
  });
  if (invalidConfigNames.length > 0) {
    throw new Error(g.f('%s is not a valid configuration variable', invalidConfigNames[0]));
  }
  return kv;
}

module.exports.setConfig = function(kv, otherKVs, options) {
  var store = _getStore(options, conf.PROJECT_STORE);
  kv = _argsToObject(kv, otherKVs, store);
  kv = config.set(kv, store);
  print(kv, store);
};

module.exports.getAnalytics = function(kv, otherKVs, options) {
  try {
    var store = _getStore(options, conf.PROJECT_STORE);
    kv = _argsToObject(kv, otherKVs, store);
  } catch (error) {
    kv = { Error: error.message };
  }
  return kv;
};

module.exports.deleteConfig = function(name, options) {
  var store = _getStore(options, conf.PROJECT_STORE);
  var data = config.get(/.*/, store);
  if (!data.hasOwnProperty(name) || !_isValidName(name, store)) {
    logger.error(g.f('Configuration %s is not set', name));
  } else {
    config.delete(name, store);
    logger.writeln(g.f('Deleted %s: %s', name, data[name]));
  }
};

module.exports.clearConfig = function(options) {
  var store = _getStore(options, conf.PROJECT_STORE);
  var data = config.get(/.*/, store);
  _.forEach(data, function(_v, _k) {
    // clean out only user settable configs
    if (!_isValidName(_k, store)) {
      return;
    }
    config.delete(_k, store);
    logger.writeln(g.f('Deleted %s: %s', _k, data[_k]));
  });
};

function _isValidName(name, store) {
  return _.includes(validConfigNames, name) ||
      (_.includes(localOnlyNames, name) && store !== conf.USER_STORE);
}

function _getStore(options, defaultStore) {
  if (options.global) {
    return conf.USER_STORE;
  }
  if (options.local) {
    return conf.PROJECT_STORE;
  }
  return defaultStore;
};

