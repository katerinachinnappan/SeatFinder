/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-loopback
'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var project = require('apiconnect-project');
var debug = require('debug')('apic:plugin:loopback');
var g = require('strong-globalize')();
var genApiAndProduct = require('./swagger').genApiAndProduct;
var logger = require('apiconnect-cli-logger');
var path = require('path');

module.exports.exportApiDef = function() {
  ensureInProject();
  return loopback({});
};

module.exports.refresh = function() {
  ensureInProject();
  return genApiAndProduct();
};

function getIndex(args, long, short) {
  var longIndex = args.indexOf(long);
  var shortIndex = args.indexOf(short);
  if (longIndex === -1) {
    return shortIndex;
  } else if (shortIndex === -1) {
    return longIndex;
  } else {
    return (longIndex < shortIndex ? longIndex : shortIndex);
  }
}

module.exports.lbGenerator = function() {
  // For command remote-method, make sure
  // --model and --remote-method are given in the right order.
  if (process.argv[2] === 'loopback:remote-method') {
    var modelIndex = getIndex(process.argv, '--model', '-m');
    var methodIndex = getIndex(process.argv, '--remote-method', '-r');
    if (modelIndex === -1 && methodIndex !== -1) {
      throw new Error(g.f('\'--model\' option is required when ' +
        '\'--remote-method\' is specified.'));
    }
    if (modelIndex !== -1 && methodIndex !== -1 && methodIndex < modelIndex) {
      var modelOption = process.argv[modelIndex];
      var modelValue = process.argv[modelIndex + 1];
      process.argv[modelIndex] = process.argv[methodIndex];
      process.argv[modelIndex + 1] = process.argv[methodIndex + 1];
      process.argv[methodIndex] = modelOption;
      process.argv[methodIndex + 1] = modelValue;
    }
  }
  ensureInProject();
  return loopback({}).then(genApiAndProduct);
};

/**
 * name is an undocumented argument that is supported for the sake
 *  of backward compatibility.
 */
module.exports.launchGenerator = function launchGenerator(name, options) {
  ensureInProject();
  if (options == null) {
    options = name;
    name = null;
  }
  // If someone provides both name arg and option, favor the option
  name = _.isFunction(options.name) ? name : options.name;

  var argv = process.argv.slice(0, 2);
  argv.push('loopback:' + options.type);
  if (name) { argv.push(name); }
  if (options.skipCache) {
    argv.push('--skip-cache');
  }
  process.argv = argv;
  return loopback({}).then(genApiAndProduct);
};

function loopback(opts) {
  // LB modules take a long time to load so require modules inside the function
  // in order to reduce command load times
  var lbGenerator = require('generator-loopback');
  //generator-loopback checks this variable to determine where its originated
  process.env.SLC_COMMAND = 'apic';
  var yeoman = lbGenerator._yeoman; // generator-loopback should export _yeoman
  if (!yeoman) {
    try {
      // Try to use the yeoman-generator from generator-loopback module
      yeoman = require('generator-loopback/node_modules/yeoman-generator');
    } catch (err) {
      // Fall back the peer/parent dep
      yeoman = require('yeoman-generator');
    }
  }

  var env = yeoman();

  // Make sure apic loopback is delegated to apic loopback:app (the default
  // subgenerator)
  env.alias(/^([^:]+)$/, '$1:app');

  // Change the working directory to the generator-loopback module so that
  // yoeman can discover the generators
  var root = path.dirname(require.resolve('generator-loopback/package.json'));
  var cwd = process.cwd();
  debug('changing directory to %s', root);
  process.chdir(root);

  // lookup for every namespaces, within the environments.paths and lookups
  env.lookup();
  debug('changing directory back to %s', cwd);
  process.chdir(cwd); // Switch bac

  if (opts.version) {
    var _package = lbGenerator._package;
    if (!_package) {
      var pkg = require('generator-loopback/package.json');
      _package = pkg.name + ': ' + pkg.version;
    }
    logger.writeln(_package);
    return;
  }

  // list generators
  if (opts.generators) {
    logger.writeln(g.f('Available LoopBack generators: '));
    logger.writeln(Object.keys(env.getGeneratorsMeta()).filter(function(name) {
      return name.indexOf('loopback:') !== -1;
    }).join('\n'));
    return;
  }

  var args = process.argv.slice(2);
  debug('invoking apic %s', args.join(' '));
  return new Promise(function(resolve, reject) {
    env.run(args, opts, function(err) {
      if (err) {
        logger.error(g.f('Error apic %s\n%s', args.join(' '),
          opts.debug ? err.stack : err.message));
        return reject(err);
      }
      logger.writeln(g.f('Done running LoopBack generator'));
      resolve();
    });
  });
}

function ensureInProject() {
  var info = project.inspectPath(process.cwd());
  if (info.type !== 'project' || info.projectType !== 'loopback') {
    throw new Error(g.f('This is not a LoopBack project directory.'));
  }
};

