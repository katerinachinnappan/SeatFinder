/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-auth

var Promise = require('bluebird');
var apicAuth = require('./auth');
var serverMeta = require('apiconnect-cli-util').serverMeta;
var bluemixLogin = require('./bluemix-login');
var apicConfig = require('apiconnect-config');
var debug = require('debug')('apiconnect-cli-auth:login');
var g = require('strong-globalize')();
var logger = require('apiconnect-cli-logger');
var url = require('url');
var util = require('./util');
var prompt = require('./creds-prompt');

var config = apicConfig.loadConfig();

//CLOUD META CONSTANTS: /v1/cloud/metadata/managament
var META_LOGIN = 'loginServiceUrl';


function loginCmd(opt) {
  var interactiveMode = true;
  if (opt.username || opt.password || opt.server) {
    interactiveMode = false;
  }

  var loginOptions = {
    interactiveMode: interactiveMode,
    useDefaultOrg: true,
    useDefaultRegion: false,
    passcode: opt.passcode,
    apikey: opt.apikey,
    code: opt.code,
    sso: opt.sso,
  };
  var host;

  if (opt.server) {
    host = opt.server;
  } else {
    var serverConfig = config.getOne('org');
    host = serverConfig && serverConfig.host;
  }

  if (host && !interactiveMode) {
    loginOptions.uri = 'https://' + host;
  }
  return login(opt.username, opt.password, loginOptions);
}
exports.loginCmd = loginCmd;

function formatUriFromHost(host) {
  return url.format({
    protocol: 'https',
    host: host,
  });
}

/**
 * Login to apim and runtime server if available.
 *
 * @param {string} username
 * @param {string} password
 * @param {object} [options]
 * @param {boolean} [options.interactiveMode] triggers interactive mode if server, username or password cannot be
 * determined. If `false` and required options are missing then will error.
 * @param {string} [options.uri] URI to override value in config.
 * @param {boolean} [options.useDefaultOrg] If no provider-org is specified in URI, use any available org to determind
 * app runtime.
 * @param {boolean} [options.useDefaultRegion] If no server is available, login to us-south region.
 */
function login(username, password, options) {
  var promptServerPromise = null;
  var promptUserAndPassPromise = null;

  if (options.interactiveMode) {
    if (!(options.uri && url.parse(options.uri).hostname)) {
      debug('going interactive. server = [%s]',
        !!(options.uri && url.parse(options.uri).hostname)
      );
      var server = url.parse(options.uri || '');
      promptServerPromise = prompt.promptServer({
        username: username,
        password: password,
        server: server.host,
        passcode: options.passcode,
        apikey: options.apikey,
        code: options.code,
        interactiveMode: options.interactiveMode,
        sso: options.sso,
      });
    } else {
      debug('the server is available.');
      promptServerPromise = Promise.resolve({
        username: username,
        password: password,
        passcode: options.passcode,
        apikey: options.apikey,
        code: options.code,
        server: url.parse(options.uri).host,
        interactiveMode: options.interactiveMode,
        sso: options.sso,
      });
    }
  } else {
    debug('non-interactive login');
    var opt = {
      username: username,
      password: password,
      passcode: options.passcode,
      apikey: options.apikey,
      code: options.code,
      interactiveMode: options.interactiveMode,
      sso: options.sso,
    };

    opt.server = util.resolveHostname(options);
    promptServerPromise = Promise.resolve(opt);
  }

  return promptServerPromise.then(function(opt) {
    var serverConfig = url.parse(formatUriFromHost(opt.server));
    var host = serverConfig.host;
    // check if the server has a bluemix element and prompt for passcode
    debug('Checking the server [%s] Bluemix Form Factor', serverConfig.hostname);
    return serverMeta.getMetadata(serverConfig, { forceRefresh: true }).then(function(meta) {
      if (meta.isBluemix() && meta.supports('authTypes', 'token')) {
        // bluemix 5030+ login flow

        var tokenCfg = {};
        tokenCfg[host + '.authType'] = 'token';
        if (meta.hasOwnProperty(META_LOGIN)) {
          tokenCfg[host + '.' + META_LOGIN] = meta[META_LOGIN];
          opt[META_LOGIN] = meta[META_LOGIN];
        }
        config.set(tokenCfg, apicConfig.TOKEN_STORE);

        return bluemixLogin.login(host, opt);
      } else {
        // APIm basic auth flow and bluemix >= 5000 < 5030 flow
        if (!opt.username || !opt.password) {
          if (opt.interactiveMode) {
            promptUserAndPassPromise = prompt.promptUserAndPass({
              username: opt.username,
              password: opt.password,
              server: host,
            });
          } else {
            var err = new Error(g.f('The {{username}} and {{password}} are required.'));
            err.missingOptions = [];
            if (!opt.username) {
              err.missingOptions.push('--username');
            }
            if (!opt.password) {
              err.missingOptions.push('--password');
            }

            promptUserAndPassPromise = Promise.reject(err);
          }
        } else {
          promptUserAndPassPromise = Promise.resolve(opt);
        }

        return promptUserAndPassPromise.then(function(opt) {
          // Bluemix 5010 && 5020 login flow
          if (meta.isBluemix() && (!opt.username || !opt.password)) {
            return bluemixLogin.login(opt.server, opt);
          }
          return apicAuth.login(opt.username, opt.password, host);
        });
      }
    }).return(opt).catch(function(err) {
      if (err.statusCode === 404) {
        throw new Error(g.f('Run apic edit and log in via the {{API Designer}} before continuing.'));
      }
      if (err.missingOptions) {
        var additional = err.additionalInfo ? err.additionalInfo : '';
        var msg = g.f('Login to %s failed. The %s option(s) are required. %s', serverConfig.host,
          err.missingOptions.join(', '), additional);
        throw new Error(msg);
      }
      throw new Error(g.f('Login to %s failed. Please verify the server and credentials.', serverConfig.host));
    });
  }).then(function(opt) {
    logger.writeln(g.f('Logged into %s successfully', opt.server));
  });
}
exports.login = login;

