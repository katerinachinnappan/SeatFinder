/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-plugins

var Promise = require('bluebird');
var _ = require('lodash');
var fs = require('fs');
var g = require('strong-globalize')();
var mkdirp = Promise.promisify(require('mkdirp'));
var os = require('os');
var path = require('path');

function mktmpdir() {
  var tmpdir = path.join(os.tmpdir(), Math.random() + '-' + (+new Date()));
  return mkdirp(tmpdir);
}

function checkExtraArgs(cmd, options) {
  var hasVardicParams = false;
  _.each(options._args, function(arg) {
    hasVardicParams = hasVardicParams || arg.variadic;
  });

  // Remove options from raw arguments
  // NOTE: this has a side effect or emiting events associated the options being parsed.
  // We should not be using option events in CLI plugins.
  var parsed = options.parseOptions(options.parent.rawArgs);
  var unexpectedParams = parsed.args.slice(3 + options._args.length);

  if (hasVardicParams || unexpectedParams.length === 0) {
    return Promise.resolve();
  } else {
    return Promise.reject(new Error(g.f('The parameters %s are invalid.',
      unexpectedParams.join(', '))));
  }
}

/**
 * Parses the default option value and performs config lookup if needed.
 */
function getOptionDefault(option, config) {
  if (!option.default) {
    return;
  }

  // See @type {OptionDef} for format of option default values.
  if (option.default && option.default.match(/^\$APIC_CONFIG\$\./)) {
    var cKey = _.split(option.default, '.', 2)[1]; // 0 = $APIC_CONFIG$, 1 = the config key

    // slice and join the rest of the string to get the deep loopkup key. See lodash::get for details
    var oKey = option.default.split('.').slice(2).join('.');
    return _.get(config.getOne(cKey), oKey);
  }
  return option.default || null;
}

/**
 * Prints error message for a missing option on a command. Message also asks for config to be set if default
 * option value is specified.
 *
 * @param {OptionDescription} option
 * @throws Error
 */
function getMissingOptionError(option) {
  throw new Error(g.f('The --%s option is required.', option.optName));
}

function getConfigDir(createDir) {
  if (typeof createDir === 'undefined') {
    createDir = true;
  }
  var os = require('os');
  var path = require('path');
  var env = process.env;
  var home = env.HOME;
  var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
  var homedir;
  if (process.platform === 'win32') {
    homedir = env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
  }
  if (process.platform === 'darwin') {
    homedir = home || (user ? '/Users/' + user : null);
  }
  if (process.platform === 'linux') {
    homedir = home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));
  }
  var userDir = typeof os.homedir === 'function' ? os.homedir() : homedir;
  process.env.APIC_CLI_CONFIG_DIR = process.env.APIC_CLI_CONFIG_DIR || '.apiconnect';
  var configDir = process.env.APIC_CONFIG_PATH || path.resolve(userDir, process.env.APIC_CLI_CONFIG_DIR);
  if (createDir) {
    var mkdirp = require('mkdirp');
    mkdirp.sync(configDir);
  }
  return configDir;
}

function promiseSeries(tasks) {
  var current = Promise.cast();
  var results = [];
  for (var k = 0; k < tasks.length; ++k) {
    results.push(current = current.then(tasks[k]));
  }
  return Promise.all(results);
}

function isFile(path) {
  try {
    var stats = fs.statSync(path);
    if (stats.isFile()) {
      return true;
    }
  } catch (e) {
    return false;
  }

}

module.exports = {
  mktmpdir: mktmpdir,
  checkExtraArgs: checkExtraArgs,
  getOptionDefault: getOptionDefault,
  getMissingOptionError: getMissingOptionError,
  getConfigDir: getConfigDir,
  isFile: isFile,
  promiseSeries: promiseSeries,
};

