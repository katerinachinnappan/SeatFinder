#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect

var Command = require('commander').Command;
var Promise = require('bluebird');
var ServerError = require('apiconnect-cli-util').ServerError;
var _ = require('lodash');
var actionWrapper = require('./cli-action-wrapper');
var d = require('debug')('apiconnect:lib:cli-builder');
var f = require('util').format;
var g = require('strong-globalize')();
var listPlugins = require('./plugins').listPlugins;
var logger = require('apiconnect-cli-logger');
var validators = require('./option-validators');

require('./cli-commander-ext');

/**
 * @typedef PackageDef
 * @param {String} name
 * @param {String} version
 */

/**
 * @typedef PluginDef
 * @param {Array.<TopicDef>}
 */

/**
 * @typedef TopicDef
 * @param {String} name
 * @param {String} description One line description for the topic.
 * @param {String|fn} helpInfo Help text or function that returns help text.
 * @param {Array.<CommandDef>} commands
 */

/**
 * @typedef
 * @param {String} command
 * @param {String} [type] Subtype for the command.
 * @param {boolean} defaultType Indicates that this is the default type for commands with multiple type.
 * @param {String|fn} helpInfo Help text or function that returns help text.
 * @param {Array.<String|OptionDef>} options
 */

/**
 * @typedef OptionDef
 * @param {String} rune One character flag for the option.
 * @param {String} name One word flag for the option.
 * @param {boolean} [optionalValue] indicates if value is required.
 * @param {boolean} [noValue] indicates that no value is expected.
 * @param {boolean} [required] indicates that either option value or default must be available.
 * @param {fn} [validator] Function to validate the param value.
 * @param {String} [type] One of:<br/>* name<br/>* name-version<br/>* name-optversion<br/>* file<br/>
 * * dir<br/>* hostname.
 * @param {boolean} [nary] indicates option accepts a space seperated list.
 * @param {boolean} [mustExist] Is type is file or dir, it must exist.
 * @param {String} [default] value for this option. A value of $APIC_CONFIG$.<key> will lookup the value in APIC config.
 * Eg. $APIC_CONFIG$.catalog.data.organization will lookup the organization from the catalog config.
 */

/**
 * Builds the final CLI based on all the plugins that are loaded. Adds version and help support.
 *
 * @param {PackageDef} apiconnectPkg
 * @param {Array.<PluginDef>} plugins
 * @param {object} [options]
 * @param {ApicLogger} [options.log]
 */
module.exports = function buildExtendedCli(apiconnectPkg, plugins, options) {
  options = options || {};
  _.defaults(options, {
    log: logger,
    pkgInfo: apiconnectPkg,
    enableAnalytics: false,
    enableVersionCheck: true,
    typeDescriminators: [ 'e', 'type' ],
  });

  var log = options.log;

  var program = buildCoreCli(buildCommandMap(plugins, options), plugins, options);
  return function(argv) {
    var productName = apiconnectPkg['product-name'] || apiconnectPkg['name'];
    var productVersion = apiconnectPkg['product-version'] || apiconnectPkg['version'];
    if (!argv.slice(2).length || (argv[2] === '-h' || argv[2] === '--help')) {
      return program.outputHelp();
    } else if (argv[2] === '-v' || argv[2] === '--version') {
      if (productName && productVersion) {
        log.write(productName + ': v' + productVersion);
      }
      log.writeln(' (' + apiconnectPkg.name + ': v' + apiconnectPkg.version + ')');
      return Promise.resolve();
    } else if (argv[2] === '--ext-version') {
      log.write(apiconnectPkg.name + ': v' + apiconnectPkg.version);
      if (productName && productVersion) {
        log.writeln(' (' + productName + ': v' + productVersion + ')');
      }
      return listPlugins();
    } else {
      var notProcessedOptions = [ '-h', '--help' ];
      var validCommands = _.concat(program.allCommands, notProcessedOptions);
      var inputCommand = argv[2];
      if (validCommands.indexOf(inputCommand) === -1) {
        var errorMsg = g.f('The command `%s` is invalid.', inputCommand);
        log.debug('Error while parsing commandline: %j, %s', process.argv, errorMsg);
        var err = new Error(errorMsg);
        err.invalidCommand = true;
        log.error(err.message);
        return Promise.reject(err);
      }
      argv[2] = program.aliasMap[inputCommand] || argv[2];
      try {
        // If a help flag was passed, don't use the commander built in support as once help is emitted, it terminates
        // the process but in the plugin framework we don't want that behavior. If the user provided help option find
        // the command and invoke help directly. Be sure to not call program.parse(...) in this instance as that
        // causes commands to be invoked.
        if (_.includes(argv, '-h') || _.includes(argv, '--help')) {
          return new Promise(function(resolve, reject) {
            // find our command and call help
            var c = _.find(program.commands, { _name: argv[2] });
            var type;
            for (var idx in options.typeDescriminators) {
              var discriminator = options.typeDescriminators[idx];
              discriminator = (discriminator.length === 1 ? '-' : '--') + discriminator;
              var typeIndex = _.indexOf(argv, discriminator);
              if (typeIndex !== -1) {
                type = argv[typeIndex + 1];
                break;
              }
            }
            c.outputHelp(type);

            return resolve();
          });
        }
        var cmd = program.parse(argv);
      } catch (err) {
        if (err instanceof ServerError) {
          log.error(err.toString());
        } else if (err.message) {
          log.error(err.message);
        } else if (err && err.length > 0) {
          log.error(err.toString());
        }
        return Promise.reject(err);
      }
      return cmd.actionPromise
        .catch(function(err) {
          if (err instanceof ServerError) {
            log.error(err.toString());
          } else if (err.message) {
            log.error(err.message);
          } else if (err && err.length > 0) {
            log.error(err.toString());
          }
          return Promise.reject(err);
        });
    }
  };
};

var DEFAULT_TYPE = -1;
function buildCommandMap(plugins, options) {
  var commandList = {};
  var pInfo = [];
  var cmds = [];
  var $ = ' - ';

  _.each(plugins, function(plugin) {
    _.each(plugin.topics, function(topic) {
      _.each(topic.commands, function(command) {
        command.topic = topic.name;
        command.description = topic.description;
        command.parentHelpInfo = topic.helpInfo;
        command.isBuiltin = plugin.isBuiltin;
        command.pluginName = plugin.name;
        command.pluginGitHead = plugin.gitHead;
        command.pluginVersion = plugin.version;
        var verb = command.command.split(' ')[0];
        var fullName = topic.name + ':' + verb;
        var type = command.type || DEFAULT_TYPE;
        if (type !== DEFAULT_TYPE) {
          command.typeHelpInfo = command.helpInfo;
        }
        commandList[fullName] = commandList[fullName] || {};
        commandList[fullName][type] = command;
        if (process.env.DEBUG === 'apiconnect:lib:cli-builder') {
          var aliases = command.aliases ?
            '[ ' + command.aliases.toString() + ' ]' : '[ ]';
          var pluginInfo = fullName + $ + plugin.name + $ + aliases;
          var typeInfo = '';
          if (type !== -1) {
            typeInfo = $ + type + (command.defaultType ?
              ' (defaultType)' : '');
          }
          pInfo.push(pluginInfo + typeInfo);
          var cmdInfo = f('apic %s %s -h', fullName,
            type === DEFAULT_TYPE ? '' : ('--type ' + type));
          cmds.push(cmdInfo);
          if (command.aliases && command.aliases.length > 0) {
            cmdInfo = f('apic %s -h', command.aliases.toString());
            cmds.push(cmdInfo);
          }
        }
      });
    });
  });
  if (process.env.DEBUG === 'apiconnect:lib:cli-builder') {
    pInfo.sort();
    console.log(
      '\n\n topic:command - plugin_name - [ aliases ] - type\n',
      '------------------------------------------------\n',
      pInfo);
    cmds = _.uniq(cmds.sort());
    console.log(cmds.join('\n'), '\n\n');
  }

  return commandList;
}

function buildCoreCli(commandList, plugins, options) {
  var cli = new Command();
  cli.logger = options.log;

  //get all commands objects
  var commandObjs = _(commandList).map(_.values).flatten();
  cli.pkgName = options.pkgInfo.name;
  cli.aliasMap = {};
  cli.allCommands = [];
  cli = commandObjs.reduce(function(cli, command) {
    var commandName = command.topic + ':' + command.command.split(' ')[0];
    cli.allCommands.push(commandName);
    _.each(command.aliases, function(alias) {
      if (cli.aliasMap[alias]) {
        var other = _.values(commandList[cli.aliasMap[alias]])[0];
        var cur = _.values(commandList[commandName])[0];
        if (other.topic !== cur.topic) {
          throw new Error(g.f('Alias %s is used by %s and %s.', alias, cli.aliasMap[alias], commandName));
        }
      }
      cli.aliasMap[alias] = commandName;
      cli.allCommands.push(alias);
    });
    return cli;
  }, cli);

  // Gather up components into list on the command object
  cli.components = _.compact(_.reduce(plugins, function(compList, plugin) {
    return _.concat(compList, plugin.components);
  }, []));

  _.each(commandList, function(types, name) {
    if (Object.keys(types).length === 1 && types.hasOwnProperty(DEFAULT_TYPE)) {
      // simple command
      var commandInfo = types[DEFAULT_TYPE];
      buildCommand(cli, name, commandInfo, false, options);

      // create help command for topic only if there are no aliases of the same name
      if (_.indexOf(cli.allCommands, commandInfo.topic) < 0) {
        var cp = cli.command(commandInfo.topic);
        cp.isBuiltin = commandInfo.isBuiltin;
        cp.outputHelp = function() {
          printHelp(commandInfo.parentHelpInfo, options.log);
        };
        cp.action(cp.outputHelp);
      };
    } else {
      buildSubCommand(cli, name, types, options);
    }
  });

  return cli;
}

function buildSubCommand(cli, name, types, options) {
  var c = cli.command(name);
  var log = options.log;

  // build sub-command by types
  var subcommands = {};
  var parentHelpInfo = null;
  _.each(types, function(commandInfo, type) {
    var subcli = new Command();
    subcli.components = cli.components;
    buildCommand(subcli, name, commandInfo, true, options);
    subcommands[type] = subcli;
    if (commandInfo.typeHelpInfo) {
      subcommands[type].helpInfo = commandInfo.typeHelpInfo;
    }
    if (commandInfo.parentHelpInfo) {
      parentHelpInfo = commandInfo.parentHelpInfo;
    }
    if (commandInfo.defaultType) {
      if (commandInfo.typeHelpInfo) {
        parentHelpInfo = commandInfo.typeHelpInfo;
      }
      c.defaultType = subcli;
    }
  });
  buildTypeDescriminators(c, options);
  c.optionMissingArgument = function(option, flag) {
    optionMissingArgument(option, flag);
  };
  c.outputHelp = function(type) {
    if (!type && c.defaultType && c.defaultType.helpInfo) {
      printHelp(c.defaultType.helpInfo, log);
    } else if (type && subcommands[type] && subcommands[type].helpInfo) {
      printHelp(subcommands[type], log);
    } else if (parentHelpInfo) {
      printHelp(parentHelpInfo, log);
    }
  };
  c.action(function() {
    var o = _.find(arguments, function(arg) {
      return arg instanceof Command;
    });

    // look for other type descriminators
    var typeDescriminator = 'type';
    for (var idx in options.typeDescriminators) {
      var discriminator = options.typeDescriminators[idx];
      if (o[discriminator]) {
        typeDescriminator = discriminator;
        o.type = o[discriminator];
        break;
      }
    }

    if (o.type && !subcommands[o.type]) {
      throw Error(g.f(
        'The --%s %s is invalid for the %s command. Supported type values are [%s].',
        typeDescriminator, o.type, name, _.keys(subcommands)
      ));
    }
    var type = o.type || DEFAULT_TYPE;
    var sc = subcommands[type] || c.defaultType;
    if (!sc) {
      if (parentHelpInfo) {
        printHelp(parentHelpInfo, log);
      } else {
        throw Error(g.f(
          'The --%s option is required for the %s command. Supported type values are [%s].',
          typeDescriminator, name, _.keys(subcommands)));
      }
    } else {
      log.debug(g.f('invoking subcommand with type: %s', type));
      var subcmd = sc.parse(o.parent.rawArgs);
      this.parent.actionPromise = subcmd.actionPromise;
    }
  });
  c.allowUnknownOrMissingArgs = true;
  c.allowUnknownOption();
}

function buildCommand(cli, name, commandInfo, addTypeOption, options) {
  d('buildCommand %s %j', name, commandInfo);
  var log = options.log;
  commandInfo.fullName = name;
  var c = cli.command(commandInfo.topic + ':' + commandInfo.command);
  c.topic = commandInfo.topic;
  c.description = commandInfo.description;
  _.each(commandInfo.options, function(option) {
    if (typeof option === 'string') {
      c.option(option, '');
    } else {
      var rune = '';
      var flag = '';
      if (option.rune) {
        rune = f('-%s, ', option.rune);
      }
      flag = f('%s--%s', rune, option.name);

      if (option.optionalValue) {
        flag = f('%s [val]', flag);
      } else if (!option.noValue && option.type !== 'boolean') {
        flag = f('%s <val>', flag);
      }

      if (option.validator) {
        c.option(flag, '', function(val) {
          option.validator(val);
          return val;
        });
      } else if (option.type) {
        c.option(flag, '', validators.getValidator(option));
      } else {
        c.option(flag, '');
      }
    }
  });
  if (addTypeOption) {
    buildTypeDescriminators(c, options);
  }
  c.action(actionWrapper(commandInfo, cli.components, options));
  c.outputHelp = function() {
    printHelp(commandInfo, log);
  };
  c.isBuiltin = commandInfo.isBuiltin;
  if (!commandInfo.allowUnknownOrMissingArgs) {
    c.optionMissingArgument = function(option, flag) {
      optionMissingArgument(option, flag);
    };
    c.unknownOption = function(flag) {
      unknownOption(flag);
    };
    c.missingArgument = function(name) {
      missingArgument(name);
    };
  } else {
    c.allowUnknownOption();
  }
  c.logger = log;
}

function missingArgument(name) {
  var err = new Error(g.f('The parameter `%s` is required.', name.split('=')[0]));
  err.invalidCommand = true;
  throw err;
}

function unknownOption(flag) {
  var err = new Error(g.f('The option `%s` is invalid.', flag));
  err.invalidCommand = true;
  throw err;
}

function printHelp(helpObject, log) {
  var helpText = '';
  if (helpObject.helpInfo) {
    helpText = _.isFunction(helpObject.helpInfo) ? helpObject.helpInfo() : helpObject.helpInfo;
  } else {
    helpText = _.isFunction(helpObject) ? helpObject() : helpObject;
  }
  log.writeln(helpText);
}

function optionMissingArgument(option, flag) {
  var err;
  if (flag) {
    err = new Error(g.f('The value `%s` for the `%s` option is invalid.', flag, option.long));
    err.invalidCommand = true;
    throw err;
  } else {
    err = new Error(g.f('Value for the `%s` option is required.', option.long));
    err.invalidCommand = true;
    throw err;
  }
}

function buildTypeDescriminators(c, options) {
  // NOTE: short option has to be combined with long option otherwise
  // commander seems to auto-uppercase the option
  var shortTypes = options.typeDescriminators.filter(function(t) {
    return t.length === 1;
  });
  var longTypes = options.typeDescriminators.filter(function(t) {
    return t.length > 1;
  });
  while (shortTypes.length + longTypes.length > 0) {
    var optStr = [];
    var sOpt = shortTypes.pop();
    var lOpt = longTypes.pop();
    if (sOpt) {
      optStr.push('-' + sOpt);
    }
    if (lOpt) {
      optStr.push('--' + lOpt);
    }
    c.option(optStr.join(', ') + ' <type>');
  }
}

