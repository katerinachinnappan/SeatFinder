#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-apis


var ApicCliUtil = require('apiconnect-cli-util');
var Apis = require('apiconnect-apim-client').apis;
var _ = require('lodash');
var apicLogger = require('apiconnect-cli-logger');
var f = require('util').format;
var g = require('strong-globalize')();
var path = require('path');
var util = require('./util/util');

var checkForOrgOrAllOrgAndCatalogOrCatalog = ApicCliUtil.Util.checkForOrgOrAllOrgAndCatalogOrCatalog;

exports.apisList = function apisList(options) {
  var logger = options.logger || apicLogger;

  checkForOrgOrAllOrgAndCatalogOrCatalog(options);
  return Apis.list(options).then(function(apis) {
    _.each(apis, function(api) {
      var status = '';
      if (api.deploymentState === 'running') {
        status = g.f('status: online');
      } else if (api.deploymentState === 'stopped') {
        status = g.f('status: offline');
      } else if (api.deploymentState === 'suspended') {
        status = g.f('status: offline');
      } else {
        status = g.f('status: %s', api.deploymentState);
      }

      if (!api.spaceEnabled) {
        logger.writeln(g.f(
          '%s:%s in %s:%s [%s]', api.apiName, api.apiVersion, api.orgName, api.catalogName, status
        ));
      } else {
        _.each(api.spaceNames, function(spaceName) {
          logger.writeln(g.f(
            '%s:%s in %s:%s:%s [%s]', api.apiName, api.apiVersion, api.orgName, api.catalogName, spaceName, status
          ));
        });
      }
    });
  });
};

exports.apisGet = function apisGet(apiNameVersion, options) {
  options.apiNameVersion = apiNameVersion;
  var logger = options.logger || apicLogger;

  return Apis.get(options).then(function(apis) {
    _.each(apis, function(api) {
      logger.writeln(g.f('name: %s', api.apiName));
      logger.writeln(g.f('version: %s', api.apiVersion));
      logger.writeln(g.f('title: %s', api.displayName));
      logger.writeln(g.f('basepath: %s', api.basePath));

      if (api.state === 'running') {
        logger.writeln(g.f('status: online'));
      } else if (api.state === 'stopped') {
        logger.writeln(g.f('status: offline'));
      } else if (api.state === 'suspended') {
        logger.writeln(g.f('status: offline'));
      } else {
        logger.writeln(g.f('status: %s', api.state));
      }

      // For backward compatibility with bluemix till it gets updated
      if (api.apiPath) {
        logger.writeln(g.f('url: %s', api.apiPath));
      } else {
        var endPoints = processEndPoints(api.apiPaths);
        logger.writeln(g.f('production endpoints: %s', endPoints.production));
        logger.writeln(g.f('development endpoints: %s', endPoints.development));
      }

      var prods = _.map(api.relatedProducts, function(prod) {
        return prod.name + ':' + prod.version;
      }).join(' ');
      logger.writeln(g.f('products: %s', prods));

      if (api.spaceEnabled) {
        logger.writeln(g.f('spaces: %s', _.sortBy(api.spaceNames).join(' ')));
      }
      logger.writeln(g.f('catalog: %s', api.catalogName));
      logger.writeln(g.f('organization: %s', api.orgName));
    });
  });
};

exports.apisPull = function apisPull(apiNameVersion, options) {
  options.apiNameVersion = apiNameVersion;
  options.dirPath = process.cwd();
  var logger = options.logger || apicLogger;

  return Apis.pull(options).then(function(apis) {
    _.each(apis, function(api) {
      var loc = f('%s:%s', api.orgName, api.catalogName);
      if (options.space) {
        loc = f('%s:%s', loc, _.first(api.spaceNames));
      }

      logger.writeln(g.f(
        'Pulled %s:%s API definition from %s [%s]',
        api.apiName,
        api.apiVersion,
        loc,
        path.relative(options.dirPath, api.apiFile)
      ));

      if (api.wsdlFile) {
        logger.writeln(g.f(
          'Pulled %s:%s API WSDL definition from %s [%s]',
          api.apiName,
          api.apiVersion,
          loc,
          path.relative(options.dirPath, api.wsdlFile)
        ));
      }
    });
  });
};

exports.apisClone = function apisClone(options) {
  options.dirPath = process.cwd();
  var logger = options.logger || apicLogger;

  checkForOrgOrAllOrgAndCatalogOrCatalog(options);
  return Apis.pullAll(options).then(function(apis) {
    _.each(apis, function(api) {
      var loc = f('%s:%s', api.orgName, api.catalogName);
      if (api.spaceEnabled) {
        loc = f('%s:%s', loc, _.first(api.spaceNames));
      }

      logger.writeln(g.f(
        'Pulled %s:%s API definition from %s [%s]',
        api.apiName,
        api.apiVersion,
        loc,
        path.relative(options.dirPath, api.apiFile)
      ));

      if (api.wsdlFile) {
        logger.writeln(g.f(
          'Pulled %s:%s API WSDL definition from %s [%s]',
          api.apiName,
          api.apiVersion,
          loc,
          path.relative(options.dirPath, api.wsdlFile)
        ));
      }
    });
  });
};

exports.apisSet = function apisSet(apiNameVersion, options) {
  options.apiNameVersion = apiNameVersion;
  var logger = options.logger || apicLogger;
  switch (options.status) {
    case 'online':
      options.status = 'start';
      break;
    case 'offline':
      options.status = 'stop';
      break;
  }

  return Apis.set(options).then(function(apis) {
    _.each(apis, function(api) {
      var loc = f('%s:%s', api.orgName, api.catalogName);
      if (options.space) {
        loc = f('%s:%s', loc, _.first(api.spaceNames));
      }

      logger.writeln(g.f(
        'Updated %s:%s in %s (status: %s)',
        api.apiName,
        api.apiVersion,
        loc,
        api.deploymentState === 'running' ? 'online' : 'offline'
      ));
    });
  });
};

function processEndPoints(endPoints) {
  var result = { production: '', development: '' };
  _.each(endPoints, function(endPoint) {
    if (util.arrayContains(endPoint.types, 'development')) {
      result.development += '\"' + endPoint.endpointUrl + '\"' + ' ';
    }
    if (util.arrayContains(endPoint.types, 'production')) {
      result.production += '\"' + endPoint.endpointUrl + '\"' + ' ';
    }
  });

  return result;
};

