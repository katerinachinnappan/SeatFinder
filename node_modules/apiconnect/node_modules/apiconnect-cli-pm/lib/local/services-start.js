/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-pm

'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var apicConfig = require('apiconnect-config');
var clientHelper = require('./util/client');
var debug = require('debug')('apiconnect-cli-pm:commands:start');
var f = require('util').format;
var fs = require('fs');
var g = require('strong-globalize')();
var logger = require('apiconnect-cli-logger');
var logs = require('./services-logs').logsImpl;
var path = require('path');
var project = require('apiconnect-project');
var start = require('./util/start');
var conf = require('./util/config');
var dp = require('../datapower');

var APP_HOME = '__APIC_APP_HOME';

module.exports = {
  startFmt: startFmt,
  startImpl: startImpl,
  startAnalytics: startAnalytics,
};

function startFmt(options) {
  var l = options.logger;
  return startImpl(options).then(function(runningServices) {
    if (!runningServices || runningServices.length === 0) {
      l.writeln(g.f('Did not find any assets to start.'));
    }
    runningServices.forEach(function(service) {
      if (service.success === false) {
        l.writeln(g.f('Service %s started but did not initialize within the timeout period. '
          + 'Dumping log buffer.\n%s', service.name, service.logs));
        return;
      }
      var msg;
      if (service.port) {
        msg = g.f('Service %s started on port %s.', service.name, service.port);
      } else {
        msg = g.f('Service %s starting, use "apic services" to obtain port details.', service.name);
      }
      if (service.env.STRONGLOOP_DASHBOARD === 'on' && service.port) {
        msg += g.f(' Access the application dashboard at http://127.0.0.1:%s/appmetrics-dash', service.port);
      }
      l.writeln(msg);
    });
    return;
  }).catch(function(err) {
    l.debug('start-command', err);
    var msg = err.message || 'Start command was unable to complete successfully.';
    return Promise.reject(new Error(msg));
  });
}

function startAnalytics(opts) {
  var l = opts.logger;
  var workDir = opts.cwd || process.cwd();
  return project.loadProject(workDir)
    .then(function(artifacts) {

      // If we don't have any artifacts we don't need to start the gateway.
      if ((!artifacts || artifacts.length === 0)) {
        l.debug('No artifacts, no gateway information');
        return {};
      }

      var datapower = false;
      artifacts.forEach(function(obj) {
        if (obj.type === 'swagger' && obj.data['x-ibm-configuration']) {
          if (obj.data['x-ibm-configuration'].gateway === 'datapower-gateway') {
            datapower = true;
          }
        }
      });

      var config = apicConfig.loadConfig();
      var experimental = config.getOne('datapower-api-gateway-experimental', apicConfig.PROJECT_STORE);
      l.debug('datapower: %s experimental: %s', datapower, experimental);
      if (datapower) {
        if (experimental === 'true') {
          return { Gateway: 'datapower-experimental' };
        } else {
          return { Gateway: 'datapower' };
        }
      } else {
        return { Gateway: 'microgateway' };
      }
    });
}

function startImpl(opts) {
  opts.autoStart = true;
  var l = opts.logger;
  var config = apicConfig.loadConfig();
  var microgw = config.get('microgateway') || config.get('micro-gateway');
  var workDir = opts.cwd || process.cwd();
  var projectInfo = project.inspectPath(workDir, { incNodeProjects: true });
  var projectName = projectInfo.name;
  var startedApp = false;
    // Are we in a loopback project dir
  var startingProject = (projectInfo.type === 'project');

  // init the pmClient opts for further reference
  clientHelper.init(opts);
  var serviceOpt = opts.service;
  l.debug('services.startImpl : ', microgw, workDir, startingProject, serviceOpt);
  var apps = [];
  if (serviceOpt) {
    return clientHelper.findService(serviceOpt)
      .then(function(asyncService) {
        if (!asyncService) {
          return fullStart();
        }
        return restartService(asyncService, null, l)
          .then(processStarted)
          .then(function() {
            l.debug('services.startImpl : returning', apps);
          })
          .return(apps);
      });
  }
  return fullStart();

  function fullStart() {
    return startApp()
      .then(processStarted)
      .then(startGateway)
      .then(processStarted)
      .then(function() {
        l.debug('services.startImpl : returning', apps);
      })
      .return(apps);
  }

  // Called after starting an app and waits for a service port
  function processStarted(service) {
    if (!service || !service.id) {
      return;
    }
    l.debug('services.processStarted ', service.id);
    return clientHelper.waitForServiceInfoPort(service)
      .then(function(appInfo) {
        l.debug('services.processStarted complete', appInfo);
        appInfo.env = service.env;
        apps.push(appInfo);
        return appInfo;
      }).catch(function(err) {
        l.debug('services.processStarted err', service.name, err);
        var ret = { id: service.id, name: service.name, success: false };
        // The service started, but we didn't get a port for it. Grab the logs then get outta here
        apps.push(ret);
        return logs(service.id)
          .then(getLogs)
          .then(function(logs) {
            throw new Error(g.f('Service %s started but did not initialize within the timeout period. '
              + 'Dumping log buffer.\n%s', service.name, logs));
          });
      });
  }; // eslint-disable-line no-unreachable

  function startApp() {
    // Are we starting a project(loopback)
    if (!startingProject) {
      l.debug('services.startApp %s is not a loopback dir. not starting app', workDir);
      // Return empty object to try to gateway to see if it needs to start
      return Promise.resolve({});
    }
    var projectDir = projectInfo.basePath;
    var projectEnv = {};
    if (config.getOne('project-port')) {
      projectEnv['PORT'] = config.getOne('project-port');
    }
    if (config.getOne('log-level')) {
      projectEnv['LOG_LEVEL'] = config.getOne('log-level');
    }
    if (projectInfo.type !== 'swiftserver') {
      projectEnv.STRONGLOOP_DASHBOARD = process.env.STRONGLOOP_DASHBOARD || 'on';
      projectEnv.STRONGLOOP_DASHBOARD_TITLE = 'IBM API Connect';
      projectEnv.STRONGLOOP_DASHBOARD_DOCS = 'https://www.ibm.com/support/' +
        'knowledgecenter/SSMNED_5.0.0/com.ibm.apic.toolkit.doc/tapic_view_appmetrics.html';
    }
    projectEnv[APP_HOME] = projectDir;
    l.debug('services.startApp ', projectName, projectEnv, projectDir);
    return clientHelper.findService(projectName)
      .then(function(appService) {
        debug('findService', appService);
        if (appService) {
          // If someone tries to start(without a --service opt) from a dir with an app that matches
          // an existing app name, throw an error as they probably wanted to have two different apps
          // running with the same time.
          if (!serviceOpt && appService.env[APP_HOME] !== projectDir) {
            var msg = 'An app with the name `%s` is already deployed from `%s`.';
            return Promise.reject(new Error(f(msg, projectName, appService.env[APP_HOME])));
          }
          return restartService(appService, projectEnv, l);
        }
        // Deploy if we don't have a --service, or --service matches projectName
        if (!serviceOpt || serviceOpt && serviceOpt === projectName) {
          startedApp = true;
          return deployProject(projectName, projectDir, projectEnv);
        }
        return Promise.resolve({});
      });
  }; // eslint-disable-line no-unreachable

  function startGateway(appInfo) {
    return project.loadProject(workDir)
      .then(function(artifacts) {

        // If we don't have any artifacts we don't need to start the gateway.
        if ((!artifacts || artifacts.length === 0)) {
          l.debug(f('%s does not contain any gw artifacts. not starting gateway', workDir));
          return {};
        }

        var datapower = false;
        artifacts.forEach(function(obj) {
          if (obj.type === 'swagger' && obj.data['x-ibm-configuration']) {
            if (obj.data['x-ibm-configuration'].gateway === 'datapower-gateway') {
              datapower = true;
            }
          }
        });
        return datapower ? startDataPower(appInfo) : startMicroGateway(appInfo);
      });
  }; // eslint-disable-line no-unreachable

  function startDataPower(appInfo) {
    var gwName = projectName + '-gw';
    var gwDir = path.dirname(require.resolve('apiconnect-mgmt-lite-datapower'));
    var gwEnv = {
      NODE_ENV: 'production',
      STRONG_PM_URL: 'http://127.0.0.1:' + conf.get('pmPort'),
      PROJECT_DIR: projectInfo.basePath,
      PROJECT_NAME: projectName,
      TARGET_URL: null,
      DATAPOWER: true,
      __APIC_GW: true,
    };
    gwEnv[APP_HOME] = workDir;
    if (config.getOne('project-port')) {
      gwEnv['PORT'] = config.getOne('project-port');
    }
    if (config.getOne('log-level')) {
      gwEnv['LOG_LEVEL'] = config.getOne('log-level');
    }
    if (appInfo && appInfo.port) {
      gwEnv['TARGET_URL'] = f('http://127.0.0.1:%d', appInfo.port);
    }
    l.debug('services.startDataPower ', gwName, gwEnv, gwDir);
    return clientHelper.findService(gwName).then(function(service) {
      debug('findService', service);
      if (service) {
        return restartService(service, gwEnv, l);
      }
      if (!serviceOpt || serviceOpt && serviceOpt === gwName) {
        return deployProject(gwName, gwDir, gwEnv);
      }
      return Promise.resolve({});
    });
  }; // eslint-disable-line no-unreachable

  function startMicroGateway(appInfo) {
    // We need to start the gateway in two cases.
    // 1. We started an app and were handed an appInfo
    // 2. We weren't given an app, but we have gateway artifacts
    var gatewayName = projectName + '-gw';
    var gatewayDir = microgw['microgateway'] || microgw['micro-gateway']
      || path.dirname(require.resolve('microgateway'));
    if (!fs.existsSync(gatewayDir)) {
      throw new Error(g.f('{{Gateway}} dir: %s not found', gatewayDir));
    }
    var pkgJson = require(path.join(gatewayDir, 'package.json'));
    if (!pkgJson['APIConnectGateway']) {
      throw new Error(g.f('Invalid {{Gateway}} runtime env specified: %s', gatewayDir));
    }
    var configDir = path.join(projectInfo.basePath, 'definitions');
    var gatewayEnv = {
      NODE_ENV: 'production',
      CONFIG_DIR: configDir,
    };
    if (config.getOne('gateway-port')) {
      gatewayEnv['PORT'] = config.getOne('gateway-port');
    }
    if (config.getOne('log-level')) {
      gatewayEnv['LOG_LEVEL'] = config.getOne('log-level');
    }
    gatewayEnv[APP_HOME] = configDir;

    l.debug('services.startGateway', gatewayName);
    return clientHelper.findService(gatewayName).then(function(gatewayService) {
      gatewayEnv['TARGET_URL'] = null;
      if (appInfo && appInfo.port) {
        gatewayEnv['TARGET_URL'] = f('http://127.0.0.1:%d', appInfo.port);
      }
      gatewayEnv['CONFIG_DIR'] = workDir;
      gatewayEnv['__APIC_GW'] = true;
      l.debug('services.startGateway.env', gatewayEnv, gatewayService === null ? null : gatewayService.id);
      if (gatewayService) {
        var targetChanged = gatewayService.env.TARGET_URL !== gatewayEnv.TARGET_URL;
        // Only restart if the targetChanged -- meaning app went from stopped -> started
        // or if a --service wasn't provided. --service case is handled earlier
        if (targetChanged || !serviceOpt) {
          // env keys with null values get deleted so if app went down the prop will be handled
          return restartService(gatewayService, gatewayEnv, l);
        }
      }
      if (!serviceOpt || serviceOpt && serviceOpt === gatewayName) {
        return deployProject(gatewayName, gatewayDir, gatewayEnv);
      }
      if (startedApp) {
        return Promise.resolve({});
      }
      debug('Did not find anything to start');
      return {};
    });
  };// eslint-disable-line no-unreachable
};// eslint-disable-line no-unreachable

function restartService(asyncService, envProps, logger) {
  logger.debug('services.restartService', asyncService.id, envProps);
  var promise = Promise.resolve(asyncService);
  if (envProps) {
    promise = setEnvProps(envProps, asyncService);
  }
  return promise
    .then(dp.prepareForShutdown)
    .call('restartAsync', {}, logger)
    .return(asyncService);
}

function deployProject(name, projectDir, envProps) {
  logger.debug('services.deployProject', name, projectDir, envProps);
  var asyncService = clientHelper.findOrCreateAsyncService(name);
  return asyncService.then(setEnvProps.bind(null, envProps))
    .then(start.bind(null, projectDir, name))
    .then(function() {
      return asyncService.value();
    });
}

function setEnvProps(envProps, asyncService) {
  logger.debug('services.setEnvProps %j', envProps, asyncService.id);
  if (Object.keys(envProps).length) {
    return asyncService.setEnvsAsync(envProps)
      .then(function(res) {
        // We just set env props, so set them into the returned asyncService
        // rather than calling out to get a new one.
        asyncService.env = _.extend({}, asyncService.env, envProps);
        return asyncService;
      });
  }
  return Promise.resolve(asyncService);
}

function getLogs(logHandler) {
  return Promise.promisify(logHandler.get.bind(logHandler))();
};

