/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-pm

'use strict';

var PmClient = require('strong-mesh-models').Client;
var conf = require('../config');
var debug = require('debug')('apiconnect-cli-pm:start:pm');
var fmt = require('util').format;
var fs = require('fs');
var g = require('strong-globalize')();
var mkdirp = require('mkdirp').sync;
var net = require('net');
var once = require('lodash').once;
var path = require('path');
var retry = require('./retry');
var slpm = require.resolve('strong-pm/bin/sl-pm.js');
var spawn = require('child_process').spawn;

module.exports = Pm;

function Pm() {
  if (!(this instanceof Pm)) {
    /* eslint new-cap:0 */
    return new Pm.apply(null, arguments);
  }
  this.base = conf.get('pmHome');
  this.logFile = path.resolve(this.base, 'start.log');
  this.port = conf.get('pmPort');
  this.url = fmt('http://127.0.0.1:%s', this.port);
  this.client = new PmClient(this.url);
}

Pm.prototype.start = function(callback) {
  var self = this;

  debug('start');

  self.isAlive(function(err) {
    if (!err) {
      debug('pm is alive');
      // Find the where the new log info will start at
      fs.stat(self.logFile, function(err, stat) {
        var logAt = err ? 0 : stat.size;
        return callback(null, logAt);
      });
      return;
    }
    // PM isn't running make sure nothing is using our port
    debug('start isAlive err:', err);
    tryPort(self.port, function(err, res) {
      if (err) {
        debug('Error connecting to port %s. Error: %s', self.port, err);
        return self.spawn(callback);
      }
      return callback(new Error(g.f('Port %s is in use.', self.port)));
    });
  });
};

// Ideally this fn would try to bind to a port and then
// unbind but that would be a rather expensive operation
function tryPort(port, callback) {
  debug('trying port %s', port);
  var client = net.connect(port)
    .once('error', callback)
    .once('connect', function() {
      client.destroy();
      callback();
    });
};

Pm.prototype.isAlive = function(_callback) {
  debug('isAlive...');
  var self = this;

  var callback = once(function(err) {
    debug('alive? %s', err);
    return _callback(err);
  });

  self.client.apiInfo(function(err, res) {
    return callback(err, res);
  });
};

Pm.prototype.spawn = function(callback) {
  callback = once(callback);

  var self = this;
  var args = [
    slpm,
    '--base', this.base,
    '--listen', this.port,
    '--base-port', conf.get('pmBasePort'),
    '--json-file-db',
  ];

  mkdirp(this.base);

  try {
    fs.truncateSync(this.logFile, 0);
  } catch (er) {
    // Ignore, probably the file doesn't exist, and other errors
    // will be caught below when we open the file.
    debug('truncate failed: %s', er.message);
  }

  var logFd = fs.openSync(this.logFile, 'a');
  var options = {
    detached: true,
    stdio: [ 'ignore', logFd, logFd ],
  };

  debug('spawn: %s args %j options %j', process.execPath, args, options);

  self.child = spawn(process.execPath, args, options)
    .once('error', function(err) {
      debug('spawn error: %s', err);
      callback(err);
    })
    .once('exit', function(status, signal) {
      debug('spawn exit', signal || status);
      return callback(new Error(g.f('Service manager failed to start. Please review %s for details.', self.logFile)));
    });

  fs.closeSync(logFd);

  debug('wait for pm to be alive');

  retry(self.isAlive.bind(self), function(err) {
    debug('alive after start? %s', err);
    callback(err, 0);
  });
};

