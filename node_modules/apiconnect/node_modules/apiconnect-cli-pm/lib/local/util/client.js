/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-pm

'use strict';

var Pm = require('./start/pm');
var PmClient = require('strong-mesh-models').Client;
var Promise = require('bluebird');
var _ = require('lodash');
var conf = require('./config');
var fmt = require('util').format;
var g = require('strong-globalize')();
var logger = require('apiconnect-cli-logger');
var rimrafAsync = Promise.promisify(require('rimraf'));
var startTimeout = conf.get('startTimeout');

Promise.promisifyAll([ Pm, PmClient ]);

exports.init = init;
exports.getPmClient = getPmClient;
exports.getService = getService;
exports.findService = findService;
exports.waitForServiceInfoPort = waitForServiceInfoPort;
exports.serviceList = serviceList;
exports.findOrCreateAsyncService = findOrCreateAsyncService;
exports.stopServiceImpl = stopServiceImpl;
exports.tryShutdown = tryShutdown;

var pmPort = conf.get('pmPort');
var defaultPmLoc = fmt('http://127.0.0.1:%s', pmPort);
var pmHome = conf.get('pmHome');
var pmBasePort = conf.get('pmBasePort');

var client = new PmClient(defaultPmLoc);
var clientOpts = { };

function init(opts) {
  clientOpts = opts || clientOpts;
  return exports;
}

function getPmClient() {
  var l = clientOpts.logger || logger;
  var autoStart = clientOpts.autoStart || false;

  return client.apiInfoAsync().catch(function maybeStartPm() {
    l.debug('services.client.getPmClientPM is not running. Autostart? %s', !!autoStart);
    if (autoStart) {
      var pm = new Pm();
      return rimrafAsync(pmHome).then(function(resolve, reject) {
        l.debug('Removed %s. resolve:%s, reject%s', pmHome, resolve, reject);
        return pm.startAsync();
      }).then(function() {
        l.debug('PM has been started');
      });
    }
    return Promise.reject(new Error(g.f('PM is not running')));
  }).then(function() {
    return client;
  });
}

function waitForServiceInfoPort(asyncService) {
  return new Promise(function(resolve, reject) {
    var delay = startTimeout / 20;
    return check(asyncService, 20);

    function check(asyncService, iter) {
      return getServiceInfo(asyncService).then(function(res) {
        var msg = null;
        if (res.port) {
          res.success = true;
          return resolve(res);
        } else if (res.error) {
          msg = g.f('%s failed to start.', asyncService.name);
          return reject(new Error(msg));
        } else if (iter === 0) {
          if (res.env.__APIC_GW) {
            msg = g.f('%s is starting, port assignment in progress.',
                      asyncService.name);
            return resolve(res);
          } else {
            msg = g.f('%s did not return a port in timeout.',
                      asyncService.name);
            logger.writeln(msg);
            return reject(new Error(msg));
          }
        }
        return setTimeout(check, delay, asyncService, --iter);
      });
    };// eslint-disable-line no-unreachable
  });
};

function getServiceInfo(asyncService) {

  // TODO -- This entire bit of code is gross and needs to be cleaned up!.
  return asyncService.refreshAsync()
    .then(Promise.promisifyAll)
    .call('getStatusSummaryAsync')
    .then(function(summary) {
      var processes = summary.processes;
      var res = {
        id: summary.id,
        name: summary.name,
        env: summary.env,
      };
      // TODO Holy buckets batman! This belongs elsewhere.
      res.gw = asyncService.env && asyncService.env.__APIC_GW;
      res.env = asyncService.env;
      for (var i = 0; i < processes.length; i++) {
        var proc = processes[i];
        var sockets = processes[i].listeningSockets;
        if (sockets.length !== 0 && !proc.stopReason) {
          if (res.env.DATAPOWER) {
            for (var p = 0; p < sockets.length; p++) {
              var port = +sockets[p].port;
              if ((res.env.PORT && port === +res.env.PORT) ||
                  (port >= pmBasePort && port <= pmBasePort + 100)) {
                res.port = sockets[p].port;
              }
            }
          } else {
            res.port = sockets[0].port;
          }
          return res;
        };
        if (+proc.stopReason === 1) {
          res.error = true;
          return res;
        }
      };
      return res;
    });
};

function getService(id) {
  return getPmClient()
    .call('serviceFindAsync', id)
    .then(Promise.promisifyAll)
    .catch(function(err) {
      var l = clientOpts.logger;
      if (l) {
        l.debug(err);
      }
      throw new Error(g.f('Unable to locate service `%s`.', id));
    });
};

function serviceList() {
  return getPmClient()
    .call('serviceListAsync')
    .then(function(services) {
      return Promise.map(services.map(Promise.promisifyAll), getServiceInfo);
    });
};

function findService(id) {
  return getPmClient()
    .call('serviceFindAsync', id)
    .then(Promise.promisifyAll)
    .catch(function(err) {
      var l = clientOpts.logger || logger;
      if (l) {
        l.debug(err);
      }
      return null;
    });
};

function findOrCreateAsyncService(name) {
  var l = clientOpts.logger || logger;
  return getPmClient()
    .call('serviceFindOrCreateAsync', name, 1)
    .then(function(service) {
      l.debug('findOrCreateAsyncService', service);
      return Promise.promisifyAll(service);
    });
};

function stopServiceImpl(name) {
  var l = clientOpts.logger || logger;
  return findService(name)
    .then(function(service) {
      l.debug('stopService', service);
      if (service) {
        return service.stopAsync({}, l).return(service.name);
      }
    });
};

function tryShutdown() {
  var l = clientOpts.logger || logger;
  return serviceList().then(function(procs) {
    l.debug('services.client.tryShutdown', procs);
    // If a proc doesn't have a port, it isn't running.
    var running = _.filter(procs, 'port');
    if (running && running.length) {
      return;
    }
    var strongPm = conf.get('pmHome');
    l.debug('services.client.tryShutdown removing', strongPm);
    return getPmClient()
      .then(function(client) {
        l.debug('services.client.tryShutdown shutting pm down!');
        return Promise.promisify(client.getApi().shutdown)();
      })
      .then(rimrafAsync.bind(null, strongPm))
      .catch(function(err) {
        l.debug('services.client.tryShutdown Error when cleaning up', strongPm, err);
        l.error(g.f('Encountered an unexpected error while shutting down. Please review logs for details.'));
      });
  });
}

