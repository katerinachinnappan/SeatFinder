/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-pm

'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var apicConfig = require('apiconnect-config');
var copyFile = Promise.promisify(require('fs-extra').copy);
var exec = Promise.promisify(require('child_process').exec);
var fs = require('fs');
var g = require('strong-globalize')();
var inquirer = require('inquirer');
var logger = require('apiconnect-cli-logger');
var makeDir = Promise.promisify(require('fs-extra').mkdirs);
var move = Promise.promisify(require('fs-extra').move);
var path = require('path');
var readDir = Promise.promisify(require('fs-extra').readdir);
var rimraf = Promise.promisify(require('rimraf'));
var url = require('url');

var apiGatewayDir = 'microgateway';

module.exports = action;

function prompt(options) {
  if (options.name) {
    return Promise.resolve({
      name: options.name,
      dir: path.resolve(options.name),
    });
  }

  var q = [ {
    type: 'input',
    name: 'name',
    message: 'What\'s the name of your application',
    default: path.basename(process.cwd()),
  }, {
    type: 'input',
    name: 'dir',
    message: 'Enter name of the directory to contain the project',
    default: function(answers) {
      return path.resolve(answers.name);
    },
    when: function(answers) {
      return answers.name !== path.basename(process.cwd());
    },
  } ];
  return new Promise(function(resolve) {
    inquirer.prompt(q, function(answers) {
      answers.dir = answers.dir || process.cwd();

      var endPoint = options.server;
      if (!options.server) {
        var conf = apicConfig.loadConfig();
        var catalog = conf.getOne('catalog');
        endPoint = catalog && catalog.host ? catalog.host : undefined;
      }
      answers.server = endPoint;

      resolve(answers);
    });
  });
}

function prepareTargetDir(targetDir) {
  return makeDir(targetDir).then(function() {
    return readDir(targetDir);
  }).then(function(files) {
    if (files.length) {
      throw new Error(g.f('Target directory not empty - %s', targetDir));
    }
  });
}

function serverCreate(targetDir, host) {
  var obj = {
    protocol: 'https',
    host: host,
    pathname: '/packages/microgateway',
  };
  logger.writeln(g.f('Fetching microgateway from %s', host));
  var cmdOpts = { cwd: targetDir };
  var applianceUrl = url.format(obj);
  var cmd = [ 'npm', 'install', applianceUrl, '--fetch-retries=0', '--strict-ssl=false', '--unsafe-perm' ].join(' ');

  return exec(cmd, cmdOpts).then(function(stdOut, stdErr) {
    // TODO -- do something with stdOut / err?
    logger.writeln(g.f('Successfully fetched files. Unpacking....'));
    return unpack(targetDir);
  }).catch(function(err) {
    logger.debug('Caught an error from serverCreate', err);
    // Cleanup working dir and fallback to npm path
    logger.writeln(g.f('Unable to create {{Micro Gateway}} from %s. Falling back to npm install.', host));
    return rimraf(targetDir)
      .then(prepareTargetDir.bind(null, targetDir))
      .then(exports.npmCreate.bind(null, targetDir));
  });
}
module.exports.serverCreate = serverCreate;  // exported for test mocking

function npmCreate(targetDir) {
  var sourceDir = path.dirname(require.resolve(apiGatewayDir));
  // Skip node_modules directory when copying over the 'microgateway' folder
  var filter = function(s) { return s.indexOf(apiGatewayDir + '/node_modules') === -1; };
  return copyFile(sourceDir, targetDir, filter).then(function() {
    logger.writeln(g.f('Installing {{Micro Gateway}} application'));
    return exec([ 'npm', 'install' ].join(' '), { cwd: targetDir });
  });
}
module.exports.npmCreate = npmCreate;  // exported for test mocking

function unpack(installRoot) {
  // rename the base node_modules dir so we don't collide when shuffling
  var modulesSource = path.join(installRoot, 'node_modules');
  var modulesWork = modulesSource + '_work';
  var mgw = path.join(modulesWork, 'microgateway');

  return move(modulesSource, modulesWork)
    .then(function() {
      return readDir(mgw);
    })
    .then(function(files) {
      return Promise.map(files, function(file) {
        var source = path.resolve(mgw, file);
        var target = path.resolve(installRoot, file);
        return move(source, target);
      });
    }).then(function() {
      return rimraf(modulesWork);
    });
}

function fixupPackage(targetDir, packageName) {
  return fs.readFileAsync(path.join(targetDir, 'package.json'), 'utf8').then(function(data) {
    data = JSON.parse(data);
    data = _.omitBy(data, function(v, k) {
      return k.indexOf('_') === 0;
    });
    data.name = packageName;
    return fs.writeFileAsync(path.join(targetDir, 'package.json'), JSON.stringify(data, null, '  '), 'utf8');
  });
}

function action(options) {
  options.name = typeof options.name === 'function' ? null : options.name;
  options.logger = options.logger || logger;
  return prompt(options).then(function(options) {
    logger.writeln(g.f('Creating {{Micro Gateway}} application in %s.', options.dir));
    return prepareTargetDir(options.dir).then(function() {
      if (options.server) {
        return module.exports.serverCreate(options.dir, options.server);
      } else {
        return module.exports.npmCreate(options.dir);
      }
    }).then(function() {
      return fixupPackage(options.dir, options.name);
    });
  }).then(function() {
    logger.writeln(g.f('{{Micro Gateway}} creation was successful.'));
  }).catch(function(err) {
    logger.debug(err);
    throw err;
  });
}

