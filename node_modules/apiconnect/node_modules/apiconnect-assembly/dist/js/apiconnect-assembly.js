/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
ace.define("ace/theme/atom_dark",["require","exports","module","ace/lib/dom"],function(e,t,n){t.isDark=!0,t.cssClass="ace-atom-dark",t.cssText=".ace-atom-dark .ace_gutter {background: #1a1a1a;color: #868989}.ace-atom-dark .ace_print-margin {width: 1px;background: #1a1a1a}.ace-atom-dark {background-color: #1d1f21;color: #A8FF60}.ace-atom-dark .ace_cursor {color: white}.ace-atom-dark .ace_marker-layer .ace_selection {background: #444444}.ace-atom-dark.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px #000000;border-radius: 2px}.ace-atom-dark .ace_marker-layer .ace_step {background: rgb(102, 82, 0)}.ace-atom-dark .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid #888888}.ace-atom-dark .ace_marker-layer .ace_highlight {border: 1px solid rgb(110, 119, 0);border-bottom: 0;box-shadow: inset 0 -1px rgb(110, 119, 0);margin: -1px 0 0 -1px;background: rgba(255, 235, 0, 0.1);}.ace-atom-dark .ace_marker-layer .ace_active-line {background: #2A2A2A}.ace-atom-dark .ace_gutter-active-line {background-color: #2A2A2A}.ace-atom-dark .ace_stack {background-color: rgb(66, 90, 44)}.ace-atom-dark .ace_marker-layer .ace_selected-word {border: 1px solid #888888}.ace-atom-dark .ace_invisible {color: #343434}.ace-atom-dark .ace_keyword,.ace-atom-dark .ace_meta,.ace-atom-dark .ace_storage,.ace-atom-dark .ace_storage.ace_type,.ace-atom-dark .ace_support.ace_type {color: #96CBFE}.ace-atom-dark .ace_keyword.ace_operator {color: #70C0B1}.ace-atom-dark .ace_constant.ace_character,.ace-atom-dark .ace_constant.ace_language,.ace-atom-dark .ace_constant.ace_numeric,.ace-atom-dark .ace_keyword.ace_other.ace_unit,.ace-atom-dark .ace_support.ace_constant,.ace-atom-dark .ace_variable.ace_parameter {color: #fe73fd}.ace-atom-dark .ace_constant.ace_other {color: #EEEEEE}.ace-atom-dark .ace_invalid {color: #CED2CF;background-color: #DF5F5F}.ace-atom-dark .ace_invalid.ace_deprecated {color: #CED2CF;background-color: #B798BF}.ace-atom-dark .ace_fold {background-color: #7AA6DA;border-color: #DEDEDE}.ace-atom-dark .ace_entity.ace_name.ace_function,.ace-atom-dark .ace_support.ace_function,.ace-atom-dark .ace_variable {color: #7AA6DA}.ace-atom-dark .ace_support.ace_class,.ace-atom-dark .ace_support.ace_type {color: #E7C547}.ace-atom-dark .ace_heading,.ace-atom-dark .ace_markup.ace_heading,.ace-atom-dark .ace_string {color: #B9CA4A}.ace-atom-dark .ace_entity.ace_name.ace_tag,.ace-atom-dark .ace_entity.ace_other.ace_attribute-name,.ace-atom-dark .ace_meta.ace_tag,.ace-atom-dark .ace_string.ace_regexp,.ace-atom-dark .ace_variable {color: #96CBFE}.ace-atom-dark .ace_comment {color: #7a7a7a}.ace-atom-dark .ace_c9searchresults.ace_keyword {color: #C2C280;}.ace-atom-dark .ace_indent-guide {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYFBXV/8PAAJoAXX4kT2EAAAAAElFTkSuQmCC) right repeat-y}";var r=e("../lib/dom");r.importCssString(t.cssText,t.cssClass)})


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly', [
  'ang-drag-drop',
  'hc.marked',
  'mohsen1.schema-form',
  'apiconnect-assembly.mapper-schema',
  'apiconnect-assembly.recursion-helper',
  'ngMaterial',
  'ngResource',
  'ngSanitize',
  'ngResize',
  'pascalprecht.translate',
  'apiconnect-assembly-localization',
  'nsPopover',
  'ui.ace'
]).controller('AssemblerController', [
  '$rootScope',
  '$scope',
  '$injector',
  'translateFilter',
  '$timeout',
  '$mdSidenav',
  'policyService',
  'AssemblerTracking',
  'triggerService',
  'canvasAnimationService',
  'assemblyModel',
  function($rootScope, $scope, $injector, translateFilter, $timeout, $mdSidenav, policyService,
    AssemblerTracking, triggerService, canvasAnimationService, assemblyModel) {

    if (this.assemblerOptions) {
      // parse the options
      $scope.config = JSON.parse(this.assemblerOptions);
      if (!$scope.config.property) $scope.config.property = "x-ibm-configuration";
      $scope.swaggerDocument = $scope.$parent[$scope.config.source];
      if ($scope.config.references) $scope.references = $scope.$parent[$scope.config.references];
      $scope.swaggerSchema = $scope.$parent[$scope.config.schema];
      $scope.externalAssemblies = $scope.$parent[$scope.config.externalAssemblies];
      var factoryInstance = $injector.get($scope.config.policies);
      $scope.policies = factoryInstance.getPolicies();
      $scope.getPolicyPartial = factoryInstance.getPolicyPartial;
    }

    var rootScopeListeners = [];
    var animationDelay = 150;

    $scope.index = -1;
    $scope.isAnimating = false;

    // Flow ID from APPC persistence
    $scope.gotFlowID = false;

    $scope.aceLoaded = function(editor) {
      $scope.editor = editor; // save editor reference
      editor.setReadOnly(true);
      editor.$blockScrolling = 'Infinity'; // disable Ace warning
    };

    $scope.isFlowSlim = function() {
      return $scope.config.slimFlowEditor;
    };

    // so NodeController can unset selectedNode
    $scope.unsetSelectedNode = function() {
      $scope.applyToEachNode($scope.nodes, function(node) {
        node.$$isSelected = false;
      });
      $scope.selectedNode = null;
    };

    var toggleFunction = function(isSlimFlow) {
      $scope.config.slimFlowEditor = isSlimFlow;
      if (isSlimFlow) {
        $scope.infoPanelBottom = true;
        $scope.scaleFactor = 1;
        $scope.nodeFilter = '';
        $scope.infoPanelOpen = true;

        // Always select a node
        $scope.selectedNode = $scope.selectedNode ? $scope.selectedNode : $scope.trigger || $scope.request;
        $scope.selectedNode.$$isSelected = true;

        $mdSidenav('assembly-info').open();
        $timeout(function() {
          canvasAnimationService.reset();
          $scope.animateCanvasSlide($scope);
        }, 400);
      } else {
        // Default to RHS panel in full mode
        $scope.infoPanelBottom = false;
        $scope.horizontalTranslation = 0;
      }
    };

    $scope.isAppConnect = function() {
      return $scope.config.isAppConnect;
    };

    $scope.allowNewNode = function() {
      return $scope.nodes.length < $scope.config.maxNodes;
    };

    if ($scope.helpEnabled) {
      $scope.showHelp({
        id: "apim_help_api_editor_assemble",
        template: 'apim/help/partials/help-api-editor-assemble.html'
      });
    }

    if (localStorage !== undefined) {
      $scope.showCatches = localStorage.getItem("apim-assembly-show-catches") === "true";
    }

    $scope.$watch('showCatches', function() {
      if (localStorage !== undefined) {
        localStorage.setItem("apim-assembly-show-catches", $scope.showCatches);
      }
    });

    $scope.jumpToCode = function(policyName, instance) {
      $scope.$emit('jump-to-policy', policyName, instance);
    };

    $scope.subflows = [];

    function addExternalAssembly(assemblyName) {
      var name = assemblyName.split("/").pop();
      var templateObj = {
        info: {
          description: assemblyName,
          name: name,
          title: name,
          display: {
            color: '#4B68FA',
            icon: 'open_in_browser'
          },
          categories: [translateFilter("api_policy_assemblies")]
        },
        type: 'subflow',
        // assembly: $scope.externalAssemblies[assemblyName],
        assembly: {
          $ref: assemblyName
        }
      };
      $scope.subflows.push(templateObj);
      $scope.policiesByType[name] = templateObj;
    };

    var snippedNodes = [];

    $scope.toggleSnipMode = function() {
      $scope.snipping = !$scope.snipping;
      if (!$scope.snipping) {
        // clear any snipped flags
        snippedNodes.forEach(function(node) {
          delete node.$$snipped;
        });
      }
      snippedNodes = [];
      $scope.snippedAssembly = {
        execute: [],
        catch: []
      };
    };
    $scope.snippedAssembly = {
      execute: [],
      catch: []
    };

    $scope.highlightSnippedNode = function(event, node) {
      if (!$scope.snipping) return;
      node.$$snipped = !node.$$snipped;
      if (!node.$$snipped) {
        snippedNodes = snippedNodes.filter(function(thisNode) {
          return (thisNode !== node);
        });
      } else {
        snippedNodes.push(node);
      }
      var execute = [];
      snippedNodes.forEach(function(node) {
        var thisNode = {};
        thisNode[node.$$type] = node;
        execute.push(thisNode);
      });
      $scope.snippedAssembly.execute = execute;
    };
    $scope.$on('node-selected', $scope.highlightSnippedNode);

    $scope.snippedAssemblyEmpty = function() {
      if ($scope.snippedAssembly.execute.length === 0 && $scope.snippedAssembly.catch.length === 0) {
        return translateFilter("assembly_nothing_to_snip");
      }
    };

    $scope.replaceWithReference = function($event, referenceData) {
      if (snippedNodes.length === 0) return;

      addExternalAssembly(referenceData.reference);

      // drop in a new external assembly at the location of the first
      // selected node...
      var targetNode = snippedNodes[0];

      if (targetNode.$$container === undefined || targetNode.$$containerIndex === undefined) {
        return;
      }
      var newNode = {
        assembly: {
          "$ref": referenceData.reference
        }
      };

      newNode.assembly.title = referenceData.reference.split("/").pop();

      // insert newNode into node.$$container at node.$$containerIndex + 1
      targetNode.$$container.splice(targetNode.$$containerIndex + 1, 0, newNode);

      // remove the old nodes
      snippedNodes.forEach(function(node) {
        $scope.deleteNode(null, node);
      });

      $scope.snippedAssembly = {
        execute: [],
        catch: []
      };
      $scope.snipping = false;
    };
    $scope.$on('reference_created', $scope.replaceWithReference);

    $scope.setTestMode = function(testMode, debugMode, clearFilter) {
      $scope.testMode = testMode;
      $scope.debugMode = debugMode;
      if (clearFilter) {
        delete $scope.operationFilter;
        $scope.showOperationFilter = false;
      }
    };

    // TODO - temporarily make work-in-progress category collapsed by default
    $scope.hideCategory = {
      'work-in-progress': true
    };

    $scope.renderingAssembly = true;
    $scope.labelPlacement = 'right';
    $scope.model = assemblyModel.flow;
    $scope.nodes = $scope.model.nodes;

    $scope.isDraggable = function() {
      // disable drag and drop when an operation filter is set
      return (!$scope.operationFilter);
    };

    function processSwaggerDocument() {
      if (!$scope.swaggerDocument) {
        return;
      }

      if ($scope.infoPanelBottom === undefined) {
        $scope.infoPanelBottom = ($scope.config && $scope.config.flyout === "bottom");
      }


      var ibmConfig = $scope.swaggerDocument[$scope.config.property];
      var unwatchFunc;
      if (ibmConfig && ibmConfig.assembly) {
        $scope.nodes = ibmConfig.assembly.execute;
        unwatchFunc = $scope.$watch('showCatches', function() {
          if ($scope.showCatches) {
            if (!ibmConfig.assembly.catch) {
              ibmConfig.assembly.catch = [];
            }
            $scope.node = {
              catch: ibmConfig.assembly.catch,
              $$type: "catch"
            };
            unwatchFunc();
          }
        });
      } else if ($scope.swaggerDocument && $scope.swaggerDocument.assembly) {
        $scope.nodes = $scope.swaggerDocument.execute;
        unwatchFunc = $scope.$watch('showCatches', function() {
          if ($scope.showCatches) {
            if (!$scope.swaggerDocument.catch) {
              $scope.swaggerDocument.catch = [];
            }
            $scope.node = {
              catch: $scope.swaggerDocument.catch,
              $$type: "catch"
            };
            unwatchFunc();
          }
        });
      } else {
        $scope.noAssembly = true;
      }

      // pick out any templates
      if ($scope.swaggerDocument[$scope.config.property] && $scope.swaggerDocument[$scope.config.property].targets) {
        var templates = [];
        Object.keys($scope.swaggerDocument[$scope.config.property].targets).forEach(function(wsdlName) {
          var wsdl = $scope.swaggerDocument[$scope.config.property].targets[wsdlName];
          if (!wsdl.paths) return;
          var targetUrl = "";
          if (wsdl['x-ibm-configuration'] && wsdl['x-ibm-configuration'].assembly && wsdl['x-ibm-configuration'].assembly.execute) {
            var proxy = wsdl['x-ibm-configuration'].assembly.execute.filter(function(policy) {
              return policy.proxy !== undefined;
            });
            if (proxy.length > 0) targetUrl = proxy[0].proxy['target-url'];
          }
          // if (!targetUrl) return;
          Object.keys(wsdl.paths).forEach(function(pathName) {
            var operation = wsdl.paths[pathName].post;
            if (!operation || !operation.parameters || !operation.responses) return;
            var inputSchema = null;
            var bodyParam = operation.parameters.filter(function(param) {
              return param.in === "body";
            });
            if (bodyParam.length > 0) inputSchema = bodyParam[0].schema;
            var outputSchema = null;
            if (operation.responses.default) outputSchema = operation.responses.default.schema;
            if (bodyParam.length > 0) inputSchema = bodyParam[0].schema;
            if (!inputSchema || !outputSchema) return;
            var soapVersion = "1.1";
            if (wsdl['x-ibm-configuration'] && wsdl['x-ibm-configuration']['wsdl-definition'] && wsdl['x-ibm-configuration']['wsdl-definition']['soap-version']) {
              soapVersion = wsdl['x-ibm-configuration']['wsdl-definition']['soap-version'];
            }
            var soapAction = operation['x-ibm-soap']['soap-action'];
            var contentType = "text/xml";
            if (soapVersion === "1.2") {
              contentType = 'application/soap+xml; charset=UTF-8; action="' + soapAction + '"';
            }
            var templateObj = {
              info: {
                description: operation.description,
                name: operation.operationId,
                display: {
                  color: '#F5A623',
                  icon: 'open_in_browser'
                },
                categories: ["Web Service Operation"]
              },
              type: 'template',
              assembly: [{
                "map": {
                  "title": operation.operationId + ": input",
                  "inputs": {},
                  "outputs": {
                    "body": {
                      "schema": inputSchema,
                      "variable": "message.body",
                      "content": "application/xml"
                    },
                    "content-type": {
                      "schema": {
                        "type": "string"
                      },
                      "variable": "message.headers.content-type"
                    }
                  },
                  "actions": [{
                    "set": "content-type",
                    "default": contentType
                  }]
                }
              }, {
                "invoke": {
                  "title": operation.operationId + ": invoke",
                  "target-url": targetUrl,
                  "timeout": 60,
                  "verb": "POST",
                  "cache-response": "protocol",
                  "cache-ttl": 900,
                  "output": operation.operationId + "Out"
                }
              }, {
                "map": {
                  "title": operation.operationId + ": output",
                  "inputs": {
                    "input": {
                      "schema": outputSchema,
                      "variable": operation.operationId + "Out.body",
                      "content": "application/xml"
                    }
                  },
                  "outputs": {},
                  "actions": []
                }
              }]
            };
            if (soapVersion === "1.1") {
              templateObj.assembly[0].map.outputs['SOAPAction'] = {
                "schema": {
                  "type": "string"
                },
                "variable": "message.headers.SOAPAction"
              };
              templateObj.assembly[0].map.actions.push({
                "set": "SOAPAction",
                "default": soapAction
              });
            }
            templates.push(templateObj);
          });
        });
        $scope.templates = templates;
      }

      // pick out any external assemblies
      if ($scope.externalAssemblies) {
        $scope.allowReferences = true;
        Object.keys($scope.externalAssemblies).forEach(function(assemblyName) {
          addExternalAssembly(assemblyName);
        });
      }

      // set up default for showing gateway filter
      $scope.showPolicyFilter = !$scope.swaggerDocument[$scope.config.property] || !$scope.swaggerDocument[$scope.config.property].gateway;

      // if we're in the context of a swagger document, pull out all the operations for later reference
      if ($scope.swaggerDocument.swagger) {
        var operations = [];
        var legacyOperations = [];
        var operationMap = {};
        if ($scope.swaggerDocument.paths) {
          Object.keys($scope.swaggerDocument.paths).forEach(function(path) {
            Object.keys($scope.swaggerDocument.paths[path]).forEach(function(verb) {
              if (verb.indexOf('$$') === 0) {
                return;
              }
              if (verb === "parameters") {
                return;
              }
              var fullPath = path;
              if ($scope.swaggerDocument.basePath && $scope.swaggerDocument.basePath !== "") {
                fullPath = $scope.swaggerDocument.basePath + fullPath;
              }
              var item;
              if ($scope.swaggerDocument.paths[path][verb].operationId) {
                item = {
                  operationId: $scope.swaggerDocument.paths[path][verb].operationId,
                  verb: verb,
                  path: path,
                  $$expressionString: "api.operation.id==='" + $scope.swaggerDocument.paths[path][verb].operationId + "'"
                };
                operations.push(item);
                legacyOperations.push($scope.swaggerDocument.paths[path][verb].operationId);
                operationMap[$scope.swaggerDocument.paths[path][verb].operationId] = {
                  verb: verb,
                  path: path
                };
                // operationMap[$scope.swaggerDocument.paths[path][verb].operationId] = item;
                operationMap[verb + ":" + path] = $scope.swaggerDocument.paths[path][verb].operationId;
              } else {
                item = {
                  verb: verb,
                  path: path,
                  $$expressionString: "request.verb==='" + verb.toUpperCase() + "'&&api.operation.path==='" + path + "'"
                };
                operations.push(item);
                legacyOperations.push(item);
              }
            });
          });
        }
        $scope.swaggerOperations = operations;
        $scope.swaggerLegacyOperations = legacyOperations;
        $scope.operationMap = operationMap;
      }
    }

    $scope.$watch('swaggerDocument', function() {
      if (!$scope.swaggerDocument) {
        return;
      }
      if ($scope.swaggerDocument.$promise && $scope.swaggerDocument.$resolved === false) {
        $scope.swaggerDocument.$promise.then(processSwaggerDocument);
      } else {
        processSwaggerDocument();
      }
    });

    $scope.createAssembly = function() {
      if (!$scope.swaggerDocument[$scope.config.property]) {
        $scope.swaggerDocument[$scope.config.property] = {};
      }
      if (!$scope.swaggerDocument[$scope.config.property].assembly) {
        $scope.swaggerDocument[$scope.config.property].assembly = {
          execute: [],
          catch: []
        };
      }
      $scope.noAssembly = false;
      processSwaggerDocument();
    };

    $scope.policyDropped = function($data, node, $index, $secondIndex, clone) {
      // node may be a policy template, or a policy instance...
      // if it's a policy type, then we're dragging from the palette
      // if it's a policy instance, we're dragging from the canvas

      if ($data.info) {
        // dropped a policy - send a tracking event
        var policyName = $data.info.name;
        var categories = ($data.info.categories) ? $data.info.categories.join(', ') : "";
        AssemblerTracking.track('assembly', 'policyDropped', {
          policyName: policyName,
          categories: categories
        });
      }

      var nodeToInsert, nodesToInsert;
      if ($data && $data.hashKey) {
        // we have a policy instance

        // these events are firing twice... sigh
        //$scope.dropDoubleFiring = !$scope.dropDoubleFiring;
        //if ($scope.dropDoubleFiring) return;

        nodeToInsert = {};
        nodeToInsert[$data.type] = $data.node;
        // TODO remove this code once https://github.ibm.com/apimesh/apiconnect-assembly/issues/97 is fixed
        nodeToInsert[$data.type].$$type = $data.type;
        if ($data.hashKey) { // dropping an existing node on canvas
          nodeToInsert[$data.type].$$touched = ($scope.selectedNode) ? $scope.selectedNode.$$touched : false;
        }
      } else {
        // no event double firing in the new policy case
        //$scope.dropDoubleFiring = false;

        if ($data.type === "template") {
          // we have a template
          nodesToInsert = $data.assembly;
        } else if ($data.type === "subflow") {
          // we have a subflow
          nodeToInsert = {
            'assembly': $data.assembly
          };
          nodeToInsert.assembly.title = $data.info.name;
        } else {
          // we have a policy template
          nodeToInsert = policyService.createPolicyInstance($data, $scope.config.versioning);
        }
      }

      var i;


      // insert the policy of type $data in the collection determined by node, at $index in the collection
      // if $secondIndex is provided, we're inserting in the nth element of a collection, which itself is an array
      // an index of -1 indicates that the new policy be inserted at the beginning
      // a node of null indicates we're inserting into the top level flow
      if (clone) {
        // clone the given node
        $scope.nodes.splice($index + 1, 0, nodeToInsert);
      } else if (!node) {
        if (nodesToInsert) {
          for (i = nodesToInsert.length - 1; i >= 0; i--) {
            $scope.nodes.splice($index + 1, 0, nodesToInsert[i]);
          }
        } else {
          $scope.nodes.splice($index + 1, 0, nodeToInsert);
        }
      } else {
        // we're inserting into a clause or catch flow
        if (node.catch || node.case) {
          if ($index === -1) {
            // we're dropping an entirely new case here
            if (node.case) {
              if (node.$$type === "operation-switch") {
                node.case.push({
                  operations: [],
                  execute: nodeToInsert ? [nodeToInsert] : nodesToInsert
                });
              } else {
                // we're dropping into a switch... careful - there may be an otherwise case
                var spliceIndex = node.case.length;
                if (node.case[spliceIndex - 1].otherwise) spliceIndex--;
                node.case.splice(spliceIndex, 0, {
                  condition: '',
                  execute: nodeToInsert ? [nodeToInsert] : nodesToInsert
                });
              }
            } else if (node.catch) {
              node.catch.push({
                errors: [],
                execute: nodeToInsert ? [nodeToInsert] : nodesToInsert
              });
            }
          } else if ($index === -2) {
            // dropping into otherwise
            node.otherwise.splice($secondIndex + 1, 0, nodeToInsert);
          } else {
            var clause = (node.catch) ? node.catch[$index] : node.case[$index];
            if (clause.execute) {
              if (nodesToInsert) {
                for (i = nodesToInsert.length - 1; i >= 0; i--) {
                  clause.execute.splice($secondIndex + 1, 0, nodesToInsert[i]);
                }
              } else {
                clause.execute.splice($secondIndex + 1, 0, nodeToInsert);
              }
            } else if (clause.otherwise) {
              if (nodesToInsert) {
                for (i = nodesToInsert.length - 1; i >= 0; i--) {
                  clause.otherwise.splice($secondIndex + 1, 0, nodesToInsert[i]);
                }
              } else {
                clause.otherwise.splice($secondIndex + 1, 0, nodeToInsert);
              }
            } else if (clause.default) {
              if (nodesToInsert) {
                for (i = nodesToInsert.length - 1; i >= 0; i--) {
                  clause.default.splice($secondIndex + 1, 0, nodesToInsert[i]);
                }
              } else {
                clause.default.splice($secondIndex + 1, 0, nodeToInsert);
              }
            }
          }
        }
        if (node.condition) {
          // no need for the first index
          if (nodesToInsert) {
            for (i = nodesToInsert.length - 1; i >= 0; i--) {
              node.execute.splice($secondIndex + 1, 0, nodesToInsert[i]);
            }
          } else {
            node.execute.splice($secondIndex + 1, 0, nodeToInsert);
          }
        }
      }
      if ($data && $data.hashKey) {
        // remove the policy afterwards to avoid confusing the insert index
        $scope.removeObject($scope.nodes, $data.hashKey);
        if ($scope.node) {
          $scope.removeObject($scope.node.catch, $data.hashKey);
        }
      }

      // only make the inserted node as selected on node creation.
      // do not select existing nodes.
      // get node type from $data.info.name for a inserting node
      // node type will be stored in $data.type for an existing node
      if (nodeToInsert && $data.info && $data.info.name) {
        $scope.nodeSelected(null, nodeToInsert[$data.info.name]);
      } else if (nodeToInsert && $data.hashKey && $scope.selectedNode && ($data.hashKey === $scope.selectedNode.$$hashKey) && $scope.infoPanelOpen) {
        // dragging a node that currently is being editing
        $scope.nodeSelected(null, nodeToInsert[$data.type]);
      } else {
        $scope.animateCanvasSlide($scope);
      }
    };

    $scope.applyToEachNode = function(nodes, callback) {
      // TODO currently we have 'execute' inside 'case' for 'switch' nodes
      // need to change this function if above structure changes.
      nodes.forEach(function(nextNode) {
        var key = Object.keys(nextNode)[0];
        if (nextNode[key].$$type) {
          // apply the callback function to the node
          callback(nextNode[key]);
        }
        // if we're in an if node
        if (nextNode[key].execute) {
          $scope.applyToEachNode(nextNode[key].execute, callback);
        }
        // if we're in a switch node
        if (nextNode[key].case) {
          nextNode[key].case.forEach(function(caseObject) {
            $scope.applyToEachNode(caseObject.execute || caseObject.otherwise, callback);
          });
        }
      });
    };

    $scope.prevNode = {};

    $scope.ghostSelected = function($event, node, index, secondIndex) {
      if (!$scope.isAppConnect() || !$scope.allowNewNode()) {
        return;
      }
      $scope.index = index;
      $scope.parentNode = node;
      $scope.secondIndex = secondIndex;

      $scope.nodeSelected($event, 'NewAction');
    };

    $scope.nodeSelected = function($event, node) {
      if ($event) {
        $event.stopPropagation();
      }

      // Don't do anything if we've clicked the selectedNode
      if (node === $scope.selectedNode && node.$$isSelected) {
        return;
      }

      if ($scope.isAppConnect() && node.$$type === 'switch') {
        node.$$minimized = false;
      }

      // Remove the isSelected class from any ghostPolicy
      var selectedDropzone = angular.element(document.querySelector('.dropzoneGroupSelected'));
      if (selectedDropzone.length) {
        selectedDropzone[0].classList.remove('dropzoneGroupSelected');
        var selectedNewAction = selectedDropzone[0].getElementsByClassName('ghostPolicy')[0];
        selectedNewAction.classList.remove('isSelected');
      }

      if ($scope.debugMode) {
        $scope.$broadcast('node-selected', node);
      } else if ($scope.snipping) {
        $scope.$broadcast('node-selected', node);
      } else {
        var target = $event ? $event.currentTarget : undefined;
        if (node === 'input' || node === 'output') {
          // no behavior defined in assembly mode for this...
          return;
        }
        if (node === 'NewAction') {
          if (!$scope.policies || $scope.policies.length < 0) {
            return;
          }
          var newActionPolicy = $scope.policies.filter(function(policy) {
            return policy.info.name === 'NewAction';
          });
          if (newActionPolicy && (newActionPolicy.length > 0)) {
            newActionPolicy = newActionPolicy[0];
            node = policyService.createPolicyInstance(newActionPolicy).NewAction;
          }

          if (target) {
            target.classList.add('isSelected');
            target.parentElement.classList.add('dropzoneGroupSelected');
          } else {
            var dropzoneGroup = angular.element(document.getElementsByClassName('dropzoneGroup'))[$scope.index + 1];
            if (dropzoneGroup) {
              dropzoneGroup.classList.add('dropzoneGroupSelected');
              var newAction = dropzoneGroup.getElementsByClassName('ghostPolicy')[0];
              newAction.classList.add('isSelected');
            }
          }
        }

        if ($scope.selectedNode) {
          $scope.prevNode = $scope.selectedNode;
          if ($scope.prevNode === $scope.trigger && !$scope.prevNode.selectedApplication.name) {
            // Don't set touched on an empty trigger...
          } else {
            $scope.prevNode.$$touched = true;
          }
        }

        // Unselect any trigger/request/response/nodes
        if ($scope.trigger) {
          $scope.trigger.$$isSelected = false;
        }
        if ($scope.request) {
          $scope.request.$$isSelected = false;
        }
        if ($scope.model.response) {
          $scope.model.response.$$isSelected = false;
        }
        $scope.applyToEachNode($scope.nodes, function(node) {
          node.$$isSelected = false;
        });

        // make sure we enter the info panel clean by allowing
        // time for a digest cycle before setting the new node
        delete $scope.selectedNode;
        $timeout(function() {
          $scope.selectedNode = node;
          node.$$isSelected = true;
        }, 0);
        $timeout(function() {
          $scope.animateCanvasSlide($scope);
        }, 200);

        $scope.infoPanelOpen = true;
        $mdSidenav('assembly-info').open();
      }
    };

    $scope.removeObject = function(theObject, hashKey) {
      if (!theObject) {
        return null;
      }
      var result = null;
      if (theObject.$$hashKey === hashKey) {
        return theObject;
      }
      if (theObject instanceof Array) {
        for (var i = 0; i < theObject.length; i++) {
          result = $scope.removeObject(theObject[i], hashKey);
          if (result) {
            theObject.splice(i, 1);
            break;
          }
        }
      } else {
        for (var prop in theObject) {
          if (prop === "$$container") continue;
          if (prop === "$$parent") continue;
          if (prop === '$$hashKey') {
            if (theObject[prop] === hashKey) {
              return theObject;
            }
          }
          if (theObject[prop] instanceof Object || theObject[prop] instanceof Array) {
            result = $scope.removeObject(theObject[prop], hashKey);
            if (result) {
              // throw the object back up one level - it'll then get spliced from the array
              return result;
            }
          }
        }
      }
      return null;
    };

    $scope.isClauseNode = function(node) {
      // if the node has an execute property that is an array, safe bet this is a clause node
      return (angular.isArray(node.execute));
    };

    var callbackDeleteNode = function($event, node) {
      // Get the current index of the node before it is deleted
      var nodeIndex = $scope.nodes.map(function(pNode) {
        var key = Object.keys(pNode)[0];
        return pNode[key];
      }).indexOf(node);

      if ($event && $event.stopPropagation) $event.stopPropagation();
      $scope.removeObject($scope.nodes, node.$$hashKey);
      if ($scope.node) {
        $scope.removeObject($scope.node.catch, node.$$hashKey);
      }
      // close info panel if selectedNode is not on canvas
      // NB $scope.trigger is used for App Connect only but the logic below still work in general since $scope.trigger will be undefined.
      if ($scope.selectedNode !== $scope.trigger && $scope.selectedNode !== $scope.request && $scope.selectedNode !== $scope.response) { // trigger/request/response are always on canvas

        if ($scope.selectedNode) {
          $scope.selectedNode.$$onCanvas = false;
        }

        // check selectedNode is still on Canvas
        $scope.applyToEachNode($scope.nodes, function(node) {
          node.$$onCanvas = true;
        });

        if ($scope.selectedNode && $scope.selectedNode.$$type !== 'NewAction') {

          if (!$scope.selectedNode.$$onCanvas) {
            // SelectedNode has been deleted so clear it
            delete $scope.selectedNode;

            if ($scope.isAppConnect() && $scope.isFlowSlim()) {
              if ($scope.nodes.length) {
                // either select the node immediately to the right, or if we've deleted the last node
                // there is no node to the right, so select the previous node.
                var nearestNodeIndex = nodeIndex < $scope.nodes.length ? nodeIndex : $scope.nodes.length - 1;
                var key = Object.keys($scope.nodes[nearestNodeIndex])[0];
                $scope.nodeSelected(null, $scope.nodes[nearestNodeIndex][key]);
              } else {
                // there are no nodes to select, so select the first dropzone
                $scope.ghostSelected(null, null, -1);
              }
            } else {
              $scope.closeInfo();
            }
          } else {
            $scope.animateCanvasSlide($scope);
          }

          // Special cases for NewAction
        } else if ($scope.selectedNode && $scope.selectedNode.$$type === 'NewAction') {

          // Nested newAction should close info if parent deleted
          if ($scope.isAppConnect() && !$scope.isFlowSlim() && $scope.parentNode && !$scope.parentNode.$$onCanvas) {
            $scope.closeInfo();
            // Deleting node attached to newAction dropzone
          } else if ($scope.index === nodeIndex) {
            $scope.index = $scope.index - 1;
            $scope.nodeSelected(null, 'NewAction');
          } else {
            // Deleting node before newAction
            if ($scope.index > nodeIndex) {
              $scope.index = $scope.index - 1;
            }
            $scope.animateCanvasSlide($scope);
          }
        }
      } else {
        $scope.animateCanvasSlide($scope);
      }
    };

    $scope.deleteNode = function($event, node) {
      // Display dialog for multiple actions in IF node
      if ($scope.isAppConnect() && assemblyModel.countInnerActions(node) > 0) {
        var numberOfActions = assemblyModel.countInnerActions(node);
        $rootScope.$emit('confirmationDialog', callbackDeleteNode, $event, node, numberOfActions);
      } else {
        //Else just delete the node
        callbackDeleteNode($event, node);
      }
    };

    $scope.deleteTrigger = function() {
      triggerService.deleteTrigger($scope.trigger);
      $scope.selectedNode = {};
      $scope.nodeSelected(null, $scope.trigger);
    };

    $scope.keyPressed = function($event, node) {
      if ($event.keyCode === 8) {
        $event.stopPropagation();
        $event.preventDefault();

        // these events are firing twice... but only for nodes... sigh
        if ($scope.isClauseNode(node)) {
          $scope.deleteDoubleFiring = false;
        } else {
          $scope.deleteDoubleFiring = !$scope.deleteDoubleFiring;
        }
        if ($scope.deleteDoubleFiring) {
          return;
        }

        $scope.deleteNode($event, node);
      }
    };

    $scope.setupTrigger = function() {
      if (!$scope.trigger) {
        if (!$scope.policies || $scope.policies.length < 0) {
          return;
        }
        var policy = $scope.policies.filter(function(policy) {
          return policy.info.name === 'Trigger';
        });
        if (policy && (policy.length > 0)) {
          policy = policy[0];
          $scope.trigger = policyService.createPolicyInstance(policy, $scope.config.versioning).Trigger;
        }
      }
    };

    $scope.setupRequest = function() {
      if (!$scope.request) {
        if (!$scope.policies || $scope.policies.length < 0) {
          return;
        }
        var policy = $scope.policies.filter(function(policy) {
          return policy.info.name === 'Request';
        });
        if (policy && (policy.length > 0)) {
          policy = policy[0];
          $scope.model.request = policyService.createPolicyInstance(policy, $scope.config.versioning).Request;
          $scope.model.request.type = 'request';
        }
      }
      $scope.request = $scope.model.request;
    };

    $scope.setupResponse = function() {
      if (!$scope.model.response) {
        if (!$scope.policies || $scope.policies.length < 0) {
          return;
        }
        var policy = $scope.policies.filter(function(policy) {
          return policy.info.name === 'Response';
        });
        if (policy && (policy.length > 0)) {
          policy = policy[0];
          $scope.model.response = policyService.createPolicyInstance(policy, $scope.config.versioning).Response;
          $scope.model.response.responses = [];
          $scope.model.response.type = 'response';
        }
      }
      $scope.response = $scope.model.response;
    };

    $scope.onTriggerMouseOver = function(trigger, val) {
      trigger.$$isHover = val;
    };

    $timeout(function() {
      //the code which needs to run after dom rendering
      $scope.renderingAssembly = false;
      $scope.$apply();

      if ($scope.isFlowSlim()) {
        canvasAnimationService.reset();
      }
    });

    /* Watch for Any Node Changes */
    // Deep Node Watch changes - for filter
    $scope.$watch('nodes', function() {
      if ($scope.nodeFilter) {
        $scope.nodeFiltered();
      }
    }, true);

    $scope.selectTriggerApplication = function(triggerApplicationId) {
      if (!triggerApplicationId) {
        triggerApplicationId = "salesforce";
      }
      triggerService.setTriggerApplication($scope.trigger, triggerApplicationId);
    };

    rootScopeListeners.push($rootScope.$on('nodeValidated', function(event, validation) {
      var theNode = $scope.selectedNode || $scope.prevNode;

      if (!theNode) {
        return;
      }

      var errors = validation.errors;
      if (errors && !angular.equals(theNode.$$errors, errors)) {
        theNode.$$errors = errors;
      }

      $rootScope.$emit('assemblyChanged');
    }));

    rootScopeListeners.push($rootScope.$on('loadNewAssembly', function(event, assembly) {
      if ($scope.isAppConnect()) {
        $scope.gotFlowID = true;
      }

      if (assembly.nodes) {
        $scope.model.nodes = assembly.nodes;
        $scope.nodes = $scope.model.nodes;
      }

      $scope.applyToEachNode($scope.nodes, function(node) {
        node.$$touched = true;
      });

      if (assembly.trigger) {
        // copy the latest validation result to the trigger object generated from YAML
        $scope.model.trigger = assembly.trigger;
        $scope.trigger = $scope.model.trigger;
        if ($scope.trigger.selectedApplication && $scope.trigger.selectedApplication.name) {
          $scope.trigger.$$touched = true;
        }
        $scope.nodeSelected(null, $scope.trigger);
      } else if ($scope.config.assemblyType === 'api') {
        $scope.nodeSelected(null, $scope.request);
      }

      $rootScope.assemblyDirty = false;

      $scope.$watchCollection('nodes', function(newValue, oldValue) {
        if (!angular.equals(newValue, oldValue)) {
          $rootScope.assemblyDirty = true;
          $rootScope.$emit('assemblyChanged');
        }
      });

      $scope.$watch('trigger', function(newValue, oldValue) {
        if (!angular.equals(newValue, oldValue)) {
          $rootScope.assemblyDirty = true;
          $rootScope.$emit('assemblyChanged');
        }
      }, true);

      rootScopeListeners.push($rootScope.$on('toggleFlowMode', function(event, isSlimFlow) {
        toggleFunction(isSlimFlow);
      }));
    }));

    $scope.animateCanvasSlide = function(scope) {
      if (!scope.isAnimating && $scope.isFlowSlim()) {
        scope.isAnimating = true;
        $timeout(function() {
          scope.horizontalTranslation = canvasAnimationService.animateCanvasSlide();
          scope.isAnimating = false;
          $scope.$apply();
        }, animationDelay, false);
      }
    };

    rootScopeListeners.push($rootScope.$on('onIfNodeSelected', function() {
      if (!$scope.policies || $scope.policies.length < 0) {
        return;
      }
      var policy = $scope.policies.filter(function(policy) {
        return policy.info.name === 'switch';
      });

      if (policy && (policy.length > 0)) {
        policy = policy[0];
        $scope.policyDropped(policy, $scope.parentNode, $scope.index, $scope.secondIndex);
      }
    }));

    rootScopeListeners.push($rootScope.$on('onActionCompletePhase', function($event, selectedAction) {

      if (!$scope.policies || $scope.policies.length < 0) {
        return;
      }
      var policy = $scope.policies.filter(function(policy) {
        return policy.info.name === 'Application';
      });

      if (policy && (policy.length > 0)) {
        policy = policy[0];
        $scope.policyDropped(policy, $scope.parentNode, $scope.index, $scope.secondIndex);

        if ($scope.nodes && $scope.nodes.length > 0) {
          // Get the new node
          var newNode;
          if ($scope.parentNode) {
            var clause = $scope.parentNode.case[$scope.index];
            if (clause.execute) {
              newNode = clause.execute[$scope.secondIndex + 1];
            } else if (clause.otherwise) {
              newNode = clause.otherwise[$scope.secondIndex + 1];
            }
          } else {
            newNode = $scope.nodes[$scope.index + 1];
          }
          if (newNode.Application && newNode.Application.$$type === 'Application') {
            newNode.Application.selectedApplication = {
              name: selectedAction.name,
              displayName: selectedAction.displayName,
              actionInstructions: selectedAction.actionInstructions
            };
            newNode.Application.selectedAction = {
              name: selectedAction.task.name,
              displayName: selectedAction.task.displayName,
              dataModel: selectedAction.task.dataModel,
              interaction: selectedAction.task.interaction
            };
            newNode.Application.mappings = [];
            newNode.Application.map = {};
            switch (selectedAction.task.interaction) {
              case 'CREATE':
                newNode.Application.type = "create-action";
                break;
              case 'RETRIEVEALL':
                newNode.Application.type = "retrieve-action";
                break;
              case 'UPSERTWITHWHERE':
                newNode.Application.type = "upsert-action";
                break;
              default:
                throw new Error('Invalid node type');
            }
            newNode.Application.target = {};
          }
        }
      }
    }));

    // Calls from other controllers
    rootScopeListeners.push($rootScope.$on('animateCanvas', function($event, animationTarget) {
      switch (animationTarget) {
        case 'Trigger':
          $scope.animateCanvasSlide($scope);
          break;
        case 'NewAction':
          $timeout(function() {
            // Drive animation in nodeSelected call
            $scope.nodeSelected(null, animationTarget);
            $scope.$apply();
          }, animationDelay * 2, false);
          break;
      }
    }));

    // Clean up rootScope listeners to stop memory leaks
    $scope.$on('$destroy', function() {
      for (var i = 0; i < rootScopeListeners.length; i++) {
        rootScopeListeners[i]();
      }
    });
  }
]);

angular.module('apiconnect-assembly').controller('NavigationBarController', ['$scope', '$timeout', function($scope, $timeout) {
  if (localStorage.getItem("apim-assembly-scale-factor") && !$scope.isFlowSlim()) {
    $scope.scaleFactor = 1 * localStorage.getItem("apim-assembly-scale-factor");
  } else {
    $scope.scaleFactor = 0.7;
  }

  if ($scope.isFlowSlim()) {
    $scope.scaleFactor = 1;
  }

  $scope.$watch('scaleFactor', function() {
    localStorage.setItem("apim-assembly-scale-factor", $scope.scaleFactor);
  });

  $scope.zoomOut = function() {
    if ($scope.scaleFactor > 0.05) {
      $scope.scaleFactor -= 0.05;
    }
  };

  $scope.zoomIn = function() {
    if ($scope.scaleFactor < 1.5) {
      $scope.scaleFactor += 0.05;
    }
  };

  $scope.fitToScreen = function() {
    var fullWidth = document.querySelector(".assemblyScaler").scrollWidth;
    var fullHeight = document.querySelector(".assemblyScaler").scrollHeight;
    var viewportWidth = document.querySelector(".assemblerCanvas").clientWidth;
    var viewportHeight = document.querySelector(".assemblerCanvas").clientHeight - 30; // 30px padding
    var widthRatio = viewportWidth / fullWidth;
    var heightRatio = viewportHeight / fullHeight;

    // these two numbers let us figure out which is the more extreme dimension so
    // we can fit to the most appropriate dimension
    var widthDelta = Math.abs(1 - widthRatio);
    var heightDelta = Math.abs(1 - heightRatio);

    if (fullWidth > viewportWidth) {
      // too wide
      if (fullHeight > viewportHeight) {
        // too tall, too wide => fit to lesser
        if (widthDelta < heightDelta) {
          $scope.scaleFactor = heightRatio;
        } else {
          $scope.scaleFactor = widthRatio;
        }
      } else {
        // too short, too wide => fit width
        $scope.scaleFactor = viewportWidth / fullWidth;
      }
    } else {
      // too narrow
      if (fullHeight > viewportHeight) {
        // too tall, too narrow => fit height
        $scope.scaleFactor = viewportHeight / fullHeight;
      } else {
        // too short, too narrow => fit to lesser
        if (widthDelta < heightDelta) {
          $scope.scaleFactor = widthRatio;
        } else {
          $scope.scaleFactor = heightRatio;
        }
      }
    }
  };

  $scope.nodeFiltered = function() {
    setTimeout(function() {
      if (!$scope.nodeFilter) {
        $scope.searchCount = '';
      }
      $scope.searchHits = document.getElementsByClassName('searchHit');
      $scope.currentSearchHitIndex = -1;
      for (var i = 0; i < $scope.searchHits.length; i++) {
        if ($scope.searchHits[i].classList.contains('isSelected')) {
          $scope.currentSearchHitIndex = i;
          break;
        }
      }
      $scope.searchCount = $scope.searchHits.length;
      $scope.hitString = ($scope.searchHits.length === 1) ? 'hit' : 'hits';
      $scope.$apply();
    }, 200);
  };

  $scope.searchBack = function() {
    $scope.currentSearchHitIndex -= 1;
    if ($scope.currentSearchHitIndex < 0) {
      $scope.currentSearchHitIndex = $scope.searchHits.length - 1;
    }
    if ($scope.searchHits.length > 0) {
      $scope.searchHits[$scope.currentSearchHitIndex].scrollIntoView({
        block: "start",
        behavior: "smooth"
      });
      $timeout(function() {
        $scope.searchHits[$scope.currentSearchHitIndex].click();
      });
    }
  };

  $scope.searchForward = function() {
    $scope.currentSearchHitIndex += 1;
    if ($scope.currentSearchHitIndex >= $scope.searchHits.length) {
      $scope.currentSearchHitIndex = 0;
    }
    if ($scope.searchHits.length > 0) {
      $scope.searchHits[$scope.currentSearchHitIndex].scrollIntoView({
        block: "start",
        behavior: "smooth"
      });
      $timeout(function() {
        $scope.searchHits[$scope.currentSearchHitIndex].click();
      });
    }
  };

  $scope.setOperationFilter = function(operation) {
    $scope.operationFilter = operation;
    $scope.showOperationFilter = true;
  };
}]);

angular.module('apiconnect-assembly').controller('SidenavController', ['$scope', '$mdSidenav', function($scope, $mdSidenav) {

  var keyCodeEscape = 27;

  // Disable the escape key button in slim canvas view
  $scope.keyDown = function($event) {
    if ($event.keyCode === keyCodeEscape) {
      if ($scope.isFlowSlim()) {
        $event.stopPropagation();
      } else {
        $scope.closeInfo();
      }
    }
  };

  $scope.infoPanelBottom = $scope.isFlowSlim() ? true : false;

  if (localStorage !== undefined) {
    if (typeof localStorage.getItem("apim-assembly-info-panel-bottom") === "string" && !$scope.isFlowSlim()) {
      $scope.infoPanelBottom = localStorage.getItem("apim-assembly-info-panel-bottom") === "true";
    }
  }

  $scope.$watch('infoPanelBottom', function() {
    if (localStorage !== undefined && $scope.infoPanelBottom !== undefined) {
      localStorage.setItem("apim-assembly-info-panel-bottom", $scope.infoPanelBottom);
    }
  });

  $scope.toggleInfoPanelBottom = function($event) {
    $event.stopPropagation();
    $scope.infoPanelBottom = !$scope.infoPanelBottom;
  };

  $scope.maximizeAssemblyInfo = function($event) {
    $event.stopPropagation();
    // make sure we're not pinned
    if ($scope.assemblyInfoPinned) {
      $scope.assemblyInfoPinned = false;
    }
    $scope.assemblyInfoMaximized = !$scope.assemblyInfoMaximized;
    setTimeout(function() {
      $scope.$broadcast('resize');
    }, 0);
  };

  $scope.canvasClick = function($event) {
    if ($event.target === $event.currentTarget) $scope.closeInfo($event);
  };

  $scope.closeInfo = function($event) {
    if ($event) $event.stopPropagation();
    // make sure we're not pinned
    $scope.assemblyInfoPinned = false;
    $scope.infoPanelOpen = false;
    $mdSidenav('assembly-info').close();
    // deselect selected node
    if ($scope.selectedNode) {
      $scope.selectedNode.$$isSelected = false;
      if ($scope.selectedNode.$$type === 'NewAction') {
        var selectedDropzone = angular.element(document.querySelector('.dropzoneGroupSelected'));
        if (selectedDropzone.length) {
          selectedDropzone[0].classList.remove('dropzoneGroupSelected');
          var newAction = selectedDropzone[0].getElementsByClassName('ghostPolicy')[0];
          newAction.classList.remove('isSelected');
        }
      }
      // set node touched
      $scope.selectedNode.$$touched = true;
      delete $scope.selectedNode;
    }
  };

  $scope.pinAssemblyInfo = function() {
    $scope.assemblyInfoPinned = !$scope.assemblyInfoPinned;
  };
}]);

angular.module('apiconnect-assembly').controller('PolicyListController', ['$scope', '$rootScope', 'translateFilter', function($scope, $rootScope, translateFilter) {


  $scope.filterCategories = function() {
    if (!$scope.policiesByCategory) return;
    var filteredCategories = {};
    var mgwFilter = $scope.showMicro();
    var dpgwFilter = $scope.showDP();
    var policyFilter = ($scope.policyFilter) ? $scope.policyFilter.toLowerCase() : "";
    Object.keys($scope.policiesByCategory).forEach(function(category) {
      var policies = $scope.policiesByCategory[category].filter(function(policy) {
        var isUgw = false;
        var isDpgw = false;
        if (policy.gateways) {
          if (policy.gateways.indexOf("datapower-gateway") >= 0) {
            isDpgw = true;
          }
          if (policy.gateways.indexOf("micro-gateway") >= 0) {
            isUgw = true;
          }
        } else {
          isDpgw = true;
        }
        if (policyFilter) {
          if (policy.info.title && policy.info.title.toLowerCase().indexOf(policyFilter) === -1) {
            return false;
          } else if (policy.info.name && policy.info.name.toLowerCase().indexOf(policyFilter) === -1) {
            return false;
          }
        } else if (!isUgw && mgwFilter) {
          return false;
        } else if (!isDpgw && dpgwFilter) {
          return false;
        }
        return true;
      });
      if (policies && policies.length > 0) filteredCategories[category] = policies;
    });
    $scope.filteredCategories = filteredCategories;
  };

  $scope.$watch('policyFilter', $scope.filterCategories);

  $scope.policiesByType = {};

  var unwatchFunc = $scope.$watch('policies', function() {
    if (!$scope.policies) {
      return;
    }
    unwatchFunc();
    $scope.policies.then(function(policies) {
      $scope.policies = policies;
      var policiesByCategory = {},
        policiesByType = {};
      $scope.policies.forEach(function(policy) {
        policiesByType[policy.info.name] = policy;
        policiesByType[policy.info.name + ":" + policy.info.version] = policy;
        if (!policy.info.categories) {
          policy.info.categories = ['Uncategorized'];
        }
        if (policy.info.categories.indexOf('Trigger') > -1) {
          return;
        }
        if (policy.info.categories) {
          policy.info.categories.forEach(function(category) {
            var policies = policiesByCategory[category];
            if (!policies) {
              policies = [];
            }
            policies.push(policy);
            policiesByCategory[category] = policies;
          });
        }
      });
      if ($scope.templates) {
        policiesByCategory[translateFilter("assembly_templates")] = $scope.templates;
      }
      if ($scope.subflows) {
        policiesByCategory[translateFilter("api_policy_assemblies")] = $scope.subflows;
      }
      $scope.policiesByCategory = policiesByCategory;
      angular.extend($scope.policiesByType, policiesByType);
      $scope.filterCategories();

      if ($scope.config.assemblyType === 'trigger-action') {
        $scope.setupTrigger();
      } else if ($scope.config.assemblyType === 'api') {
        $scope.setupRequest();
        $scope.setupResponse();
      }
    });
  });

  $scope.$watch('templates', function() {
    if (!$scope.templates) return;
    if (!$scope.policiesByCategory) return;
    $scope.policiesByCategory[translateFilter("assembly_templates")] = $scope.templates;
  });

  $scope.$watchCollection('subflows', function() {
    if (!$scope.subflows) return;
    if (!$scope.policiesByCategory) return;
    $scope.policiesByCategory[translateFilter("api_policy_assemblies")] = $scope.subflows;
    $scope.filterCategories();
  });

  $scope.collapsedCategories = {};

  $scope.closeCategory = function($event, category) {
    var parentElement = $event.currentTarget.parentElement,
      maxHeight = (Array.prototype.reduce.call(parentElement.childNodes, function(p, c) {
        return p + (c.offsetHeight || 0);
      }, 0) - 40) + 'px',
      element = $event.currentTarget.nextElementSibling;

    if (!element.style["max-height"]) {
      element.style["max-height"] = maxHeight;
    }

    $scope.collapsedCategories[category] = !$scope.collapsedCategories[category];
  };

  var defaultGateway = ($rootScope.offlineMode) ? "micro-gateway" : "datapower-gateway";
  $scope.showMicro = function() {
    // if explicitly set...
    if ($scope.swaggerDocument[$scope.config.property] &&
      $scope.swaggerDocument[$scope.config.property].gateway) {
      return $scope.swaggerDocument[$scope.config.property].gateway === "micro-gateway";
    } else {
      // honour default
      return defaultGateway === "micro-gateway";
    }
  };

  $scope.showDP = function() {
    // if explicitly set...
    if ($scope.swaggerDocument[$scope.config.property] &&
      $scope.swaggerDocument[$scope.config.property].gateway) {
      return $scope.swaggerDocument[$scope.config.property].gateway === "datapower-gateway";
    } else {
      // honour default
      return defaultGateway === "datapower-gateway";
    }
  };

  $scope.microPolicy = function(policy) {
    if (!policy || !policy.gateways) {
      return false;
    }

    return (policy.gateways.indexOf("micro-gateway") >= 0);
  };

  $scope.dpPolicy = function(policy) {
    if (!policy) {
      return false;
    }

    if (!policy.gateways) {
      return true;
    }

    return (policy.gateways.indexOf("datapower-gateway") >= 0);
  };

  $scope.$gateway = function(value) {
    if (value) {
      // setter
      $scope.swaggerDocument[$scope.config.property].gateway = value;
      $scope.filterCategories();
    } else {
      return $scope.showDP() ? "datapower-gateway" : "micro-gateway";
    }
  };

  $scope.showPolicy = function(name, policy) {
    if ($scope.showDP() && $scope.showMicro()) {
      return true;
    }

    if ($scope.policyFilter && name.toLowerCase().indexOf($scope.policyFilter.toLowerCase()) === -1) {
      return false;
    }

    // if gateways.micro is false, this is only a DP policy
    if (!$scope.microPolicy(policy) && $scope.showMicro()) {
      return false;
    }

    // if gateways.dp is false, this is only a Micro policy
    if (!$scope.dpPolicy(policy) && $scope.showDP()) {
      return false;
    }

    return true;
  };
}]);

angular.module('apiconnect-assembly').controller('NodeController', ['$scope', '$rootScope', '$element', '$timeout', '$filter', 'translateFilter', 'assemblyModel', function($scope, $rootScope, $element, $timeout, $filter, translateFilter, assemblyModel) {
  $scope.descriptionLine1 = "";
  $scope.descriptionLine2 = "";
  $scope.nodeFullDescription = "";
  $scope.nodeHasErrors = false;
  $scope.expanded = {};
  $scope.labelPlacement = 'left';
  $element.on('dragstart', function(event) {
    event.stopPropagation();
  });

  if ($scope.node) {
    $scope.data = {
      hashKey: $scope.node.$$hashKey,
      node: $scope.node,
      type: $scope.node.$$type
    };
  } else {
    throw new Error('Unrecognised node');
  }

  if ($scope.node.$$readOnly) {
    $scope.nodeIsReadOnly = true;
  }

  if ($scope.nodeIsReadOnly) {
    $scope.node.$$parentReadOnly = true;
  }

  if ($scope.node.$$subflow) {
    $scope.inSubflow = true;
  }

  $scope.countInnerActions = function(node) {
    return assemblyModel.countInnerActions(node);
  };

  $scope.expandBranch = function($event, node, $index) {
    if (!node.outputSchema || !node.outputSchema.properties || !Object.keys(node.outputSchema.properties).length) {
      return;
    }
    $timeout(function() {
      node.$$expandedBranch = node.$$expandedBranch === $index ? undefined : $index;
      node.$$selectedBranch = $index;
    });
    $scope.nodeSelected($event, node);
  };

  $scope.hasOutputSchema = function(node) {
    if (node.outputSchema && node.outputSchema.properties && Object.keys(node.outputSchema.properties).length) {
      return true;
    } else {
      return false;
    }
  };

  $scope.isDraggable = function() {
    // disable drag and drop when an operation filter is set
    if ($scope.operationFilter) {
      return false;
    }
    // disable drag and drop when nested inside a subflow node
    return (!$scope.$parent || !$scope.$parent.inSubflow);
  };

  $scope.hasObject = function(theObject, hashKey) {
    if (!theObject) {
      return null;
    }
    var result = false;
    if (theObject.$$hashKey === hashKey) {
      return true;
    }
    if (theObject instanceof Array) {
      for (var i = 0; i < theObject.length; i++) {
        result = $scope.hasObject(theObject[i], hashKey);
        if (result) {
          break;
        }
      }
    } else {
      for (var prop in theObject) {
        if (prop === "$$container") continue;
        if (prop === '$$hashKey') {
          if (theObject[prop] === hashKey) {
            return true;
          }
        }
        if (theObject[prop] instanceof Object || theObject[prop] instanceof Array) {
          result = $scope.hasObject(theObject[prop], hashKey);
          if (result) {
            return result;
          }
        }
      }
    }
    return result;
  };

  $scope.isHovered = false;

  $scope.highlightNode = function(toggle, e) {
    $scope.isHovered = toggle ? true : false;
    e.stopPropagation();
  };

  $scope.minimize = function($event) {
    $event.stopPropagation();
    $scope.node.$$minimized = !$scope.node.$$minimized;

    if ($scope.selectedNode) {
      // Check the parent node is in the minimised node if it is a NewAction
      var nodeToFind = $scope.selectedNode.$$type !== 'NewAction' ? $scope.selectedNode : $scope.parentNode;

      // If selectedNode is in the minimized node then unselect and close info
      if ($scope.node.$$minimized && nodeToFind && assemblyModel.containsNode($scope.node, nodeToFind)) {
        $scope.unsetSelectedNode();
        $scope.closeInfo();
      }
    }
  };

  $scope.canMinimize = function() {
    return ($scope.node.$$type === "switch" || $scope.node.$$type === "operation-switch" || $scope.node.$$type === "if");
  };

  $scope.hasMatchedSearch = function() {
    if (!$scope.nodeFilter) {
      return true;
    }
    if ($scope.isAppConnect()) {
      if ($scope.node.selectedApplication && $scope.node.selectedApplication.displayName) {
        return ($scope.node.selectedApplication.displayName.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
      }
      // TODO: Add support for highlighting selectedAction
      // if ($scope.node.nodeName) {
      //   return ($scope.node.nodeName.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
      // }
    }
    if ($scope.node.name) {
      return ($scope.node.name.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
    }
    if ($scope.node.title) {
      return ($scope.node.title.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
    }
    if ($scope.node.$$type) {
      return ($scope.node.$$type.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
    }
    return false;
  };

  $scope.conditionHasMatchedSearch = function(clause) {
    if (!$scope.nodeFilter) {
      return true;
    }
    if (angular.isString(clause)) {
      return (clause.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
    }
    var arrayToSearch;
    if (clause.operations) {
      arrayToSearch = clause.operations;
    } else if (clause.condition && clause.condition.operations) {
      arrayToSearch = clause.errors;
    } else if (clause.errors) {
      arrayToSearch = clause.errors;
    } else if (clause.default) {
      arrayToSearch = clause.default;
    }
    if (!arrayToSearch) {
      return false;
    }
    return (arrayToSearch.join(' ').toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
  };

  $scope.isClauseEmpty = function() {
    return _.isEmpty($scope.node.case) && _.isEmpty($scope.node.catch) && _.isEmpty($scope.node.condition) && _.isEmpty($scope.node.execute);
  };

  $scope.policyWithContent = function() {
    return (!!$scope.showCatches && !!$scope.node.catch) || !!$scope.node.case || !!$scope.node.execute;
  };

  $scope.policyGatewayMiss = function() {
    delete $scope.gatewayErrorMessage;
    var policy = $scope.policiesByType[$scope.node.$$type];
    if (!policy) {
      return false;
    }
    if (!$scope.microPolicy(policy) && $scope.showMicro()) {
      $scope.gatewayErrorMessage = translateFilter('assembly_node_gateway_mismatch');
      return true;
    }
    if (!$scope.dpPolicy(policy) && $scope.showDP()) {
      $scope.gatewayErrorMessage = translateFilter('assembly_node_gateway_mismatch');
      return true;
    }
    return false;
  };

  $scope.cloneNode = function($event, node) {
    $event.stopPropagation();

    if (node.$$container === undefined || node.$$containerIndex === undefined) {
      return;
    }

    var newNode = {};
    newNode[node.$$type] = angular.fromJson(angular.toJson(node));
    // TODO remove this code once https://github.ibm.com/apimesh/apiconnect-assembly/issues/97 is fixed
    newNode[node.$$type].$$type = node.$$type;

    // insert newNode into node.$$container at node.$$containerIndex + 1
    node.$$container.splice(node.$$containerIndex + 1, 0, newNode);
    $scope.nodeSelected(null, newNode[node.$$type]);
  };

  $scope.truncateNodeDescription = function() {

    $scope.descriptionLine1 = $filter('actionForNode')($scope.node, $scope.nodes);
    $scope.nodeFullDescription =  $scope.descriptionLine1;

    if (!$scope.node || !$scope.descriptionLine1) {
      $scope.descriptionLine1 = "";
      $scope.descriptionLine2 = "";
      return;
    }

    $timeout(function() {
      $scope.descriptionLine2 = "";
      var textContainer = $element[0].getElementsByClassName('applicationNodeDetails')[0];
      if (textContainer) {
        if (textContainer.scrollHeight > textContainer.clientHeight) {
          while (textContainer.scrollHeight > textContainer.clientHeight) {
            var lastSpace = $scope.descriptionLine1.lastIndexOf(" ");
            if (lastSpace > -1) {
              var word = $scope.descriptionLine1.slice(lastSpace, $scope.descriptionLine1.length);
              $scope.descriptionLine1 = $scope.descriptionLine1.slice(0, lastSpace);
              $scope.descriptionLine2 = word + $scope.descriptionLine2;
            } else {
              var character = $scope.descriptionLine1.slice(-1);
              $scope.descriptionLine1 = $scope.descriptionLine1.slice(0, -1);
              $scope.descriptionLine2 = character + $scope.descriptionLine2;
            }
            $scope.$digest();
          }
          $scope.descriptionLine1 = $scope.descriptionLine1.trim();
          $scope.descriptionLine2 = $scope.descriptionLine2.trim();
        }
      }
    });
  };

  $scope.updateDefaultDescription = function() {
    if (!$scope.node.description) {
      $scope.truncateNodeDescription();
    }
  };

  $scope.$watch('node.description', $scope.truncateNodeDescription, true);
  $scope.$watchGroup(['node.name', 'node.dataModel'], function(newValue, oldValue) {
    // Need this to prevent truncateNodeDescription being called twice initially in some cases
    // truncateNodeDescription will already be called once on the node.description watcher initially
    if (newValue !== oldValue) {
      $scope.updateDefaultDescription();
    }
  }, true);
}]);

angular.module('apiconnect-assembly').controller('NodeCaseController', ['$scope', '$rootScope', 'clauseMessageFilter', function($scope, $rootScope, clauseMessageFilter) {
  if ($scope.node && $scope.node.case && $scope.node.case.length > 10) {
    $scope.collapseNodes = true;
  }

  $scope.showContent = function($event) {
    $event.stopPropagation();
    $scope.collapseNodes = false;
  };

  $scope.hideContent = function($event) {
    $event.stopPropagation();
    $scope.collapseNodes = true;
  };

  $scope.$watch('case.condition', function() {
    if ($scope.case.condition === undefined) return;
    if ($scope.case.condition === "") {
      delete $scope.case.$$expression;
    } else {
      $scope.case.$$expression = window.jsep($scope.case.condition);
    }
    delete $scope.case.$$expressionString;
    $scope.case.$$expressionString = clauseMessageFilter($scope.case);
  });

  $scope.$watchCollection('case.execute', function(newValue, oldValue) {
    if (!angular.equals(newValue, oldValue)) {
      $rootScope.$emit('assemblyChanged');
    }
  });
}]);

angular.module('apiconnect-assembly').controller('MapDataController', ['$scope', '$mdDialog', function($scope, $mdDialog) {
  $scope.openMapDialog = function($event, selectedNode) {
    $mdDialog.show({
      controller: 'DialogController',
      templateUrl: 'src/html/mapper.html',
      parent: document.body,
      targetEvent: $event,
      fullscreen: true,
      locals: {
        node: selectedNode
      }
    });
  };
}]).controller('DialogController', ['$scope', '$rootScope', '$mdDialog', 'node', function($scope, $rootScope, $mdDialog, node) {
  $scope.node = node;
  var textContent = node.mappingData;

  $scope.done = function() {
    $mdDialog.hide(textContent);
    $rootScope.$emit('nodeMappingUpdated');
  };
}]);

angular.module('apiconnect-assembly').controller('TriggerController', ['$rootScope', '$scope', '$element', '$filter', '$timeout', 'triggerService', function($rootScope, $scope, $element, $filter, $timeout, triggerService) {
  $scope.descriptionLine1 = "";
  $scope.descriptionLine2 = "";
  $scope.descriptionLine3 = "";

  $scope.isTriggerSlim = function() {
    return $scope.config.slimFlowEditor;
  };

  $scope.hasMatchedSearch = function() {
    if (!$scope.nodeFilter) {
      return true;
    }
    var matchedApplication;
    var matchedTrigger;

    if ($scope.trigger.selectedApplication && $scope.trigger.selectedApplication.displayName) {
      matchedApplication = ($scope.trigger.selectedApplication.displayName.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
    }
    // TODO Add support for highlighting selectedTrigger
    // if ($scope.trigger.selectedTrigger && $scope.trigger.selectedTrigger.displayName) {
    //   matchedTrigger = ($scope.trigger.selectedTrigger.displayName.toLowerCase().indexOf($scope.nodeFilter.toLowerCase()) > -1);
    // }
    return matchedApplication || matchedTrigger;
  };

  $scope.selectTriggerApplication = function(selectedTrigger) {
    triggerService.setTriggerApplication($scope.trigger, selectedTrigger);
  };

  $scope.hasOperationSelected = function() {
    var activeOperations = [];
    if ($scope.trigger.selectedTrigger && ($scope.trigger.selectedTrigger.operations)) {
      $scope.trigger.selectedTrigger.operations.forEach(function(op) {
        if (op.state) {
          activeOperations.push(op.id);
        }
      });
    }
    return activeOperations.length > 0;
  };

  $scope.truncateNodeDescription = function() {
    $scope.descriptionLine1 = $filter('actionForTrigger')($scope.trigger);
    if (!$scope.trigger || !$scope.descriptionLine1) {
      $scope.descriptionLine1 = "";
      $scope.descriptionLine2 = "";
      $scope.descriptionLine3 = "";
      return;
    }
    $timeout(function() {
      $scope.descriptionLine2 = "";
      var textContainer = $element[0].getElementsByClassName('triggerNodeDetails')[0];
      if (textContainer) {
        if (textContainer.scrollHeight > textContainer.clientHeight) {
          while (textContainer.scrollHeight > textContainer.clientHeight) {
            var lastSpace = $scope.descriptionLine1.lastIndexOf(" ");
            if (lastSpace > -1) {
              var word = $scope.descriptionLine1.slice(lastSpace, $scope.descriptionLine1.length);
              $scope.descriptionLine1 = $scope.descriptionLine1.slice(0, lastSpace);
              $scope.descriptionLine2 = word + $scope.descriptionLine2;
            } else {
              var character = $scope.descriptionLine1.slice(-1);
              $scope.descriptionLine1 = $scope.descriptionLine1.slice(0, -1);
              $scope.descriptionLine2 = character + $scope.descriptionLine2;
            }
            $scope.$digest();
          }
          $scope.descriptionLine1 = $scope.descriptionLine1.trim();
          $scope.descriptionLine2 = $scope.descriptionLine2.trim();
        }
        $timeout(function() {
          $scope.descriptionLine3 = "";
          var textContainerLine2 = $element[0].getElementsByClassName('triggerNodeDetails')[1];
          if (textContainerLine2) {
            if (textContainerLine2.scrollHeight > textContainerLine2.clientHeight) {
              while (textContainerLine2.scrollHeight > textContainerLine2.clientHeight) {
                var lastSpace = $scope.descriptionLine2.lastIndexOf(" ");
                if (lastSpace > -1) {
                  var word = $scope.descriptionLine2.slice(lastSpace, $scope.descriptionLine2.length);
                  $scope.descriptionLine2 = $scope.descriptionLine2.slice(0, lastSpace);
                  $scope.descriptionLine3 = word + $scope.descriptionLine3;
                } else {
                  var character = $scope.descriptionLine2.slice(-1);
                  $scope.descriptionLine2 = $scope.descriptionLine2.slice(0, -1);
                  $scope.descriptionLine3 = character + $scope.descriptionLine3;
                }
                $scope.$digest();
              }
              $scope.descriptionLine2 = $scope.descriptionLine2.trim();
            }
          }
        });
      }
    });
  };

  $scope.updateDefaultDescription = function() {
    if (!$scope.trigger.description) {
      $scope.truncateNodeDescription();
    }
  };

  $rootScope.$on('onTriggerCompletePhase', function($event, nextTarget, selectedTrigger) {
    if (selectedTrigger) {
      $scope.selectTriggerApplication(selectedTrigger);
    }
    $rootScope.$emit('animateCanvas', nextTarget);
  });

  $scope.$watch('trigger.description', function() {
    $scope.truncateNodeDescription();
  }, true);

  $scope.$watch('trigger.selectedTrigger.dataModel', function(newValue, oldValue) {
    // Need this to prevent truncateNodeDescription being called twice initially in some cases
    // truncateNodeDescription will already be called once on the node.description watcher initially
    if (newValue !== oldValue) {
      $scope.updateDefaultDescription();
    }
  }, true);
}]);

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
'use strict';

angular.module('apiconnect-assembly').controller('ErrorController', ['$scope', '$mdDialog', function ($scope, $mdDialog) {

  // Set some defaults
  var defaultErrorMessage = "An error has occurred",
    defaultErrorDescription = "An error occurred in the IBM App Connect flow editor.",
    defaultErrorLinkText = "Find the solution on the IBM App Connect forum",
    defaultErrorButtons = [{
      "buttonTitle" : "Close"
    }];
  $scope.errorCodeText = "Error Code";
  if (!$scope.errorObject) {
    $scope.errorObject = {};
  }

  // Populate our variables
  $scope.errorMessage = $scope.errorObject.errorMessage || defaultErrorMessage;
  $scope.errorCode = $scope.errorObject.errorCode;
  $scope.errorDescription = $scope.errorObject.errorDescription || defaultErrorDescription;
  $scope.errorLinkUrl = $scope.errorObject.errorLinkUrl;
  if ($scope.errorLinkUrl) {
    $scope.errorLinkText = $scope.errorObject.errorLinkText || defaultErrorLinkText;
  }
  $scope.errorButtons = (($scope.errorObject.errorButtons) && ($scope.errorObject.errorButtons.length > 0)) ? $scope.errorObject.errorButtons : defaultErrorButtons;
  $scope.dismissable = (typeof $scope.errorObject.dismissable !== 'undefined') ? $scope.errorObject.dismissable : true;
  $scope.closeCallback = $scope.errorObject.closeCallback;

  $scope.closeDialog = function (invokeCloseCallback) {
    $mdDialog.hide();
    if (invokeCloseCallback && $scope.closeCallback) {
      $scope.closeCallback();
    }
  };

  $scope.runCallback = function (callbackFunction, keepDialogOpen) {
    if (callbackFunction) {
      callbackFunction();
    }
    if (!keepDialogOpen) {
      $scope.closeDialog();
    }
  };
}]).controller('WarningController', ['$scope', '$timeout', function ($scope, $timeout) {

  // Set some defaults
  var defaultWarningMessage = "",
    defaultWarningButtons = [];
  if (!$scope.warningObject) {
    $scope.warningObject = {};
  }

  var countdownTimer;

  // Build warning Message with a counter
  if($scope.warningObject.warningMessage) {
    if($scope.warningObject.warningMessage.hasCounter &&
      ($scope.warningObject.warningMessage.count > 0) &&
      ($scope.warningObject.warningMessage.messages.length === 2)) {
      // Set count
      $scope.counter = $scope.warningObject.warningMessage.count;
      // Setup countdown message updates - countdown in seconds
      $scope.countdown = function() {
        // Set initial message
        $scope.warningMessage = $scope.warningObject.warningMessage.messages[0] + $scope.counter + $scope.warningObject.warningMessage.messages[1];
        countdownTimer = $timeout(function() {
          $scope.warningMessage = $scope.warningObject.warningMessage.messages[0] + $scope.counter + $scope.warningObject.warningMessage.messages[1];
          $scope.counter--;
          if($scope.counter >= 0){
            $scope.countdown();
          } else {
            $scope.closeDialog();
          }
        }, 1000);
      };
      // Start the timer
      $scope.countdown();
    } else {
      if($scope.warningObject.warningMessage.messages && ($scope.warningObject.warningMessage.messages.length === 1)) {
        $scope.warningMessage = $scope.warningObject.warningMessage.messages[0];
      } else {
        $scope.warningMessage = defaultWarningMessage;
      }
    }
  } else {
    $scope.warningMessage = defaultWarningMessage;
  }


  // Populate our variables
  $scope.warningButtons = (($scope.warningObject.warningButtons) && ($scope.warningObject.warningButtons.length > 0)) ? $scope.warningObject.warningButtons : defaultWarningButtons;
  $scope.closeCallback = $scope.warningObject.closeCallback;

  $scope.closeDialog = function () {
    $timeout.cancel(countdownTimer);
    if($scope.closeCallback) {
      $scope.closeCallback();
    }
    $scope.panelReference.close();
  };

  $scope.runCallback = function (callbackFunction, keepDialogOpen) {
    if (callbackFunction) {
      callbackFunction();
    }
    if (!keepDialogOpen) {
      $scope.closeDialog();
    }
  };
}]);


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly').directive('apimAssemblyPolicy', function () {
  return {
    restrict: 'E',
    templateUrl: 'src/html/policy.html'
  };
}).directive('apimAssemblyTemplate', function () {
  return {
    restrict: 'E',
    templateUrl: 'src/html/template.html'
  };
}).directive('apimAssembler', function () {
  return {
    restrict: 'E',
    templateUrl: 'src/html/assembler.html',
    scope: {
      assemblerOptions: '@'
    },
    controller: 'AssemblerController',
    controllerAs: 'AssemblerController',
    bindToController: true
  };
}).directive('apimNode', ['RecursionHelper', function (RecursionHelper) {
  return {
    restrict: 'E',
    templateUrl: 'src/html/node.html',
    compile: function(element) {
      return RecursionHelper.compile(element);
    }
  };
}]).directive('apimLogicNode', ['RecursionHelper', function (RecursionHelper) {
  return {
    restrict: 'E',
    templateUrl: 'src/html/logic-node.html',
    compile: function(element) {
      return RecursionHelper.compile(element);
    }
  };
}]).directive('apimMapper', function() {
  return {
    restrict: 'E',
    templateUrl: 'src/html/mapper.html'
  };
}).directive('apimGenerator', function() {
  return {
    restrict: 'E',
    templateUrl: 'src/html/generator.html'
  };
}).directive('apimTestParameter', function() {
  return {
    restrict: 'E',
    templateUrl: 'src/html/test-parameter.html'
  };
}).directive('apimAssemblyTest', function() {
  return {
    restrict: 'E',
    templateUrl: 'src/html/assembly-test.html'
  };
}).directive('apimDraftAssembly', function() {
  return {
    restrict: 'E',
    templateUrl: 'src/html/draft-assembly.html'
  };
}).directive('apicConditionBuilder', function() {
  return {
    restrict: 'E',
    controller: "ConditionController as conditionController",
    templateUrl: 'src/html/condition-builder.html',
    scope: {
      condition: '='
    }
  };
}).directive('apicConditionExpression', function(RecursionHelper) {
  return {
    restrict: 'E',
    templateUrl: 'src/html/condition-expression.html',
    controller: "ConditionExpressionController as expressionController",
    scope: true,
    compile: function(element) {
      return RecursionHelper.compile(element);
    }
  };
}).directive('apicConditionExpressionLeft', function(RecursionHelper) {
  return {
    restrict: 'E',
    templateUrl: 'src/html/condition-expression.html',
    controller: "ConditionExpressionLeftController as expressionController",
    scope: true,
    compile: function(element) {
      return RecursionHelper.compile(element);
    }
  };
}).directive('apicConditionExpressionRight', function(RecursionHelper) {
  return {
    restrict: 'E',
    templateUrl: 'src/html/condition-expression.html',
    controller: "ConditionExpressionRightController as expressionController",
    scope: true,
    compile: function(element) {
      return RecursionHelper.compile(element);
    }
  };
}).directive('apimNotEmpty', function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function (scope, elem, attrs, ctrl) {
      ctrl.$parsers.push(function(viewValue) {
        if(viewValue === "") {
          return null;
        }
        return viewValue;
      });
    }
  };
}).directive('appCTrigger', function () {
  return {
    controller: 'TriggerController as triggerController',
    restrict: 'E',
    templateUrl: '/app/nodeTemplates/trigger.html'
  };
}).directive('apimSidenav', function () {
  return {
    controller: 'SidenavController',
    restrict: 'E',
    templateUrl: 'src/html/sidenav.html'
  };
}).directive('errorDialog', function () {
  return {
    controller: 'ErrorController',
    restrict: 'E',
    templateUrl: 'src/html/error-dialog.html'
  };
}).directive('warningDialog', function () {
  return {
    controller: 'WarningController',
    restrict: 'E',
    templateUrl: 'src/html/warning-dialog.html'
  };
}).directive('policyList', function () {
  return {
    controller: 'PolicyListController',
    restrict: 'E',
    templateUrl: 'src/html/policy-list.html'
  };
}).directive('navigationBar', function () {
  return {
    controller: 'NavigationBarController',
    restrict: 'E',
    templateUrl: 'src/html/navigation-bar.html'
  };
}).directive('assemblerCanvas', function () {
  return {
    restrict: 'E',
    templateUrl: 'src/html/assembler-canvas.html'
  };
}).directive('nodeGroup', function () {
  return {
    restrict: 'E',
    templateUrl: 'src/html/node-group.html'
  };
});

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

var instanceCounters = {};
function unwrapOperationSwitch(operation, policy, nodes, policies, operationMap) {
  if (!policy['operation-switch']) return;
  if (!policy['operation-switch'].case) return;
  for (var i = 0; i < policy['operation-switch'].case.length; i++) {
    var thisCase = policy['operation-switch'].case[i];
    if (!thisCase.operations || thisCase.operations.length === 0) continue;
    for (var j = 0; j < thisCase.operations.length; j++) {
      var policiesToProcess = [];
      if (operation.verb && operation.path &&
        operation.verb === thisCase.operations[j].verb &&
        operation.path === thisCase.operations[j].path) {
        policiesToProcess = thisCase.execute;
      } else if (typeof operation === "string" && operation === thisCase.operations[j]) {
        policiesToProcess = thisCase.execute;
      } else if (typeof operation === "string" &&
        operationMap[operation].verb === thisCase.operations[j].verb &&
        operationMap[operation].path === thisCase.operations[j].path) {
        policiesToProcess = thisCase.execute;
      } else if (operation.operationId && operation.operationId === thisCase.operations[j]) {
        policiesToProcess = thisCase.execute;
      } else if (operation.operationId &&
        operationMap[operation.operationId].verb === thisCase.operations[j].verb &&
        operationMap[operation.operationId].path === thisCase.operations[j].path) {
        policiesToProcess = thisCase.execute;
      }
      if (policiesToProcess.length > 0) {
        policiesToProcess.forEach(function(policy) {
          var key = Object.keys(policy)[0];
          if (key === "operation-switch") {
            // look deeper through the policy to unwrap the operation-switches
            unwrapOperationSwitch(operation, policy, nodes, operationMap);
          } else {
            // just push it on the stack
            var obj = policy[key];
            obj.$$type = key;
            var versionedKey = (obj.version) ? key + ":" + obj.version : key;
            if (policies) {
              var definition = policies[versionedKey] || policies[key];
              if (!definition && key === "assembly") {
                definition = {
                  type: 'subflow',
                  info: {
                    display: {
                      color: '#4B68FA',
                      icon: 'open_in_browser'
                    }
                  }
                };
              }
              if (definition) {
                obj.$$display = definition.info.display;
                obj.$$schema = definition.properties;
                obj.$$classes = definition.classes || [];
                obj.$$logic = !!definition.logic;
                obj.$$subflow = (definition.type === 'subflow');
                obj.$$application = !!definition.application;
              }
            }
            if (instanceCounters[key] === undefined) {
              instanceCounters[key] = 1;
              obj.$$instance = 1;
            } else {
              instanceCounters[key]++;
              obj.$$instance = instanceCounters[key];
            }
            if (thisCase.operations.length > 1) obj.$$operations = thisCase.operations.length - 1;
            nodes.push(obj);
          }
        });
        return;
      }
    }
  }
};

angular.module('apiconnect-assembly').filter('byCategory', function () {
  return function byCategory(policies) {
    var categorized = {};
    policies.forEach(function(policy) {
      policy.categories.forEach(function(category) {
        var thesePolicies = categorized[category];
        if (!thesePolicies) thesePolicies = [];
        thesePolicies.push(policy);
        categorized[category] = thesePolicies;
      });
    });
    return categorized;
  };
}).filter('transformNodeModel', ['$injector', function ($injector) {
  return function transformNodeModel(nodes, policies, filter, operationMap, resetCounters) {
    if (resetCounters) instanceCounters = {};
    var transformedNodes = [];
    if (!nodes) return;
    var ComponentRegistry;
    try {
      ComponentRegistry = $injector.get('ComponentRegistry');
    } catch(e) {
      // that's ok - it isn't guaranteed to be available and won't be used if not
    }
    for (var i = 0; i < nodes.length; i++) {
      var obj = {};
      Object.keys(nodes[i]).forEach(function(key) {
        if (key.indexOf('$$') !== 0) {
          if (filter && key === "operation-switch") {
            // look deeper through the policy to unwrap the operation-switches
            unwrapOperationSwitch(filter, nodes[i], transformedNodes, policies, operationMap);
          } else {
            obj = nodes[i][key];
            if (obj.$ref) {
              if (!obj.$$resolved) {
                // de-ref if ComponentRegistry is available
                if (ComponentRegistry) {
                  var deref = ComponentRegistry.getReference(obj.$ref, "assemblies");
                  obj.$$resolved = angular.copy(deref);
                  obj.$$resolved.$ref = obj.$ref;
                  obj.$$resolved.$$readOnly = true;
                  obj.$$resolved.$$parent = obj;
                  obj.$$resolved.title = obj.title;
                }
              }
              obj = obj.$$resolved;
            }
            // just push it on the stack
            obj.$$type = key;
            obj.$$container = nodes;
            obj.$$containerIndex = i;
            var versionedKey = (obj.version) ? key + ":" + obj.version : key;
            if (policies) {
              var definition = policies[versionedKey] || policies[key];
              if (!definition && key === "assembly") {
                definition = {
                  type: 'subflow',
                  info: {
                    display: {
                      color: '#4B68FA',
                      icon: 'open_in_browser'
                    }
                  }
                };
              }
              if (definition) {
                obj.$$display = definition.info.display;
                obj.$$schema = definition.properties;
                obj.$$classes = definition.classes || [];
                obj.$$logic = !!definition.logic;
                obj.$$subflow = (definition.type === 'subflow');
                obj.$$application = !!definition.application;
              }
            }
            if (instanceCounters[key] === undefined) {
              instanceCounters[key] = 1;
              obj.$$instance = 1;
            } else {
              instanceCounters[key]++;
              obj.$$instance = instanceCounters[key];
            }
            transformedNodes.push(obj);
          }
        }
      });
    }
    return transformedNodes;
  };
}]).filter('policyDisplayName', function () {
  return function policyDisplayName(policy) {
    if (policy.name) return policy.name;
    if (policy.selectedApplication) {
      if (policy.selectedApplication.displayName) {
        return policy.selectedApplication.displayName;
      }
      if (policy.selectedApplication.name) {
        return policy.selectedApplication.name;
      }
      if (policy.selectedApplication.type) {
        return policy.selectedApplication.type;
      }
    }
    if (policy.nodeName) return policy.nodeName;
    if (policy.title) return policy.title;
    return policy.$$type;
  };
}).filter('clauseMessage', ['translateFilter', 'Expressions', function (translateFilter, Expressions) {
  return function(clause) {
    if (clause.$$expressionString) return clause.$$expressionString;
    var message = "";
    if (clause.operations) {
      clause.operations.forEach(function(operation) {
        if (!operation) return;
        if (typeof operation === "string") {
          message += operation + ", ";
        } else if (operation.operationId) {
          message += operation.operationId + ", ";
        } else {
          message += operation.verb + " " + operation.path + ", ";
        }
      });
      if (message.length > 2) message = message.substring(0, message.length - 2);
      if (message === "") return translateFilter('assemblyEmptyCase');
    } else if (clause.condition && clause.condition.operations) {
      clause.condition.operations.forEach(function(operation) {
        if (!operation) return;
        if (typeof operation === "string") {
          message += operation + ", ";
        } else {
          message += operation.verb + " " + operation.path + ", ";
        }
      });
      if (message.length > 2) message = message.substring(0, message.length - 2);
      if (message === "") return translateFilter('assemblyEmptyCase');
    } else if (clause.condition && clause.condition.expression) {
      message = clause.condition.expression;
    } else if (typeof clause.condition === "string") {
      if (clause.$$expression) return Expressions.expressionAsString(clause.$$expression) || clause.condition;
      if (clause.condition === "") return translateFilter('assemblyEmptyCase');
    } else if (clause.otherwise) {
      return translateFilter('assemblyOtherwise');
    } else if (clause.errors) {
      message = clause.errors.join(", ");
    } else if (clause.default) {
      return translateFilter('policies_default');
    }
    return message;
  };
}]).filter('catchMessage', ['translateFilter', function (translateFilter) {
  return function(catchStatement) {
    if (catchStatement.errors && catchStatement.errors.length > 0) {
      return catchStatement.errors.join(", ");
    } else if (catchStatement.default) {
      return translateFilter('policies_default');
    }
    return translateFilter('assemblyEmptyCatch');
  };
}]).filter('assemblyInfoMaximizeLabel', function () {
  return function(assemblyInfoMaximized) {
    return (assemblyInfoMaximized) ? 'remove_from_queue' : 'add_to_queue';
  };
}).filter('iconForNode', function() {
  return function(node) {
    if (node.selectedApplication && node.selectedApplication.name) return "connector:" + node.selectedApplication.name;
    if (node.info && node.info.display && node.info.display.icon) return node.info.display.icon;
    if (node.$$display && node.$$display.icon) return node.$$display.icon;
    if (node.$$type === "catch") return "error";
    return "";
  };
}).filter('formatResponseData', function() {
  return function(data, headers) {
    if (headers['content-type'] === "application/json") {
      return JSON.stringify(data, null, 2);
    }
    return data;
  };
}).filter('httpErrorToMessage', ['HttpErrors', function(HttpErrors) {
  return function(errorCode) {
    if (HttpErrors[errorCode]) return HttpErrors[errorCode];
    return "";
  };
}]).filter('noAssemblies', ['translateFilter', function(translateFilter) {
  return function (assemblies) {
    if (!assemblies || assemblies.length === 0) return translateFilter('assembliesNoAssembliesFound');
    return translateFilter('assembliesNoMatchingAssemblies');
  };
}]).filter('assemblyTitleQuery', function() {
  return function (assemblies, query) {
    if(!assemblies) return assemblies;
    if(!query) return assemblies;
    var term = query.toLowerCase();
    return assemblies.filter(function(assembly) {
      return (assembly.info && assembly.info.title && assembly.info.title.toLowerCase().indexOf(term) > -1);
    });
  };
}).filter('expressionToLabel', function() {
  return function(expression) {
    var expr = expression;
    if (angular.isArray(expression)) expr = expression[0];
    if (angular.isObject(expr)) return window.jseb(expr);
    return expr;
  };
}).filter('highlight', function() {
  return function(input, matching) {
    if (!input || !matching || matching === "") return input;
    // Escape any special characters (e.g. $, [, {, etc.) with a backslash
    matching = matching.replace(/[#-.]|[[-^]|[?|{}]/g, '\\$&');
    var reg = new RegExp(matching, "ig");
    return input.replace(reg, function(match) { return '<span class="ui-match">' + match + '</span>';});
  };
}).filter('isActionCategory', function() {
  return function(node) {
    if (node.info && node.info.categories &&
      (node.info.categories.length > 0) &&
      (node.info.categories.indexOf('Action') > -1)) return true;
    if (node.$$categories &&
      (node.$$categories.length > 0) &&
      (node.$$categories.indexOf('Action') > -1)) return true;
    return false;
  };
}).filter('isTriggerCategory', function() {
  return function(node) {
    if (node.info && node.info.categories &&
      (node.info.categories.length > 0) &&
      (node.info.categories.indexOf('Trigger') > -1)) return true;
    if (node.$$categories &&
      (node.$$categories.length > 0) &&
      (node.$$categories.indexOf('Trigger') > -1)) return true;
    return false;
  };
}).filter('actionForTrigger', function() {
  return function actionForTrigger(trigger) {
    var action = "";

    if (trigger.description && trigger.description.length > 0) {
      return trigger.description;
    }

    if (trigger.selectedTrigger) {
      return (trigger.selectedTrigger.displayName) ? trigger.selectedTrigger.displayName : trigger.selectedTrigger.name;
    }

    return action;
  };
}).filter('actionForNode', function() {
  return function actionForNode(node,nodes) {
    var action = "";
    var existingNames = {};

    if(node.description && node.description.length > 0) {
      return node.description;
    }

    if(node.name && node.dataModel) {
      return node.name + " " + node.dataModel;
    }
    if(node.$$type === 'Application') {
      if(node.nodeName){
        var applicationName = node.selectedApplication.displayName + " ";
        return node.nodeName.replace(applicationName, '');
      }
      if(node.selectedAction.displayName) {
        action = node.selectedAction.displayName;
      } else {
        action = node.selectedAction.name;
      }

      var index = 2;
      nodes.forEach(function(n){
        var key = Object.keys(n)[0];
        if (key === 'Application') {
          if(node.selectedApplication.name === n.Application.selectedApplication.name && node.selectedAction.name === n.Application.selectedAction.name){
            if(n.Application.nodeName){
              var applicationName = n.Application.selectedApplication.displayName + " ";
              existingNames[n.Application.nodeName.replace(applicationName, '')] = true;
            }
          }
        }
      });
      var foundId = false;
      if (existingNames[action]) {
        while (!foundId) {
          if (!existingNames[action + " " + index]) {
            foundId = true;
          } else {
            index++;
          }
        };
        action = action + " " + index;
      }
    }
    return action;
  };
});


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

function AssemblerInfoController($scope, SchemaForm) {
  $scope.minorTab = 'configure';
  SchemaForm.options = {
    'ajax': true,
    'theme': 'bootstrap3',
    'show_errors': 'change',
    'no_additional_properties': true,
    'disable_edit_json': true,
    'required_by_default': true
  };

  $scope.aceLoaded = function() {
    window.e.setOption('enableBasicAutocompletion', false);
    window.e.setOption('enableLiveAutocompletion', false);
  };

  var modelChanged = function(model, updateInScope) {
    if (updateInScope) { $scope.model = model; }
    angular.extend($scope.selectedNode, model);
    // clear out any properties present in the selected node which aren't present in the new node
    Object.keys($scope.selectedNode).forEach(function(key) {
      if (key.indexOf('$$') !== 0) {
        if ($scope.selectedNode.hasOwnProperty(key) && !model.hasOwnProperty(key)) {
          delete $scope.selectedNode[key];
        }
      }
    });
  };

  $scope.policyAsYaml = function(newYaml) {
    if (arguments.length) {
      // Setter
      modelChanged(jsyaml.safeLoad(newYaml), true);
    } else {
      // Getter
      var cleanObject = JSON.parse(angular.toJson($scope.selectedNode));
      if (_.isEmpty(cleanObject)) return "";
      return jsyaml.safeDump(cleanObject, {lineWidth: -1});
    }
  };

  $scope.formChanged = _.debounce(modelChanged, 200);
  $scope.aceChanged = _.debounce(modelChanged, 200);

  var currentHash;
  // deep watch the object
  $scope.$watch('selectedNode', function() {
    if (!$scope.selectedNode) { return; }

    // remove anything explicitly set to null
    Object.keys($scope.selectedNode).forEach(function(key) {
      if ($scope.selectedNode.hasOwnProperty(key) && $scope.selectedNode[key] === null) {
        delete $scope.selectedNode[key];
      }
    });
    if (!currentHash || currentHash !== $scope.selectedNode.$$hashKey) {
      currentHash = $scope.selectedNode.$$hashKey;
      $scope.schema = $scope.selectedNode.$$schema;
      $scope.model = angular.copy($scope.selectedNode);
    }
  }, true);
};

angular.module('apiconnect-assembly').controller('AssemblerInfoController', ['$scope', 'SchemaForm', AssemblerInfoController]);

function OperationSwitchController($scope) {
  var self = this;
  self.addCase = function() {
    $scope.selectedNode.case.push({operations: [], execute: []});
  };
  self.removeCase = function(index) {
    $scope.selectedNode.case.splice(index, 1);
  };
};

angular.module('apiconnect-assembly').controller('OperationSwitchController', ['$scope', OperationSwitchController]);

function OperationCaseController($scope) {
  if (!$scope.case.operations) $scope.case.operations = [];
  if (!$scope.case.execute) $scope.case.execute = [];
  var self = this;
  self.filter = function() {
    var search = this.searchText.toLowerCase();
    return $scope.swaggerLegacyOperations.filter(function(operation) {
      if (typeof operation === "string") {
        if (operation.toLowerCase().indexOf(search) === -1) return false;
      } else {
        if (operation.verb.toLowerCase().indexOf(search) === -1 && operation.path.toLowerCase().indexOf(search) === -1) return false;
      }
      // we match, so return true only if the operation isn't used elsewhere already
      for (var i = 0; i < $scope.selectedNode.case.length; i++) {
        for (var j = 0; j < $scope.selectedNode.case[i].operations.length; j++) {
          var usedOperation = $scope.selectedNode.case[i].operations[j];
          if (typeof operation === "string" && operation === usedOperation) return false;
          if (typeof operation === "object" && operation.verb === usedOperation.verb && operation.path === usedOperation.path) return false;
        }
      }
      return true;
    });
  };
};

angular.module('apiconnect-assembly').controller('OperationCaseController', ['$scope', OperationCaseController]);

function SwitchController($scope) {
  var self = this;
  self.addCase = function() {
    if ($scope.hasOtherwise()) {
      $scope.selectedNode.case.splice($scope.selectedNode.case.length - 1, 0, {condition: "", execute: []});
    } else {
      $scope.selectedNode.case.push({condition: "", execute: []});
    }
  };
  self.removeCase = function(index) {
    $scope.selectedNode.case.splice(index, 1);
  };
  self.moveUp = function(index) {
    if (index <= 0) return;
    var newCases = [];
    $scope.selectedNode.case.forEach(function(thisCase, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index - 1) {
        newCases.push($scope.selectedNode.case[index]);
        newCases.push(thisCase);
      } else {
        newCases.push(thisCase);
      }
    });
    $scope.selectedNode.case = newCases;
  };
  self.moveDown = function(index) {
    if (index >= $scope.selectedNode.case.length - 1) return;
    var newCases = [];
    $scope.selectedNode.case.forEach(function(thisCase, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index + 1) {
        newCases.push(thisCase);
        newCases.push($scope.selectedNode.case[index]);
      } else {
        newCases.push(thisCase);
      }
    });
    $scope.selectedNode.case = newCases;
  };
  $scope.hasOtherwise = function() {
    return $scope.selectedNode.case[$scope.selectedNode.case.length - 1].otherwise !== undefined;
  };
  self.addOtherwise = function() {
    $scope.selectedNode.case.push({otherwise: []});
  };
};

angular.module('apiconnect-assembly').controller('SwitchController', ['$scope', SwitchController]);

function CaseController($scope, $mdDialog, Expressions) {
  if (!$scope.case.otherwise && !$scope.case.execute) $scope.case.execute = [];
  var self = this;

  self.filter = function() {
    if (!$scope.chips || $scope.chips.length === 0) return $scope.swaggerOperations;
    var search = this.searchText.toLowerCase();
    return $scope.swaggerOperations.filter(function(operation) {
      if (operation.operationId && operation.operationId.toLowerCase().indexOf(search) === -1) return false;
      if (operation.verb && operation.path && operation.verb.toLowerCase().indexOf(search) === -1 && operation.path.toLowerCase().indexOf(search) === -1) return false;
      // we match, so return true only if the operation isn't used elsewhere already
      for (var i = 0; i < $scope.chips.length; i++) {
        if (operation.verb && $scope.chips[i].verb && $scope.chips[i].verb.toLowerCase() === operation.verb.toLowerCase() &&
          operation.path && $scope.chips[i].path && $scope.chips[i].path === operation.path) return false;
        if (operation.operationId && $scope.chips[i].operationId === operation.operationId) return false;
      }
      return true;
    });
  };
  self.canMoveUp = function($index) {
    if ($scope.case.otherwise) return false;
    return $index > 0;
  };
  self.canMoveDown = function($index) {
    if ($scope.case.otherwise) return false;
    if ($scope.hasOtherwise()) return $index < $scope.selectedNode.case.length - 2;
    return $index < $scope.selectedNode.case.length - 1;
  };
  self.convertToExpression = function() {
    // empty case
    var expression;
    if (!$scope.case.condition.operations || $scope.case.condition.operations.length === 0) {
      delete $scope.case.condition.operations;
      $scope.case.condition.expression = "(function() {\n  return false;\n})();";
      return;
    }
    $scope.case.condition.operations.forEach(function(operation) {
      if (typeof operation === "string") {
        expression += "$(operation.operationId) === '" + operation + "' || ";
      } else {
        expression += "($(operation.verb) === '" + operation.verb + "' && $(operation.path) === '" + operation.path + "') || ";
      }
    });
    expression = expression.substring(0, expression.length - 4) + ");\n})();";
    delete $scope.case.condition.operations;
    $scope.case.condition.expression = expression;
  };
  self.launchExpressionEditor = function() {
    $mdDialog.show({
      templateUrl: 'src/html/expression-editor.html',
      controller: 'ConditionEditorController',
      locals: {
        expression: $scope.case.condition
      }
    }).then(function(response) {
      $scope.case.condition = response;
    });
  };
  if (!$scope.case.otherwise) {
    $scope.$watch('case.condition', function() {
      if ($scope.case.condition && $scope.case.condition !== "") {
        $scope.expression = window.jsep($scope.case.condition);
        $scope.highLevelExpression = Expressions.highLevelExpression($scope.expression);
        if ($scope.highLevelExpression) $scope.chips = Expressions.expressionAsChips($scope.expression);
      } else {
        $scope.highLevelExpression = true;
        $scope.chips = [];
      }
    });

    $scope.$watchCollection('chips', function() {
      if (!$scope.highLevelExpression) return;
      if (!$scope.chips || $scope.chips.length === 0) {
        $scope.case.condition = "";
      } else {
        $scope.case.condition = Expressions.chipsAsExpressionString($scope.chips);
      }
    });
  }
};

angular.module('apiconnect-assembly').controller('CaseController', ['$scope', '$mdDialog', 'Expressions', CaseController]);

function ConditionEditorController($scope, $mdDialog, expression) {

  $scope.expressionString = expression;

  $scope.$on("condition-change", function($event, expression) {
    $scope.expressionString = expression;
  });

  $scope.commit = function() {
    $mdDialog.hide($scope.expressionString);
  };

  $scope.cancel = function() {
    $mdDialog.cancel();
  };

};

angular.module('apiconnect-assembly').controller('ConditionEditorController', ['$scope','$mdDialog', 'expression', ConditionEditorController]);

function CatchController($scope) {
  var self = this;
  self.addCatch = function() {
    if (!$scope.selectedNode.catch) $scope.selectedNode.catch = [];
    var insertIndex = $scope.selectedNode.catch.length;
    if (self.hasDefault()) insertIndex--;
    $scope.selectedNode.catch.splice(insertIndex, 0, {errors: [], execute: []});
  };
  self.hasDefault = function() {
    var lastCatch = $scope.selectedNode.catch.length - 1;
    if (lastCatch < 0) return false;
    return ($scope.selectedNode.catch[lastCatch].default !== undefined);
  };
  self.addCatchDefault = function() {
    if (self.hasDefault()) return;
    $scope.selectedNode.catch.push({default: []});
  };
  self.removeCatch = function(index) {
    $scope.selectedNode.catch.splice(index, 1);
  };
  self.moveUp = function(index) {
    if (index <= 0) return;
    var newCatches = [];
    $scope.selectedNode.catch.forEach(function(thisCatch, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index - 1) {
        newCatches.push($scope.selectedNode.catch[index]);
        newCatches.push(thisCatch);
      } else {
        newCatches.push(thisCatch);
      }
    });
    $scope.selectedNode.catch = newCatches;
  };
  self.moveDown = function(index) {
    if (index >= $scope.selectedNode.catch.length - 1) return;
    var newCatches = [];
    $scope.selectedNode.catch.forEach(function(thisCatch, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index + 1) {
        newCatches.push(thisCatch);
        newCatches.push($scope.selectedNode.catch[index]);
      } else {
        newCatches.push(thisCatch);
      }
    });
    $scope.selectedNode.catch = newCatches;
  };
  self.canMoveUp = function($index) {
    if ($scope.selectedNode.catch[$index].default !== undefined) return false;
    return $index > 0;
  };
  self.canMoveDown = function($index) {
    if ($scope.selectedNode.catch[$index].default !== undefined) return false;
    if (self.hasDefault()) return $index < $scope.selectedNode.catch.length - 2;
    return $index < $scope.selectedNode.catch.length - 1;
  };
};

angular.module('apiconnect-assembly').controller('CatchController', ['$scope', CatchController]);

function ErrorFilterController($scope) {
  var self = this;
  self.errors = {
    'ConnectionError': true,
    'SOAPError': true,
    'OperationError': true
  };

  $scope.selectedNode.$$stopOnError = ($scope.selectedNode['stop-on-error'] !== undefined);

  $scope.$watch('selectedNode.$$stopOnError', function() {
    if ($scope.selectedNode.$$stopOnError) {
      if (!$scope.selectedNode['stop-on-error'][0]) $scope.selectedNode['stop-on-error'] = [];
    } else {
      delete $scope.selectedNode['stop-on-error'];
    }
  });

  self.filter = function() {
    var search = this.searchText.toLowerCase();
    return Object.keys(self.errors).filter(function(error) {
      if (error.toLowerCase().indexOf(search) === -1) return false;
      if (!$scope.selectedNode['stop-on-error']) return true;
      return $scope.selectedNode['stop-on-error'].indexOf(error) < 0;
    });
  };
};

angular.module('apiconnect-assembly').controller('ErrorFilterController', ['$scope', ErrorFilterController]);

function CatchBlockController($scope) {
  var self = this;
  self.errors = {
    'ConnectionError': true,
    'JavaScriptError': true,
    'PropertyError': true,
    'RedactionError': true,
    'TransformError': true,
    'RuntimeError': true,
    'SOAPError': true,
    'OperationError': true,
    'BadRequestError': true,
    'UnauthorizedError': true,
    'ForbiddenError': true,
    'ValidateError': true
  };

  // bring in any errors defined on the policies themselves
  if ($scope.policies) {
    $scope.policies.forEach(function(policy) {
      if (policy.errors) {
        policy.errors.forEach(function(error) {
          self.errors[error] = true;
        });
      }
    });
  }

  var unwrapAndFlattenNodes;

  var flattenNodes = function(nodeArray, flattenedModel) {
    nodeArray.forEach(function(node) {
      if (node.$$type === "throw" && node.name) flattenedModel[node.name] = true;
      if (node.execute) unwrapAndFlattenNodes(node.execute, flattenedModel);
      if (node.otherwise) unwrapAndFlattenNodes(node.otherwise, flattenedModel);
      if (node.case) flattenNodes(node.case, flattenedModel);
    });
  };

  unwrapAndFlattenNodes = function(nodeArray, flattenedModel) {
    nodeArray.forEach(function(node) {
      var policyInstance = null;
      Object.keys(node).forEach(function(policyName) {
        policyInstance = node[policyName];
        if (policyInstance.$$type === "throw" && policyInstance.name) flattenedModel[policyInstance.name] = true;
        if (policyInstance.execute) unwrapAndFlattenNodes(policyInstance.execute, flattenedModel);
        if (policyInstance.case) flattenNodes(policyInstance.case, flattenedModel);
      });
    });
  };

  unwrapAndFlattenNodes($scope.nodes, self.errors);

  if (!$scope.catch.default && !$scope.catch.errors) $scope.catch.errors = [];
  if (!$scope.catch.default && !$scope.catch.execute) $scope.catch.execute = [];

  self.filter = function() {
    var search = this.searchText.toLowerCase();
    return Object.keys(self.errors).filter(function(error) {
      if (error.toLowerCase().indexOf(search) === -1) return false;
      // we match, so return true only if the operation isn't used elsewhere already
      for (var i = 0; i < $scope.selectedNode.catch.length; i++) {
        if ($scope.selectedNode.catch[i].default) continue;
        for (var j = 0; j < $scope.selectedNode.catch[i].errors.length; j++) {
          var usedError = $scope.selectedNode.catch[i].errors[j];
          if (error === usedError) return false;
        }
      }
      return true;
    });
  };
  self.isDefault = function() {
    return ($scope.catch.default !== undefined);
  };
};

angular.module('apiconnect-assembly').controller('CatchBlockController', ['$scope', CatchBlockController]);

function ValidationDefinitionController($scope) {
  var definitions = [{
    name: "request"
  },{
    name: "response"
  }];
  if ($scope.swaggerDocument.definitions) {
    Object.keys($scope.swaggerDocument.definitions).forEach(function(definition) {
      definitions.push({name: "#/definitions/" + definition});
    });
  }
  $scope.definitions = definitions;
};

angular.module('apiconnect-assembly').controller('ValidationDefinitionController', ['$scope', ValidationDefinitionController]);

function TLSProfileController($rootScope, $scope, SSLProfile) {
  var tlsProfiles = [];
  var tlsProfile = $scope.selectedNode['tls-profile'];

  if (!$rootScope.offlineMode) {
    SSLProfile.query({orgId: $rootScope.orgId}).$promise.then(function(profiles) {
      profiles.forEach(function(profile) {
        tlsProfiles.push({name: profile.title, value: profile.name});
      });
    });
  }

  this.tlsProfiles = tlsProfiles;

  $scope.$watch("selectedNode['secure-gateway']", function() {
    if ($scope.selectedNode['secure-gateway']) {
      $scope.tlsStyle = { color: '#e0e0e0' };
      tlsProfile = $scope.selectedNode['tls-profile'];
      delete $scope.selectedNode['tls-profile'];
    } else {
      $scope.selectedNode['tls-profile'] = tlsProfile;
      $scope.tlsStyle = {};
    }
  });
};

angular.module('apiconnect-assembly').controller('TLSProfileController', ['$rootScope', '$scope', 'SSLProfile', TLSProfileController]);

function UserRegistryController($rootScope, $scope, UserRegistry) {
    var userRegistries = [];
    if (!$rootScope.offlineMode) {
        UserRegistry.query({orgId: $rootScope.orgId}).$promise.then(function(registries) {
            registries.forEach(function(registry) {
                userRegistries.push({name: registry.title, value: registry.name});
            });
        });
    }
    this.userRegistries = userRegistries;
};

angular.module('apiconnect-assembly').controller('UserRegistryController', ['$rootScope', '$scope', 'UserRegistry', UserRegistryController]);

function SetVariableController($scope) {
  var self = this;
  self.addAction = function() {
    $scope.selectedNode.actions.push({
      set: "",
      value: ""
    });
  };
  self.removeAction = function($index) {
    $scope.selectedNode.actions.splice($index, 1);
  };
};

angular.module('apiconnect-assembly').controller('SetVariableController', ['$scope', SetVariableController]);

function SetVariableActionController($scope) {
  var self = this;

  $scope.valueType = "string";
  if ($scope.action.value !== undefined) {
    if (typeof $scope.action.value === "boolean") {
      $scope.valueType = "boolean";
    } else if (typeof $scope.action.value === "number") {
      $scope.valueType = "number";
    }
  }
  if ($scope.action.add) {
    $scope.actionValue = 'add';
  } else if ($scope.action.clear) {
    $scope.actionValue = 'clear';
  } else {
    $scope.actionValue = 'set';
  }
  var firstWatch = false;
  $scope.$watch('actionValue', function() {
    if (!firstWatch) {
      firstWatch = true;
      return;
    }
    // no value field for a clear
    if ($scope.actionValue === 'clear') {
      delete $scope.action.value;
    }

    // keep any previously entered action value
    ['set', 'add', 'clear'].forEach(function(actionValue) {
      if (actionValue === $scope.actionValue) return;
      if ($scope.action[actionValue] !== undefined) {
        $scope.action[$scope.actionValue] = $scope.action[actionValue];
        delete $scope.action[actionValue];
      }
    });
  });
  self.modifyValue = function() {
    if ($scope.valueType === "boolean" && typeof $scope.action.value !== "boolean") {
      $scope.action.value = true;

    } else if ($scope.valueType === "number" && typeof $scope.action.value !== "number") {
      $scope.action.value = 0;

    } else if ($scope.valueType === "string" && typeof $scope.action.value !== "string") {
      $scope.action.value = "";
    }
  };
};

angular.module('apiconnect-assembly').controller('SetVariableActionController', ['$scope', SetVariableActionController]);

function RedactController($scope) {
  var self = this;
  self.addRedact = function() {
    $scope.selectedNode.actions.push({from: [], action: 'redact'});
  };
  self.removeRedact = function($index) {
    $scope.selectedNode.actions.splice($index, 1);
  };
};

angular.module('apiconnect-assembly').controller('RedactController', ['$scope', RedactController]);

function RedactItemController($scope) {
  this.allFields = function() {
    if (!$scope.action.from) return false;
    return ($scope.action.from.length === 1 && $scope.action.from[0] === 'all');
  };
  $scope.$watch('action.from', function() {
    if (!$scope.action.from) return;
    if ($scope.action.from.indexOf('all') > -1 && $scope.action.from.length > 1) $scope.action.from = ['all'];
  }, true);
};

angular.module('apiconnect-assembly').controller('RedactItemController', ['$scope', RedactItemController]);


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

// Node module: apiconnect-assembly

'use strict';

angular.module('apiconnect-assembly-test', ['apiconnect-assembly']).controller('AssemblerTestController', ['$scope', '$rootScope', '$q', '$filter', '$http', 'Product', 'Gateway', 'ProductUtil', 'DeployedProduct', 'ProviderApp', 'ProviderAppSubscription', 'TestCallGenerator', 'SwaggerOAuth', 'AssemblerTracking', 'GatewayCluster', function($scope, $rootScope, $q, $filter, $http, Product, Gateway, ProductUtil, DeployedProduct, ProviderApp, ProviderAppSubscription, TestCallGenerator, SwaggerOAuth, AssemblerTracking, GatewayCluster) {

	var self = this;

	$scope.environments = $rootScope.environments;
	$scope.publishTargets = $rootScope.publishTargets;
	$scope.matchingGwServices = [];

	$scope.offlineMode = $rootScope.offlineMode;

	if (!$scope.offlineMode) {
		$scope.dataPowerGateways = GatewayCluster.query();

		$q.all([$scope.dataPowerGateways.$promise]).then(function(){
			$scope.gateways = $scope.dataPowerGateways;
			self.restoreSetup(); // Run setup once gateways have loaded
		});
	}

	$scope.scopes = {};
	$scope.authToken = {};

	// auto-transition from setup to test on first load
	$scope.autoTransition = true;

	if ($scope.offlineMode) {
		$scope.clientId = "default";
		$scope.clientSecret = "SECRET";
	}
	$scope.$watch('application', function() {
		if ($scope.application && $scope.application.credentials) {
			$scope.clientId = $scope.application.credentials.clientID;
		}
	});

	// set up defaults
	$scope.currentPage = ($rootScope.offlineMode) ? 2 : 1;
	$scope.repeater = {
		repeat: false,
		count: 10,
		stopOnError: true
	};

	$scope.$on('api_is_dirty', function(event, isDirty) {
		// if the new isDirty flag given here is the same as the one we already have, then we don't need to do anything
		if (isDirty === $scope.apiDirty) {
		    return;
		}

		$scope.apiDirty = isDirty;

		if (!isDirty) {
			// API has been saved...
			$scope.saveSinceLastPublish = true;


			// if we've already got a request for the gateways in flight, let's not make another call
			if ($scope.secureGateways && $scope.secureGateways.$promise && $scope.secureGateways.$resolved === false) {
				return;
			}

			// after the API has been saved, check the swagger and see if the API needs a secure gateway
			self.secureGatewaySetup();

			// if the API needs a secure gateway, get secure gateways, and set the page back to 1
			if($scope.secureGatewayDeploymentInfo.length > 0) {
				$scope.secureGateways = Gateway.query({
					orgId: $rootScope.orgId
				});

				$scope.secureGateways.$promise.then(function() {
					self.setCurrentPage(1);
				});
			}
		}
	});

	$scope.testLoaded = $rootScope.offlineMode;

	self.restoreSetup = function() {
		if ($scope.offlineMode) { return; }
		if (!$scope.gateways) { return; } // If gateways aren't loaded yet.

		if (typeof localStorage === "undefined") { return; }

		// target
		var target = localStorage.getItem('apim.test.target');
		if (target) {
			target = angular.fromJson(target);
			var matchingTargets = $scope.publishTargets.filter(function(candidateTarget) {
				return (candidateTarget.environmentId === target.environmentId && candidateTarget.spaceId === target.spaceId);
			});
			if (matchingTargets.length > 0) {
				$scope.target = matchingTargets[0];
				var matchingCatalogs = $scope.environments.filter(function(environment) {
					return (environment.id === $scope.target.environmentId);
				});
				if (matchingCatalogs.length > 0 ) {
					$scope.catalog = matchingCatalogs[0];
				}
			} else {
				if ($scope.publishTargets.length > 0 ) {
					$scope.target = $scope.publishTargets[0];
					self.targetChange();				
				} else {
					$scope.target = null;
					self.targetChange();
				}
				
			}
		} else {
			$scope.target = $scope.publishTargets[0];
			self.targetChange();
		}

		// gateway
		self.gwServiceChange();

		// product
		var productId = localStorage.getItem('apim.test.product');
		if (productId) {
			var sections = productId.split(':');
			var matchingProducts = $scope.products.filter(function(product) {
				return (product.info.name === sections[0] && product.info.version === sections[1]);
			});
			if (matchingProducts.length > 0) {
				$scope.product = matchingProducts[0];
				$scope.productContainsApi = ProductUtil.containsApi($scope.product, $scope.swaggerDocument);
			}
		}

		// product
		var planName = localStorage.getItem('apim.test.plan');
		if ($scope.product && planName && $scope.product.plans[planName]) { $scope.plan = planName; }

		// application
		var appId = localStorage.getItem('apim.test.application');
		if (appId) {
			$scope.$watch('applications', function() {
				if (!$scope.applications) { return; }
				var matchingApps = $scope.applications.filter(function(application) {
					return (application.id === appId);
				});
				if (matchingApps.length > 0) {
					$scope.application = matchingApps[0];
					if ($scope.secureGatewayDeploymentInfo.length === 0 && $scope.target && $scope.product && $scope.plan) {
						if ($scope.autoTransition) { $scope.currentPage = 2; }
					}
				}
			});
		}

		// if we have a target and product selected, and either:
		// the catalog has a test app enabled, or
		// we have both a plan and an application selected...
		// start on the test page, not the setup page
		if ($scope.secureGatewayDeploymentInfo.length === 0 && $scope.target && $scope.product && ($scope.catalog.testAppEnabled || ($scope.plan && $scope.application))) {
			if ($scope.autoTransition) { $scope.currentPage = 2; }
		}

		$scope.testLoaded = true;
	};

	self.secureGatewaySetup = function() {
		$scope.needSecureGatewaySetup = false;
		$scope.secureGatewayDeploymentInfo = [];

		if ($scope.offlineMode) { return; }

		var config = $scope.swaggerDocument[$scope.config.property];

		if (!config) { return; }

		var assembly = config.assembly;

		if (!assembly) { return; }

		var execute = assembly.execute || [];

		for(var i = 0; i < execute.length; i++) {
			var secureGatewayInfo = {
				gateway: '',
				apiId: $scope.swaggerDocument.info["x-ibm-name"] + ":" + $scope.swaggerDocument.info.version,
				spaceGUID: $rootScope.bluemixExternalSpaceId,
				orgGUID: $rootScope.bluemixExternalOrgId
			};

			if(execute[i].hasOwnProperty('invoke') && execute[i].invoke['secure-gateway']) {
				secureGatewayInfo.destination = execute[i].invoke['target-url'];
				$scope.secureGatewayDeploymentInfo.push(secureGatewayInfo);
				$scope.needSecureGatewaySetup = true;
			} else if(execute[i].hasOwnProperty('proxy') && execute[i].proxy['secure-gateway']) {
				secureGatewayInfo.destination = execute[i].proxy['target-url'];
				$scope.secureGatewayDeploymentInfo.push(secureGatewayInfo);
				$scope.needSecureGatewaySetup = true;
			}
		}
	};

	self.setCurrentPage = function(page) {
		$scope.currentPage = page;

		if (page === 1 && $scope.target.spaceId) { // Reset test environment when going back to page 1 with spaces enabled
			$scope.selectedOperation = undefined;
			$scope.operation = undefined;
			$scope.response = undefined;
		}
		if (page === 3) {
			$scope.setTestMode(true, true);
		} else {
			$scope.setTestMode(true, false);
		}
		$scope.autoTransition = false;
		if (page === 2) {
			self.updateConfig();
		}
	};

    // I'm sorry
    function getScopes() {
        if (!$scope.scopes) return [];
        var selectedScopes = [];
        Object.keys($scope.scopes).forEach(function(scope) {
            if ($scope.scopes[scope]) selectedScopes.push(scope);
        });
        return selectedScopes;
    };

	// check security requirements
	self.updateConfig = function() {
		if (!$scope.operation) return;
		self.config = TestCallGenerator.getConfigurationForOperation($scope.operation, $scope.path, $scope.swaggerDocument, $scope.securityFlow);
		// pre-select all scopes
		if (self.config.oauthScopes) {
			self.config.oauthScopes.forEach(function(scope) {
				$scope.scopes[scope] = true;
			});
		}

		// send debug header for assembly when not in offline mode
		self.config.sendDebugHeader = !$scope.offlineMode;
	};

	self.config = {};
	$scope.updateConfigForOperation = function() {
		if ($scope.selectedOperation) {
			$scope.setOperationFilter($scope.selectedOperation);
			var operationRef = $scope.selectedOperation;
			if (typeof $scope.selectedOperation === "string") { operationRef = $scope.operationMap[$scope.selectedOperation]; }
			if ($scope.selectedOperation.operationId) { operationRef = $scope.operationMap[$scope.selectedOperation.operationId]; }
			$scope.operationRef = operationRef;
			var operation = $scope.swaggerDocument.paths[operationRef.path][operationRef.verb];

			$scope.operation = operation;

			$scope.path = $scope.swaggerDocument.paths[operationRef.path];

			if ($scope.swaggerDocument.schemes) {
				$scope.schemes = $scope.swaggerDocument.schemes;
			} else {
				$scope.schemes = ["https"];
			}
			$scope.scheme = $scope.schemes[0];

			var defaultHost = localStorage.getItem('apim_local_gateway');
			if (!defaultHost) { defaultHost = $scope.scheme + "://localhost:4001"; }

			var baseUrl = "";
			
			// if this is unenforced, try to use the host field
			if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].enforced === false) {
				baseUrl = ($scope.swaggerDocument.host) ? $scope.scheme + "://" + $scope.swaggerDocument.host : defaultHost;
			} else if ($scope.catalog && $scope.catalog.gwServices && $scope.catalog.gwServices.length > 0) {
				if (!$scope.gwServiceTarget) { // No spaces / gateways, use default
					baseUrl = $scope.catalog.gwServices[0].endpointUrl;
				}
				else {
					// Find gateway service id given gateway service Name
					var gwServiceTargetId;
					$scope.gateways.forEach(function(candidateGateway) {
						if (candidateGateway.name === $scope.gwServiceTarget) {
							gwServiceTargetId = candidateGateway.id;
						}
					});

					// Find gateway endpointUrl given gateway service id
					$scope.catalog.gwServices.forEach(function(candidateService) {
						if (candidateService.id === gwServiceTargetId) {
							baseUrl = candidateService.endpointUrl;
						}
					});
				}
			} else if ($scope.catalog && $scope.catalog.customBaseUrl) {
				baseUrl = $scope.catalog.customBaseUrl;
			} else if ($scope.catalog && $scope.catalog.baseUrl) {
				baseUrl = $scope.catalog.baseUrl;
			} else {
				baseUrl = defaultHost;
			}

			var urlSuffix = $scope.swaggerDocument.basePath;
			if (!urlSuffix) { urlSuffix = "/"; }
			if (_.endsWith(urlSuffix, "/") && _.startsWith(operationRef.path, "/")) {
				urlSuffix = urlSuffix.substring(0, urlSuffix.length - 1) + operationRef.path;
			} else {
				urlSuffix += operationRef.path;
			}
			var targetUrlTemplate = baseUrl + urlSuffix;

			// is this SOAP? if so, ditch the operationId from the end...
			if ($scope.operation['x-ibm-soap'] && $scope.operation.operationId && _.endsWith(targetUrlTemplate, "/" + $scope.operation.operationId)) {
				targetUrlTemplate = targetUrlTemplate.substring(0, targetUrlTemplate.length - ($scope.operation.operationId.length + 1));
			}

			$scope.targetUrlTemplate = targetUrlTemplate;

			self.updateConfig();

			// seed scopes if required
			if (self.config.requiresOauth && self.config.oauthScopes) {
				$scope.scopes = self.config.oauthScopes;
			}
		}
	};

	$scope.$watch('selectedOperation', $scope.updateConfigForOperation);
	$scope.$watch('securityFlow', self.updateConfig);

	self.invoke = function() {
		TestCallGenerator.invoke($scope, self.config, $scope.repeater);
	};
	
	$scope.setAuthToken = function(data) {
		$scope.authToken = data;
	};

	$scope.setAuthCode = function(data) {
		$scope.authCode = data;
	};

	$scope.setAuthError = function(error) {
		$scope.authError = error;
	};

	$scope.clearAuthError = function() {
		delete $scope.authError;
	};


    self.authorize = function() {
        var scopes = getScopes();
        $scope.clearAuthError();
        SwaggerOAuth.authorize(self.config, $scope.clientId, $scope.clientSecret, scopes, $scope.username, $scope.password, $scope.redirectUri).then(function(response) {
          angular.extend($scope.authToken, response.data);
        }, function(error) {
          $scope.setAuthError(error);
        });
    };

    self.getToken = function() {
        var scopes = getScopes();
		$scope.clearAuthError();
        SwaggerOAuth.getToken(self.config, $scope.authToken, $scope.clientId, $scope.clientSecret, scopes, $scope.redirectUri).then(function(response) {
            angular.extend($scope.authToken, response.data);
        }, function(error) {
			$scope.setAuthError(error);
        });
    };

    self.refreshToken = function() {
		$scope.clearAuthError();
        SwaggerOAuth.refreshToken(self.config, $scope.authToken, $scope.clientId, $scope.clientSecret).then(function(data) {
            console.log(data);
        }, function(error) {
			$scope.setAuthError(error);
        });
    };

	var appsLoaded = false;
	var productsLoaded = false;

	self.refreshApps = function() {
		$scope.xhrProcessing = true;
		$scope.applications = ProviderApp.query({
			orgId: $rootScope.orgId,
			envId: $scope.catalog.id
		});
		$scope.applications.$promise.then(function() {
			$scope.xhrProcessing = false;
			appsLoaded = true;
			if (productsLoaded) { self.restoreSetup(); }
		});
	};

	$scope.$watch('catalog', function() {
		if (!$scope.catalog) { return; }
		if ($scope.catalog.testAppEnabled === true && $scope.catalog.testAppCredentials) {
			// we have test app credentials - further setup not required
			$scope.testAppCredentials = true;
			delete $scope.application;
			delete $scope.plan;
			$scope.clientId = $scope.catalog.testAppCredentials.clientId;
			$scope.clientSecret = $scope.catalog.testAppCredentials.clientSecret;
		} else {
			delete $scope.clientSecret;
			self.refreshApps();
			self.refreshDeployedProducts();
		}
	});

	self.refresh = function() {
		$scope.xhrProcessing = true;

		$scope.products = Product.query({orgId: $rootScope.orgId});

		$scope.products.$promise.then(function() {
			self.secureGatewaySetup();

			if($scope.secureGatewayDeploymentInfo.length > 0) {
				$scope.secureGateways = Gateway.query({
					orgId: $rootScope.orgId
				});

				return $scope.secureGateways.$promise;
			}
		}).then(function() {
			$scope.xhrProcessing = false;
			productsLoaded = true;
			self.restoreSetup();
		});
	};
	self.refresh();

	self.refreshDeployedProducts = function() {
		$scope.deployedProducts = DeployedProduct.query({
			orgId: $rootScope.orgId,
			envId: $scope.catalog.id
		});
	};

	self.createAndPublishProduct = function() {
		if ($scope.productName && $scope.target) {
			// #1 create a new product and plan containing this API
			var newProduct = {
				product: "1.0.0",
				info: {name: $rootScope.generateName($scope.productName), title: $scope.productName, version: "1.0.0"},
				apis: {},
				plans: {}
			};
			newProduct.apis[$scope.swaggerDocument.info["x-ibm-name"]] = {
				name: $scope.swaggerDocument.info["x-ibm-name"] + ":" + $scope.swaggerDocument.info.version
			};
			newProduct.plans['default'] = {
				title: $filter('translate')("product_default_plan_name")
			};
			var product = new Product(newProduct);
			$scope.creatingProduct = true;
			product.$create({orgId: $rootScope.orgId}).then(function(product) {
				$scope.product = product;
				AssemblerTracking.track('assembly', 'createdProduct');
				self.productChange();
				self.republishProduct();
			}, function() {
				$scope.creatingProduct = false;
			});
		}
	};

	self.republishProduct = function() {
		$scope.republishingProduct = true;
		var url = "";
		if ($scope.target.type === "SPACE") {
			url = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/spaces/' + $scope.target.spaceId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version;
		} else {
			url = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version;
		}
		$http.post(url)
			.success(function() {
				self.refreshDeployedProducts();
				var visibilityData = {};

				if ($scope.product.visibility) {
					visibilityData = {
						visibility: $scope.product.visibility
					};
				} else {
					visibilityData = {
						visibility: {
							view: {
								enabled: true,
								type: "public"
							},
							subscribe: {
								enabled: true,
								type: "authenticated"
							}
						}
					};
				}

				if($scope.secureGatewayDeploymentInfo.length > 0) {
					visibilityData.secureGatewayDeploymentInfo = $scope.secureGatewayDeploymentInfo;
				}

				var publishURL = "";

				if ($scope.target.type === "SPACE") {
					publishURL = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/spaces/' + $scope.target.spaceId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version + '/publish';
				} else {
					publishURL = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version + '/publish';
				}

				$http.post(publishURL, visibilityData).success(function() {
					$scope.republishingProduct = false;
					$scope.creatingProduct = false;
					$scope.saveSinceLastPublish = false;
					delete $scope.productNotPublished;
					AssemblerTracking.track('assembly', 'republishedProduct');
				}).error(function() {
					$scope.republishingProduct = false;
					$scope.creatingProduct = false;
					$scope.xhrProcessing = false;
					delete $scope.productNotPublished;
				});
			}).error(function() {
				$scope.creatingProduct = false;
				$scope.republishingProduct = false;
				$scope.xhrProcessing = false;
			});
	};

	self.addApiToProduct = function() {
		if (!$scope.product) { return; }
		var apiName = $scope.swaggerDocument.info['x-ibm-name'] || $scope.swaggerDocument.info.title;
		if (!$scope.product.apis) { $scope.product.apis = {}; }
		var suffix = 1;
		var apiNameBase = apiName;
		while($scope.product.apis[apiName]) {
			apiName = apiNameBase + "_" + suffix;
			suffix++;
		}
		$scope.product.apis[apiName] = {
			name: apiNameBase + ":" + $scope.swaggerDocument.info.version
		};
		// do we need to explicitly add it to the plan?
		if ($scope.product.plans[$scope.plan] && !_.isEmpty($scope.product.plans[$scope.plan].apis)) {
			// yes we do...
			$scope.product.plans[$scope.plan].apis[apiName] = {};
		}
		$scope.republishingProduct = true;
		$scope.product.$save({
			orgId: $rootScope.orgId,
			productVersion: $scope.product.info.name + ":" + $scope.product.info.version
		}).then(function() {
			$scope.republishingProduct = false;
			$scope.productContainsApi = true;
		}, function() {
			$scope.republishingProduct = false;
			$scope.productContainsApi = true;
		});
	};

	self.createAndSubscribeApp = function() {
		if (!$scope.appName) { return; }
		$scope.creatingApp = true;
		$http.post('proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/providerApps', {name: $scope.appName})
			.success(function(app) {
				$scope.application = app;
				$scope.applicationCreated = true;
				self.applicationChange();
				self.subscribeApp();
			}).error(function() {
				$scope.creatingApp = false;
			});
	};

	self.subscribeApp = function() {
		if (!$scope.application) { return; }
		$scope.subscribingApp = true;
		var deployedProduct = $scope.deployedProducts.filter(function(product) {
			return (product.productName === $scope.product.info.name && product.productVersion === $scope.product.info.version);
		});
		if (deployedProduct.length < 1) {
			$scope.productNotPublished = true;
			$scope.subscribingApp = false;
			return;
		}
		var planURL = deployedProduct[0].url + "/plans/" + $scope.plan;
		$http.post('proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/providerApps/' + $scope.application.id + '/subscriptions',
			{planURL: planURL})
			.success(function() {
				$scope.creatingApp = false;
				$scope.subscribingApp = false;
			}).error(function() {
				$scope.creatingApp = false;
				$scope.subscribingApp = false;
			});
	};

	self.targetChange = function() {
		if (!$scope.target) { return; }
		if (typeof localStorage === "undefined") { return; }
		$scope.catalog = $scope.environments.filter(function(environment) {
			return (environment.id === $scope.target.environmentId);
		})[0];
		localStorage.setItem('apim.test.target', angular.toJson($scope.target));

		self.gwServiceChange(true);
	};

	self.gwServiceChange = function(targetChanged) {
		if ($scope.offlineMode) { return; }
		if (!$scope.target) { return; }
		if (typeof localStorage === "undefined") { return; }
		if (!$scope.target.spaceId) { return; } // When no spaces are present

		var matchingSpace = $scope.catalog.spaces.filter(function(candidateSpace) {
			return (candidateSpace.id === $scope.target.spaceId);
		});

		if (targetChanged || $scope.matchingGwServices.length === 0) {
			$scope.matchingGwServices = [];

			var services = matchingSpace[0].gwServices;

			if (!services) { // No service assigned to space
				$scope.gwServiceTarget = "";
				return;
			}

			services.forEach(function(service) {
				$scope.gateways.forEach(function(candidateGateway) {
					if (candidateGateway.id === service) {
						$scope.matchingGwServices.push(candidateGateway); //Find matching services
					}
				});
			});

			$scope.gwServiceTarget = $scope.matchingGwServices[0].name; //Auto select first gateway service
		}
	};

	self.secureGatewayDeploymentInfoChange = function() {
		if (!$scope.secureGatewayDeploymentInfo) { return; }

		var numberOfGatewaysNotAssigned = 0;

		for(var i = 0; i < $scope.secureGatewayDeploymentInfo.length; i++) {
			if($scope.secureGatewayDeploymentInfo[i].gateway.length === 0) {
				numberOfGatewaysNotAssigned++;
			}
		}

		if(numberOfGatewaysNotAssigned === 0) {
			$scope.needSecureGatewaySetup = false;
		}
	};

	self.productChange = function() {
		if (!$scope.product) { return; }
		// default the plan to the first in the product
		var plans = Object.keys($scope.product.plans);
		if (plans.length > 0) {
			$scope.plan = plans[0];
			self.planChange();
		}
		delete $scope.productNotPublished;
		$scope.productContainsApi = ProductUtil.containsApi($scope.product, $scope.swaggerDocument);
		if (typeof localStorage === "undefined") { return; }
		localStorage.setItem('apim.test.product', $scope.product.info.name + ':' + $scope.product.info.version);
	};

	self.planChange = function() {
		if (!$scope.plan) { return; }
		if (typeof localStorage === "undefined") { return; }
		localStorage.setItem('apim.test.plan', $scope.plan);
	};

	self.applicationChange = function() {
		if (!$scope.application) { return; }
		if (typeof localStorage === "undefined") { return; }
		localStorage.setItem('apim.test.application', $scope.application.id);
		$scope.clientId = $scope.application.credentials.clientID;
	};

	self.operationChange = function() {
		if (!$scope.selectedOperation) { return; }
		if (typeof localStorage === "undefined") { return; }
		$scope.parameterValues = {};
		localStorage.setItem('apim.test.operation', $scope.selectedOperation.verb + ' ' + $scope.selectedOperation.path);
	};

	self.loadDebugData = function() {
		delete $scope.debugData;
		if (!$scope.response || !$scope.response.transactionId) {return; }
		$scope.loadingDebugData = true;
		$http.get("proxy/orgs/" + $rootScope.orgId + '/analytics/query?eventType=apievent&fields=ALL&size=1000&sort=datetime&timeRange=QUARTER&timeZoneOffset=0&queryString=debug.transid:"' + $scope.response.transactionId + '"').then(
			function(data) {
				$scope.loadingDebugData = false;
				if (data.data && data.data.hits && data.data.hits.length > 0 && data.data.hits[0].debug) {
					$scope.debugData = data.data.hits[0].debug;
				}
			},
			function() {
				$scope.loadingDebugData = false;
			}
		);
	};

	self.focusIndex = -1;
	self.previousPolicy = function() {
		if (self.focusIndex < 0) { return; }
		self.focusIndex--;
		if (self.focusIndex === -1) {
			$("apim-assembler")[0].focus();
		}
		if (self.focusIndex === 0) {
			$("apim-assembler .inputNode")[0].focus();
		}
		// else try to find the policy with the correct name...
		$("apim-assembler apim-node .policyName:contains(PROXY)").parent();
	};

	self.nextPolicy = function() {
		self.focusIndex++;
		if (self.focusIndex === 0) {
			$("apim-assembler .inputNode")[0].focus();
		}
	};

	function getDebugDataByName(name) {
		var filtered = $scope.debugData.filter(function(data) {
			return (data.name === name);
		});
		if (filtered.length > 0) { return filtered[0]; }
		return null;
	}

	self.showDebugForNode = function(event, node) {
		// try to tie the selected node to an entry in debug data
		var debugData;
		if (node === 'input') {
			debugData = getDebugDataByName('Request');
			if (!debugData) { debugData = getDebugDataByName('API Information'); }
		} else if (node === 'output') {
			debugData = getDebugDataByName('Response');
		} else {
			debugData = getDebugDataByName(node.$$type);
			// do something hacky for now
			if (node.title && node.title.toLowerCase().indexOf("proxy") > -1) {
				// probably a proxy then...
				debugData = getDebugDataByName("Assembly Proxy");
			}
		}
		if (debugData && debugData.name) {
			// scroll into view
			$scope.selectedDebugData = debugData;
			$("apim-assembly-test .testItemHeader:contains(" + debugData.name + ")")[0].scrollIntoView();
		}
	};

	$scope.$on('node-selected', self.showDebugForNode);

}]);

angular.module('apiconnect-assembly-test').controller('AssemblerTestParameterController', ['$scope', function($scope) {

	var self = this;

	$scope.canGenerate = true;
	if ($scope.parameter && $scope.parameter.format === "JSON") {
		// generator doesn't know this type...
		$scope.canGenerate = false;
	}
    if ($scope.parameter && $scope.parameter.type === "boolean") {
        // generating booleans isn't very valuable...
        $scope.canGenerate = false;
    }

	// take a copy of the schema so we can de-ref for display without touching the model
	if ($scope.parameter && $scope.parameter.schema) {
		$scope.schema = angular.copy($scope.parameter.schema);
		if ($scope.schema.example) { $scope.parameterValues[$scope.parameter.name] = $scope.schema.example; }
	}

	var path = ($scope.operationRef) ? $scope.operationRef.path : $scope.pathName;
	var verb = ($scope.operationRef) ? $scope.operationRef.verb : $scope.verb;

	self.generateExample = function() {
		$scope.parameterValues[$scope.parameter.name] = window.exampleGenerator.generateExampleParameter($scope.swaggerDocument, path, verb, $scope.parameter, $scope.contentTypeHeader);
	};

}]);

angular.module('apiconnect-assembly-test').controller('AssemblyTestDebugDataController', ['$scope', function($scope) {

	$scope.yamlValue = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.data)), {lineWidth: -1});;

}]);


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly').factory('Assembly', ['$resource',
    function ($resource) {
      return $resource('proxy/orgs/:orgId/assemblies/:assemblyId/', {}, {
        query: {
          method: 'GET',
          params: {
            orgId: '@orgId'
          },
          isArray: true
        },
        get: {
          method: 'GET',
          params: {
            orgId: '@orgId',
            assemblyId: '@assemblyId'
          },
          isArray: false
        },
        update: {
          method: 'PUT',
          params: {
            orgId: '@orgId',
            assemblyId: '@assemblyId'
          },
          isArray: false
        }
      });
    }
  ]).factory('Path', function () {
    return function (path, dimensionality, container, type) {
      var self = this;
      self.path = path;
      if (typeof dimensionality === "string") {
        dimensionality = JSON.parse(dimensionality);
      }
      self.dimensionality = dimensionality;
      self.container = container;
      self.type = type;

      // var unnamed = "$item";
      // var unnamedRe = new RegExp("\\$item", "g");

      self.getPath = function () {
        return path;
      };

      // getDimensionality
      // get the dimension of the given path
      // items[0].items[2].name has dimension 2 - two nested arrays
      self.getDimensionality = function () {
        return self.dimensionality.length;
      };

      self.getType = function () {
        return self.type;
      };

      return self;
    };
  }).factory('Map', ['SchemaReferences', function (SchemaReferences) {
    return function (map, definitions, callback) {
      var self = this,
        model = [];

      self.readOnly = !!map.$$readOnly || !!map.$$parentReadOnly;

      function processMapping(mapping) {
        if (mapping.actions) {
          // go deeper
          mapping.actions.forEach(function (nextMapping) {
            nextMapping.$$parent = mapping;
            processMapping(nextMapping);
          });
        } else {
          // we're at a root
          var foreach = [],
            source = angular.copy(mapping.from),
            target = mapping.set || mapping.create,
            parentMapping = mapping;

          if (typeof source === "string") {
            source = [source];
          }
          var merge = false;
          while (parentMapping.$$parent) {
            parentMapping = parentMapping.$$parent;
            if (source) {
              for (var i = 0; i < source.length; i++) {
                if (source[i].indexOf("#/") !== 0) {
                  // if the source is not absolute, prepend the context
                  source[i] = (parentMapping.foreach || parentMapping.source) + "." + source[i];
                } else {
                  merge = true;
                }
              }
            }
            target = (parentMapping.set || parentMapping.create) + "." + target;
            foreach.splice(0, 0, {
              source: (parentMapping.foreach || parentMapping.source),
              target: (parentMapping.set || parentMapping.create)
            });
          }
          var item = {
            target: target
          };
          if (source) {
            item.source = source;
          }
          if (mapping.create) {
            item.$$create = true;
          }

          if (merge === true) {
            item.merge = true;
          }

          if (mapping.value) {
            item.value = mapping.value;
          }
          if (mapping.default !== undefined) {
            item.default = mapping.default;
          }
          if (foreach.length > 0) {
            item.foreach = foreach;
          }
          model.push(item);
        }
      }

      if (map.actions) {
        map.actions.forEach(function (mapping) {
          processMapping(mapping);
        });
      }

      self.getMapping = function (targetPath) {
        var filtered = model.filter(function (mapping) {
          return mapping.target === targetPath;
        });
        if (filtered.length > 0) {
          return filtered[0];
        }
        return null;
      };

      // determine if a given path has a mapping
      // if a path is mapped, return the mapping for that path
      // direct parameter (defaults to true) - only consider a direct mapping
      // as true - sub-element mappings would not be considered true
      // otherwide return null
      self.hasMapping = function (path) {
        if (self.getMapping(path.getPath()) !== null) {
          return true;
        } else {
          return (self.getMapping(path.getPath() + ".$item") !== null);
        }
      };

      // gets the mapping for this path, creating where necessary
      self.getMappingForPath = function (path) {
        return self.getMapping(path.getPath());
      };

      // gets the mapping for this path, creating where necessary
      self.setMappingForPath = function (targetPath, sourcePath) {
        var mapping = self.getMapping(targetPath.getPath());

        // subtle case - if the user has set a default value on the target
        // path already, and that target path resides within an array, it's
        // hard to retro-fit the existing mapping with all the necessary
        // foreach iterators. But the existing mapping is simpley a default
        // value string, so the simplest thing to do is to remember the default,
        // clear out the existing mapping, and recreate it with the default value.
        // It's an edge case, so get it out of the way...
        var defaultValue;
        if (mapping &&
          mapping.default !== undefined &&
          mapping.foreach &&
          mapping.foreach.length > 0 &&
          !mapping.foreach[0].source) {
          // this is such a mapping...
          defaultValue = mapping.default;
          self.deleteMappingForPath(targetPath);
          mapping = null;
        }

        // now continue as normal, safe in the knowledge that that awkward
        // case is no longer lying around to trip us up
        if (mapping) {
          if (sourcePath) {
              if (!mapping.source) mapping.source = [];
              mapping.source.push(sourcePath.getPath());
          }
        } else {
          mapping = {
            target: targetPath.getPath()
          };
          if (sourcePath) {
            mapping.source = [sourcePath.getPath()];
          }
          // re-instate any previously set defaultValue from the edge case above
          if (defaultValue) {
            mapping.default = defaultValue;
          }

          // do we have any dimensionality to address?
          var foreach = [];
          if (targetPath.getDimensionality() > 0) {
            // indeed we do...
            // take a simple approach and map each level on the source to the equivalent on the right
            // this will be right most of the time, I swear...
            var index = 0,
              targetContext = "",
              sourceContext = "";
            while (index < targetPath.getDimensionality()) {
              var sourceDimension = "$item";
              if (sourcePath) {
                if (sourcePath.getDimensionality() > index) {
                  sourceDimension = sourcePath.dimensionality[index].replace(sourceContext, "");
                  sourceContext = sourcePath.dimensionality[index] + ".";
                } else {
                  sourceDimension = sourcePath.getPath();
                }
              }
              // if there is no sourcePath, there is nothing to iterate over
              var foreachObj = {
                target: targetPath.dimensionality[index].replace(targetContext, "")
              };
              if (sourcePath) foreachObj.source = sourceDimension;
              foreach.push(foreachObj);
              targetContext = targetPath.dimensionality[index] + ".";
              index++;
            }
          }
          if (foreach.length > 0) {
            mapping.foreach = foreach;
          }
          model.push(mapping);
        }
        callback(self.getActions());
        return mapping;
      };

      self.deleteMappingForPath = function (targetPath) {
        self.deleteMapping(targetPath.getPath());
      };

      self.deleteMapping = function (targetPath) {
        model = model.filter(function (mapping) {
          return (mapping.target !== targetPath);
        });
        callback(self.getActions());
      };

      function serializeMapping(mapping, actions) {
        var action = {},
          contextualizedSources = [];
        if (!mapping.foreach || mapping.foreach.length === 0) {
          // simple case
          // are we within a target context?
          var target = (mapping.targetContext) ? mapping.target.replace(mapping.targetContext + ".", "") : mapping.target;
          // are we mapping something simple within a target context?
          if (mapping.targetContext === mapping.target) {
            target = "$item";
          }
          action[(mapping.$$create) ? "create" : "set"] = target;
          if (mapping.source) {
            mapping.source.forEach(function (source) {
              var contextualizedSource = (mapping.sourceContext) ? source.replace(mapping.sourceContext + ".", "") : source;
                            
              if (contextualizedSource.indexOf(".$item") > 0) {
                  contextualizedSource = contextualizedSource.replace(".$item", "");
              } else if (contextualizedSource.indexOf("$item.") === 0) {
                  contextualizedSource = contextualizedSource.replace("$item.", "");
              }
              
              contextualizedSources.push(contextualizedSource);
            });
            action.from = (contextualizedSources.length > 1) ? contextualizedSources : contextualizedSources[0];
          }
          if (mapping.value) {
            action.value = mapping.value;
          }
          if (mapping.default !== undefined) {
            action.default = mapping.default;
          }
        } else {
          action = {
            create: mapping.foreach[0].target
          };

          if (mapping.merge) {
            action.$$merge = true;
          }

          if (mapping.foreach[0].source) action.foreach = mapping.foreach[0].source;
          if (mapping.source) {
            mapping.source.forEach(function (source) {
              var contextualizedSource = (mapping.sourceContext) ? source.replace(mapping.sourceContext + ".", "") : source;
              if (contextualizedSource === action.foreach) {
                // ok, our source is the same as the iterator, so either
                // 1) this is a simple object, not an array, and we want to iterate on the object
                // or 2) we want to merge this with another iterator and use an absolute path
                if (mapping.merge) {
                  contextualizedSource = "#/" + contextualizedSource;
                } else {
                  contextualizedSource = "$item";
                }
              }
              contextualizedSources.push(contextualizedSource);
            });
            if (mapping.foreach[0].source) {
              action.from = (mapping.foreach[0].source.length > 1) ?
                mapping.foreach[0].source :
                mapping.foreach[0].source[0];
            }
          }

          // Prevent UI deletion of the 'from' property in the create action when child only has default mapping
          // apiconnect-assembly/#409
          if (!mapping.source && mapping.default !== undefined) {
            if (mapping.foreach[0].source) {
                action.from = (mapping.foreach[0].source.length > 1) ?
                mapping.foreach[0].source :
                mapping.foreach[0].source[0];
            }
          }

          action.actions = [];
          var subMapping = {
            source: contextualizedSources,
            target: (mapping.targetContext) ? mapping.target.replace(mapping.targetContext + ".", "") : mapping.target,
            foreach: mapping.foreach.slice(1),
            targetContext: mapping.foreach[0].target
          };

          if (mapping.$$create) {
            subMapping.$$create = true;
          }
          if (mapping.foreach[0].source) {
            subMapping.sourceContext = mapping.foreach[0].source;
          }
          if (mapping.value) {
            subMapping.value = mapping.value;
          }
          if (mapping.default !== undefined) {
            subMapping.default = mapping.default;
          }
          if (mapping.merge) {
            subMapping.merge = true;
          }
          serializeMapping(subMapping, action.actions);
        }
        actions.push(action);
      };

      function actionsMatch(firstAction, secondAction, mergeable) {
        if (!firstAction.actions || !secondAction.actions) {
          return false;
        }
        var firstActionTarget = firstAction.create || firstAction.set,
          secondActionTarget = secondAction.create || secondAction.set;
        if (firstAction.$$merge || secondAction.$$merge) {
          // user wants to merge, therefore the foreach does not have to match
          return (firstActionTarget === secondActionTarget);
        }  else if (!mergeable) {
          // Extension type selection. No consolidation.
          return (firstActionTarget === secondActionTarget &&
            firstAction.foreach === secondAction.foreach);
        }  else {
          // Merge all actions with same target #apiconnect-assembly/411
          return (firstActionTarget === secondActionTarget &&
            (firstAction.foreach === secondAction.foreach || firstAction.foreach === undefined || secondAction.foreach === undefined));
        }
      };

      /*
       * Consolidates the mapping rules down to a canonical set
       * by merging rules with common ancestors
       */
      function consolidateActions(actions) {
        var index = 0,
          currentAction,
          compareAction,
          consolidated,
          action = 0;

        // if merge checkbox is checked. Extension type selection shouldn't consolidate actions.
        var mergeable = false;
        while (action < actions.length) {
          if (actions[action].$$merge) {
            mergeable = true;
          }
          action++;
        }

        while (index < actions.length) {
          currentAction = actions[index];
          if (!currentAction.actions) {
            // no actions means no iteration nesting, so no consolidation required
            index++;
            continue;
          }
          var i = index + 1;
          while (i < actions.length) {
            consolidated = false;
            compareAction = actions[i];
            if (!compareAction.actions) {
              i++;
              continue;
            }
            // do currentAction and compareAction have anything in common?
            if (actionsMatch(currentAction, compareAction, mergeable)) {
              consolidated = true;
              currentAction.actions = currentAction.actions.concat(compareAction.actions);
              currentAction.actions = consolidateActions(currentAction.actions);
              actions.splice(i, 1);
              currentAction.from = currentAction.from || compareAction.from;
              currentAction.foreach = currentAction.foreach || compareAction.foreach;
            }
            if (!consolidated) {
              i++;
            }
          }
          index++;
        }
        return actions;
      };

      self.getActions = function () {
        var actions = [];
        model.forEach(function (mapping) {
          serializeMapping(mapping, actions);
        });
        return angular.fromJson(angular.toJson(consolidateActions(actions)));
      };

      self.getModel = function () {
        return model;
      };

      self.pruneModel = function (inputs, outputs, saveDiscriminator, checkOnly) {
        if (self.readOnly) return;
        var prunedModel = [];
        var modelChanged = false;
        var keepDiscriminator = true;
        if (saveDiscriminator === false) {
        	keepDiscriminator = false;
        }
        var unrecognized = [];
        model.forEach(function (mapping) {

          var source = [];
          // check the sources
          if (mapping.source) {
            for (var i = 0; i < mapping.source.length; i++) {
              if (!SchemaReferences.propertyExistsInSchemas(mapping.source[i], inputs, definitions, keepDiscriminator)) {
                if (unrecognized.indexOf(mapping.source[i]) === -1) {
                  unrecognized.push(mapping.source[i]);
                }
                modelChanged = true;
              } else {
                source.push(mapping.source[i]);
              }
            }
            if (source.length === 0) return;
          }

          // check the target
          if (mapping.target && !SchemaReferences.propertyExistsInSchemas(mapping.target, outputs, definitions, keepDiscriminator)) {
            if (unrecognized.indexOf(mapping.target) === -1) {
              unrecognized.push(mapping.target);
            }
            modelChanged = true;
            return;
          } else if (!mapping.target) { // target doesn't exist (illegal action like in apiconnect-assembly/#416)
              if (unrecognized.indexOf(mapping.source[0]) === -1) {
                  unrecognized.push(mapping.source[0]);
              }
              modelChanged = true;
              return;
          }

          // it exists, keep it
          if ((source.length === 0) || (source.length === mapping.source.length)) {
            // no changes to source, so we can use the existing mapping
            prunedModel.push(mapping);
          } else {
            // one (or more) of the source schemas was not found, so we need to create a new
            // mapping object that can be used if the user decides to perform the pruning
            var newMapping = angular.fromJson(angular.toJson(mapping));
            newMapping.source = source;
            prunedModel.push(newMapping);
          }
        });

        if (modelChanged) {
          if (!checkOnly) {
            model = prunedModel;
            callback(self.getActions());
          }
        }

        return unrecognized;
      };

      function updateSource(obj,newText,oldText) {
        var changed = false;
        if (obj && obj.source) {
          if (typeof obj.source === 'string') {
            if (obj.source === oldText) {
              obj.source = newText;
              changed = true;
            } else if (obj.source.indexOf(oldText+'.') === 0) {
              obj.source = newText + obj.source.substring(oldText.length);
              changed = true;
            }
          } else {
            for (var i=0; i<obj.source.length; i++) {
              if (obj.source[i] === oldText) {
                obj.source[i] = newText;
                changed = true;
              } else if (obj.source[i].indexOf(oldText+'.') === 0) {
                obj.source[i] = newText + obj.source[i].substring(oldText.length);
                changed = true;
              }
            }
          }
        }
        return changed;
      };

      function updateTarget(obj,newText,oldText) {
        var changed = false;
        if (obj && obj.target) {
          if (obj.target === oldText) {
            obj.target = newText;
            changed = true;
          } else if (obj.target.indexOf(oldText+'.') === 0) {
            obj.target = newText + obj.target.substring(oldText.length);
            changed = true;
          }
        }
        return changed;
      };

      function updateValue(obj,newText,oldText) {
        var changed = false;
        if (obj.value) {
          var i = obj.value.indexOf(oldText);
          while (i > -1) {
            obj.value = obj.value.substring(0,i) + newText + obj.value.substring(i+oldText.length);
            i=obj.value.indexOf(oldText,i+newText.length);
            changed = true;
          }
        }
        return changed;
      };

      self.inputRenamed = function(newName, oldName) {
        var newPath = newName.replace(/\./g,'\\.');
        var oldPath = oldName.replace(/\./g,'\\.');
        var newAbsolute = '#/' + newPath;
        var oldAbsolute = '#/' + oldPath;
        var modelChanged = false;
        model.forEach(function (mapping) {
          if (mapping.source) {
            if (updateSource(mapping,newPath,oldPath)) modelChanged = true;
            if (updateSource(mapping,newAbsolute,oldAbsolute)) modelChanged = true;
          }
          if (mapping.value) {
            if (updateValue(mapping,'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
          }
          if (mapping.foreach) {
            if (mapping.foreach[0]) {
              if (mapping.foreach[0].source) {
                if (updateSource(mapping.foreach[0],newPath,oldPath)) modelChanged = true;
              }
              if (mapping.foreach[0].value) {
                if (updateValue(mapping.foreach[0],'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
                if (updateValue(mapping.foreach[0],'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
              }
            }
            mapping.foreach.forEach(function(fe){
              if (fe.source) {
                if (updateSource(fe,newAbsolute,oldAbsolute)) modelChanged = true;
              }
              if (fe.value) {
                if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
                if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
              }
            });
          }
        });
        if (modelChanged) {
          callback(self.getActions());
        }
      };

      self.outputRenamed = function(newName, oldName) {
        var newPath = newName.replace(/\./g,'\\.');
        var oldPath = oldName.replace(/\./g,'\\.');
        var newAbsolute = '#/' + newPath;
        var oldAbsolute = '#/' + oldPath;
        var modelChanged = false;
        model.forEach(function (mapping) {
          if (mapping.target) {
            if (updateTarget(mapping,newPath,oldPath)) modelChanged = true;
            if (updateTarget(mapping,newAbsolute,oldAbsolute)) modelChanged = true;
          }
          if (mapping.value) {
            if (updateValue(mapping,'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
          }
          if (mapping.foreach) {
            if (mapping.foreach[0]) {
              if (mapping.foreach[0].target) {
                if (updateTarget(mapping.foreach[0],newPath,oldPath)) modelChanged = true;
              }
              if (mapping.foreach[0].value) {
                if (updateValue(mapping.foreach[0],'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
                if (updateValue(mapping.foreach[0],'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
              }
            }
            mapping.foreach.forEach(function(fe){
              if (fe.target) {
                if (updateTarget(fe,newAbsolute,oldAbsolute)) modelChanged = true;
              }
              if (fe.value) {
                if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
                if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
              }
            });
          }
        });
        if (modelChanged) {
          callback(self.getActions());
        }
      };

      return self;
    };
  }]).service('ExtensionType', ['Path', function (Path) {
	  var handler = null;
	  var self = this;

	  self.setHandler = function(inHandler) {
		  handler = inHandler;
	  };

	  self.getValueForPath = function (path) {
		  var targetPath = handler.paths[path];
		  var mapping = null;
		  if (targetPath) {
			  mapping = handler.map.getMappingForPath(targetPath);
		  }
		  return mapping ? mapping.default : null;
	  };

	  self.setValueForPath = function(path, value) {
		  var targetPath = handler.paths[path];
		  if (!value) {
			  // remove the mapping
			  if (targetPath) {
				  handler.map.deleteMappingForPath(targetPath);
			  }
		  } else {
			  if (!targetPath) {
				  targetPath = new Path(path, 0);
				  handler.paths[path] = targetPath;
			  }
			  var mapping = handler.map.getMapping(targetPath);
			  if (!mapping) {
				  mapping = handler.map.setMappingForPath(targetPath);	// creates the output target path
				  mapping.default = value;
				  handler.map.setMappingForPath(targetPath);	// updates and serialises the new mapping value
			  } else {
				  mapping.default = value;
				  handler.map.setMappingForPath(targetPath);
			  }
		  }
		  handler.markDirty();
		  handler.selectedNode.actions = handler.map.getActions();
	  };
  }]).service('policyService', function () {
    var self = this;
    self.createPolicyInstance = function (policy, injectVersion) {
      if (!policy.info) {
        // we don't have a schema here, assume it's already an instance
        return policy;
      }
      var node = {};
      if (!policy.info.name) {
        return node;
      }

      // policy.info.name is e.g. "SAP", "operation-switch", "m
      var properties = policy.properties,
        action = {
          $$type: policy.info.name,
          $$categories: policy.info.categories,
          $$display: policy.info.display,
          $$schema: properties
        };
      // default a title if there are any properties defined
      if (properties) {
        // be careful - display is not required
        if (policy.info.display && policy.info.display.name) {
          action.title = policy.info.display.name;
        } else {
          action.title = policy.info.name;
        }
      }
      if (policy.info.name === 'operation-switch') {
        angular.extend(action, {
          case: [{
            operations: [],
            execute: []
          }],
          otherwise: []
        });
      } else if (policy.info.name === 'switch') {
        angular.extend(action, {
          case: [{
            condition: "",
            execute: []
          }]
        });

        // Load if with else statement if in AppC
        if (policy.info.categories && policy.info.categories.indexOf('AppConnect') > -1) {
          action.case.push({otherwise: []});
        }
      } else if (policy.info.name === 'if') {
        angular.extend(action, {
          condition: "true",
          execute: []
        });
      } else if (policy.info.name === 'map') {
        angular.extend(action, {
          inputs: {},
          outputs: {},
          actions: []
        });
      } else if (policy.info.name === 'set-variable') {
        angular.extend(action, {
          actions: []
        });
      } else if (policy.info.name === 'Application') {
        angular.extend(action, {
          selectedApplication: {},
          selectedAction: {},
          $$advanced: false
        });
      } else if (policy.info.name === 'Trigger') {
        angular.extend(action, {
          selectedApplication: {},
          selectedTrigger: {}
        });
      } else {
        // there may not be any properties...
        if (properties) {
          angular.extend(action, jsonSchemaDefaults(properties));
        }
        // fix stop-on-error bug
        if (policy.info.name === 'invoke' && node && node.invoke) {
          delete node.invoke['stop-on-error'];
        }
      }
      if ((policy.custom || injectVersion) && policy.info.version) {
        // also inject the version
        action.version = policy.info.version;
      }
      node[policy.info.name] = action;
      return node;
    };
  }).service('triggerService', function () {
    var self = this;

    self.deleteTrigger = function (trigger) {
      trigger.selectedApplication = {};
      trigger.selectedTrigger = {};
      delete trigger.accountName;
      delete trigger.$$touched;
      delete trigger.$$errors;
      delete trigger.auth;
      delete trigger.options;
      delete trigger.outputSchema;
    };

    self.setTriggerApplication = function (trigger, selectedApplication) {
      delete trigger.$$errors;
      var triggerApplication = {
        name: selectedApplication.name,
        displayName: selectedApplication.displayName
      };

      trigger.selectedApplication = angular.copy(triggerApplication);

      // Single target object
      trigger.selectedTrigger.name = selectedApplication.task.name;
      trigger.selectedTrigger.displayName = selectedApplication.task.displayName;
      trigger.selectedTrigger.dataModel = selectedApplication.task.dataModel;
      trigger.selectedTrigger.hasConfig = selectedApplication.task.hasConfig;
    };
  }).factory('errorFactory', ['$rootScope', '$mdDialog', '$mdPanel', function ($rootScope, $mdDialog, $mdPanel) {
    return {
      throwError: function (errorObject) {
        // Setup scope for error dialog directive
        var $newScope = $rootScope.$new();
        $newScope.errorObject = errorObject;
        $mdDialog.show({
          fullscreen: true,
          parent: document.body,
          scope: $newScope,
          template: '<md-dialog class="error-dialog"><error-dialog></error-dialog></md-dialog>'
        });
      },

      showWarning: function (warningObject) {
        // Setup scope for error dialog directive
        var $newScope = $rootScope.$new();
        $newScope.warningObject = warningObject;
        $newScope.panelReference = $mdPanel.create({
          attachTo: document.body.querySelector("apim-assembler"),
          panelClass: "warning-dialog",
          scope: $newScope,
          template: '<warning-dialog></warning-dialog>',
          trapFocus: false
        });
        $newScope.panelReference.open();

        return $newScope.panelReference;
      }
    };
  }])
  .factory('AssemblerTracking', [
    '$rootScope',
    function (
      $rootScope
    ) {
      var svc = {};

      svc.track = function (ns, key, data) {
        $rootScope.$emit('event:track', ns, key, data);
      };

      return svc;
    }
  ]).service('canvasAnimationService', [function () {

    var self = this;
    self.canvasXPosition = 0;

    self.reset = function () {
      self.initialPositionSet = false;
      self.canvasXPosition = 0;
    };

    self.animateCanvasSlide = function () {
      var newPosition = self.canvasXPosition || 0;
      var bounds = {};
      var windowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var focusNodeElement = document.querySelector('.isSelected');

      // Only animate to selected nodes
      if (focusNodeElement) {
        bounds = focusNodeElement.getBoundingClientRect();
        newPosition = (windowWidth / 2) - bounds.right + (bounds.width / 2);
        newPosition += self.canvasXPosition;
        self.canvasXPosition = newPosition;
      }

      return newPosition;
    };
  }]).service('assemblyModel', function() {
    var self = this;
    self.flow = {
      trigger: null,
      nodes: [],
      request: null,
      response: null
    };

    self._searchForSelectedNode = function(nodesArray) {

      // Remove top level keys from nodes array
      var nodes = nodesArray.map( function(node) {
        return node.$$type ? node : node[Object.keys(node)[0]];
      });

      // loop through top level nodes
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].$$isSelected) {
          return nodes[i];
        }

        if (nodes[i].$$type === 'switch') {
          // loop through each case statement
          for (var j = 0; j < nodes[i].case.length; j++) {
            var foundNode = self._searchForSelectedNode(nodes[i].case[j].execute || nodes[i].case[j].otherwise);
            if (foundNode) {
              return foundNode;
            }
          }
        }
      }
      return;
    };

    self._searchForNode = function(nodes, nodeToFind) {

      // loop through top level nodes
      for (var i = 0; i < nodes.length; i++) {

        // Remove any top level keys (i.e 'Application')
        var keys = Object.keys(nodes[i]);
        var currentNode = keys.length === 1 ? nodes[i][keys[0]] : nodes[i];

        if (currentNode === nodeToFind) {
          return true;
        }

        if (currentNode.$$type === 'switch') {
          // loop through each case statement
          for (var j = 0; j < currentNode.case.length; j++) {
            var nodesArray = currentNode.case[j].execute || currentNode.case[j].otherwise;
            var foundNode = self._searchForNode(nodesArray, nodeToFind);
            if (foundNode) {
              return true;
            }
          }
        }
      }
      return false;
    };

    self.getSelectedNode = function() {
      if (self.flow.trigger && self.flow.trigger.$$isSelected) {
        return self.flow.trigger;
      } else if (self.flow.response && self.flow.response.$$isSelected) {
        return self.flow.response;
      } else {
        return self._searchForSelectedNode(self.flow.nodes);
      }
    };

    self.containsSelectedNode = function (node) {
      return self._searchForSelectedNode([node]) ? true : false;
    };

    self.containsNode = function (node, nodeToFind) {
      return self._searchForNode([node], nodeToFind);
    };

    self.countInnerActions = function(node) {
      var count = 0;

      if (node.$$type !== 'switch') {
        return 0;
      }

      var recursiveCount = function (node) {
        // loop through each case statement
        for (var i = 0; i < node.case.length; i++) {
          var nodeBranch = (node.case[i].execute || node.case[i].otherwise);

          for(var j = 0; j < nodeBranch.length; j++) {

            if (nodeBranch[j].switch) {
              recursiveCount(nodeBranch[j].switch);
            } else {
              count++;
            }
          }
        }
      };

      recursiveCount(node);
      return count;

    };
  });

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly').factory('SchemaReferences', function () {

    var self = this;

    function findExtendingTypesHelper(refToMatch, definitions, matches, parentTypes) {
    	Object.keys(definitions).forEach(function(definitionName) {
    		var definition = definitions[definitionName];
    		if (!definition.allOf) return false;
    		var filtered = definition.allOf.filter(function(allOfSchema) {
    			return (allOfSchema.$ref === refToMatch);
    		});
    		if (filtered.length > 0) {
    			if (!matches[definitionName]) {
        			var prunedDefinition = angular.copy(definition);
        			// strip out the matching allOf
        			prunedDefinition.allOf = prunedDefinition.allOf.filter(function(allOfSchema) {
        				if (allOfSchema.$ref !== refToMatch) {
        					allOfSchema.$$extender = definitionName;
        					allOfSchema.$$extendedType = definition["x-xsi-type"];
        					allOfSchema.$$extendedParents = parentTypes;
        					return true;
        				}
        				return false;
        			});
        			matches[definitionName] = prunedDefinition;
        			// check for any nested sub-types
    				var lastSlash = refToMatch.lastIndexOf("/");
    				var coreRef = refToMatch.substring(0, lastSlash + 1);
        			var subTypeRef = coreRef + definitionName;
        			var parentSubTypes = {
        					parentTypes: parentTypes,
        					types: []
        			};
        			parentSubTypes.types = parentSubTypes.types.concat(prunedDefinition.allOf);
   					findExtendingTypesHelper(subTypeRef, definitions, matches, parentSubTypes);
    			}
    		}
    	});
    };

    /*
    * Insert referenced schema in place of $ref, where the definitions have been provided
    */
    function findExtendingTypes(schema, definitions) {
    	if (!schema.$ref) {
    		return;
    	}
    	var refToMatch = schema.$ref;
    	var matchingDefinitions = {};
    	if (definitions.definitions) {
    		findExtendingTypesHelper(refToMatch, definitions.definitions, matchingDefinitions, null);
    	}
    	if (definitions['x-ibm-configuration'] && definitions['x-ibm-configuration'].targets) {
    		Object.keys(definitions['x-ibm-configuration'].targets).forEach(function(targetName) {
    			var target = definitions['x-ibm-configuration'].targets[targetName];
    			if (target.definitions) {
    				findExtendingTypesHelper(refToMatch, target.definitions, matchingDefinitions, null);
    			}
    		});
    	}
    	return matchingDefinitions;
    };

    function findRef(ref, definitions, references) {
    	if (references && references[ref]) {
    		return angular.copy(references[ref]);
    	}
    	var sections = ref.split("/");
    	var theSchema = definitions;
    	for (var i = 1; i < sections.length; i++) {
    		theSchema = theSchema[sections[i]];
    		if (!theSchema) return;
    	}
    	var refSchema = angular.copy(theSchema);
    	if (refSchema.properties) {
    		Object.keys(refSchema.properties).forEach(function(propertyName) {
    			refSchema.properties[propertyName].name = propertyName;
    		});
    	}
    	return refSchema;
    };

    /*
    * Insert referenced schema in place of $ref, where the definitions have been provided
    */
    self.unwindRefs = function(schema, definitions, references) {
    	if (!schema || !definitions) {
    		return;
    	}

    	// is it already unwound?
    	if (schema.$$unwound) return;
    	schema.$$unwound = true;

    	if (schema.allOf) {
    		schema.allOf.forEach(function(allOfSchema) {
    			self.unwindRefs(allOfSchema, definitions, references);
    		});
    	}
    	if (schema.anyOf) {
    		schema.anyOf.forEach(function(anyOfSchema) {
    			self.unwindRefs(anyOfSchema, definitions, references);
    		});
    	}
    	if (schema.oneOf) {
    		schema.oneOf.forEach(function(oneOfSchema) {
    			self.unwindRefs(oneOfSchema, definitions, references);
    		});
    	}
    	if (schema.items) {
    		self.unwindRefs(schema.items, definitions, references);
    	}
    	if (schema.$ref) {
    		var refSchema = findRef(schema.$ref, definitions, references);
    		if (refSchema) angular.extend(schema, refSchema);
    	}

    	// now handle discriminators
    	if (schema.discriminator || schema['x-ibm-discriminator']) {
    		// we're a base type - we need to find any extending types
    		var matches = findExtendingTypes(schema, definitions);
    		var extendingTypes = [];
    		if (matches) {
        		Object.keys(matches).forEach(function(definitionName) {
        			extendingTypes.push(matches[definitionName]);
        		});
    		}
    		if (extendingTypes.length > 0) {
    			schema.$$extendingTypes = extendingTypes;
    			// now we've listed the extending types, do we need to add
    			// an x-ibm-discriminator field to the target schema?
    			if (schema['x-ibm-discriminator'] && schema.type === 'object') {
    				if (!schema.properties) schema.properties = {};
    				schema.properties['x-ibm-discriminator'] = {
    						type: 'string'
    				};
					}
					// now make sure that all these schema are valid extensions
					if (!schema.allOf) {
						schema.allOf = [];
					}
    			schema.$$extendingTypes.forEach(function(extendingType) {
						schema.allOf = schema.allOf.concat(extendingType.allOf);
					});
    		} else {
    			schema.$$extendingTypes = [];
    		}
    	}
    };

    function propertyExistsInSchema(property, schema, definitions, references, keepDiscriminator) {
      self.unwindRefs(schema, definitions, references);

      // have we matched the whole thing?
      // properties may themselves contain "." characters...
      var fullPath = property.join(".");
      var title = schema.title || schema.name || schema.$$title;
      if (title) {
        if (title === fullPath) {
          return true;
        }

        // perhaps we're array-mapping a non-repeating type...
        title += ".$item";
        if (title === fullPath) {
          return true;
        }
      }

      // else match parts
      title = schema.title || schema.name || schema.$$title;
			// if we are in the right object, or if the object itself is untitled
			// either due to a missing title or it's use as an anonymous array item
      if ((title === property[0]) || !title || property[0] === '$item') {
        if (property.length === 1) return true;
        // look through properties, which may contain "."
        if (schema.properties) {
          var x = 1;
          var propertySegment = property[x];
          while (x < property.length) {
            x++;
            if (keepDiscriminator && schema["x-ibm-discriminator"]) {
            	return true;
            }
            if (schema.properties[propertySegment]) {
              return propertyExistsInSchema([propertySegment].concat(property.slice(x)), schema.properties[propertySegment], definitions, references, keepDiscriminator);
            }
            // maybe we're looking at an attribute?
            if (propertySegment.indexOf('@') === 0) {
              var attributeName = propertySegment.substring(1);
              if (schema.properties[attributeName] && schema.properties[attributeName].xml &&
              schema.properties[attributeName].xml.attribute === true) {
                return true;
              }
            }
            propertySegment += "." + property[x];
          }
        }
        if (schema.items) {
          if (property[1] === "$item") return true;
          property[0] = "$item";
          return propertyExistsInSchema(property, schema.items, definitions, references, keepDiscriminator);
        }
        if (schema.allOf || schema.anyOf || schema.oneOf) {
          var schemaArray = schema.allOf || schema.anyOf || schema.oneOf;
          for (var i = 0; i < schemaArray.length; i++) {
            if (propertyExistsInSchema(property, schemaArray[i], definitions, references, keepDiscriminator)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    self.propertyExistsInSchemas = function(property, schemas, definitions, keepDiscriminator) {
      if (property.indexOf("#/") === 0) {
          // this is an absolute reference - strip it off
          property = property.substring(2);
      }
      for (var i = 0; i < schemas.length; i++) {
        if (propertyExistsInSchema(property.split(/\\?\./), schemas[i], definitions, null, keepDiscriminator)) return true;
      }
      return false;
    };

    return self;
});

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

function mapperController($scope, $mdDialog, $timeout, translateFilter, resize, Path, Map, ExtensionType) {

  /*jshint validthis:true */
  var self = this;

  // unnamed item name
  self.unnamed = "$item";

  self.currentPage = "map";

  // set up a definitions array for the dropdowns
  var definitions = [
    {
      name: translateFilter('assembly_inline_definition'),
      value: 'inline'
    },
    {
      name: "integer",
      type: "integer",
      format: "int32"
    },{
      name: "long",
      type: "integer",
      format: "int64"
    },{
      name: "float",
      type: "number",
      format: "float"
    },{
      name: "double",
      type: "number",
      format: "double"
    },{
      name: "string",
      type: "string"
    },{
      name: "byte",
      type: "string",
      format: "byte"
    },{
      name: "binary",
      type: "string",
      format: "binary"
    },{
      name: "boolean",
      type: "boolean"
    },{
      name: "date",
      type: "string",
      format: "date"
    },{
      name: "dateTime",
      type: "string",
      format: "date-time"
    },{
      name: "password",
      type: "string",
      format: "password"
    },{
      name: "array",
      type: "array"
    },{
      name: "object",
      type: "object"
    }
  ];
  var schemas = [];
  if ($scope.swaggerDocument.definitions) {
    Object.keys($scope.swaggerDocument.definitions).forEach(function(definition) {
        definitions.push({name: "#/definitions/" + definition, value:  "#/definitions/" + definition});
    });
    schemas = Object.keys($scope.swaggerDocument.definitions);
    $scope.swaggerDefinitions = angular.copy($scope.swaggerDocument.definitions);
  }
  if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].targets) {
    Object.keys($scope.swaggerDocument['x-ibm-configuration'].targets).forEach(function(targetName) {
      var target = $scope.swaggerDocument['x-ibm-configuration'].targets[targetName];
      Object.keys(target.definitions).forEach(function(definition) {
        definitions.push({name: "#/" + targetName + "/definitions/" + definition, value: "#/x-ibm-configuration/targets/" + targetName + "/definitions/" + definition});
      });
    });
  }
  $scope.definitions = definitions;
  $scope.schemas = schemas;

  var backoffTime = 0;
  if (window.navigator && (/firefox/i.test(window.navigator.userAgent) || /AppleWebKit/i.test(window.navigator.userAgent))) {
    backoffTime = 1000;
  }

  $scope.includeEmptyXMLElements = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value) {
        if ($scope.selectedNode.options) {
          delete $scope.selectedNode.options.includeEmptyXMLElements;
        }
      } else {
        if (!$scope.selectedNode.options) {
          $scope.selectedNode.options = {};
        }
        $scope.selectedNode.options.includeEmptyXMLElements = false;
      }
    } else {
      // getter
      if (!$scope.selectedNode.options) return true;
      if (typeof $scope.selectedNode.options.includeEmptyXMLElements === "undefined") return true;
      return $scope.selectedNode.options.includeEmptyXMLElements;
    }
  };

  $scope.namespaceInheritance = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value) {
        if ($scope.selectedNode.options) {
          delete $scope.selectedNode.options.namespaceInheritance;
        }
      } else {
        if (!$scope.selectedNode.options) {
          $scope.selectedNode.options = {};
        }
        $scope.selectedNode.options.namespaceInheritance = false;
      }
    } else {
      // getter
      if (!$scope.selectedNode.options) return true;
      if (typeof $scope.selectedNode.options.namespaceInheritance === "undefined") return true;
      return $scope.selectedNode.options.namespaceInheritance;
    }
  };

  $scope.inlineNamespaces = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value) {
        if ($scope.selectedNode.options) {
          delete $scope.selectedNode.options.inlineNamespaces;
        }
      } else {
        if (!$scope.selectedNode.options) {
          $scope.selectedNode.options = {};
        }
        $scope.selectedNode.options.inlineNamespaces = false;
      }
    } else {
      // getter
      if (!$scope.selectedNode.options) return true;
      if (typeof $scope.selectedNode.options.inlineNamespaces === "undefined") return true;
      return $scope.selectedNode.options.inlineNamespaces;
    }
  };

  $scope.$on('resize', function() {
    $timeout(self.constructCanvas, backoffTime);
  });

  $scope.markDirty = function() {
    $scope.$emit('mark_api_dirty');
  };

// seem to be unused...
  // $scope.inputSchemaName = "source";
  // $scope.outputSchemaName = "target";

  self.switchToMap = function() {
    self.currentPage = 'map';
    $timeout(self.constructCanvas, backoffTime);
  };

  self.addInput = function(inputName, schema, variable) {
    if (!schema) schema = {type: "object"};
    if (!variable) variable = "request.body";
    if (!inputName) inputName = "input";
    var rootName = inputName;
    var counter = 1;
    while ($scope.selectedNode.inputs.hasOwnProperty(inputName)) {
      inputName = rootName + "_" + counter++;
    }
    $scope.selectedNode.inputs[inputName] = {schema: schema, variable: variable};
  };

  self.addParametersForOperation = function(selectedOperation) {
    var parameters = [];

    var path = $scope.swaggerDocument.paths[selectedOperation.path];
    var operation = path[selectedOperation.verb];

    if (operation.parameters) parameters = parameters.concat(operation.parameters);
    if (path.parameters) parameters = parameters.concat(path.parameters);

    parameters.forEach(function(parameter) {
      var parameterName = parameter.name;
      if (parameter.$ref) {
        parameterName = parameter.$ref.replace("#/parameters/", "");
        parameter = $scope.swaggerDocument.parameters[parameterName];
      }
      var schema = (parameter.schema) ? parameter.schema : {type: parameter.type};
      var variable = (parameter.in === "body") ? "request.body" : (parameter.in === "header") ? "request.headers." + parameterName : "request.parameters." + parameterName;
      self.addInput(parameterName, schema, variable);
    });
  };

  self.addOutputsForOperation = function(selectedOperation) {
    var operation = $scope.swaggerDocument.paths[selectedOperation.path][selectedOperation.verb];

    var output = operation.responses["200"] || operation.responses["201"] || operation.responses["default"];
    if (!output) return;

    var schema = (output.schema) ? output.schema : {type: "object"};
    var variable = "message.body";
    self.addOutput("response", schema, variable);
  };

  self.addOutput = function(outputName, schema, variable) {
    if (!schema) schema = {type: "object"};
    if (!variable) variable = "message.body";
    if (!outputName) outputName = "output";
    var rootName = outputName;
    var counter = 1;
    while ($scope.selectedNode.outputs.hasOwnProperty(outputName)) {
      outputName = rootName + "_" + counter++;
    }
    $scope.selectedNode.outputs[outputName] = {schema: schema, variable: variable};
  };

  self.removeInput = function(inputName) {
    delete $scope.selectedNode.inputs[inputName];
  };

  self.removeOutput = function(outputName) {
    delete $scope.selectedNode.outputs[outputName];
  };

  var mapperConfig = {
    connectorRadius: 4,
    backOff: 4,
    indentFactor: 8,
    curveFactor: 0.3
  };

  var currentLine = null;
  var currentGroup = null;
  var currentInput = null;
  var currentMapping = null;
  var mappings = [];
  var automappable = true;
  var initialScrollOffsetLeft = 0;
  var scrollOffsetLeft = 0;
  var initialScrollOffsetRight = 0;
  var scrollOffsetRight = 0;

  self.updateModelActions = function(actions) {
    $scope.selectedNode.actions = actions;
  };

  $scope.map = new Map($scope.selectedNode, $scope.swaggerDocument, self.updateModelActions);

  self.showTargetDetails = function(target) {
    //$scope.selectedTargetNode = target;
    var targetPath = $scope.paths[target.connectorPath];
    var mapping = $scope.map.getMappingForPath(targetPath);
    var valueType = targetPath.type;

    $mdDialog.show({
      controller: 'TargetConnectorController',
      flex: "50",
      backdrop: 'static',
      keyboard: false,
      templateUrl: 'src/html/target-connector.html',
      parent: angular.element(document.body),
      focusOnOpen: false,
      locals: {
        mapping: mapping,
        target: target,
        paths: $scope.paths,
        valueType: valueType
      }
    }).then(function(response) {

      var responseDefault = '' + response.default;

      if (response.remove === true || (_.isEmpty(response.from) && _.isEmpty(response.value) && _.isEmpty(responseDefault) && !response.emptyString)) {
        $scope.map.deleteMappingForPath(targetPath);
        $scope.markDirty();
      } else {
        // we're creating or modifying the mapping
        if (!mapping) {
          $scope.map.setMappingForPath(targetPath);
          $scope.markDirty();
          mapping = $scope.map.getMappingForPath(targetPath);
        }
        if (!response.from || response.from.length === 0) {
          delete mapping.source;
        } else {
          mapping.source = response.from;
        }
      }

      if (response.value) {
        mapping.value = response.value;
      } else {
        delete mapping.value;
      }
      
      if (response.foreach) {
        mapping.foreach = response.foreach;
      } else if (response.from) {
        // only clear out foreach if the mapping hasn't
        // 1) got a foreach defined, and
        // 2) got sources defined
        // no sources means implicit iteration
        delete mapping.foreach;
      }

      if (response.default !== undefined) {
        if (response.valueType) {
          switch (response.valueType) {
            case 'boolean':
              responseDefault = responseDefault.toLowerCase();
              // only convert boolean values
              if (responseDefault === 'true' || responseDefault === 'false') {
                responseDefault = (responseDefault === 'true');
              }
              break;
            case 'number':
            case 'integer':
              var aNumber = Number(responseDefault);
              // only convert number values
              if (isFinite(aNumber)) {
                responseDefault = aNumber;
              }
              break;
          }
        }

        mapping.default = responseDefault;
      } else {
        delete mapping.default;
      }

      if (response.merge) {
        mapping.merge = true;
      } else {
        delete mapping.merge;
      }

      self.updateModelActions($scope.map.getActions());

      $timeout(self.constructCanvas, backoffTime);
    });
  };

  $scope.paths = {};
  ExtensionType.setHandler($scope);

  function constructInputNodes(cssRule, cssClass, connectorNodeData, clickZoneData) {
    var yOffset = 40; // allow for column headers
    var mappableInputs = $(cssRule);
    var i, position, height, parent, item;
    for (i = 0; i < mappableInputs.length; i++) {
      var input = $(cssRule + ":nth(" + i + ")");
      position = input.position();
      if (position.top === 0 && position.left === 0) {
        // this signifies a collapsed input - do not render any connectors
        continue;
      }
      height = input.height();
      $scope.paths[input.attr("path")] = new Path(input.attr("path"), input.attr("dimensions"), input.attr("container"), input.attr("type"));
      var containerAdjust = 0;
      // if (input.hasClass('mapper-schema-container')) containerAdjust = -24;
      connectorNodeData.push({
        "cx": mapperConfig.connectorRadius * 2,
        "cy": position.top - yOffset + containerAdjust + 12,
        "radius": mapperConfig.connectorRadius,
        "class": (input.hasClass("collapsed")) ? "collapsed-" + cssClass : cssClass,
        "connectorPath": $scope.paths[input.attr("path")].getPath(),
        "connectorDimension": $scope.paths[input.attr("path")].getDimensionality(),
        "connectorParent": parent,
        "connectorItem": item
      });
      if (clickZoneData) {
        clickZoneData.push({
          "width": 30,
          "height": 20,
          "x": 0,
          "y": position.top - yOffset + containerAdjust + 2,
          "class": "click-zone-input",
          "connectorPath": $scope.paths[input.attr("path")].getPath(),
          "connectorDimension": $scope.paths[input.attr("path")].getDimensionality(),
          "connectorParent": parent,
          "connectorItem": item,
          "position": "input"
        });
      }
    }
  };

  function constructOutputNodes(cssRule, cssClass, connectorNodeData, clickZoneData) {
    var yOffset = 40; // allow for column headers
    var canvas = $("svg.mapper-canvas");
    var mappableTargets = $(cssRule);
    var i, position, height, target, className;
    for (i = 0; i < mappableTargets.length; i++) {
      target = $(cssRule + ":nth(" + i + ")");
      position = target.position();
      if (position.top === 0 && position.left === 0) {
        // this signifies a collapsed input - do not render any connectors
        continue;
      }
      height = target.height();
      $scope.paths[target.attr("path")] = new Path(target.attr("path"), target.attr("dimensions"), target.attr("container"), target.attr("type"));
      className = cssClass;
      if ($scope.map.hasMapping($scope.paths[target.attr("path")])) className += " mapped";
      var containerAdjust = 0;
      // if (target.hasClass('mapper-schema-container')) containerAdjust = -24;
      connectorNodeData.push({
        "cx": canvas.width() - mapperConfig.connectorRadius * 2,
        "cy": position.top - yOffset + containerAdjust + 12,
        "radius": mapperConfig.connectorRadius,
        "class":  (target.hasClass("collapsed")) ? "collapsed-" + className : className,
        "connectorPath": $scope.paths[target.attr("path")].getPath(),
        "connectorDimension": $scope.paths[target.attr("path")].getDimensionality()
      });
      if (clickZoneData) {
        clickZoneData.push({
          "width": 30,
          "height": 20,
          "x": canvas.width() - 30,
          "y": position.top - yOffset + containerAdjust + 2,
          "class": "click-zone-output",
          "connectorPath": $scope.paths[target.attr("path")].getPath(),
          "connectorDimension": $scope.paths[target.attr("path")].getDimensionality(),
          "position": "output"
        });
      }
    }
  };

  function selectMapping(e, targetPath) {
      d3.event.stopPropagation();
      if (currentMapping) currentMapping.attr("class", currentMapping.attr("class").replace(" mapper-group-selected", ""));
      e.attr("class", e.attr("class") + " mapper-group-selected");
      currentMapping = e;

      var thisMapping = mappings.filter(function(mapping) {
          return (mapping.target === targetPath);
      });
      if (thisMapping.length > 0 && thisMapping[0].config && thisMapping[0].config.fn) {
          $(".mapper-function textarea")[0].value = thisMapping[0].config.fn;
          $(".mapper-function textarea")[0].connectorPath = targetPath;
      }
  }

  function createPath(startX, startY, endX, endY, connectorPath, isCollapsed) {
      // safety first - string safety
      startX = startX * 1;
      startY = startY * 1;
      endX = endX * 1;
      endY = endY * 1;

      // offset tracking
      if (scrollOffsetLeft > 0) startY -= scrollOffsetLeft;
      // add back in any scroll offset we started with
      if (initialScrollOffsetLeft > 0) startY += initialScrollOffsetLeft;
      // nuance here... if we're given a connector path, that means we've completed a mapping,
      // which means we're trying to connect the line to a circle (which might be offset due to scrolling).
      // If not, we're freeform drawing and don't yet care about offsets
      if (connectorPath && scrollOffsetRight > 0) endY -= scrollOffsetRight;
      // add back in any scroll offset we started with
      if (connectorPath && initialScrollOffsetRight > 0) endY += initialScrollOffsetRight;

      // back the line off from the connector centre
      startX += (mapperConfig.connectorRadius / 2) + 2;
      endX -= (mapperConfig.connectorRadius / 2) + 2;

      // calculate an indent relative to the lines X-length
      // indentLeft must = width / 2 when endX = width
      // add 5% to the left indent. Without this, a map from
      // top left to bottom right
      // will curve off on the right while still within the
      // zone of the function, and look weird
      var indentRight = ((endX - startX) / 2) + ((endX - startX) * 0.05);
      var indentLeft = mapperConfig.curveFactor * (endX - startX);
      var pathString = "M " + endX + " " + endY;

      // draw the curve
      pathString += "L " + (endX - indentRight) + " " + endY;
      pathString += "C " + (endX - indentLeft - indentRight) + " " + endY;
      pathString += " " + (startX + indentLeft) + " " + startY;
      pathString += " " + startX + " " + startY;

      // create the shape
      if (!currentGroup) {
          // create a new group
          var canvas = d3.select("svg.mapper-canvas");
          currentGroup = canvas.append("g");
          currentGroup.attr("class", "mapper-group");
      }
      if (!currentLine) {
          // create a new line
          currentLine = currentGroup.insert("path", ".function-node");
          if (isCollapsed) {
            currentLine.attr("class", "collapsed-mapper-line");
          } else {
            currentLine.attr("class", "mapper-line");
          }
      }
      currentLine.attr("d", pathString);
      if (connectorPath) {
          // line is complete and has a target
          var scopedGroup = currentGroup;
          currentLine.attr("connectorPath", connectorPath);
          currentLine.on("click", function() {
              selectMapping(scopedGroup, connectorPath);
          });
      }
  }

  function restoreMap() {
    var model = $scope.map.getModel();
    var targetConnectors = d3.selectAll("circle.output-node");
    var targetCollapsedConnectors = d3.selectAll("circle.collapsed-output-node");
    var sourceConnectors = d3.selectAll("circle.input-node");
    var sourceCollapsedConnectors = d3.selectAll("circle.collapsed-input-node");
    var targets, sources, targetPath;
    model.forEach(function(mapping) {
      // mappings do not have to have a source...
      if (!mapping.source) return;
      // target doesn't exist (illegal action like in apiconnect-assembly/#416)
      if (!mapping.target) return;
      // find the best target match
      var targetCollapsed = false;
      targets = targetConnectors.filter(function(targetConnector) {
        return (targetConnector.connectorPath === mapping.target ||
                targetConnector.connectorPath + ".$item" === mapping.target ||
                targetConnector.connectorPath === mapping.target + ".$item");
      }).data();
      if (targets.length === 0) {
        targetCollapsed = true;
        // find the most relevant collapsed node
        var targetConnectorSections = mapping.target.split(".");
        while (targets.length === 0 && targetConnectorSections.length > 0) {
          targetPath = targetConnectorSections.join(".");
          targets = targetCollapsedConnectors.filter(function(targetConnector) {
            return (targetConnector.connectorPath === targetPath ||
                targetConnector.connectorPath + ".$item" === targetPath ||
                targetConnector.connectorPath === targetPath + ".$item");
          }).data();
          targetConnectorSections.pop();
        }
      }
      mapping.source.forEach(function(sourcePath) {
        // find the best source match
        var sourceCollapsed = false;
        // handle absolute paths
        if (sourcePath.indexOf("#/") === 0) sourcePath = sourcePath.substring(2);
        sources = sourceConnectors.filter(function(item) {
          return (item.connectorPath === sourcePath ||
            item.connectorPath + ".$item" === sourcePath ||
            item.connectorPath === sourcePath + ".$item");
        }).data();
        if (sources.length === 0) {
          sourceCollapsed = true;
          // find the most relevant collapsed node
          var sourceConnectorSections = sourcePath.split(".");
          while (sources.length === 0 && sourceConnectorSections.length > 0) {
            sourcePath = sourceConnectorSections.join(".");
            sources = sourceCollapsedConnectors.filter(function(sourceConnector) {
              return (sourceConnector.connectorPath === sourcePath ||
                sourceConnector.connectorPath + ".$item" === sourcePath ||
                sourceConnector.connectorPath === sourcePath + ".$item");
            }).data();
            sourceConnectorSections.pop();
          }
        }
        sources.forEach(function(source) {
          targets.forEach(function(target) {
            createPath(source.cx, source.cy, target.cx, target.cy, target.connectorPath, sourceCollapsed || targetCollapsed);
            currentLine = null;
          });
        });
      });
    });
  };

  function restoreMapFromModel() {
    var svgContainer = d3.select("svg.mapper-canvas");
    // restore stored mappings
    svgContainer.selectAll("g").remove();

    restoreMap();
    currentGroup = null;
  };

  function canvasMouseUp() {
    if ($scope.map.readOnly) return;
    if (currentGroup && currentInput) {
        // we're mapping
        var canvas = $("svg.mapper-canvas");
        canvas.unbind("mousemove");
        currentGroup.remove();
    };
    currentLine = null;
    currentGroup = null;
    currentInput = null;
    currentMapping = null;
  }

  var isFF = (window.navigator && /firefox/i.test(window.navigator.userAgent));
  // var isSafari = (window.navigator && /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent));
  function trackMouse(e) {
      var offsetX = e.offsetX;
      var offsetY = e.offsetY;
      if (e.target && e.target.nodeName !== "svg") {
        var position = e.target.getAttribute('position');
        if (position === 'input') {
          //offsetY += (initialScrollOffsetLeft - scrollOffsetLeft);
        } else if (position === 'output') {
          // offsetY += (initialScrollOffsetRight - scrollOffsetRight);
        }
        if (isFF) {
          // firefox defines offsets relative to the event target rather than the absolute parent
          offsetX += (1 * e.target.getAttribute('x'));
          offsetY += (1 * e.target.getAttribute('y'));
        }
      }
      createPath(8, currentInput.y + 10, offsetX - mapperConfig.backOff, offsetY);
  }

  function connectorMouseUp(e) {
    // allow click events - mouse down & mouse up on same element
    d3.event.stopPropagation();
    if (currentInput === e) return;
    if ($scope.map.readOnly) return;
    var canvas = $("svg.mapper-canvas");
    if (e.class === "output-node" || e.class === "click-zone-output" ||
      e.class === "output-node mapped" || e.class === "click-zone-output mapped") {
      // if we aren't mapping, show the target details dialog
      if (!currentInput || !currentGroup) {
          self.showTargetDetails(e);
          return;
      }
      // otherwise add the new mapping
      var sourcePath = $scope.paths[currentInput.connectorPath];
      var targetPath = $scope.paths[e.connectorPath];
      $scope.map.setMappingForPath(targetPath, sourcePath);
      $scope.markDirty();
      $scope.$apply();
      createPath(8, currentInput.y + 10, 192, e.y + 10, e.connectorPath);

      // ensure the connector node now has the mapped class
      $(".output-node:not(.mapped)").filter(function(index, node) { return node.getAttribute('connectorPath') === e.connectorPath; }).attr('class', 'output-node mapped');

      // user has started to interact with the map - let's not do anything annoying with automapping now
      automappable = false;

      canvas.unbind('mousemove');
      currentLine = null;
      currentGroup = null;
      currentInput = null;

      restoreMapFromModel();
    }
  };

  function connectorMouseDown(e) {
    // allow click events - mouse down & mouse up on same element
    if (currentInput === e) return;
    d3.event.stopPropagation();
    if ($scope.map.readOnly) return;
    var canvas = $("svg.mapper-canvas");
    if (e.class === "input-node" || e.class === "click-zone-input") {
      if (currentGroup) {
          // flow through - we're cancelling the existing mapping and starting a new one
          // but we'll just keep using this line to make life easy
      }
      currentInput = e;
      canvas.bind('mousemove', trackMouse);
    }
  };

  // scrolling functions - allow the user to scroll the left and right panes independently,
  // and transform the central mapping panel. This allows mapping from the bottom of a long
  // list on the left, to the top on the right (for example)
  function transformLeftNodes() {
    scrollOffsetLeft = $(".mapper-inputs-container")[0].scrollTop;
    // console.log(scrollOffsetLeft);
    d3.selectAll(".input-node").attr("transform", "translate(0, " + (0 - scrollOffsetLeft + initialScrollOffsetLeft) + ")");
    d3.selectAll(".collapsed-input-node").attr("transform", "translate(0, " + (0 - scrollOffsetLeft + initialScrollOffsetLeft) + ")");
    d3.selectAll(".click-zone-input").attr("transform", "translate(0, " + (0 - scrollOffsetLeft + initialScrollOffsetLeft) + ")");
  }

  function scrollLeft() {
    transformLeftNodes();
    restoreMapFromModel();
  }

  function transformRightNodes() {
    scrollOffsetRight = $(".mapper-outputs-container")[0].scrollTop;
    d3.selectAll(".output-node").attr("transform", "translate(0, " + (0 - scrollOffsetRight + initialScrollOffsetRight) + ")");
    d3.selectAll(".collapsed-output-node").attr("transform", "translate(0, " + (0 - scrollOffsetRight + initialScrollOffsetRight) + ")");
    d3.selectAll(".click-zone-output").attr("transform", "translate(0, " + (0 - scrollOffsetRight + initialScrollOffsetRight) + ")");
  }

  function scrollRight() {
    transformRightNodes();
    restoreMapFromModel();
  }

  // function scrollToTop() {
  //   $(".mapper-inputs-container")[0].scrollTop = 0;
  //   scrollOffsetLeft = 0;
  //   $(".mapper-outputs-container")[0].scrollTop = 0;
  //   scrollOffsetRight = 0;
  // }

  // end scrolling functions

  self.eventsBound = false;
  self.constructCanvas = function(forceClear) {
    if (self.currentPage !== 'map') return;

    // when constructing the canvas, we need to record the initial left and right scroll offsets
    // then we can adjust the rendered heights of the input nodes and wires for the life of the canvas
    var inputsContainer = $(".mapper-inputs-container")[0];
    var outputsContainer = $(".mapper-outputs-container")[0];
    if (!inputsContainer || !outputsContainer) return;
    initialScrollOffsetLeft = (inputsContainer) ? inputsContainer.scrollTop : 0;
    initialScrollOffsetRight = (outputsContainer) ? outputsContainer.scrollTop : 0;

    // listen for scroll events
    if (!self.eventsBound) {
      $(".mapper-inputs-container").on("scroll", _.throttle(scrollLeft, 100, {leading: true}));
      $(".mapper-outputs-container").on("scroll", _.throttle(scrollRight, 100, {leading: true}));
    }

    var canvas = $("svg.mapper-canvas");
    if (!self.eventsBound) {
      canvas.on("mouseup", canvasMouseUp);
    }
    self.eventsBound = true;
    var svgContainer = d3.select("svg.mapper-canvas");
    var connectorNodeData = [];
    var clickZoneData = [];

    constructInputNodes(".mapper-input-schema .mapper-schema-path", "input-node", connectorNodeData, clickZoneData);

    constructOutputNodes(".mapper-output-schema .mapper-schema-path", "output-node", connectorNodeData, clickZoneData);

    // now check that the model is consistent with the available inputs and outputs
    var saveDiscriminator = true;
    if (forceClear) {
    	saveDiscriminator = false;
    }

    if ($scope.map && $scope.inputSchemas && $scope.outputSchemas && !$scope.pruneDialog) {
      var unrecognized = $scope.map.pruneModel($scope.inputSchemas, $scope.outputSchemas, saveDiscriminator, true);
      if (unrecognized.length > 0) {
        // prompt the user if pruning should be performed
        $scope.pruneDialog = $mdDialog.show({
          controller: 'PruneConfirmationController',
          flex: "50",
          backdrop: 'static',
          keyboard: false,
          templateUrl: 'src/html/confirmation-dialog.html',
          parent: angular.element(document.body),
          focusOnOpen: false,
          locals: {
            parentScope: $scope,
            saveDiscriminator: saveDiscriminator,
            unrecognized: unrecognized
          }
        });
      }
    }

    svgContainer.selectAll("circle").remove();
    var circles = svgContainer.selectAll("circle")
      .data(connectorNodeData)
      .enter()
      .append("circle");
    circles
      .attr("cx", function (d) { return d.cx; })
      .attr("cy", function (d) { return d.cy; })
      .attr("r", function (d) { return d.radius; })
      .attr("class", function (d) { return d.class; })
      .attr("connectorPath", function (d) { return d.connectorPath; });
    svgContainer.selectAll("rect").remove();
    var rects = svgContainer.selectAll("rect")
      .data(clickZoneData)
      .enter()
      .append("rect");
    rects
      .attr("x", function (d) { return d.x; })
      .attr("y", function (d) { return d.y; })
      .attr("width", function (d) { return d.width; })
      .attr("height", function (d) { return d.height; })
      .attr("class", function (d) { return d.class; })
      .attr("connectorPath", function (d) { return d.connectorPath; })
      .attr("position", function (d) { return d.position; })
      // .on("click", connectorClick)
      .on("mousedown", connectorMouseDown)
      .on("mouseup", connectorMouseUp);

      // TODO - offsets are being incorrectly applied... scrolling to top for now
    // // initialize and act on any current scroll offsets
    transformLeftNodes();
    transformRightNodes();

    restoreMapFromModel();
  };

  function getSchema(definition) {
    var schema;
    // var schema, shortName;
    // do we have an inline definition, a definition reference, or a basic type
    if (definition.properties || definition.items || definition.allOf) {
      // inline definition, so just use it as is
      schema = definition;
    } else if (definition.$ref) {
      // reference, just use it as is
      schema = definition;
      // definition
      // if (definition.$ref.indexOf("#/definitions/") === 0) {
      //   shortName = definition.$ref.replace("#/definitions/", "");
      //   schema = angular.copy($scope.swaggerDocument.definitions[shortName]);
      //   schema.$$ref = definition.$ref;
      //   if (!schema) return;
      // } else if (definition.$ref.indexOf("#/x-ibm-configuration/targets/") === 0) {
      //   shortName = definition.$ref.replace("#/x-ibm-configuration/targets/", "");
      //   var sections = shortName.split("/");
      //   if (sections.length < 3) return;
      //   var targets = $scope.swaggerDocument['x-ibm-configuration'].targets;
      //   if (!targets) return;
      //   var target = targets[sections[0]];
      //   if (!target) return;
      //   var targetDefs = target.definitions;
      //   if (!targetDefs) return;
      //   if (!targetDefs[sections[2]]) return;
      //   schema = angular.copy(targetDefs[sections[2]]);
      //   schema.$$ref = definition.$ref;
      // }
    } else if (definition.type) {
      // basic type
      // var schemas = $scope.definitions.filter(function(thisSchema) {
      //   return (thisSchema.name === definition.type);
      // });
      // if (schemas.length === 0) return;
      // schema = angular.copy(schemas[0]);
      definition.$$byref = true;
      schema = definition;
    }
    return schema;
  }

  function constructInputs(force) {
    if (!$scope.selectedNode.inputs) return;
    if (!force && self.currentPage === 'map' && $scope.inputSchemas) {
      // inputs aren't being added or removed in this view, so no need to re-generate
      return;
    }
    var inputSchemas = [];
    Object.keys($scope.selectedNode.inputs).forEach(function(input) {
      var definition = $scope.selectedNode.inputs[input].schema;
      var schema = getSchema(definition);
      if (!schema) return;
      // take a copy if this is a reference to avoid dereferencing it in the model
      schema = (schema.$ref) ? angular.copy(schema) : schema;
      schema.$$title = input;
      inputSchemas.push(schema);
    });
    $scope.inputSchemas = inputSchemas;
  }

  function constructOutputs(force) {
    if (!$scope.selectedNode.outputs) return;
    if (!force && self.currentPage === 'map' && $scope.outputSchemas) {
      // inputs aren't being added or removed in this view, so no need to re-generate
      return;
    }
    var outputSchemas = [];
    Object.keys($scope.selectedNode.outputs).forEach(function(output) {
      var definition = $scope.selectedNode.outputs[output].schema;
      var schema = getSchema(definition);
      if (!schema) return;
      // take a copy if this is a reference to avoid dereferencing it in the model
      schema = (schema.$ref) ? angular.copy(schema) : schema;
      schema.$$title = output;
      outputSchemas.push(schema);
    });
    $scope.outputSchemas = outputSchemas;
  }

  $scope.$on('input-output-modified', function() {
    constructInputs();
    constructOutputs();
  });

  $scope.$watch('inputSchemas', function() {
    $timeout(self.constructCanvas, backoffTime);
  });
  $scope.$watch('outputSchema', function() {
    $timeout(self.constructCanvas, backoffTime);
  });

  $scope.$watch('selectedNode.inputs', function() {
    constructInputs();
  }, true);
  $scope.$watch('selectedNode.outputs', function() {
    constructOutputs();
  }, true);

  $scope.$on('json-schema-view-property-collapsed', function() {
    $timeout(self.constructCanvas, backoffTime);
  });

  $scope.$on('json-schema-view-property-modified', function() {
    constructInputs(true);
    constructOutputs(true);
  });

  $scope.$on('json-schema-view-refresh', function(event, forceClear) {
	  $timeout(function() {
		  self.constructCanvas(forceClear);
	  }, backoffTime);
  });

  var hashKey;
  $scope.$watch('selectedNode.$$hashKey', function() {
    if (hashKey === $scope.selectedNode.$$hashKey) return;
    if (!hashKey) hashKey = $scope.selectedNode.$$hashKey;
    $timeout(function() {
      $scope.map = new Map($scope.selectedNode, $scope.swaggerDocument, self.updateModelActions);
      constructInputs(true);
      constructOutputs(true);
      self.constructCanvas();
    }, backoffTime);
  }, true);
};

angular.module('apiconnect-assembly').controller('MapperController', ['$scope', '$mdDialog', '$timeout', 'translateFilter', 'resize', 'Path', 'Map', 'ExtensionType', mapperController]);

function targetConnectorController($scope, $mdDialog, mapping, target, paths, valueType) {
  if (mapping && mapping.source) {
    $scope.sources = angular.copy(mapping.source);
  }

  $scope.valueType = valueType;

  $scope.merge = (mapping && mapping.merge === true) ? true : false;

  $scope.emptyString = (mapping && mapping.default === "") ? true : false;

  if (mapping) {
    if (mapping.default !== undefined) {
      $scope.default = mapping.default;
    }
  }

  if (mapping && mapping.value) {
    $scope.value = mapping.value;
  }

  // issue 411 - record the dimensionality of the target
  // this will be used to control whether or not to show users the merge checkbox
  // we can't rely on looking at source iterators here as there is an edge case
  // where the user is only setting a default value - no sources at all
  // instead, we should show the merge option for any connector with a positive
  // dimensionality
  $scope.mergeable = target.connectorDimension > 0;

  if (mapping && mapping.target) {
    $scope.target = mapping.target;
    var outputPath = paths[mapping.target];

    var foreach = {};
    if (outputPath.getDimensionality() > 0 && $scope.sources) {
      var dimensions = outputPath.dimensionality;
      dimensions.forEach(function(dimension) {
        foreach[dimension] = null;
      });
      if (mapping && mapping.foreach) {
        var sourceContext = "", targetContext = "";
        mapping.foreach.forEach(function(foreachObj) {
          foreach[targetContext + foreachObj.target] = sourceContext + foreachObj.source;
          sourceContext += foreachObj.source + ".";
          targetContext += foreachObj.target + ".";
        });
      }
      $scope.foreach = foreach;
    }
  }

  // allow iterating over any input property - not just array types
  var iterators = [];
  if ($scope.sources && $scope.sources.length > 0) {
    $scope.sources.forEach(function(inputPath) {
      if (!inputPath) return;
      var sections = inputPath.split(".");
      if (sections.length === 1) {
        iterators.push(sections[0]);
      } else {
        for (var i = 0; i < sections.length - 1; i++) {
          var section = sections.slice(0, i + 1).join(".");
          if (iterators.indexOf(section) < 0) iterators.push(section);
        }
      }
    });
  }
  if (iterators.length > 0) $scope.iterators = iterators;

  if (mapping) $scope.value = angular.copy(mapping.value);
  $scope.removeMapping = function(from) {
    $scope.sources = $scope.sources.filter(function(source) {
      return (from !== source);
    });
    if ($scope.sources.length === 0) delete $scope.sources;
  };
  $scope.removeStaticValue = function() {
    delete $scope.value;
  };
  $scope.deleteMapping = function() {
    $mdDialog.hide({
      remove: true
    });
  };
  $scope.updateModel = function() {
    var response = {
      from: $scope.sources,
      value: $scope.value,
      remove: $scope.remove
    };
    if ($scope.valueType) {
      response.valueType = $scope.valueType;
    }
    if ($scope.emptyString === true) {
      response.default = "";
      response.emptyString = $scope.emptyString;
    } else if ($scope.default !== undefined) {
      response.default = $scope.default;
    }
    if ($scope.merge === true) {
      response.merge = $scope.merge;
    }
    if ($scope.foreach) {
      response.foreach = [];
      var sourceContext = "", targetContext = "";
      Object.keys($scope.foreach).forEach(function(key) {
        if (!$scope.foreach[key]) return;
        response.foreach.push({
          target: key.replace(targetContext, ""),
          source: $scope.foreach[key].replace(sourceContext, "")
        });
        targetContext = key + ".";
        sourceContext = $scope.foreach[key] + ".";
      });
      if (response.foreach.length === 0) delete response.foreach;
    }
    $mdDialog.hide(response);
  };
  $scope.cancel = function() {
    $mdDialog.cancel();
  };
  $scope.aceLoaded = function(editor) {
	  editor.focus();
  };
}

angular.module('apiconnect-assembly').controller('TargetConnectorController', ['$scope', '$mdDialog', 'mapping', 'target', 'paths', 'valueType', targetConnectorController]);

function pruneConfirmationController($scope, $mdDialog, parentScope, saveDiscriminator, unrecognized) {
  $scope.unrecognized = unrecognized;
  $scope.prune = function() {
    parentScope.map.pruneModel(parentScope.inputSchemas, parentScope.outputSchemas, saveDiscriminator, false);
    $mdDialog.cancel();
    parentScope.pruneDialog = null;
    parentScope.$emit('json-schema-view-refresh', false);	// trigger canvas update
  };
  $scope.cancel = function() {
    $mdDialog.cancel();
    parentScope.pruneDialog = null;
  };
}

angular.module('apiconnect-assembly').controller('PruneConfirmationController', ['$scope', '$mdDialog', 'parentScope', 'saveDiscriminator', 'unrecognized', pruneConfirmationController]);

function MapInputOutputController($scope, $modal, translateFilter) {

  var self = this;

  if ($scope.object.schema) {
    if (_.isEmpty($scope.object.schema)) {
      $scope.selectedDefinition = "";
    } else if ($scope.object.schema.$ref) {
      $scope.selectedDefinition = $scope.object.schema.$ref;
    } else if ($scope.object.schema.type && !$scope.object.schema.items && !$scope.object.schema.properties && !$scope.object.schema.allOf) {
      $scope.selectedDefinition = $scope.object.schema.type;
    } else {
      $scope.selectedDefinition = 'inline';
    }
  }

  self.contentTypes = [{
    value: "none",
    name: translateFilter('assemblyContentTypeNone')
  },{
    value: "application/json",
    name: "application/json"
  },{
    value: "application/xml",
    name: "application/xml"
  },{
    value: "text/xml",
    name: "text/xml"
  },{
    value: "text/plain",
    name: "text/plain"
  }];

  $scope.$contentType = function(type) {
    if (arguments.length) {
      // Setter
      if (type === "" || type === "none") {
        delete $scope.object.content;
      } else {
        $scope.object.content = type;
      }
    } else {
      // Getter
      return $scope.object.content || "none";
    }
  };

  $scope.contentType = $scope.object.content || "none";
  $scope.$watch('contentType', function() {
    if (typeof $scope.contentType === "string") $scope.$contentType($scope.contentType);
  });

  $scope.$inputName = function(newName) {
    if (arguments.length) {
      // Setter
      var updatedInputs = {};
      for(var input in $scope.selectedNode.inputs) {
        if (input === $scope.name) {
          updatedInputs[newName] = $scope.selectedNode.inputs[input];
          $scope.map.inputRenamed(newName,input);
        } else {
          updatedInputs[input] = $scope.selectedNode.inputs[input];
        }
      }
      $scope.selectedNode.inputs = updatedInputs;
      $scope.name = newName;
    } else {
      // Getter
      return $scope.name;
    }
  };
  $scope.$outputName = function(newName) {
    if (arguments.length) {
      // Setter
      var updatedOutputs = {};
      for(var output in $scope.selectedNode.outputs) {
        if(output === $scope.name) {
          updatedOutputs[newName] = $scope.selectedNode.outputs[output];
          $scope.map.outputRenamed(newName,output);
        } else {
          updatedOutputs[output] = $scope.selectedNode.outputs[output];
        }
      }
      $scope.selectedNode.outputs = updatedOutputs;
      $scope.name = newName;
    } else {
      // Getter
      return $scope.name;
    }
  };
  var firstWatchSelectedDefinition = false;
  $scope.$watch('selectedDefinition', function() {
    if (!firstWatchSelectedDefinition) {
      firstWatchSelectedDefinition = true;
      return;
    }
    if ($scope.selectedDefinition === "inline") {
      self.launchInlineEditor();
    } else if ($scope.selectedDefinition.indexOf("#/") === 0) {
      $scope.object.schema = {
        $ref: $scope.selectedDefinition
      };
    } else {
      $scope.object.schema = {
        type: $scope.selectedDefinition
      };
    }
    $scope.$emit('input-output-modified');
  });
  self.launchInlineEditor = function() {
    $modal.open({
      templateUrl: 'src/html/inline-schema.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'InlineSchemaController',
      size: 'lg',
      scope: $scope
    });
  };
}

angular.module('apiconnect-assembly').controller('MapInputOutputController', ['$scope', '$modal', 'translateFilter', MapInputOutputController]);

function InlineSchemaController($scope, $modalInstance) {

  var x2js;
  if (typeof window.X2JS === "function") {
    x2js = new window.X2JS({
      attributePrefix: '@'
    });
  } else {
    x2js = {
      xml2js: function(xml) {
        return xml;
      }
    };
  }

  // default to YAML
  $scope.selectedTabIndex = 0;
  if (!_.isEmpty($scope.object.schema)) {
    $scope.inlineJsonSchema = angular.toJson($scope.object.schema, true);
    $scope.inlineYamlSchema = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.object.schema)), {lineWidth: -1});
    if ($scope.object.schema.example) {
      // JSON or XML?
      try {
        JSON.parse($scope.object.schema.example);
        $scope.inlineJsonObject = $scope.object.schema.example;
      } catch (e) {
        $scope.inlineXMLObject = $scope.object.schema.example;
      }
    }
  }

  $scope.validSchema = false;
  $scope.$watch('inlineYamlSchema', function() {
    if ($scope.selectedTabIndex !== 0) return;
    try {
      jsyaml.safeLoad($scope.inlineYamlSchema);
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });
  $scope.$watch('inlineJsonSchema', function() {
    if ($scope.selectedTabIndex !== 1) return;
    try {
      JSON.parse($scope.inlineJsonSchema);
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });
  $scope.$watch('inlineJsonObject', function() {
    if ($scope.selectedTabIndex !== 2) return;
    try {
      window.jsonSchemaGenerator(JSON.parse($scope.inlineJsonObject));
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });
  $scope.$watch('inlineXMLObject', function() {
    if ($scope.selectedTabIndex !== 3) return;
    try {
      var asJson = x2js.xml2js($scope.inlineXMLObject);
      if (asJson === null) {
        $scope.validSchema = false;
        return;
      }
      window.jsonSchemaGenerator(asJson);
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });

  $scope.generate = function() {
    var schema = {
      "type": "object",
      "allOf": []
    };
    $scope.inputSchemas.forEach(function(input) {
      schema.allOf.push(input);
    });
    $scope.inlineSchema = ($scope.asJson) ? JSON.stringify(schema) : jsyaml.safeDump(schema);
  };

  var cleanJsonSchema = function(schema, object) {
    if (!schema || typeof object === "undefined") return;
    delete schema.required;
    delete schema.$schema;

    // have we worked our way down to a basic type?
    if (typeof object !== "object") {
      delete schema.properties;
      schema.type = (typeof object);
      return;
    }

    if (schema.type === "array") {
      delete schema.uniqueItems;
      delete schema.minItems;
      // look for a missing type property
      if (schema.items && schema.items.properties && !schema.items.type) {
        schema.items.type = 'object';
      }
      cleanJsonSchema(schema.items, object[0]);
      return;
    }
    for (var property in schema.properties) {
      delete schema.properties[property].minLength;
      cleanJsonSchema(schema.properties[property], object[property]);
    }
  };

  var namespaceMap = {};

  // ensures namespaces, prefixes, properties ordering
  function xmlSortFunction(a, b) {
      if ((a.indexOf('@') === 0 && b.indexOf('@') === 0) ||
          (a.indexOf('__') === 0 && b.indexOf('__') === 0)) {
        return 0;
      }
      if (a.indexOf('@') === 0 && b.indexOf('@') === 0) {
        return 0;
      }
      if (a.indexOf('@') === 0) {
        return -1;
      }
      if (a.indexOf('__') === 0 && b.indexOf('__') === 0) {
        return 0;
      }
      if (a.indexOf('__') === 0 && b.indexOf('@') === 0) {
        return 1;
      }
      if (a.indexOf('__') === 0) {
        return -1;
      }
      if (b.indexOf('@') === 0 || b.indexOf('__') === 0) {
        return 1;
      }
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
  };

  var injectXmlConfig = function(schema, object, currentNamespace) {
    if (!schema || typeof object === "undefined") return;

    delete schema.required;
    delete schema.$schema;

    // have we worked our way down to a basic type?
    if (typeof object !== "object") {
      delete schema.properties;
      schema.type = (typeof object);
      if (currentNamespace !== "") {
        // we have no namespace prefix here, but our parent does
        // so override...
        schema.xml = {
          namespace: ''
        };
      }
      return;
    }
    if (schema.type === "array") {
      delete schema.uniqueItems;
      delete schema.minItems;
      // look for a missing type property
      if (schema.items && schema.items.properties && !schema.items.type) {
        schema.items.type = 'object';
      }
      injectXmlConfig(schema.items, object[0], currentNamespace);
      return;
    }
    // ensure iteration order
    // this way we pick up namespaces first
    var keys = Object.keys(schema.properties).sort(xmlSortFunction);

    // default override of parent namespace
    schema.xml = {
      namespace: ''
    };

    keys.forEach(function(property) {
      delete schema.properties[property].minLength;
      if (property.indexOf('@') === 0) {
        // we have an attribute
        var nsName;
        var attrProperty = property.substring(1);
        if (attrProperty.indexOf("xmlns") === 0) {
          delete schema.properties[property];
          schema.xml = {
            namespace: object[property]
          };
          nsName = attrProperty.split(":");
          nsName = (nsName.length > 1) ? nsName[1] : '';
          namespaceMap[nsName] = object[property];
        } else {
          // is the attribute namespaced?
          if (attrProperty.indexOf(':') > 0) {
            var split = attrProperty.split(':');
            attrProperty = split[1];
            nsName = split[0];
          }
          schema.properties[attrProperty] = schema.properties[property];
          delete schema.properties[property];
          schema.properties[attrProperty].xml = {attribute: true};
          if (nsName) {
            schema.properties[attrProperty].xml.prefix = nsName;
          }
        }
      } else if (property.indexOf('__') === 0) {
        // could be __prefix or __text
        // if it's __prefix, we want to add it to the xml config
        if (property === "__prefix") {
          if (object[property] !== currentNamespace) {
            currentNamespace = object[property];
            if (!schema.xml) schema.xml = {};
            schema.xml.prefix = object[property];
            if (namespaceMap[schema.xml.prefix]) {
              schema.xml.namespace = namespaceMap[schema.xml.prefix];
            }
          } else {
            // inherit...
            delete schema.xml;
          }
        } else if (property === "__text") {
          // we're a text leaf node
          schema.type = "string";
        }
        delete schema.properties[property];
      } else {
        if (!object[property] || typeof object[property] === "function") {
          delete schema.properties[property];
        } else {
          injectXmlConfig(schema.properties[property], object[property], currentNamespace);
        }
      }
    });
    // we may have cleaned out all properties if those properties were namespace-related
    if (schema.properties && Object.keys(schema.properties).length === 0) delete schema.properties;
  };

  $scope.generateAndShow = function() {
    var definition = '';
    var object;
    switch($scope.selectedTabIndex) {
      case 2:
        object = JSON.parse($scope.inlineJsonObject);
        definition = window.jsonSchemaGenerator(object);
        cleanJsonSchema(definition, object);
        var sanitizedExampleJSON = JSON.stringify(object);
        definition.example = sanitizedExampleJSON;
        break;
      case 3:
        object = x2js.xml2js($scope.inlineXMLObject);
        definition = window.jsonSchemaGenerator(object);
        // clear any existing namespace map
        namespaceMap = {};
        injectXmlConfig(definition, object, '');
        definition.example = $scope.inlineXMLObject;
        break;
    }
    try {
      $scope.inlineYamlSchema = jsyaml.safeDump(definition);
    } catch (e) {
      $scope.inlineYamlSchema = jsyaml.dump(definition);
    }
    $scope.inlineJsonSchema = JSON.stringify(definition);
    $scope.object.schema = definition;
    $scope.selectedTabIndex = 0;
  };

  $scope.commit = function() {
    var definition = '';
    var object;
    switch($scope.selectedTabIndex) {
      case 0:
        definition = jsyaml.safeLoad($scope.inlineYamlSchema);
        break;
      case 1:
        definition = JSON.parse($scope.inlineJsonSchema);
        break;
      case 2:
        object = JSON.parse($scope.inlineJsonObject);
        definition = window.jsonSchemaGenerator(object);
        cleanJsonSchema(definition, object);
        definition.example = $scope.inlineJsonObject;
        break;
      case 3:
        object = x2js.xml2js($scope.inlineXMLObject);
        definition = window.jsonSchemaGenerator(object);
        // clear any existing namespace map
        namespaceMap = {};
        injectXmlConfig(definition, object, '');
        definition.example = $scope.inlineXMLObject;
        break;
    }
    $scope.object.schema = definition;
    $modalInstance.close();
  };

  $scope.cancel = function() {
    $modalInstance.close();
  };

}

angular.module('apiconnect-assembly').controller('InlineSchemaController', ['$scope', '$modalInstance', InlineSchemaController]);

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
'use strict';

function ConditionController($scope) {
  $scope.expression = window.jsep($scope.condition);
  $scope.$watch("expression", function() {
    var expressionString = window.jseb($scope.expression);
    $scope.$emit("condition-change", expressionString);
    console.log(expressionString);
  }, true);
  function pruneExpression(tree, leaf) {
    if (!tree || !leaf) return tree;
    if (angular.equals(tree.left, leaf)) return tree.right;
    if (angular.equals(tree.right, leaf)) return tree.left;
    tree.left = pruneExpression(tree.left, leaf);
    tree.right = pruneExpression(tree.right, leaf);
    return tree;
  }
  $scope.deleteExpression = function(expression) {
    var newExpression = pruneExpression($scope.expression, expression);
    for (var prop in $scope.expression) {
      if ($scope.expression.hasOwnProperty(prop)) {
        delete $scope.expression[prop];
      }
    }
    angular.extend($scope.expression, newExpression);
  };
};

angular.module('apiconnect-assembly').controller('ConditionController', ['$scope', ConditionController]);

function ConditionExpressionController($scope, Expressions) {

  $scope.$watch('expression', function() {
    $scope.expressionString = window.jseb($scope.expression);

    if (Expressions.isOperationExpression($scope.expression)) {
      $scope.isOperation = true;
      $scope.operationString = Expressions.getOperationString($scope.expression);
    } else {
      $scope.isOperation = false;
    }
  });
  
  $scope.expand = function(expanded) {
    $scope.expanded = expanded;
  };

  $scope.isLogicalExpression = function() {
    return $scope.expression.type === "LogicalExpression";
  };
  $scope.changeOperator = function(operator) {
    $scope.expression.operator = operator;
  };
  $scope.insertLogicalExpression = function(operator) {
    var currentExpression = angular.copy($scope.expression);
    for (var prop in $scope.expression) {
      if ($scope.expression.hasOwnProperty(prop)) {
        delete $scope.expression[prop];
      }
    }
    // left operator right type
    $scope.expression.operator = operator;
    $scope.expression.type = "LogicalExpression";
    var newExpression = window.jsep('$(operation.verb) == "get"');
    newExpression.$$edit = true;
    $scope.expression.right = newExpression;
    $scope.expression.left = currentExpression;
  };

  $scope.commitExpression = function() {
    try {
      var newExpression = window.jsep($scope.expressionString);
      for (var prop in $scope.expression) {
        if ($scope.expression.hasOwnProperty(prop)) {
          delete $scope.expression[prop];
        }
      }
      angular.extend($scope.expression, newExpression);
    } catch (e) {}
  };
};

angular.module('apiconnect-assembly').controller('ConditionExpressionController', ['$scope', 'Expressions', ConditionExpressionController]);

function ConditionExpressionLeftController($scope, $controller) {
  $scope.parentExpression = $scope.expression;
  $scope.expression = $scope.parentExpression.left;
  $scope.$watch('parentExpression', function() {
    $scope.expression = $scope.parentExpression.left;
  }, true);
  $controller('ConditionExpressionController', {$scope: $scope});
}

angular.module('apiconnect-assembly').controller('ConditionExpressionLeftController', ['$scope', '$controller', ConditionExpressionLeftController]);

function ConditionExpressionRightController($scope, $controller) {
  $scope.parentExpression = $scope.expression;
  $scope.expression = $scope.parentExpression.right;
  $scope.$watch('parentExpression', function() {
    $scope.expression = $scope.parentExpression.right;
  }, true);
  $controller('ConditionExpressionController', {$scope: $scope});
}

angular.module('apiconnect-assembly').controller('ConditionExpressionRightController', ['$scope', '$controller', ConditionExpressionRightController]);


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
'use strict';

angular.module('apiconnect-assembly').factory('Expressions', function() {
	function isVerbExpression(expression) {
		// request.verb==='GET'
		if (expression.type !== "BinaryExpression") return false;
		if (expression.left.type !== "MemberExpression") return false;
		if (expression.left.object.name !== "request") return false;
		if (expression.left.property.name !== "verb") return false;
		if (expression.right.type !== "Literal") return false;
		return true;
	}
	function isPathExpression(expression) {
		// api.operation.path==='/path'
		if (expression.type !== "BinaryExpression") return false;
		if (expression.operator !== "==" && expression.operator !== "===") return false;
		if (expression.left.type !== "MemberExpression") return false;
		if (expression.left.object.type !== "MemberExpression") return false;
		if (expression.left.object.object.name !== "api") return false;
		if (expression.left.object.property.name !== "operation") return false;
		if (expression.left.property.name !== "path") return false;
		if (expression.right.type !== "Literal") return false;
		return true;
	}
	function isOperationExpression(expression) {
		if (expression.type !== "LogicalExpression") return false;
		if (expression.operator !== "&&") return false;
		// one of them must be a verb expression
		if (!isVerbExpression(expression.left) && !isVerbExpression(expression.right)) return false;
		// one of them must be a path expression
		if (!isPathExpression(expression.left) && !isPathExpression(expression.right)) return false;
		return true;
	}
	function isOperationIdExpression(expression) {
		// api.operation.id==='opId'
		if (expression.type !== "BinaryExpression") return false;
		if (expression.operator !== "==" && expression.operator !== "===") return false;
		if (expression.left.type !== "MemberExpression") return false;
		if (expression.left.object.type !== "MemberExpression") return false;
		if (expression.left.object.object.name !== "api") return false;
		if (expression.left.object.property.name !== "operation") return false;
		if (expression.left.property.name !== "id") return false;
		if (expression.right.type !== "Literal") return false;
		return true;
	}
	function getOperationString(expression) {
		if (!isOperationExpression(expression)) return "";
		if (["get", "put", "post", "delete", "options", "patch", "head"].indexOf(expression.left.right.value.toLowerCase()) >= 0) {
			return expression.left.right.value + " " + expression.right.right.value;
		} else {
			return expression.right.right.value + " " + expression.left.right.value;
		}
	}
	function getOperationObject(expression) {
		if (!expression || !expression.left || !expression.left.right || !expression.right || !expression.right.right) return {};
		if (["get", "put", "post", "delete", "options", "patch", "head"].indexOf(expression.left.right.value.toLowerCase()) >= 0) {
			return {
				verb: expression.left.right.value,
				path: expression.right.right.value,
				$$expressionString: window.jseb(expression)
			};
		} else {
			return {
				verb: expression.right.right.value,
				path: expression.left.right.value,
				$$expressionString: window.jseb(expression)
			};
		}
	}
	function getOperationIdString(expression) {
		if (!isOperationIdExpression(expression)) return "";
		return expression.right.value;
	}
	function getOperationIdObject(expression) {
		if (!expression || !expression.right) return {};
		return {
			operationId: expression.right.value,
			$$expressionString: window.jseb(expression)
		};
	}
	function knownExpression(expression) {
		if (isOperationExpression(expression)) return true;
		if (isOperationIdExpression(expression)) return true;
		return false;
	}
	function knownExpressionString(expression) {
		if (isOperationExpression(expression)) return getOperationString(expression);
		if (isOperationIdExpression(expression)) return getOperationIdString(expression);
	}
	function knownExpressionObject(expression) {
		if (isOperationExpression(expression)) return getOperationObject(expression);
		if (isOperationIdExpression(expression)) return getOperationIdObject(expression);
	}
	function highLevelExpression(expression) {
		if (knownExpression(expression)) return true;
		if (!expression.left || !highLevelExpression(expression.left)) return false;
		if (!expression.right || !highLevelExpression(expression.right)) return false;
		return true;
	}
	function highLevelExpressionString(expression) {
		var asString = knownExpressionString(expression);
		if (asString) return asString;
		if (expression.left && expression.right) {
			var leftString = highLevelExpressionString(expression.left);
			if (!leftString) return;
			var rightString = highLevelExpressionString(expression.right);
			if (!rightString) return;
			return leftString + " or " + rightString;
		}
	}
	function expressionAsChipsHelper(expression, chips) {
		var asObj = knownExpressionObject(expression);
		if (asObj) {
			chips.push(asObj);
			return chips;
		}
		if (expression.left) expressionAsChipsHelper(expression.left, chips);
		if (expression.right) expressionAsChipsHelper(expression.right, chips);
		return chips;
	}
	function expressionAsChips(expression) {
		return expressionAsChipsHelper(expression, []);
	}
	function chipsAsExpressionString(chips) {
		if (!chips || chips.length === 0) return "";
		var expressionString = "(" + chips[0].$$expressionString + ")";
		for (var i = 1; i < chips.length; i++) {
			expressionString += "||(" + chips[i].$$expressionString + ")";
		}
		return expressionString;
	}
	function expressionAsString(expression) {
		return highLevelExpressionString(expression) || window.jseb(expression);
	}
	return {
		isOperationExpression: isOperationExpression,
		isOperationIdExpression: isOperationIdExpression,
		getOperationString: getOperationString,
		getOperationIdString: getOperationIdString,
		highLevelExpression: highLevelExpression,
		expressionAsString: expressionAsString,
		expressionAsChips: expressionAsChips,
		chipsAsExpressionString: chipsAsExpressionString
	};
});


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly.recursion-helper', []).factory('RecursionHelper', ['$compile', function($compile) {
  return {
    /**
     * Manually compiles the element, fixing the recursion loop.
     * @param {Element} element
     * @param {function} [link] A post-link function, or an object with function(s)
     * registered via pre and post properties.
     * @returns An object containing the linking functions.
     */
    compile: function(element, link) {
      // Normalize the link parameter
      if (angular.isFunction(link)) {
        link = {post: link};
      }

      // Break the recursion loop by removing the contents
      var contents = element.contents().remove();
      var compiledContents;
      return {
        pre: (link && link.pre) ? link.pre : null,
        /**
         * Compiles and re-adds the contents
         */
        post: function(scope, element) {
          // Compile the contents
          if (!compiledContents) {
            compiledContents = $compile(contents);
          }
          // Re-add the compiled contents to the element
          compiledContents(scope, function(clone) {
            element.append(clone);
          });

          // Call the post-linking function, if any
          if (link && link.post) {
            link.post.apply(null, arguments);
          }
        }
      };
    }
  };
}]);


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

angular.module('apiconnect-assembly').filter('translateMultiple', ['translateFilter', function(translateFilter) {
  return function (property, values) {
    return translateFilter(property, values);
  };
}]);

angular.module('apiconnect-assembly').filter('translatePlurality', ['translateFilter', function(translateFilter) {
  return function (value, property, substituteVar) {
    var substitutions = {};
    if (!substituteVar) {
      substituteVar = "0";
    }
    substitutions[substituteVar] = value;
    if (value === 1) {
      return translateFilter(property + "Singular", substitutions);
    } else {
      return translateFilter(property + "Plural", substitutions);
    }
  };
}]);


/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

var basicTypes = {
  integer: {
    type: "integer",
    format: "int32"
  },
  long: {
    type: "integer",
    format: "int64"
  },
  float: {
    type: "number",
    format: "float"
  },
  double: {
    type: "number",
    format: "double"
  },
  string: {
    type: "string"
  },
  byte: {
    type: "string",
    format: "byte"
  },
  binary: {
    type: "string",
    format: "binary"
  },
  boolean: {
    type: "boolean"
  },
  date: {
    type: "string",
    format: "date"
  },
  dateTime: {
    type: "string",
    format: "date-time"
  },
  password: {
    type: "string",
    format: "password"
  },
  array: {
    type: "array"
  },
  object: {
    type: "object"
  }
};

// specialization of the excellent json-schema-view listed in package.json
angular.module('apiconnect-assembly.mapper-schema', ['apiconnect-assembly.recursion-helper'])

.controller('SchemaPropertyController', ['$scope', 'SchemaReferences', function($scope, SchemaReferences) {

  if ($scope.schema && $scope.schema.$$extender) {
    $scope.extendingObjectName = $scope.schema.$$extender;
  }

  $scope.propertyCollapsed = $scope.open < 1 && !$scope.isPrimitive;

  $scope.toggleProperty = function() {
    $scope.$broadcast('collapse-property', $scope.property);
    $scope.propertyCollapsed = !$scope.propertyCollapsed;
  };

  if (!$scope.propertyCollapsed) SchemaReferences.unwindRefs($scope.property, $scope.definitions, $scope.references);

  $scope.propertyIsArray = ($scope.property.type === "array");

  if ($scope.property.type === "object") $scope.propertyIsObject = true; // is an object...
  if ($scope.property.properties !== undefined) $scope.propertyIsObject = true; // or has properties defined...
  if ($scope.property.type === "array" && $scope.property.items && $scope.property.items.type === "object") $scope.propertyIsObject = true; // or is an array of objects

}])

.directive('apicMapperSchema', ['RecursionHelper', 'SchemaReferences', 'ExtensionType', function(RecursionHelper, SchemaReferences, ExtensionType) {
  function link($scope) {
    /*
     * Recursively walk the schema and add property 'name' to property objects
    */
    function addPropertyName(schema) {
      if (!schema) {
        return;
      }
      if (angular.isObject(schema.items)) {
        addPropertyName(schema.items);
      }
      else if (angular.isObject(schema.properties)) {
        Object.keys(schema.properties).forEach(function(propertyName) {
          var prefix = "";
          if (angular.isObject(schema.properties[propertyName].xml) && schema.properties[propertyName].xml.attribute === true && propertyName.indexOf('@') !== 0) {
            prefix = "@";
          }
          schema.properties[propertyName].name = prefix + propertyName;
          addPropertyName(schema.properties[propertyName]);
        });
      }
    }

    // Determine unique name for an extending type by looking at the
    // x-xsi-type and x-xsi-type-uniquename attrbutes
    $scope.getUniqueTypeName = function(type) {
        if (type['x-xsi-type-uniquename']) {
          return type['x-xsi-type-uniquename'];
        }
        return type['x-xsi-type'];
    };

    // are we a root?
    $scope.isRoot = (typeof $scope.root === "undefined") ? true : false;
    if ($scope.editable === false) $scope.schemaEditable = false;
    if (typeof $scope.schemaEditable === "undefined") {
      $scope.schemaEditable = !$scope.schema.$ref;
    }

    if (!$scope.editable) {
      // if we're not editable, clone the schema to prevent
      // accidental modifications leaking into the document
      $scope.schema = angular.copy($scope.schema);
    }

    SchemaReferences.unwindRefs($scope.schema, $scope.definitions, $scope.references);

    addPropertyName($scope.schema);

    // Determine if a schema is an array
    $scope.isArray = $scope.schema && $scope.schema.type === 'array';

    // Determine if a schema is a primitive
    // primitive if it has a schema with a type, but not object or array, and no properties or items
    $scope.isPrimitive = $scope.schema &&
      !$scope.schema.properties &&
      !$scope.schema.items &&
      typeof $scope.schema.type !== 'undefined' &&
      $scope.schema.type !== 'array' &&
      $scope.schema.type !== 'object';

    // mark as collapsed in the open count has reduced to zero, and the item is not a primitive
    $scope.isCollapsed = $scope.open < 1 && !$scope.isPrimitive;

    if (!$scope.isCollapsed) SchemaReferences.unwindRefs($scope.schema, $scope.definitions, $scope.references);

    $scope.isDiscriminator = false;
    if (!$scope.isArray && !$scope.isPrimitive && $scope.schema["x-ibm-discriminator"]) {
    	// must check if parent is one of the concrete types this schema can be extended by
    	var concreteParent = false;
    	var typeLen = $scope.schema.$$extendingTypes.length;
    	for (var i=0;i<typeLen;i++) {
    		var extendingType = $scope.schema.$$extendingTypes[i];
    		if ($scope.getUniqueTypeName(extendingType) === $scope.getUniqueTypeName($scope.parentSchema)) {
    			concreteParent = true;
    			break;
    		}
    	} // end for
    	// no need to show discriminator choice with a concrete parent type
    	if (!concreteParent && typeLen > 0) {
    		$scope.isDiscriminator = true;
    	}
    }

    $scope.showProperty = function(propertyName) {
      if ($scope.isCollapsed) {
        // do not show any properties when collapsed
        return false;
      }
      if (propertyName === 'x-ibm-discriminator') {
        // do not show the x-ibm-discriminator property when there are no
        // extending types or this is not a discriminator
        if (!$scope.schema.$$extendingTypes || !$scope.isDiscriminator) {
          return false;
        }
      }
      return true;
    };

    /*
     * Toggles the 'collapsed' state
    */
    $scope.toggle = function() {
      $scope.isCollapsed = !$scope.isCollapsed;
      SchemaReferences.unwindRefs($scope.schema, $scope.definitions, $scope.references);
      $scope.$emit('json-schema-view-property-collapsed');
    };

    $scope.deleteProperty = function() {
      if ($scope.parentSchema && $scope.parentSchema.properties &&
        $scope.parentSchema.properties[$scope.schema.name]) {
          delete $scope.parentSchema.properties[$scope.schema.name];
      } else if ($scope.parentSchema && $scope.parentSchema.items) {
        delete $scope.parentSchema.items;
      }
      $scope.$emit('json-schema-view-property-modified', $scope.parentSchema);
    };

    /*
     * Returns true if property is required in given schema
    */
    $scope.isRequired = function(schema) {
      var parent = $scope.$parent.schema;

      if (parent && Array.isArray(parent.required) && schema.name) {
        return parent.required.indexOf(schema.name) > -1;
      }

      return false;
    };

    /*
     * Returns true if the schema is too simple to be collapsible
    */
    $scope.isPrimitiveCollapsible = function() {
      return $scope.schema.description ||
        $scope.schema.title;
    };

    /*
     * Converts anyOf, allOf and oneOf to human readable string
    */
    $scope.convertXOf = function(type) {
      return type.substring(0, 3) + ' of';
    };

    $scope.$on('collapse-property', function(event, property) {
      if (property === $scope.schema) $scope.toggle();
    });

    $scope.getPath = function() {
      if (!$scope.$parent.getPath) {
        // we're at the root
        return $scope.schema.title || $scope.schema.$$title;
      }
      var parentPath = $scope.$parent.getPath();
      parentPath = parentPath.replace(/\.\$item$/, "");
      if ($scope.schema.name) {
        return parentPath + "." + $scope.schema.name.replace(/\./g,'\\.');
      }
      if ($scope.$parent.isArray) {
        return parentPath;
      }
      return parentPath;
    };

    // $scope.getDimensionArray = function() {
    //   var dimensions;
    //   if (!$scope.$parent.getDimensionArray) {
    //     // we're at the root
    //     if ($scope.isArray || $scope.$parent.isArray) {
    //       dimensions = [$scope.getPath()];
    //     } else {
    //       dimensions = [];
    //     }
    //     return dimensions;
    //   }
    //   if ($scope.isArray || $scope.$parent.isArray) {
    //     dimensions = $scope.$parent.getDimensionArray();
    //     dimensions.pop();
    //     dimensions.push($scope.getPath());
    //     return dimensions;
    //   } else {
    //     // we're not an array, so replace the parent path
    //     dimensions = $scope.$parent.getDimensionArray();
    //     dimensions.pop();
    //     dimensions.push($scope.getPath());
    //     return dimensions;
    //   }
    // };

    $scope.getDimensionArray = function() {
      if (!$scope.$parent.getDimensionArray) {
        // we're at the root
        if ($scope.isArray) {
          return [$scope.getPath()];
        } else {
          return [];
        }
      }
      if ($scope.isArray) {
        var dimensions = $scope.$parent.getDimensionArray();
        dimensions.push($scope.getPath());
        return dimensions;
      } else {
        return $scope.$parent.getDimensionArray();
      }
    };

    $scope.getContainer = function() {
      if (!$scope.$parent.getContainer) {
        // we're at the root
        return $scope.getPath();
      }
      return ($scope.isArray) ? $scope.getPath() : $scope.$parent.getPath();
    };

    function flattenParentTypes(allOf) {
    	var ret = [];
    	if (allOf) {
    		allOf.forEach(function(allOfItem) {
    			if (allOfItem.$$extendedParents) {
    				var parents = allOfItem.$$extendedParents;
    				while (parents && parents.types && parents.types.length > 0) {
    					ret = ret.concat(parents.types);
    					parents = parents.parentTypes;
    				} // end while
    			}
    		});
    	}
    	return ret;
    }

    function setExtensionTypes(type) {
		$scope.schema.allOf = [];
		if (!type) {
			// unset selection will show all possible types again
    		$scope.schema.$$extendingTypes.forEach(function(extendingType) {
    			$scope.schema.allOf = $scope.schema.allOf.concat(extendingType.allOf);
    		});
		} else {
    		$scope.schema.$$extendingTypes.forEach(function(extendingType) {
    			if ($scope.getUniqueTypeName(extendingType) === type) {
        			$scope.schema.allOf = $scope.schema.allOf.concat(extendingType.allOf);
        			var parentTypes = flattenParentTypes(extendingType.allOf);
        			if (parentTypes.length > 0) {
            			$scope.schema.allOf = $scope.schema.allOf.concat(parentTypes);
        			}
    			}
    		});
		}
    }

    $scope.previousType = "";
    $scope.$discriminatorType = function(type) {
    	if (arguments.length) {
    		// setter
			setExtensionTypes(type);
    		var path = $scope.getPath() + ".x-ibm-discriminator";
    		ExtensionType.setValueForPath(path, type);
    		$scope.schema.allOf.forEach(function(allOfItem) {
        		addPropertyName(allOfItem);
    		});
    		$scope.$emit('json-schema-view-refresh', true);	// trigger canvas update
    	} else {
    		// getter
    		var extensionPath = $scope.getPath() + ".x-ibm-discriminator";
    		var discriminator = ExtensionType.getValueForPath(extensionPath);
    		// first time through, add the chosen allOf clause
    		if ($scope.schema.$$extendingTypes && $scope.previousType !== discriminator) {
    			$scope.previousType = discriminator;
    			setExtensionTypes(discriminator);
        		$scope.schema.allOf.forEach(function(allOfItem) {
            		addPropertyName(allOfItem);
        		});
        		$scope.$emit('json-schema-view-refresh', false);	// trigger canvas update
    		}
    		return discriminator ? discriminator : "";
    	}
    };
  }

  return {
    restrict: 'E',
    templateUrl: 'src/html/mapper-schema/json-schema-view.html',
    scope: {
      'schema': '=',
      'parentSchema': '=',
      'name': '=',
      'open': '=',
      'definitions': '=',
      'root': '=',
      'editable': '=',
      'references': '='
    },
    compile: function(element) {

      // Use the compile function from the RecursionHelper,
      // And return the linking function(s) which it returns
      return RecursionHelper.compile(element, link);
    }
  };
}])

.controller('AddPropertyController', ['$scope', function($scope) {

  $scope.basicTypes = basicTypes;
  $scope.propertyType = 'string';

  $scope.addProperty = function() {
    if ($scope.isArray) {
      // we're adding an item definition to an array schema
      $scope.schema.items = angular.copy(basicTypes[$scope.propertyType]);
    } else {
      // we're adding a property definition to an object schema
      if (!$scope.propertyName || $scope.propertyName === "") return;
      if (!$scope.schema.properties) $scope.schema.properties = {};
      if ($scope.schema.properties[$scope.propertyName]) return;
      $scope.schema.properties[$scope.propertyName] = angular.copy(basicTypes[$scope.propertyType]);
      $scope.schema.properties[$scope.propertyName].name = $scope.propertyName;
    }
    $scope.addProp = false;
    delete $scope.propertyName;
    $scope.$emit('json-schema-view-property-modified');
  };

}]);

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

angular.module('apiconnect-assembly-localization', [
]).config(['$translateProvider', function ($translateProvider) {
  $translateProvider.useSanitizeValueStrategy('escaped');
  var enBundle = {
    "assemblySaving": "Saving assembly...",
    "assemblySaved": "Assembly saved",
    "assembly-move-panel": "Toggle info panel between right and bottom",
    "assembliesNoAssembliesFound": "No assemblies found.",
    "assembliesNoMatchingAssemblies": "There are no assemblies that match the chosen filters.",
    "assembly_empty_schema": "There are no properties to configure for this policy",
    "assembly_otherwise": "otherwise",
    "assembly_title": "Title",
    "assembly_filter_policies": "Filter policies",
    "assembly_policies_filter_micro": "Micro Gateway policies",
    "assembly_policies_filter_dp": "DataPower Gateway policies",
    "assembly_node_gateway_mismatch": "This policy is not available on the selected gateway",
    "assemblies_search": "Search assemblies",
    "assemblyLastModified": "Last modified",
    "assemblyCreateProduct": "Create and publish",
    "assemblyRefreshProducts": "Refresh products",
    "assemblyRepublishProduct": "Republish product",
    "assemblySubscribeApp": "Subscribe",
    "assemblyCreateAndSubscribeApp": "Create and subscribe",
    "assemblyAppName": "App name",
    "assemblyPlanName": "Plan name",
    "assemblyCondition": "Condition",
    "assemblerMapperConfigureTarget": "Configure mapping",
    "assemblerMapperIterate": "Iterate?",
    "assemblerMapperIterateOn": "Iterate on",
    "assemblerMapperOutputArray": "Output array",
    "assemblerMapperInputArray": "iterate over",
    "assemblerMapperIterateOutput": "The output of this mapping is within an array and it's contents will be created by iterating over the chosen input. If the chosen input isn't an array, an array of length 1 will be produced.",
    "assemblerMapperIterateDescription": "Some inputs are arrays, or contained within arrays. To iterate over the contents, choose the iterate option and choose the input over which to iterate.",
    "assemblerMapperInputSchema": "Source schema",
    "assemblerMapperMappedFrom": "Mapped from: ",
    "assemblerMapperOutputSchema": "Target schema",
    "assemblerMapperTargetDescription": "Property {{target}} is currently mapped to {{from}} - the mapping can be removed below.",
    "assemblerMapperTargetNoMapDescription": "Property {{target}} can be assigned a static value by entering it below.",
    "assemblerMapperValue": "Value",
    "assemblerMapperDefault": "Default",
    "assemblerMapperEmptyString": "Empty string as default value",
    "assemblerMapperValueDescription": "A simple JavaScript expression which resolves to the value of the output. This could be a static string ('my static string'), or an expression involving any mapped inputs ($(input.firstName) + ' ' + $(input.lastName))",
    "assemblerMapperDefaultDescription": "A default value which will be used if the inputs to the map are not defined.",
    "assemblyMapSource": "Input",
    "assemblyEditInputs": "Edit inputs",
    "assemblyMapTransformation": "Map",
    "assemblyMapTarget": "Output",
    "assemblyEditOutputs": "Edit outputs",
    "assemblyRefresh": "Refresh",
    "assembly-create-assembly": "Create assembly",
    "assembly-no-assembly": "This API does not yet contain an assembly. Would you like to create one?",
    "assemblySearchErrors": "search errors...",
    "assemblySearchOperations": "search operations...",
    "assemblyFilterOperations": "Select operation...",
    "assemblyFilterOperationsLabel": "Filter by operation",
    "assemblyClearFilterOperationsLabel": "Clear operation filter",
    "assemblySearchDefinitions": "search definitions...",
    "assemblyZoomLabel": "Zoom in and out",
    "assemblyShowCatches": "Show catches",
    "assemblyCase": "case",
    "assemblyCatch": "catch",
    "assemblyEmptyCase": "empty case",
    "assemblyEmptyCatch": "empty catch",
    "assemblyActivityLogContent": "Content",
    "assemblyActivityLogErrorContent": "Error content",
    "assemblyAddCase": "+ Case",
    "assemblyAddCaseTitle": "Add case",
    "assemblyAddCatch": "+ Catch",
    "assemblyAddCatchDefault": "+ Default",
    "assemblyAddCatchTitle": "Add catch",
    "assemblyAddCatchDefaultTitle": "Add default catch",
    "assemblyAddOtherwise": "+ Otherwise",
    "assemblyOtherwise": "otherwise",
    "assemblyRemoveAction": "Remove",
    "assemblyAddAction": "+ Action",
    "assemblyAction": "Action",
    "assemblyRemoveActionTitle": "Remove action",
    "assemblyAddActionTitle": "Add action",
    "assemblyRedactPath": "Path",
    "assemblyRedactRemove": "Remove",
    "assemblyRedactRedact": "Redact",
    "assemblyRedactFrom": "+ redact from...",
    "assemblyRedactAll": "or redact from all",
    "assemblyRemoveCase": "Remove case",
    "assemblyRemoveCatch": "Remove catch",
    "assemblyMoveUp": "Move up",
    "assemblyMoveDown": "Move down",
    "assemblyPinMenu": "Pin menu",
    "assemblyMaximize": "Maximize / minimize",
    "assemblyJumpToSource": "Jump to source",
    "assemblyTitle": "Title",
    "assemblyDescription": "Description",
    "assemblyExpression": "Condition",
    "assemblyConvertToExpression": "Convert to expression",
    "assemblyLaunchExpressionEditor": "edit condition",
    "assemblyOr": "or",
    "assemblyExpressionEditor": "Condition editor",
    "assemblyDefinition": "Definition",
    "assemblyActionValue": "Value",
    "assemblyActionAdd": "Add",
    "assemblyActionSet": "Set",
    "assemblyActionClear": "Clear",
    "assemblyFitToScreen": "Fit to screen",
    "assemblyZoomIn": "Zoom in",
    "assemblyZoomOut": "Zoom out",
    "assemblyPrevious": "Previous",
    "assemblyNext": "Next",
    "assemblyDone": "Done",
    "assemblyCloseInfo": "Close",
    "assemblyInvoke": "Invoke",
    "assemblyTest": "Test",
    "assemblyTestIdentification": "Identification",
    "assemblyTestAuthorization": "Authorization",
    "assemblyTestAuthorize": "Authorize",
    "assemblyTestRefreshToken": "Refresh token",
    "assemblyTestForgetToken": "Forget token",
    "assemblyTestBasicAuth": "This operation is secured with basic authentication",
    "assemblyTestOauthPassword": "This operation is secured with password flow OAuth",
    "assemblyTestOauthImplicit": "This operation is secured with implicit flow OAuth",
    "assemblyTestOauthAccessCode": "This operation is secured with access code flow OAuth",
    "assemblyTestOauthApplication": "This operation is secured with application flow OAuth",
    "assemblyTestOauthTokenStorage": "The token will not be stored in either a cookie or local storage. If you close the test panel, the token will be lost but may still be valid.",
    "assemblyAppSecret": "Please take note of the client ID and secret for this new application. Store the secret somewhere safe as it cannot be retrieved again, although it can be reset if required:",
    "assemblyTestUsername": "Username",
    "assemblyTestPassword": "Password",
    "assemblyBackToTest": "Back to test",
    "assemblyTestSetup": "Setup",
    "assemblyTestResponse": "Response",
    "assemblyTestResponseCode": "Status code",
    "assemblyTestResponseBody": "Body",
    "assemblyTestResponseTime": "Response time",
    "assemblyTestCallCounter": "Counter",
    "assemblyTestTotalTime": "Total time",
    "assemblyTestAverageTime": "Average time",
    "assemblyTestHeaders": "Headers",
    "assemblyTestDebug": "Debug",
    "assemblyNoDebugData": "No debug data was found for this API call",
    "assemblyApiUnpublishedChanges": "The API may have unpublished changes. Would you like to republish the product?",
    "assemblyApiUnsavedChanges": "The API has unsaved changes.",
    "assemblyApiSaveRepublish": "Save and republish",
    "assemblyTestCatalogDesc": "Choose a catalog to test within:",
    "assemblyTestProductDesc": "Choose a product containing this API, or create a new one:",
    "assemblyTestProductExisting": "Choose an existing product",
    "assemblyTestProductCreate": "Or create a new product and publish it to the selected catalog",
    "assemblyTestProductDoesntContainApi": "The selected product does not contain this API",
    "assemblyTestProductNotPublished": " The selected product is not published to the selected catalog, so it is not possible to subscribe the application",
    "assemblyTestProductAddApi": "Add API",
    "assemblyTestPlanDesc": "Choose a plan against which to test:",
    "assemblyTestAppDesc": "Choose an application with which to test, or create a new one:",
    "assemblyTestAppExisting": "Choose an existing application",
    "assemblyTestAppCreate": "Or create a new application and subscribe to the selected plan",
    "assemblyTestChooseOperation": "Choose an operation to invoke:",
    "assemblyTestRepeat": "Repeat",
    "assemblyTestRepeatDesc": "Repeat the API invocation a set number of times, or until the stop button is clicked",
    "assemblyTestRepeatFor": "Stop after:",
    "assemblyTestStopOnError": "Stop on error",
    "assembly_test_minus_one_response": "No response received. Causes include a lack of CORS support on the target server, the server being unavailable, or an untrusted certificate being encountered.",
    "assemblyStopInvoke": "Stop",
    "assemblyShowSchema": "Show schema",
    "assemblyGenerateData": "Generate",
    "assemblyChangeSetup": "Change setup",
    "assemblyGenerateDefaultObject": "Generate an object",
    "assemblyAverageResponseTime": "Average response time: {{value}}ms",
    "assemblyResponseTime": "Response time: {{value}}ms",
    "assemblyContextVariable": "Context variable",
    "assemblyAddInputTitle": "+ input",
    "assemblyAddParametersTitle": "+ parameters for operation...",
    "assemblyAddOutputsTitle": "+ outputs for operation...",
    "assemblyAddOutputTitle": "+ output",
    "assemblyRemoveInput": "Remove input",
    "assemblyRemoveOutput": "Remove output",
    "assemblyRemoveMappingTitle": "Remove mapping",
    "assemblyRemoveStaticValueTitle": "Remove static value",
    "assemblyOtherOperationsSingular": "This policy is used by one other operation",
    "assemblyOtherOperationsPlural": "This policy is used by {{count}} other operations",
    "assemblyShowPalette": "Show / hide policy palette",
    "assemblyInvokeTargetURL": "Target URL",
    "assemblyInvokeTLSProfile": "TLS profile",
    "assemblyInvokeTimeout": "Timeout",
    "assemblyInvokeUsername": "Username",
    "assemblyInvokePassword": "Password",
    "assemblyInvokeVerb": "HTTP Method",
    "assemblyInvokeCompression": "Compression",
    "assemblyInvokeCacheResponse": "Cache Type",
    "assemblyInvokeCacheTTL": "Cache Time-To-Live",
    "assemblyInvokeCacheKey": "Cache Key",
    "assemblyInvokeOutput": "Output variable",
    "assemblyTransformXSLTInput": "Use context current payload",
    "assemblyJ2XRootElementName": "Root XML Element Name",
    "assemblyJ2XAlwayOutputRoot": "Always output the root element.",
    "assemblyVerbGet": "GET",
    "assemblyVerbPost": "POST",
    "assemblyVerbPut": "PUT",
    "assemblyVerbDelete": "DELETE",
    "assemblyVerbPatch": "PATCH",
    "assemblyVerbHead": "HEAD",
    "assemblyVerbOptions": "OPTIONS",
    "assemblyVerbRequest": "Keep",
    "assemblyCacheNone": "Protocol",
    "assemblyCacheNoCache": "No Cache",
    "assemblyCacheTimeToLive": "Time to Live",
    "assemblyDefineInputs": "Define the inputs to be used in the map. You can also assign a title and description to the map.",
    "assemblyDefineOutputs": "Define the outputs to be used in the map.",
    "assembly_delete_node_tooltip": "Delete",
    "assembly_clone_node_tooltip": "Clone",
    "assembly_build_node_tooltip": "Implement policy",
    "assembly_delete_node_title": "Deleting {{name}}...",
    "assembly_delete_node_description": "Are you sure you want to delete this policy?",
    "assembly_inline_definition": "Inline schema",
    "assembly_load_wsdl": "Load schema from WSDL",
    "assembly_edit_inline_definition": "Edit inline schema",
    "assembly_inline_enter_yaml": "Enter YAML or",
    "assembly_inline_as_yaml" : "switch to JSON",
    "assembly_inline_enter_json": "Enter JSON or",
    "assembly_inline_as_json" : "switch to YAML",
    "assembly_inline_schema": "Provide a schema",
    "assembly_templates": "Web service operations",
    "assembly_add_property": "add property...",
    "assembly_add_item": "add item...",
    "assembly_add_property_placeholder": "property",
    "assembly_add_item_placeholder": "item",
    "assemblyMapName": "Name",
    "assemblyContentType": "Content type",
    "assemblyContentTypeNone": "none",
    "assemblyPruneModelTitle": "Unrecognized Schema Element(s) Encountered",
    "assemblyPruneModelText": "The current mapping contains references to unrecognized schema elements.",
    "assemblyPruneModel": "Do you want to remove these references?",
    "assemblyCancel": "Ignore",
    "assemblyPrune": "Remove",
    "explorer_check_certificate": "Clicking the link below will open the server in a new tab. If the browser displays a certificate issue, you may choose to accept it and return here to test again.",
    "node_multiple_errors": "{{count}} errors need attention"
  };
  // var enBundle = __inline(nls/en.json);
  // var deBundle = __inline(nls/de.json);
  // var esBundle = __inline(nls/es.json);
  // var frBundle = __inline(nls/fr.json);
  // var itBundle = __inline(nls/it.json);
  // var jaBundle = __inline(nls/ja.json);
  // var koBundle = __inline(nls/ko.json);
  // var ptBRBundle = __inline(nls/pt_BR.json);
  // var trBundle = __inline(nls/tr.json);
  // var zhBundle = __inline(nls/zh.json);
  // var zhTWBundle = __inline(nls/zh_TW.json);
  $translateProvider.translations('en', enBundle);
  // $translateProvider.translations('de', deBundle);
  // $translateProvider.translations('es', esBundle);
  // $translateProvider.translations('fr', frBundle);
  // $translateProvider.translations('it', itBundle);
  // $translateProvider.translations('ja', jaBundle);
  // $translateProvider.translations('ko', koBundle);
  // $translateProvider.translations('pt_BR', ptBRBundle);
  // $translateProvider.translations('tr', trBundle);
  // $translateProvider.translations('zh', zhBundle);
  // $translateProvider.translations('zh_TW', zhTWBundle);
    $translateProvider.registerAvailableLanguageKeys(['en'/*, 'de', 'es', 'fr', 'it', 'ja', 'ko', 'pt_BR', 'tr', 'zh', 'zh_TW'*/], {
      "en_*": 'en'//,
      // "de_*": 'de',
      // "es_*": 'es',
      // "fr_*": 'fr',
      // "it_*": 'it',
      // "ja_*": 'ja',
      // "ko_*": 'ko',
      // "tr_*": 'tr',
      // "zh_CN": 'zh'
    });
    // use browser local list if it's available
    if (navigator.languages) {
      $translateProvider.determinePreferredLanguage();
    } else {
        if (typeof(localStorage) !== "undefined") {
          var userLocale = localStorage.getItem("apim-client-locale");
          // check if we've got the session locale in global var
          // supports browsers that dont have the new language list
            if (window['apimSessionLocale']) {
              var adjusted = window['apimSessionLocale'].split('-').join('_');
              localStorage.setItem("apim-client-locale", adjusted);
              userLocale = adjusted;
            }
            if (userLocale) {
              $translateProvider.preferredLanguage(userLocale);
            } else {
              $translateProvider.determinePreferredLanguage();
            }
        } else {
          // no local storage - probably private browsing, do the best we can instead
          $translateProvider.determinePreferredLanguage();
        }
    }
  $translateProvider.fallbackLanguage('en');
}]);;

angular.module("apiconnect-assembly").run(["$templateCache", function($templateCache) {$templateCache.put("src/html/assembler-canvas.html","<div data-ng-show=\"(isFlowSlim() && gotFlowID) || (!isFlowSlim() && policiesByType)\" class=\"assemblerCanvas\" data-ng-class=\"{\'filtering\': nodeFilter, \'hideCatches\': !showCatches}\"><div data-ng-if=\"isFlowSlim()\" class=\"assembly-canvas__fin-container\"><div class=\"assembly-canvas__fin\"></div></div><div data-ng-if=\"noAssembly && !isAppConnect()\" style=\"padding: 20px\"><div>{{::\'assembly-no-assembly\' | translate}}</div><button style=\"margin-top: 10px\" data-ng-click=\"createAssembly();\">{{::\'assembly-create-assembly\' | translate}}</button></div><div class=\"assemblyScaler\" ng-class=\"{\'assembly-scaler__slim\': isFlowSlim()}\" data-ng-attr-style=\"transform: scale({{scaleFactor}}) translateX({{(horizontalTranslation ? horizontalTranslation : 0) + \'px\'}});\"><div data-ng-show=\"(!renderingAssembly && !noAssembly) || isAppConnect()\" class=\"outerMain\"><div class=\"inlineContainer\" data-ng-if=\"config.assemblyType === \'api\'\"><app-c-request></app-c-request></div><app-c-trigger data-ng-if=\"config.assemblyType === \'trigger-action\'\" class=\"triggerNode\" tabindex=\"0\"></app-c-trigger><div data-ng-if=\"!isAppConnect()\" class=\"inputNode\" tabindex=\"0\" data-ng-click=\"nodeSelected($event, \'input\');\"></div><div class=\"dropzoneGroup\" data-ng-class=\"{\'dropzoneGroupSingle\': isAppConnect() && !nodes.length && config.assemblyType !== \'api\',\n                        \'dropzoneGroupSingleApi\': isAppConnect() && !nodes.length && config.assemblyType === \'api\',\n                        \'assembly-canvas__insert-point\': allowNewNode()\n                       }\" data-ui-on-drop=\"policyDropped($data, null, -1)\"><div class=\"ghostPolicy\" data-ng-class=\"{\'js-assembly-canvas__animation-target\': isFlowSlim()}\" data-ng-click=\"ghostSelected($event, null, -1)\"><md-icon data-ng-if=\"isAppConnect() && allowNewNode()\" md-svg-icon=\"floweditor:Plus-Light\" class=\"assembly-canvas__plus-inner\"></md-icon></div><div ng-if=\"isAppConnect() && allowNewNode()\" class=\"ghostPadder\"></div></div><node-group></node-group><div data-ng-if=\"!isAppConnect()\" class=\"outputNode\" tabindex=\"0\" data-ng-click=\"nodeSelected($event, \'output\');\"></div><div class=\"inlineContainer\" data-ng-if=\"config.assemblyType === \'api\'\"><app-c-response></app-c-response></div></div><div class=\"outerCatch catchShellContainer\" data-ng-class=\"{\'emptyClause\': isClauseEmpty(node)}\"><div data-ng-include=\"\'src/html/catch.html\'\"></div></div></div></div>");
$templateCache.put("src/html/assembler.html","<div data-ng-class=\"{\'testMode\': testMode, \'snipMode\': snipping}\"><apim-assembly-test data-ng-if=\"testMode && config.test\"></apim-assembly-test><policy-list data-ng-show=\"!isAppConnect()\"></policy-list><div class=\"assemblySection stretch\" data-ng-class=\"{\'maximized\': hidePalette || isAppConnect(), \'hideHeader\': config.standAlone }\"><div class=\"assemblyFlow\" data-ng-class=\"{\n        \'infoPanelOpen\': infoPanelOpen,\n        \'infoPanelBottom\': infoPanelBottom,\n        \'infoPanelRight\': !infoPanelBottom,\n        \'infoPanelDoubleWidth\': selectedNode.$$type === \'map\' && infoPanelOpen && !infoPanelBottom\n      }\"><navigation-bar data-ng-show=\"!isFlowSlim()\"></navigation-bar><div data-ng-class=\"{\'spinner\': renderingassembly}\"></div><assembler-canvas></assembler-canvas><apim-sidenav></apim-sidenav></div></div></div>");
$templateCache.put("src/html/assembly-editor.html","<div data-ng-controller=\"AssemblyEditorController\"><div class=\"bannerActions\" data-ng-show=\"!xhrProcessing\"><div class=\"dijitInline contentBox saveButton\"><div class=\"buttonAndLabel\" style=\"position: relative; text-align: center\" title=\"{{\'save\' | translate}}\"><button aria-label=\"{{::\'save\' | translate}}\" title=\"{{::\'save\' | translate}}\" data-ng-disabled=\"assemblyInFlux || !isDirty\" data-ng-click=\"saveVersion()\" class=\"iconOnlyButton\"><div class=\"material-icons\">save</div></button></div></div></div><div class=\"stretch underMainBanner\"><apim-assembler data-policy-factory=\"ApimPolicyFactory\" data-swagger-doc=\"swaggerDocument\" data-schema=\"swaggerSchema\"></apim-assembler></div></div>");
$templateCache.put("src/html/assembly-test.html","<div class=\"assemblyTestPanel\" data-ng-controller=\"AssemblerTestController as ctrl\"><div data-ng-class=\"{\'spinner\': !testLoaded}\"></div><div class=\"testSection\" data-ng-if=\"currentPage == 1 && testLoaded && !offlineMode\"><div class=\"testHeader\"><h3 class=\"mainTitle\">{{::\'assemblyTestSetup\' | translate}}</h3><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 8px 0px 0px\" data-ng-click=\"setTestMode(false, false, true);\" title=\"{{::\'assemblyCloseInfo\' | translate}}\"><span class=\"material-icons\">close</span></button></div><div class=\"testBody\"><div class=\"testItem\"><div class=\"testItemHeader\">{{::\'environment\' | translate}}</div><div class=\"testItemDescription\">{{::\'assemblyTestCatalogDesc\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"environment\" | translate}}</label><md-select data-ng-model=\"$parent.target\" data-ng-change=\"ctrl.targetChange();\"><md-option data-ng-repeat=\"publishTarget in publishTargets\" data-ng-value=\"publishTarget\">{{publishTarget.displayAs}}</md-option></md-select></md-input-container></div><div class=\"testItemRow\"><md-input-container data-ng-show=\"$parent.gwServiceTarget\"><label>{{::\"datapower_gateway_cluster\" | translate}}</label><md-select data-ng-model=\"$parent.gwServiceTarget\" data-ng-change=\"ctrl.gwServiceChange();\"><md-option data-ng-repeat=\"gwService in matchingGwServices\" data-ng-value=\"gwService.name\">{{gwService.name}}</md-option></md-select></md-input-container></div></div><div class=\"testItem\" data-ng-if=\"secureGatewayDeploymentInfo.length > 0\"><div class=\"testItemHeader\">{{::\'secureGateway\' | translate}}</div><div class=\"testItem\" data-ng-repeat=\"secureGatewayInfo in secureGatewayDeploymentInfo\"><div class=\"testItemDescription\">{{::\'assemblyTestSecureGatewayDesc\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\'assemblyInvokeTargetURL\' | translate}}</label><input type=\"text\" data-ng-model=\"secureGatewayInfo.destination\" readonly=\"readonly\"></md-input-container></div><div class=\"testItemRow\"><md-input-container><label>{{::\"secureGateway\" | translate}}</label><md-select data-ng-model=\"secureGatewayInfo.gateway\" data-ng-change=\"ctrl.secureGatewayDeploymentInfoChange();\"><md-option data-ng-repeat=\"secureGateway in secureGateways\" data-ng-value=\"secureGateway._id\">{{secureGateway.desc}}</md-option></md-select></md-input-container></div></div></div><div class=\"testItem\"><div class=\"testItemHeader\">{{::\'realProductSingular\' | translate}}</div><div class=\"testItemDescription\">{{::\'assemblyTestProductDesc\' | translate}}</div><div class=\"testItem\"><div class=\"testItemDescription\">{{::\'assemblyTestProductExisting\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"realProductSingular\" | translate}}</label><md-select data-ng-model=\"$parent.product\" data-ng-change=\"ctrl.productChange();\"><md-option data-ng-repeat=\"product in products\" data-ng-value=\"product\">{{product.info.title}} {{product.info.version}}</md-option></md-select></md-input-container></div><button style=\"margin: 10px; float: right\" data-ng-disabled=\"xhrProcessing || republishingProduct || !$parent.product || needSecureGatewaySetup\" data-ng-click=\"ctrl.republishProduct()\" title=\"{{::\'assemblyRepublishProduct\' | translate}}\">{{::\'assemblyRepublishProduct\' | translate}}</button><div class=\"clearBoth\"></div><div class=\"alertNote alertNoteTopBottom\" data-ng-if=\"!productContainsApi && $parent.product\"><div>{{::\'assemblyTestProductDoesntContainApi\' | translate}}</div><button style=\"float: right; margin-top: 10px\" data-ng-disabled=\"xhrProcessing || republishingProduct || !$parent.product\" data-ng-click=\"ctrl.addApiToProduct()\" title=\"{{::\'assemblyTestProductAddApi\' | translate}}\">{{::\'assemblyTestProductAddApi\' | translate}}</button><div class=\"clearBoth\"></div></div><div data-ng-class=\"{\'spinner\': !creatingProduct && republishingProduct}\"></div></div><div class=\"testItem\"><div class=\"testItemDescription\">{{::\'assemblyTestProductCreate\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"name\" | translate}}</label><input data-ng-model=\"$parent.productName\"></md-input-container></div><button style=\"margin: 10px; float: right\" data-ng-disabled=\"xhrProcessing || creatingProduct || !$parent.productName || needSecureGatewaySetup\" data-ng-click=\"ctrl.createAndPublishProduct()\" title=\"{{::\'assemblyCreateProduct\' | translate}}\">{{::\'assemblyCreateProduct\' | translate}}</button><div class=\"clearBoth\"></div><div data-ng-class=\"{\'spinner\': creatingProduct && republishingProduct}\"></div></div></div><div class=\"testItem\" data-ng-show=\"!$parent.catalog.testAppEnabled\"><div class=\"alertNote alertNoteTopBottom\">{{::\'assemblyTestAppNotEnabled\' | translate}}</div></div><div class=\"testItem\" data-ng-show=\"!$parent.catalog.testAppEnabled\"><div class=\"testItemHeader\">{{::\'planSingular\' | translate}}</div><div class=\"testItemDescription\">{{::\'assemblyTestPlanDesc\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"name\" | translate}}</label><md-select data-ng-model=\"$parent.plan\" data-ng-change=\"ctrl.planChange();\"><md-option data-ng-repeat=\"(planName, plan) in $parent.product.plans\" data-ng-value=\"planName\">{{planName}}</md-option></md-select></md-input-container></div></div><div class=\"testItem\" data-ng-show=\"!$parent.catalog.testAppEnabled\"><div class=\"testItemHeader\">{{::\'application\' | translate}}</div><div class=\"testItemDescription\">{{::\'assemblyTestAppDesc\' | translate}}</div><div class=\"testItem\"><div class=\"testItemDescription\">{{::\'assemblyTestAppExisting\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"application\" | translate}}</label><md-select data-ng-model=\"$parent.application\" data-ng-change=\"ctrl.applicationChange();\"><md-option data-ng-repeat=\"application in applications\" data-ng-value=\"application\">{{application.name}}</md-option></md-select></md-input-container></div><button style=\"margin: 10px; float: right\" data-ng-disabled=\"xhrProcessing || creatingApp || !application\" data-ng-click=\"ctrl.subscribeApp()\" title=\"{{::\'assemblySubscribeApp\' | translate}}\">{{::\'assemblySubscribeApp\' | translate}}</button><div class=\"clearBoth\"></div><div class=\"alertNote alertNoteTopBottom\" data-ng-if=\"productNotPublished\">{{::\'assemblyTestProductNotPublished\' | translate}}</div><div data-ng-class=\"{\'spinner\': subscribingApp}\"></div></div><div class=\"testItem\"><div class=\"testItemDescription\">{{::\'assemblyTestAppCreate\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"assemblyAppName\" | translate}}</label><input data-ng-model=\"$parent.appName\"></md-input-container></div><div data-ng-if=\"applicationCreated\" class=\"alertNote\" style=\"border-bottom: 1px solid #e0e0e0\"><div>{{::\'assemblyAppSecret\' | translate}}</div><div style=\"margin-top: 10px\">{{::\'clientId\' | translate}}: {{application.credentials.clientID}}</div><div style=\"margin-top: 10px\">{{::\'clientSecret\' | translate}}: {{application.credentials.clientSecret}}</div></div><button style=\"margin: 10px; float: right\" data-ng-disabled=\"xhrProcessing || creatingApp || !$parent.appName\" data-ng-click=\"ctrl.createAndSubscribeApp()\" title=\"{{::\'assemblyCreateAndSubscribeApp\' | translate}}\">{{::\'assemblyCreateAndSubscribeApp\' | translate}}</button><div class=\"clearBoth\"></div><div data-ng-class=\"{\'spinner\': creatingApp}\"></div></div></div><button style=\"margin: 10px; float: right\" data-ng-disabled=\"!product || !catalog || xhrProcessing\" data-ng-click=\"ctrl.setCurrentPage(2);\" title=\"{{::\'assemblyNext\' | translate}}\">{{::\'assemblyNext\' | translate}}</button><div class=\"clearBoth\"></div><div data-ng-class=\"{\'spinner\': xhrProcessing}\"></div></div></div><div class=\"testSection\" data-ng-if=\"currentPage == 2 && testLoaded\"><div class=\"testHeader\"><h3 class=\"mainTitle\">{{::\'assemblyTest\' | translate}}</h3><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 8px 0px 0px\" data-ng-click=\"setTestMode(false, false, true);\" title=\"{{::\'assemblyCloseInfo\' | translate}}\"><span class=\"material-icons\">close</span></button></div><div class=\"testBody\"><div class=\"testItem\" data-ng-show=\"!offlineMode\"><div class=\"testItemHeader\">{{::\'assemblyTestSetup\' | translate}}</div><div class=\"testSetup\"><div data-ng-if=\"!catalog.testAppEnabled\">{{target.displayAs}}, {{product.info.title}} {{product.info.version}}, {{plan}}, {{application.name}}</div><div data-ng-if=\"catalog.testAppEnabled\">{{target.displayAs}}, {{product.info.title}} {{product.info.version}}, {{\'assemblyTestUsingTestApp\' | translate}}</div><button style=\"float: right\" data-ng-disabled=\"xhrProcessing || $parent.invokeRunning\" data-ng-click=\"ctrl.setCurrentPage(1);\" title=\"{{::\'assemblyChangeSetup\' | translate}}\">{{::\'assemblyChangeSetup\' | translate}}</button> <button style=\"margin-right: 10px; float: right\" data-ng-disabled=\"xhrProcessing || republishingProduct || !$parent.product || needSecureGatewaySetup\" data-ng-click=\"ctrl.republishProduct()\" title=\"{{::\'assemblyRepublishProduct\' | translate}}\">{{::\'assemblyRepublishProduct\' | translate}}</button><div class=\"clearBoth\"></div><div class=\"alertNote alertNoteTopBottom\" style=\"margin: 10px -10px 0px -10px\" data-ng-if=\"!offlineMode && !productContainsApi && $parent.product\"><div>{{::\'assemblyTestProductDoesntContainApi\' | translate}}</div><button style=\"float: right; margin-top: 10px\" data-ng-disabled=\"xhrProcessing || republishingProduct || !$parent.product\" data-ng-click=\"ctrl.addApiToProduct()\" title=\"{{::\'assemblyTestProductAddApi\' | translate}}\">{{::\'assemblyTestProductAddApi\' | translate}}</button><div class=\"clearBoth\"></div></div><div data-ng-class=\"{\'spinner\': republishingProduct}\"></div></div></div><div class=\"alertNote\" data-ng-if=\"apiDirty\"><span>{{::\'assemblyApiUnsavedChanges\' | translate}}</span></div><div class=\"alertNote\" data-ng-if=\"!apiDirty && saveSinceLastPublish\"><span>{{::\'assemblyApiUnpublishedChanges\' | translate}}</span></div><div class=\"testItem\"><div class=\"testItemHeader\">{{::\'product_api_operation\' | translate}}</div><div class=\"testItemDescription\">{{::\'assemblyTestChooseOperation\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\"product_api_operation\" | translate}}</label><md-select data-ng-model=\"$parent.selectedOperation\" data-ng-change=\"ctrl.operationChange();\"><md-option data-ng-value=\"operation\" data-ng-repeat=\"operation in swaggerOperations\"><span data-ng-if=\"operation.verb\">{{operation.verb}} {{operation.path}}</span> <span data-ng-if=\"!operation.verb\">{{operation.operationId}}</span></md-option></md-select></md-input-container></div></div><div data-ng-show=\"operation && (swaggerDocument.schemes.length > 1)\" class=\"testItem\"><div class=\"testItemHeader\">{{::\'scheme\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\'scheme\' | translate}}</label><md-select data-ng-model=\"$parent.scheme\"><md-option data-ng-repeat=\"scheme in swaggerDocument.schemes\" data-ng-value=\"scheme\">{{scheme}}</md-option></md-select></md-input-container></div></div><div class=\"testItem\" data-ng-show=\"ctrl.config.requiresSecuritySection && ctrl.config.securityFlows.length > 1\"><div class=\"testItemHeader\">{{::\'explorer_security_flow\' | translate}}</div><div class=\"testItemRow\"><md-select style=\"margin-top: 0; margin-bottom: 0\" data-ng-model=\"$parent.securityFlow\" data-ng-change=\"ctrl.updateConfig();\" required=\"true\" name=\"securityFlow\"><md-option data-ng-repeat=\"securityFlow in ctrl.config.securityFlows\" data-ng-selected=\"$index == 0\" data-ng-value=\"securityFlow\">{{::securityFlow.$$label}}</md-option></md-select></div><div class=\"hidden\" data-ng-show=\"ctrl.config.requiresOauth\"><div class=\"testItemHeader\">{{::\'explorer_client_type\' | translate}}</div><div class=\"testItemRow\"><md-radio-group data-ng-model=\"$parent.clientType\" required=\"true\" name=\"clientType\"><md-radio-button md-no-ink class=\"md-primary\" style=\"margin-bottom: 10px\" value=\"public\">{{::\'public\' | translate}}</md-radio-button><md-radio-button md-no-ink class=\"md-primary\" value=\"confidential\">{{::\'confidential\' | translate}}</md-radio-button></md-radio-group></div></div></div><div class=\"testItem\" data-ng-show=\"operation && (ctrl.config.requiresClientId || ctrl.config.requiresClientSecret)\"><div class=\"testItemHeader\">{{::\'assemblyTestIdentification\' | translate}}</div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.requiresClientId\"><md-input-container><label>{{::\"clientId\" | translate}}</label><input data-ng-model=\"$parent.clientId\" autocomplete=\"off\"></md-input-container></div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.requiresClientSecret\"><md-input-container><label>{{::\"clientSecret\" | translate}}</label><input type=\"password\" data-ng-model=\"$parent.clientSecret\" autocomplete=\"off\"></md-input-container></div></div><div class=\"testItem\" data-ng-show=\"operation && (ctrl.config.requiresBasicAuth || ctrl.config.requiresOauth)\"><div class=\"testItemHeader\">{{::\'assemblyTestAuthorization\' | translate}}</div><div class=\"testItemDescription\" data-ng-if=\"ctrl.config.requiresBasicAuth\">{{::\'assemblyTestBasicAuth\' | translate}}</div><div class=\"testItemDescription\" data-ng-if=\"ctrl.config.requiresOauth && ctrl.config.oauthFlow == \'password\'\">{{::\'assemblyTestOauthPassword\' | translate}}</div><div class=\"testItemDescription\" data-ng-if=\"ctrl.config.requiresOauth && ctrl.config.oauthFlow == \'application\'\">{{::\'assemblyTestOauthApplication\' | translate}}</div><div class=\"testItemDescription\" data-ng-if=\"ctrl.config.requiresOauth && ctrl.config.oauthFlow == \'implicit\'\">{{::\'assemblyTestOauthImplicit\' | translate}}</div><div class=\"testItemDescription\" data-ng-if=\"ctrl.config.requiresOauth && ctrl.config.oauthFlow == \'accessCode\'\">{{::\'assemblyTestOauthAccessCode\' | translate}}</div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.requiresBasicAuth || (ctrl.config.requiresOauth && ctrl.config.oauthFlow == \'password\')\"><md-input-container><label>{{::\"assemblyTestUsername\" | translate}}</label><input data-ng-model=\"$parent.username\"></md-input-container></div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.requiresBasicAuth || (ctrl.config.requiresOauth && ctrl.config.oauthFlow == \'password\')\"><md-input-container><label>{{::\"assemblyTestPassword\" | translate}}</label><input type=\"password\" data-ng-model=\"$parent.password\"></md-input-container></div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.requiresRedirectUri\"><md-input-container><label>{{::\'explorer_redirect_uri\' | translate}}</label><input data-ng-model=\"$parent.redirectUri\"></md-input-container></div><div class=\"testItemRow\" style=\"display: inline-block\" data-ng-show=\"ctrl.config.oauthScopes\"><div>{{::\'explorer_scopes\' | translate}}</div><md-checkbox class=\"md-primary\" style=\"margin-bottom: 0\" data-ng-repeat=\"scope in ctrl.config.oauthScopes\" data-ng-model=\"$parent.scopes[scope]\">{{::scope}}</md-checkbox></div><div style=\"margin: 0px 10px 10px 10px\" data-ng-show=\"ctrl.config.requiresOauth\"><div data-ng-if=\"ctrl.config.requiresOauth && ctrl.config.oauthAuthUrl\"><span style=\"font-size: 1.2em; margin-right: 10px\">{{::\'api_security_oauth_authorization_url\' | translate}}:</span> <span style=\"word-break: break-word\">{{ctrl.config.oauthAuthUrl}}</span></div><div data-ng-if=\"ctrl.config.requiresOauth && ctrl.config.oauthTokenUrl\"><span style=\"font-size: 1.2em; margin-right: 10px\">{{::\'api_security_oauth_token_url\' | translate}}:</span> <span style=\"word-break: break-word\">{{ctrl.config.oauthTokenUrl}}</span></div></div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.oauthFlow === \'accessCode\'\"><button style=\"margin: 18px 10px 0 0; height: 26px\" class=\"apimAuthorize\" data-ng-click=\"ctrl.authorize();\">{{::\'explorer_authorize\' | translate}}</button><md-input-container style=\"flex: 1\"><label>{{::\'explorer_auth_code\' | translate}}</label><input type=\"password\" data-ng-model=\"$parent.authToken[\'code\']\"></md-input-container></div><div class=\"testItemRow\" data-ng-show=\"ctrl.config.requiresOauth\"><button style=\"margin: 18px 10px 0 0; height: 26px\" class=\"apimGetToken\" data-ng-show=\"ctrl.config.oauthFlow === \'accessCode\' && $parent.authToken[\'code\']\" data-ng-click=\"ctrl.getToken();\">{{::\'explorer_get_token\' | translate}}</button> <button style=\"margin: 18px 10px 0 0; height: 26px\" class=\"apimAuthorize\" data-ng-show=\"ctrl.config.oauthFlow !== \'accessCode\'\" data-ng-click=\"ctrl.authorize();\">{{::\'explorer_authorize\' | translate}}</button><md-input-container style=\"flex: 1\"><label>{{::\'explorer_access_token\' | translate}}</label><input type=\"password\" data-ng-model=\"$parent.authToken[\'access_token\']\"></md-input-container></div><div class=\"testItemRow\" data-ng-show=\"$parent.authToken[\'refresh_token\']\"><button style=\"margin: 18px 10px 0 0; height: 26px\" class=\"apimRefreshToken\" data-ng-show=\"ctrl.config.oauthFlow === \'accessCode\'\" data-ng-click=\"ctrl.refreshToken();\">{{::\'explorer_refresh_token\' | translate}}</button></div><div class=\"alertNote\" data-ng-if=\"authError\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestResponseCode\' | translate}}: {{authError.status}}</div><div data-ng-if=\"authError.statusText\">{{authError.statusText}}</div><div data-ng-if=\"authError.data.error\">{{authError.data.error}}</div><div data-ng-if=\"authError.data.error_description\">{{authError.data.error_description}}</div></div></div><div data-ng-show=\"operation && (ctrl.config.requiresParametersSection || swaggerDocument.consumes.length > 0 || swaggerDocument.produces.length > 0)\" class=\"testItem\"><div class=\"testItemHeader\">{{::\'parameters\' | translate}}</div><div data-ng-show=\"swaggerDocument.consumes.length > 0\" class=\"testItemRow\"><md-input-container><label>Content-Type</label><md-select data-ng-model=\"$parent.contentTypeHeader\"><md-option data-ng-repeat=\"contentType in swaggerDocument.consumes\" data-ng-selected=\"$index == 0\" data-ng-value=\"contentType\">{{contentType}}</md-option></md-select></md-input-container></div><div data-ng-show=\"swaggerDocument.produces.length > 0\" class=\"testItemRow\"><md-input-container><label>Accept</label><md-select data-ng-model=\"$parent.acceptHeader\"><md-option data-ng-repeat=\"accept in swaggerDocument.produces\" data-ng-selected=\"$index == 0\" data-ng-value=\"accept\">{{accept}}</md-option></md-select></md-input-container></div><div data-ng-repeat=\"parameter in ctrl.config.parameters track by parameter.$$tmpId\" class=\"testItemRow\"><apim-test-parameter style=\"width: 100%\"></apim-test-parameter></div></div><div class=\"testItem\" data-ng-show=\"operation\"><div style=\"padding: 5px 10px\" class=\"testItemHeader\"><md-checkbox style=\"margin: 0px\" md-no-ink aria-label=\"Repeat\" data-ng-model=\"$parent.repeater.repeat\" class=\"md-primary\">{{::\'assemblyTestRepeat\' | translate}}</md-checkbox></div><div class=\"testItemDescription\">{{::\'assemblyTestRepeatDesc\' | translate}}</div><div class=\"testItemRow\"><md-input-container><label>{{::\'assemblyTestRepeatFor\' | translate}}</label><input data-ng-disabled=\"!$parent.repeater.repeat\" data-ng-model=\"$parent.repeater.count\"></md-input-container><md-checkbox data-ng-disabled=\"!$parent.repeater.repeat\" md-no-ink aria-label=\"Stop on error\" data-ng-model=\"$parent.repeater.stopOnError\" class=\"md-primary\">{{::\'assemblyTestStopOnError\' | translate}}</md-checkbox></div></div><div class=\"testItem\" data-ng-show=\"operation && offlineMode\"><div style=\"padding: 5px 10px\" class=\"testItemHeader\"><md-checkbox style=\"margin: 0px\" md-no-ink aria-label=\"proxy\" data-ng-model=\"$parent.proxy\" class=\"md-primary\">{{::\'assemblyTestProxy\' | translate}}</md-checkbox></div><div class=\"testItemDescription\">{{::\'assemblyTestProxyDesc\' | translate}}</div></div><button style=\"margin: 10px 10px 10px 0px; float: right\" data-ng-show=\"$parent.repeater.repeat\" data-ng-disabled=\"!$parent.invokeRunning\" data-ng-click=\"$parent.stopInvoke = true;\" title=\"{{::\'assemblyStopInvoke\' | translate}}\">{{::\'assemblyStopInvoke\' | translate}}</button> <button style=\"margin: 10px; float: right\" data-ng-disabled=\"!selectedOperation\" data-ng-click=\"ctrl.invoke();\" title=\"{{::\'assemblyInvoke\' | translate}}\">{{::\'assemblyInvoke\' | translate}}</button><div class=\"clearBoth\"></div><div data-ng-class=\"{\'spinner\': invokeRunning}\"></div><div data-ng-if=\"response.statusCode\" class=\"testItem testItemResponse\"><div class=\"testItemHeader\">{{::\'assemblyTestResponse\' | translate}}</div><div class=\"testItemRow\" data-ng-if=\"response.callCounter\"><div style=\"flex: 1\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestCallCounter\' | translate}}:</div><div>{{response.callCounter}} / {{$parent.repeater.count}}</div></div><div style=\"flex: 1\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestTotalTime\' | translate}}:</div><div>{{response.totalTime}}ms</div></div><div style=\"flex: 1\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestAverageTime\' | translate}}:</div><div>{{response.avgResponseTime}}ms</div></div></div><div class=\"testItemRow\" style=\"display: block\" data-ng-if=\"response.statusCode\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestResponseCode\' | translate}}:</div><div>{{response.statusCode}}</div><div class=\"alertNote alertNoteTopBottom\" style=\"margin: 10px -10px 0px -10px\" data-ng-if=\"response.statusInfo\">{{response.statusInfo}}</div><div class=\"alertNote alertNoteTopBottom\" style=\"margin: 10px -10px 0px -10px\" data-ng-if=\"response.statusCode == -1\"><div>{{::\'explorer_check_certificate\' | translate}}</div><a style=\"color: #4b68fa\" target=\"_blank\" data-ng-attr-href=\"{{response.request.url}}\">{{response.request.url}}</a></div></div><div class=\"testItemRow\" style=\"display: block\" data-ng-if=\"response.responseTime\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestResponseTime\' | translate}}:</div><div>{{response.responseTime}}ms</div></div><div class=\"testItemRow\" style=\"display: block\" data-ng-if=\"response.containsHeaders\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestHeaders\' | translate}}:</div><div data-ng-repeat=\"(name, value) in response.headers\"><span>{{name}}: </span><span>{{value}}</span></div></div><div class=\"testItemRow\" style=\"display: block\" data-ng-if=\"response.responseData\"><div style=\"font-size: 1.2em\">{{::\'assemblyTestResponseBody\' | translate}}:</div><div class=\"hljs\" hljs source=\"response.responseDataString\"></div></div><button style=\"margin: 0px 10px 10px 10px; float: right\" data-ng-show=\"response.transactionId\" data-ng-click=\"ctrl.loadDebugData(); ctrl.setCurrentPage(3);\" title=\"{{::\'assemblyTestDebug\' | translate}}\">{{::\'assemblyTestDebug\' | translate}}</button><div class=\"clearBoth\"></div></div></div></div><div class=\"testSection\" data-ng-if=\"currentPage == 3 && testLoaded\"><div class=\"testHeader\"><h3 class=\"mainTitle\">{{::\'assemblyTestDebug\' | translate}}</h3><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 8px 0px 0px\" data-ng-click=\"setTestMode(false, false, true);\" title=\"{{::\'assemblyCloseInfo\' | translate}}\"><span class=\"material-icons\">close</span></button></div><div class=\"testBody\"><div class=\"alertNote alertNoteTop\" data-ng-if=\"!loadingDebugData && !debugData\">{{::\'assemblyNoDebugData\' | translate}}</div><div class=\"testItem\" style=\"word-wrap: break-word\" data-ng-if=\"!loadingDebugData && debugData.length > 1\" data-ng-repeat=\"data in debugData\"><div data-ng-if=\"$index > 0\" data-ng-controller=\"AssemblyTestDebugDataController\"><div class=\"testItemHeader\" style=\"margin-bottom: 0px\" data-ng-class=\"{\'selected\': selectedDebugData == data}\">{{data.name}}</div><div class=\"hljs\" hljs source=\"yamlValue\" hljs-language=\"http\"></div></div></div><div data-ng-class=\"{\'spinner\': loadingDebugData}\"></div><div class=\"testItem\"><button style=\"margin: 10px; float: right\" data-ng-disabled=\"xhrProcessing || !$parent.product\" data-ng-click=\"ctrl.setCurrentPage(2);\" title=\"{{::\'assemblyBackToTest\' | translate}}\">{{::\'assemblyBackToTest\' | translate}}</button><div class=\"clearBoth\"></div></div></div></div></div>");
$templateCache.put("src/html/catch.html","<div class=\"catchShell\"><div class=\"catchLabel\" data-ng-click=\"nodeSelected($event, node)\">{{::\'assemblyCatch\' | translate}}</div><div class=\"catchContainer\" data-ng-repeat=\"catch in node.catch\"><div class=\"clauseRow\"><div class=\"clauseLabel\" data-ng-class=\"{\'expanded\': expanded[$index]}\" data-ng-click=\"expanded[$index] = !expanded[$index]\">{{catch | catchMessage}}</div><div tabindex=\"0\" class=\"catchIcon\" data-ng-class=\"{\'searchMiss\': !conditionHasMatchedSearch(catch), \'searchHit\': conditionHasMatchedSearch(catch)}\" data-ng-keydown=\"keyPressed($event, catch);\" data-ng-click=\"nodeSelected($event, node)\"></div><div class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, $index, -1)\"><div class=\"ghostPolicy\"></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in catch.execute | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, $parent.$parent.$index, $index)\"><div class=\"ghostPolicy\"></div></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in catch.default | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, $parent.$parent.$index, $index)\"><div class=\"ghostPolicy\"></div></div></div><div class=\"outputNode\" tabindex=\"0\"></div></div></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"clauseDropzoneGroup\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, -1)\"><div class=\"catchGhost\"></div></div></div>");
$templateCache.put("src/html/clause.html","<div data-ng-class=\"{\'clauseShell\': node.case, \'selectedNode\': selectedNode == node, \'conditionShell\': node.condition || node.execute}\"><div class=\"clauseContainer\" data-ng-if=\"node.case\" data-ng-repeat=\"case in node.case\" data-ng-controller=\"NodeCaseController\"><div class=\"clauseRow\" data-ng-class=\"{\'otherwiseClause\': !!case.otherwise}\"><div class=\"clauseRowInner\" ng-class=\"{\'clause-row--selected\': $index === node.$$selectedBranch}\"><div class=\"clauseLabel\" data-ng-class=\"{\'expanded\': expanded[$index]}\" data-ng-click=\"expanded[$index] = !expanded[$index]\"><span ng-if=\"!isAppConnect()\"><button class=\"clauseToggle\" style=\"\" data-ng-if=\"collapseNodes\" data-ng-click=\"showContent($event);\">+</button> <button class=\"clauseToggle\" data-ng-if=\"!collapseNodes\" data-ng-click=\"hideContent($event);\">-</button> <span>{{case | clauseMessage}}</span> </span><span ng-if=\"isAppConnect()\"><span ng-if=\"$first\" translate=\"ifPanel.if\"></span> <span ng-if=\"$last\" translate=\"ifPanel.else\"></span> <span ng-if=\"$middle\" translate=\"ifPanel.elseIf\"></span><branch-label ng-if=\"!case.otherwise\" condition=\"case.condition\" node=\"node\"></branch-label></span></div><div data-ng-if=\"!collapseNodes\"><div class=\"clauseIcon\" data-ng-if=\"!case.otherwise\" tabindex=\"0\" data-ng-class=\"{\'searchMiss\': !conditionHasMatchedSearch(case), \'searchHit\': conditionHasMatchedSearch(case)}\" data-ng-keydown=\"keyPressed($event, case);\" data-ng-click=\"nodeSelected($event, node)\"></div><div class=\"dropzoneGroupSpacer\"></div><div class=\"dropzoneGroup\" data-ng-class=\"{\'assembly-canvas__insert-point\': allowNewNode()}\" data-ui-on-drop=\"policyDropped($data, node, $index, -1)\"><div class=\"ghostPolicy\" data-ng-click=\"ghostSelected($event, node, $index, -1)\"><md-icon data-ng-if=\"isAppConnect() && allowNewNode()\" md-svg-icon=\"floweditor:Plus-Light\" class=\"assembly-canvas__plus-inner\"></md-icon></div><div ng-if=\"isAppConnect() && allowNewNode()\" class=\"ghostPadder\"></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in case.execute | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div class=\"dropzoneGroupSpacer\"></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ng-class=\"{\'assembly-canvas__insert-point\': allowNewNode()}\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, $parent.$parent.$index, $index)\"><div class=\"ghostPolicy\" data-ng-click=\"ghostSelected($event, $parent.$parent.node, $parent.$parent.$index, $index)\"><md-icon data-ng-if=\"isAppConnect() && allowNewNode()\" md-svg-icon=\"floweditor:Plus-Light\" class=\"assembly-canvas__plus-inner\"></md-icon></div><div ng-if=\"isAppConnect() && allowNewNode()\" class=\"ghostPadder\"></div></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in case.otherwise | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div class=\"dropzoneGroupSpacer\"></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ng-class=\"{\'assembly-canvas__insert-point\': allowNewNode()}\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, $parent.$parent.$index, $index)\"><div class=\"ghostPolicy\" data-ng-click=\"ghostSelected($event, $parent.$parent.node, $parent.$parent.$index, $index)\"><md-icon data-ng-if=\"isAppConnect() && allowNewNode()\" md-svg-icon=\"floweditor:Plus-Light\" class=\"assembly-canvas__plus-inner\"></md-icon></div><div ng-if=\"isAppConnect() && allowNewNode()\" class=\"ghostPadder\"></div></div></div><div class=\"clauseRowTerminator\"><div class=\"clause-row__map-button-wrapper\"><div class=\"clause-row__map-button-tooltip-wrapper\" ng-show=\"!hasOutputSchema(node)\"><md-tooltip>{{\"ifPanel.outputSchemaCanvasTooltip\" | translate}}</md-tooltip></div><md-button ng-if=\"isAppConnect()\" ng-click=\"expandBranch($event, node, $index)\" ng-class=\"{\'clause-row__map-button--active\': $index === node.$$expandedBranch}\" class=\"iconOnlyButton clause-row__map-button\"><md-icon md-svg-icon=\"floweditor:output-data\"></md-icon></md-button></div></div></div></div></div></div><div class=\"clauseContainer conditionContainer\" data-ng-if=\"node.condition || node.execute\"><div class=\"clauseRow\"><div class=\"clauseRowInner\"><div class=\"clauseLabel\" data-ng-class=\"{\'expanded\': expanded[$index]}\" data-ng-click=\"expanded[$index] = !expanded[$index]\">{{node.condition}}</div><div class=\"clauseIcon\" data-ng-show=\"node.condition\" data-ng-class=\"{\'searchMiss\': !conditionHasMatchedSearch(node.condition), \'searchHit\': conditionHasMatchedSearch(node.condition)}\" data-ng-keydown=\"$event.stopPropagation();\" data-ng-click=\"$event.stopPropagation();\" data-popover=\"{{node | clauseMessage}}\" data-popover-placement=\"left\" data-popover-trigger=\"focus\" data-popover-animation=\"true\"></div><div class=\"dropzoneGroupSpacer\"></div><div class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, 0, -1)\"><div class=\"ghostPolicy\"></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in node.execute | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div class=\"dropzoneGroupSpacer\"></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, 0, $index)\"><div class=\"ghostPolicy\"></div></div></div></div></div></div><span data-ng-if=\"node.case\" class=\"clauseDropzoneGroup\" data-ng-class=\"{\'clause-dropzone-group--hidden\': node.case.length > 9}\" data-ui-on-drop=\"policyDropped($data, node, -1)\"><div class=\"clauseGhost\"></div></span></div>");
$templateCache.put("src/html/condition-builder.html","<div><apic-condition-expression></apic-condition-expression></div>");
$templateCache.put("src/html/condition-expression.html","<span class=\"expression-clause operation-clause\" data-ng-if=\"isOperation\"><span class=\"button-panel\" style=\"float: left\"><button data-ng-if=\"!expanded\" data-ng-click=\"expand(true);\" class=\"iconOnlyButton material-icons\">expand_more</button><button data-ng-if=\"expanded\" data-ng-click=\"expand(false);\" class=\"iconOnlyButton material-icons\">expand_less</button> </span><span data-ng-click=\"expand(!expanded);\">{{operationString}}</span> <span class=\"button-panel\"><button data-ng-click=\"deleteExpression(expression);\" class=\"iconOnlyButton material-icons\">delete</button> </span></span><span data-ng-if=\"!expression.$$edit && (!isOperation || expanded)\"><span data-ng-if=\"expression.type == \'Literal\'\"><span>{{expression.raw}}</span> </span><span data-ng-if=\"expression.type == \'Identifier\'\"><span>{{expression.name}}</span> </span><span class=\"expression-clause binary-expression\" data-ng-if=\"expression.type == \'BinaryExpression\'\"><apic-condition-expression-left data-ng-click=\"$parent.expression.$$edit = true;\"></apic-condition-expression-left><span data-ng-click=\"$parent.expression.$$edit = true;\">{{expression.operator}}</span><apic-condition-expression-right data-ng-click=\"$parent.expression.$$edit = true;\"></apic-condition-expression-right><span class=\"button-panel\"><button data-ng-click=\"insertLogicalExpression(\'||\');\" class=\"iconOnlyButton material-icons\">add_circle_outline</button><button data-ng-click=\"expression.$$edit = true;\" class=\"iconOnlyButton material-icons\">edit</button><button data-ng-click=\"deleteExpression(expression);\" class=\"iconOnlyButton material-icons\">delete</button> </span></span><span data-ng-if=\"expression.type == \'CallExpression\'\" class=\"call-expression\"><span>{{expression.callee.name}}(</span><span data-ng-repeat=\"expression in expression.arguments\" class=\"argument\"><apic-condition-expression></apic-condition-expression><span class=\"argument-separator\">,</span> </span><span>)</span> </span><span data-ng-if=\"expression.type == \'MemberExpression\'\"><span>{{expression.object.name}}.{{expression.property.name}}</span> </span><span class=\"expression-clause expression-group\" data-ng-if=\"expression.type == \'LogicalExpression\'\"><apic-condition-expression-left></apic-condition-expression-left><button class=\"operator\" data-ng-if=\"expression.operator == \'&&\'\" data-ng-click=\"changeOperator(\'||\');\">AND</button><button class=\"operator\" data-ng-if=\"expression.operator == \'||\'\" data-ng-click=\"changeOperator(\'&&\');\">OR</button><apic-condition-expression-right class=\"expression-right\"></apic-condition-expression-right><div class=\"button-panel\"><button data-ng-click=\"insertLogicalExpression(\'||\');\" class=\"iconOnlyButton material-icons\">add_circle_outline</button></div></span></span><span data-ng-if=\"expression.$$edit && (!isOperation || expanded)\" class=\"expression-editor\"><input data-ng-model=\"$parent.expressionString\" data-ng-model-options=\"{debounce: 200}\" style=\"width: 90%; margin: 8px\"> <span class=\"button-panel\"><button data-ng-click=\"commitExpression();\" class=\"iconOnlyButton material-icons\">done</button> </span></span>");
$templateCache.put("src/html/confirmation-dialog.html","<md-dialog aria-labelledby=\"{{$id}}_bannerHeading\"><md-toolbar><div class=\"md-toolbar-tools\"><h2 id=\"{{$id}}_bannerHeading\">{{::\'assemblyPruneModelTitle\' | translate}}</h2></div></md-toolbar><md-dialog-content style=\"min-width: 450px\"><div class=\"secondaryText\">{{::\'assemblyPruneModelText\' | translate}}</div><div class=\"secondaryText unrecognizedList\"><ul><li data-ng-repeat=\"schema in unrecognized\">{{schema}}</li></ul></div><div class=\"secondaryText\">{{::\'assemblyPruneModel\' | translate}}</div></md-dialog-content><div class=\"md-actions layout-row\"><button class=\"cancelButton\" data-ng-click=\"cancel();\">{{::\'assemblyCancel\' | translate}}</button> <button class=\"createButton\" data-ng-click=\"prune();\">{{::\'assemblyPrune\' | translate}}</button></div></md-dialog>");
$templateCache.put("src/html/draft-assemblies.html","<div class=\"assemblies centerColumn secondaryBackground slideContainer absolutelyFabulous fullHeightMinusBanner\" data-ng-controller=\"AssembliesController\"><div class=\"bannerActions\" style=\"margin-right:5px\" data-ng-if=\"!offlineMode\"><div class=\"dropdown\" dropdown data-is-open=\"addAssemblyOpen\"><button class=\"iconOnlyButton\" role=\"button\" title=\"{{::\'assembly_add\' | translate}}\"><div class=\"material-icons\" aria-label=\"{{::\'assembly_add\' | translate}}\">add_circle_outline</div></button></div></div><div class=\"whiteBackground layout fullWidth searchBanner\"><div class=\"displayInline itsAllRelative flex\"><input style=\"border-top: 0\" type=\"search\" aria-label=\"{{::\'assemblies_search\' | translate}}\" placeholder=\"{{::\'assemblies_search\' | translate}}\" data-ng-model=\"query\" data-ng-disabled=\"!assemblies.$resolved\"> <button type=\"reset\" class=\"iconOnlyButton\" data-ng-click=\"query = \'\'\" data-ng-show=\"query\" title=\"{{::\'resetFilter\' | translate}}\"><div class=\"closeIcon\"></div></button></div></div><div class=\"expanded\"><div class=\"secondaryBackground listingColumn assembliesCollection\"><div class=\"floatRight\"><pagination style=\"margin: 0px\" data-ng-show=\"totalItems > pageSize\" boundary-links=\"true\" rotate=\"false\" data-ng-change=\"pageChanged(currentPage)\" total-items=\"totalItems\" data-ng-model=\"currentPage\" class=\"pagination-sm\" previous-text=\"‹\" next-text=\"›\" first-text=\"«\" last-text=\"»\" items-per-page=\"pageSize\" max-size=\"3\"></pagination></div><div class=\"clearBoth\"></div><div class=\"tableHeaderBackground apiSelfClear\"><div class=\"column draftAssemblyNameColumn\">{{::\'assembly_title\' | translate}}</div><div class=\"column draftAssemblyLastModifiedColumn\">{{::\'assemblyLastModified\' | translate}}</div><div class=\"column draftAssemblyActionsColumn\"></div></div><div data-ng-class=\"{\'spinner\': xhrProcessing}\"></div><div class=\"emptyCollectionMessage xlargePadding\" data-ng-show=\"!xhrProcessing && filteredAssemblies && filteredAssemblies.length == 0\">{{assemblies | noAssemblies}}</div><ul data-ng-show=\"!xhrProcessing && filteredAssemblies && filteredAssemblies.length > 0\"><li data-ng-repeat=\"assembly in filteredAssemblies = (assemblies | assemblyTitleQuery: query | orderBy: [\'info.title\', \'-info.version\'])\"><apim-draft-assembly></apim-draft-assembly></li></ul></div></div></div>");
$templateCache.put("src/html/draft-assembly.html","<div class=\"card primaryBorder apiSelfClear\" data-ng-class=\"{backgroundDisabled: beingDeleted}\" data-ng-controller=\"AssemblyVersionController\"><div class=\"dijitInline boundedText draftAssemblyNameColumn\"><a class=\"documentNameLink\" href=\"#/design/assemblies/{{assembly.info.name}}:{{assembly.info.version}}\" data-ng-bind-html=\"assembly.info.title | highlight: query\"></a> <span>{{assembly.info.version}}</span> <span style=\"margin-left: 10px\" data-ng-if=\"assembly.file\">[{{assembly.file}}]</span></div><div class=\"dijitInline draftAssemblyLastModifiedColumn\" title=\"{{apiVersion.updatedAt}}\">{{assembly.updatedAt | since}}</div><div class=\"dijitInline draftAssemblyActionsColumn\"><button class=\"iconOnlyButton material-icons\" data-ng-disabled=\"beingDeleted\" data-ng-if=\"!offlineMode\" title=\"{{::\'ttDelete\' | translate}}\" data-ng-click=\"delete()\">delete</button></div></div>");
$templateCache.put("src/html/error-dialog.html","<div class=\"error-header\"><svg class=\"error-icon\"></svg> <span class=\"error-message\">{{errorMessage}}</span> <button data-ng-if=\"dismissable\" class=\"error-close-button material-icons\" data-ng-click=\"closeDialog(true);\" aria-label=\"Close Dialog\">close</button></div><div data-ng-if=\"errorCode\" class=\"error-code\">{{errorCodeText}}: {{errorCode}}</div><div class=\"error-description\">{{errorDescription}}</div><div data-ng-if=\"errorLinkUrl\" class=\"error-link\"><a data-ng-href=\"{{errorLinkUrl}}\" target=\"_blank\">{{errorLinkText}}</a></div><div class=\"error-buttons\"><md-button data-ng-repeat=\"button in errorButtons\" data-ng-click=\"runCallback(button.callbackFunction, button.keepDialogOpen)\" md-no-ink=\"true\">{{button.buttonTitle}}</md-button></div>");
$templateCache.put("src/html/execute.html","<div class=\"executeShell\" data-ng-if=\"node.execute && node.iterator\"><div class=\"executeContainer\"><div class=\"clauseRow\"><div class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, $index, -1)\"><div class=\"ghostPolicy\"></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in node.execute | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, $parent.$parent.$index, $index)\"><div class=\"ghostPolicy\"></div></div></div></div></div><div data-ng-if=\"node.case\" class=\"clauseDropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, -1)\"><div class=\"clauseGhost\"></div></div></div>");
$templateCache.put("src/html/expression-editor.html","<header class=\"modal-header\" role=\"banner\" aria-label=\"{{::\'assemblyExpressionEditor\' | translate}}\"><hgroup><h2 class=\"modal-title floatLeft\">{{::\'assemblyExpressionEditor\' | translate}}</h2></hgroup><div class=\"clearBoth\"></div></header><section class=\"modal-body\" style=\"padding: 0px; min-width: 50vw\"><div class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"min-height: 100px\" data-ng-model=\"expressionString\" data-ng-model-options=\"{debounce:200}\" ui-ace=\"{useWrapMode: true, mode: \'javascript\', theme: \'atom_dark\'}\"></div></section><footer class=\"modal-footer\" role=\"contentinfo\" aria-label=\"{{\'footerSectionLabel\' | translate}}\"><button class=\"cancelButton\" data-ng-click=\"cancel();\">{{::\'cancel\' | translate}}</button> <button class=\"createButton\" data-ng-click=\"commit();\">{{::\'done\' | translate}}</button></footer>");
$templateCache.put("src/html/inline-schema.html","<header class=\"modal-header\" role=\"banner\" aria-label=\"{{::\'assembly_inline_schema\' | translate}}\"><hgroup><h2 class=\"modal-title floatLeft\">{{::\'assembly_inline_schema\' | translate}}</h2></hgroup><div class=\"clearBoth\"></div></header><section class=\"modal-body inline-schema-dialog\" style=\"padding: 0px\"><md-content><md-tabs md-dynamic-height md-border-bottom md-selected=\"selectedTabIndex\"><md-tab label=\"{{::\'assembly_inline_enter_yaml\' | translate}}\"><div class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"min-height: 300px\" data-ng-model=\"inlineYamlSchema\" ui-ace=\"{useWrapMode: true, mode: \'yaml\', theme: \'atom_dark\'}\"></div></md-tab><md-tab label=\"{{::\'assembly_inline_enter_json\' | translate}}\"><div class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"min-height: 300px\" data-ng-model=\"inlineJsonSchema\" ui-ace=\"{useWrapMode: true, mode: \'json\', theme: \'atom_dark\'}\"></div></md-tab><md-tab label=\"{{::\'assembly_inline_generate_json\' | translate}}\"><div class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"min-height: 300px\" data-ng-model=\"inlineJsonObject\" ui-ace=\"{useWrapMode: true, mode: \'json\', theme: \'atom_dark\'}\"></div></md-tab><md-tab label=\"{{::\'assembly_inline_generate_xml\' | translate}}\"><div class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"min-height: 300px\" data-ng-model=\"inlineXMLObject\" ui-ace=\"{useWrapMode: true, mode: \'xml\', theme: \'atom_dark\'}\"></div></md-tab></md-tabs></md-content></section><footer class=\"modal-footer\" role=\"contentinfo\" aria-label=\"{{\'footerSectionLabel\' | translate}}\"><button class=\"createButton\" data-ng-show=\"selectedTabIndex === 2 || selectedTabIndex === 3\" data-ng-disabled=\"!validSchema\" data-ng-click=\"generateAndShow();\">{{::\'generate\' | translate}}</button> <button class=\"createButton\" data-ng-disabled=\"!validSchema\" data-ng-click=\"commit();\">{{::\'done\' | translate}}</button> <button class=\"cancelButton\" data-ng-click=\"cancel();\">{{::\'cancel\' | translate}}</button></footer>");
$templateCache.put("src/html/logic-node.html","<script data-ng-if=\"!isAppConnect()\" type=\"text/ng-template\" id=\"errorPopover\"><div class=\"popoverArrow\"></div>\n  <div data-ng-if=\"gatewayErrorMessage\" class=\"popoverError\">\n    {{gatewayErrorMessage}}\n  </div>\n  <div data-ng-if=\"!gatewayErrorMessage\" class=\"popoverError\">\n    {{errorMessage}}\n  </div></script><div data-drag=\"data\" data-ui-draggable=\"isDraggable()\" data-ng-keydown=\"keyPressed($event, node)\" data-ng-click=\"nodeSelected($event, node)\" data-ng-controller=\"NodeController as NodeController\" class=\"policyNode logicNode subflowNode {{node.$$type}} {{node.$$classes.join(\' \')}}\" data-ng-class=\"{\'policyWithContent\': policyWithContent, \'hover-effect\' : isHovered, \'policyGatewayMiss\': policyGatewayMiss(), \'minimized\': node.$$minimized, \'snipped\': snipping && node.$$snipped, \'isSelected\': node.$$isSelected, \'logic-node__has-branch-selected\': node.$$selectedBranch !== undefined}\" ng-mouseover=\"highlightNode(true, $event)\" ng-mouseout=\"highlightNode(false, $event)\"><div class=\"outerShell\"><div data-ng-if=\"gatewayErrorMessage && !isAppConnect()\" class=\"errorShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\"><div class=\"errorIcon\"></div></div><div data-ng-if=\"errorMessage && !gatewayErrorMessage && node.$$touched && !isAppConnect()\" class=\"errorShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\"><div class=\"errorIcon\"></div></div><div class=\"innerShell\" data-ng-class=\"{\'searchMiss\': !hasMatchedSearch(), \'searchHit\': hasMatchedSearch()}\" data-ng-attr-style=\"background-color: {{node.$$display.color}};\"><div data-ng-if=\"isAppConnect()\"><appc-node-decorator data-node-touched=\"node.$$touched\" data-messages=\"node.$$errors\" data-icon-name=\"exclamation\"></appc-node-decorator></div><div class=\"iconShell iconShellBackground\"><div ng-if=\"!isAppConnect()\" class=\"material-icons\" style=\"transform: rotate(-135deg)\">{{node | iconForNode}}</div><div ng-if=\"isAppConnect()\" class=\"logic-node__icon-container\"><md-icon class=\"logic-node__icon\" md-svg-icon=\"{{node | iconForNode}}\"></md-icon></div></div><div class=\"policyName\" data-ng-bind-html=\"node | policyDisplayName | highlight: nodeFilter\"></div><div ng-if=\"isAppConnect() && node.$$minimized\" class=\"logic-node__actions-count\">{{countInnerActions(node)}} {{::\'ifNode.actions\' | translate}}</div><div class=\"nodeActionsContainer\"><div class=\"closeShell\" data-ng-show=\"isDraggable()\"><button data-ng-if=\"!isAppConnect() && node.$$type !== \'throw\' && node.$$minimized\" data-ng-click=\"minimize($event);\" class=\"iconOnlyButton material-icons collapseNode\">fullscreen</button> <button data-ng-if=\"!isAppConnect() && node.$$type !== \'throw\' && !node.$$minimized\" data-ng-click=\"minimize($event);\" class=\"iconOnlyButton material-icons collapseNode\">fullscreen_exit</button> <button data-ng-if=\"isAppConnect() && node.$$minimized\" data-ng-click=\"minimize($event);\" class=\"iconOnlyButton collapseNode\" title=\"{{::\'assembly_maximise_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_maximise_node_tooltip\' | translate}}\"><md-icon class=\"node-actions-container__appc-icon\" md-svg-icon=\"floweditor:maximize-node\"></md-icon></button> <button data-ng-if=\"isAppConnect() && !node.$$minimized\" data-ng-click=\"minimize($event);\" class=\"iconOnlyButton collapseNode\" title=\"{{::\'assembly_minimise_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_minimise_node_tooltip\' | translate}}\"><md-icon class=\"node-actions-container__appc-icon\" md-svg-icon=\"floweditor:minimize-node\"></md-icon></button> <button data-ng-show=\"config.components\" class=\"iconOnlyButton material-icons snipNode\" title=\"{{::\'assemblySnipNode\' | translate}}\" aria-label=\"{{::\'assemblySnipNode\' | translate}}\" data-ng-click=\"snipNode(node);\">content_cut</button> <button class=\"iconOnlyButton material-icons jumpToCode\" title=\"{{::\'assemblyJumpToSource\' | translate}}\" aria-label=\"{{::\'assemblyJumpToSource\' | translate}}\" data-ng-click=\"jumpToCode(node.$$type, node.$$instance);\">code</button> <button data-ng-if=\"!isAppConnect()\" class=\"iconOnlyButton material-icons copyNode\" title=\"{{::\'assembly_clone_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_clone_node_tooltip\' | translate}}\" data-ng-click=\"cloneNode($event, node);\">content_copy</button> <button data-ng-if=\"!isAppConnect()\" class=\"iconOnlyButton material-icons deleteNode\" style=\"margin-left: 0px\" title=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" data-ng-click=\"deleteNode($event, node);\">delete</button> <button data-ng-if=\"isAppConnect()\" class=\"iconOnlyButton deleteNode\" title=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" data-ng-click=\"deleteNode($event, node);\"><md-icon class=\"node-actions-container__appc-icon\" md-svg-icon=\"floweditor:delete\"></md-icon></button></div></div><div data-ng-if=\"operationFilter && node.$$operations\" class=\"operationCountShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\">{{node.$$operations}}</div></div><div class=\"catchShellContainer\" data-ng-if=\"showCatches && node.catch && !node.$$minimized\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/catch.html\'\"></div></div><div data-ng-if=\"!node.$$minimized\" class=\"clauseShellContainer\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/clause.html\'\"></div></div></div></div><div data-ng-if=\"node.type == \'response\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, $index)\"></div><div data-ng-if=\"node.type == \'response\'\" class=\"outputNode\"></div>");
$templateCache.put("src/html/navigation-bar.html","<div class=\"searchContainer\"><span data-ng-show=\"!testMode && !isAppConnect()\" class=\"searchSectionBorder searchSectionSlim\"><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-click=\"hidePalette = !hidePalette\" title=\"{{::\'assemblyShowPalette\' | translate}}\"><span data-ng-class=\"{\'rotate180\': hidePalette}\" class=\"material-icons transition200\">navigate_before</span></button> </span><span data-ng-show=\"config.test && !testMode\" class=\"searchSectionBorder searchSectionSlim\"><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-click=\"testMode = true;\" title=\"{{::\'assemblyTest\' | translate}}\"><span class=\"material-icons\">play_arrow</span></button></span><div class=\"searchSectionBorder\" flex><div data-ng-class=\"{focused: searchBoxFocused}\" class=\"searchBoxContainer\"><button data-ng-show=\"!nodeFilter\" class=\"iconOnlyButton searchIcon\"></button> <button data-ng-show=\"nodeFilter\" data-ng-click=\"nodeFilter = \'\'\" class=\"iconOnlyButton clearIcon material-icons\">close</button> <input style=\"border-bottom: none\" class=\"searchBox\" data-ng-focus=\"searchBoxFocused = true\" data-ng-blur=\"searchBoxFocused = false\" data-ng-change=\"nodeFiltered();\" data-ng-model=\"nodeFilter\" type=\"text\" spellcheck=\"false\" title=\"{{\'search\' | translate}}\" placeholder=\"{{\'search\' | translate}}\"></div></div><span data-ng-if=\"nodeFilter\" class=\"searchResults searchSectionBorder searchSection\"><span class=\"ui-match\">{{searchCount}} {{hitString}}</span><div class=\"searchButtonContainer\" data-ng-show=\"searchCount\"><button class=\"iconOnlyButton material-icons\" style=\"font-size: 16px; padding: 5px 0px\" data-ng-click=\"searchBack();\" title=\"{{::\'assemblyPrevious\' | translate}}\">navigate_before</button> <button class=\"iconOnlyButton material-icons\" style=\"font-size: 16px; padding: 5px 0px\" data-ng-click=\"searchForward();\" title=\"{{::\'assemblyNext\' | translate}}\">navigate_next</button></div></span><span class=\"searchSectionBorder searchSection operationFilter\" data-ng-show=\"!testMode && !config.hideOperationsFilter\"><md-select placeholder=\"{{::\'assemblyFilterOperations\' | translate}}\" class=\"displayInline alignTop\" style=\"margin: 5px 0px 0px 0px; font-size: 1.2em\" data-ng-if=\"showOperationFilter\" data-ng-model=\"$parent.operationFilter\"><md-option data-ng-value=\"operation\" data-ng-repeat=\"operation in swaggerOperations\"><span data-ng-if=\"!operation.verb\">{{operation.operationId}}</span> <span data-ng-if=\"operation.verb\">{{operation.verb}} {{operation.path}}</span></md-option></md-select><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-show=\"!showOperationFilter\" data-ng-click=\"showOperationFilter = !showOperationFilter\" title=\"{{::\'assemblyFilterOperationsLabel\' | translate}}\"><span class=\"material-icons\">filter_list</span></button> <button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-show=\"showOperationFilter\" data-ng-click=\"operationFilter = null; showOperationFilter = false;\" title=\"{{::\'assemblyClearFilterOperationsLabel\' | translate}}\"><span class=\"material-icons\">close</span></button> </span><span class=\"searchSectionBorder searchSection catchSwitch\"><md-switch ng-model=\"showCatches\" md-no-ink aria-label=\"{{::\'assemblyShowCatches\' | translate}}\" class=\"assemblyCatchSwitch md-block\">{{::\'assemblyShowCatches\' | translate}}</md-switch></span><span class=\"searchSectionBorder searchSection\"><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-click=\"fitToScreen();\" title=\"{{::\'assemblyFitToScreen\' | translate}}\"><span class=\"material-icons\">gps_fixed</span></button> </span><span class=\"searchSectionBorder searchSection\" data-ng-if=\"allowReferences\"><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-show=\"!snipping\" data-ng-click=\"toggleSnipMode();\" title=\"{{::\'assemblySnip\' | translate}}\"><span class=\"material-icons\">content_cut</span></button> <span style=\"margin-right: 10px\" data-ng-if=\"snipping\"><apic-component-mover data-reference-source=\"snippedAssembly\" data-reference-scope=\"assemblies\" empty-message=\"snippedAssemblyEmpty()\"></apic-component-mover></span><button class=\"iconOnlyButton\" style=\"font-size: 16px; padding: 8px 0px 0px 0px\" data-ng-show=\"snipping\" data-ng-click=\"toggleSnipMode();\" title=\"{{::\'close\' | translate}}\"><span class=\"material-icons\">close</span></button> </span><span class=\"sliderSection searchSection\"><button class=\"iconOnlyButton displayInline material-icons\" data-ng-click=\"zoomOut();\" style=\"padding-top: 8px\" title=\"{{::\'assemblyZoomOut\' | translate}}\">remove</button><md-slider class=\"assemblySlider displayInline\" aria-label=\"{{::\'assemblyZoomLabel\' | translate}}\" md-discrete data-ng-model=\"scaleFactor\" step=\"0.05\" min=\"0.1\" max=\"1.5\"></md-slider><button class=\"iconOnlyButton displayInline material-icons\" data-ng-click=\"zoomIn();\" style=\"padding-top: 8px\" title=\"{{::\'assemblyZoomIn\' | translate}}\">add</button></span></div>");
$templateCache.put("src/html/node-group.html","<div class=\"nodeGroup\" data-ng-repeat=\"node in nodes | transformNodeModel: policiesByType: operationFilter: operationMap: true\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, null, $index)\" data-ng-class=\"{\'assembly-canvas__insert-point\': allowNewNode(), \'dropzoneGroupApi\': config.assemblyType === \'api\'}\"><div class=\"ghostPolicy\" data-ng-class=\"{\'js-assembly-canvas__animation-target\': isFlowSlim()}\" data-ng-click=\"ghostSelected($event, null, $index)\"><md-icon data-ng-if=\"isAppConnect() && allowNewNode()\" md-svg-icon=\"floweditor:Plus-Light\" class=\"assembly-canvas__plus-inner\"></md-icon></div><div ng-if=\"isAppConnect() && allowNewNode()\" class=\"ghostPadder\"></div></div></div>");
$templateCache.put("src/html/node.html","<div class=\"nodeWrapper\" data-ng-if=\"node.$$application\" data-ng-include src=\"\'/app/nodeTemplates/application-node.html\'\"></div><div class=\"nodeWrapper\" data-ng-if=\"node.$$logic\" data-ng-include src=\"\'src/html/logic-node.html\'\"></div><div class=\"nodeWrapper\" data-ng-if=\"!node.$$logic && !node.$$application && !node.$$subflow\" data-ng-include src=\"\'src/html/policy-node.html\'\"></div><div class=\"nodeWrapper\" data-ng-if=\"node.$$subflow\" data-ng-include src=\"\'src/html/subflow-node.html\'\"></div>");
$templateCache.put("src/html/policy-list.html","<div class=\"policyList stretch\" data-ng-show=\"!hidePalette && !testMode\"><div class=\"searchContainer\"><div class=\"filterBoxContainer displayInline\" data-ng-class=\"{\'makeSpaceForGateways\': config.gateways}\"><div data-ng-class=\"{focused: filterBoxFocused}\" class=\"filterBoxFocus\" flex><button data-ng-show=\"!policyFilter\" class=\"iconOnlyButton searchIcon\"></button> <button data-ng-show=\"policyFilter\" data-ng-click=\"policyFilter = \'\'\" class=\"iconOnlyButton clearIcon material-icons\">close</button> <input class=\"filterBox\" data-ng-focus=\"filterBoxFocused = true\" data-ng-blur=\"filterBoxFocused = false\" data-ng-change=\"nodeFiltered();\" data-ng-model=\"policyFilter\" type=\"text\" spellcheck=\"false\" title=\"{{\'Filter\' | translate}}\" placeholder=\"{{\'Filter\' | translate}}\"></div></div><div class=\"displayInline alignTop policyFilterIcon\" data-ng-show=\"config.gateways\"><button class=\"iconOnlyButton material-icons\" style=\"font-size: 16px; padding: 6px 6px 0px 7px\" data-ng-click=\"showPolicyFilter = !showPolicyFilter\" title=\"{{::\'assembly_filter_policies\' | translate}}\">filter_list</button></div></div><ul class=\"policyGateways\" data-ng-show=\"config.gateways && showPolicyFilter\"><md-radio-group data-ng-model=\"$gateway\" data-ng-model-options=\"{getterSetter: true}\"><md-radio-button value=\"micro-gateway\" class=\"md-primary\">{{::\'assembly_policies_filter_micro\' | translate}}</md-radio-button><md-radio-button value=\"datapower-gateway\" class=\"md-primary\">{{::\'assembly_policies_filter_dp\' | translate}}</md-radio-button></md-radio-group></ul><ul class=\"simpleList policyInner\" data-ng-class=\"{\'gatewaysShown\': config.gateways && showPolicyFilter}\"><div class=\"policyCategoryGroup\" data-ng-repeat=\"(category, policies) in filteredCategories\"><li class=\"policyCategoryHeader\" data-ng-click=\"closeCategory($event, category);\"><span>{{::category}}</span> <button class=\"iconOnlyButton minimizeButton\"><span class=\"material-icons\" data-ng-class=\"{\'rotate180\': collapsedCategories[category]}\">keyboard_arrow_up</span></button></li><div class=\"policyCategoryContents\" data-ng-show=\"!collapsedCategories[category]\"><li data-ng-repeat=\"policy in policies | orderBy: \'info.title\'\"><apim-assembly-policy></apim-assembly-policy></li></div></div></ul></div>");
$templateCache.put("src/html/policy-node.html","<script type=\"text/ng-template\" id=\"errorPopover\"><div class=\"popoverArrow\"></div>\n<div data-ng-if=\"gatewayErrorMessage\" class=\"popoverError\">\n  {{gatewayErrorMessage}}\n</div>\n<div data-ng-if=\"!gatewayErrorMessage\" class=\"popoverError\">\n  {{errorMessage}}\n</div></script><div data-ng-controller=\"NodeController as NodeController\" class=\"policyNode {{node.$$type}} {{node.$$classes.join(\' \')}}\" data-ng-class=\"{\n    \'policyWithContent\': policyWithContent(),\n    \'policyGatewayMiss\': policyGatewayMiss(),\n    \'snipped\': snipping && node.$$snipped\n  }\"><div class=\"outerShell\"><div data-ng-if=\"gatewayErrorMessage\" class=\"errorShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\"><div class=\"errorIcon\"></div></div><div data-ng-if=\"errorMessage && !gatewayErrorMessage && node.$$touched\" class=\"errorShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\"><div class=\"errorIcon\"></div></div><div tabindex=\"0\" data-drag=\"data\" data-ui-draggable=\"isDraggable()\" class=\"innerShell\" data-ng-click=\"nodeSelected($event, node)\" data-ng-keydown=\"keyPressed($event, node)\" data-ng-class=\"{\n        \'searchMiss\' : !hasMatchedSearch(),\n        \'searchHit\'  : hasMatchedSearch(),\n        \'isSelected\' : node.$$isSelected\n      }\"><div class=\"nodeHeader\"><div class=\"iconShell material-icons\" data-ng-attr-style=\"background-color: {{node.$$display.color}};\">{{node | iconForNode}}</div><div class=\"policyName\" data-ng-bind-html=\"node | policyDisplayName | highlight: nodeFilter\" ng-attr-title=\"{{node | policyDisplayName}}\"></div></div><div class=\"nodeActionsContainer\"><div class=\"closeShell\"><button class=\"iconOnlyButton material-icons jumpToCode\" title=\"{{::\'assemblyJumpToSource\' | translate}}\" aria-label=\"{{::\'assemblyJumpToSource\' | translate}}\" data-ng-click=\"jumpToCode(node.$$type, node.$$instance);\">code</button> <button class=\"iconOnlyButton material-icons copyNode\" title=\"{{::\'assembly_clone_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_clone_node_tooltip\' | translate}}\" data-ng-click=\"cloneNode($event, node);\">content_copy</button> <button class=\"iconOnlyButton material-icons deleteNode\" style=\"margin-left: 0px\" title=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" data-ng-click=\"deleteNode($event, node);\">delete</button></div></div><div data-ng-if=\"operationFilter && node.$$operations\" class=\"operationCountShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\">{{node.$$operations}}</div></div><div class=\"catchShellContainer\" data-ng-if=\"showCatches && node.catch\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/catch.html\'\"></div></div><div class=\"clauseShellContainer\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/clause.html\'\"></div></div></div></div><div data-ng-if=\"node.type == \'response\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, $index)\"></div><div data-ng-if=\"node.type == \'response\'\" class=\"outputNode\"></div>");
$templateCache.put("src/html/policy.html","<div class=\"policy {{::policy.info.name}} {{::policy.classes.join(\' \')}}\" tabindex=\"0\" data-drag=\"policy\" data-ui-draggable=\"isDraggable()\" title=\"{{::policy.info.title}}\"><div class=\"policyHeader\" data-ng-class=\"{\'expanded\': showPolicyInfo && policy.info.description}\"><div class=\"iconShell\" data-ng-attr-style=\"background-color: {{policy.info.display.color}};\"><div data-ng-class=\"{\'material-icons\': (policy | iconForNode)}\" class=\"iconInnerShell\">{{::policy | iconForNode}}</div></div><span class=\"policyName boundedText\" data-ng-bind-html=\"policy.info.title || policy.info.name | highlight: policyFilter\" data-ng-attr-title=\"{{policy.info.title || policy.info.name}}\"></span> <span data-ng-if=\"policy.custom\" class=\"policyVersion\">{{::policy.info.version}}</span> <button class=\"iconOnlyButton policyInfoButton material-icons\" data-ng-if=\"policy.info.description\" data-ng-click=\"$parent.showPolicyInfo = !$parent.showPolicyInfo\">info</button></div><div data-ng-if=\"showPolicyInfo && policy.info.description\" style=\"margin-top: 10px; padding: 3px\" marked=\"policy.info.description\"></div></div>");
$templateCache.put("src/html/sidenav.html","<md-sidenav md-component-id=\"assembly-info\" data-ng-class=\"{\n    \'pinned\': assemblyInfoPinned,\n    \'maximized\': assemblyInfoMaximized,\n    \'doubleWidth\': selectedNode.$$type === \'map\'\n  }\" md-is-locked-open=\"assemblyInfoPinned\" data-ng-keydown=\"keyDown($event)\" class=\"assemblyInfoSection md-sidenav-right\"><div class=\"assemblyInfo\"><div class=\"infoView {{selectedNode.$$type}} {{selectedNode.selectedApplication.name}} {{selectedNode.$$classes.join(\' \')}}\" data-ng-if=\"selectedNode\" data-ng-controller=\"AssemblerInfoController\"><div ng-if=\"!isFlowSlim()\" class=\"header\" layout=\"row\" layout-align=\"center center\"><div data-ng-if=\"!isAppConnect()\" data-ng-class=\"{\'material-icons\': (selectedNode | iconForNode)}\" class=\"iconShell\" ng-attr-style=\"background-color: {{selectedNode.$$display.color}}\"><div class=\"iconInnerShell\">{{selectedNode | iconForNode}}</div></div><div class=\"assembly-info__content-container\" flex layout=\"row\" layout-align=\"start center\"><div ng-if=\"isAppConnect()\" class=\"iconShell\" data-ng-class=\"{\'node--has-application\': selectedNode.selectedApplication && selectedNode.selectedApplication.name}\"><md-icon class=\"iconInnerShell\" md-svg-icon=\"{{selectedNode | iconForNode}}\"></md-icon></div><div class=\"assembly-info__node-info\" layout=\"column\" flex layout-align=\"center start\"><span class=\"policyName boundedText\">{{selectedNode | policyDisplayName}}</span> <span class=\"assembly-info__account-name\" ng-if=\"selectedNode.accountName && isAppConnect()\">{{selectedNode.accountName}}</span></div></div><div class=\"assembly-info__control-buttons\" layout=\"row\" layout-align=\"end center\"><button class=\"iconOnlyButton material-icons togglePanelPosition\" data-ng-click=\"toggleInfoPanelBottom($event);\" title=\"{{::\'assembly-move-panel\' | translate}}\" aria-label=\"{{::\'assembly-move-panel\' | translate}}\">screen_rotation</button> <button class=\"iconOnlyButton material-icons jumpToCode\" data-ng-show=\"!selectedNode.$$readOnly && !selectedNode.$$parentReadOnly\" data-ng-click=\"jumpToCode(selectedNode.$$type, selectedNode.$$instance);\" title=\"{{::\'assemblyJumpToSource\' | translate}}\" aria-label=\"{{::\'assemblyJumpToSource\' | translate}}\">code</button> <button class=\"iconOnlyButton material-icons maximizeInfo\" data-ng-click=\"maximizeAssemblyInfo($event);\" title=\"{{::\'assemblyMaximize\' | translate}}\" aria-label=\"{{::\'assemblyMaximize\' | translate}}\">{{assemblyInfoMaximized | assemblyInfoMaximizeLabel}}</button> <button class=\"iconOnlyButton material-icons closeInfo\" data-ng-click=\"closeInfo($event);\" title=\"{{::\'assemblyCloseInfo\' | translate}}\" aria-label=\"{{::\'assemblyCloseInfo\' | translate}}\">close</button></div></div><div data-ng-include src=\"scope.config.html + getPolicyPartial(selectedNode.$$type, selectedNode.version)\" class=\"policyPartial\"></div></div></div></md-sidenav>");
$templateCache.put("src/html/subflow-node.html","<script type=\"text/ng-template\" id=\"errorPopover\"><div class=\"popoverArrow\"></div>\n<div data-ng-if=\"gatewayErrorMessage\" class=\"popoverError\">\n  {{gatewayErrorMessage}}\n</div>\n<div data-ng-if=\"!gatewayErrorMessage\" class=\"popoverError\">\n  {{errorMessage}}\n</div></script><div data-ng-controller=\"NodeController as NodeController\" class=\"policyNode subflowNode referenceNode {{node.$$type}} {{node.$$classes.join(\' \')}}\" data-ng-init=\"node.$$minimized = true;\" data-ng-class=\"{\'policyWithContent\': policyWithContent(), \'policyGatewayMiss\': policyGatewayMiss(), \'minimized\': node.$$minimized, \'snipped\': snipping && node.$$snipped}\"><div class=\"outerShell\"><div data-ng-if=\"gatewayErrorMessage\" class=\"errorShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\"><div class=\"errorIcon\"></div></div><div data-ng-if=\"errorMessage && !gatewayErrorMessage && node.$$touched\" class=\"errorShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\"><div class=\"errorIcon\"></div></div><div data-drag=\"data\" data-ui-draggable=\"isDraggable()\" class=\"innerShell\" data-ng-click=\"nodeSelected($event, node)\" data-ng-keydown=\"keyPressed($event, node)\" data-ng-class=\"{\'searchMiss\': !hasMatchedSearch(), \'searchHit\': hasMatchedSearch()}\"><div class=\"iconShell material-icons\">{{node | iconForNode}}</div><div class=\"policyName\" data-ng-bind-html=\"node | policyDisplayName | highlight: nodeFilter\"></div><div class=\"nodeActionsContainer\"><div class=\"closeShell\"><button data-ng-if=\"node.$$type !== \'throw\' && node.$$minimized\" data-ng-click=\"minimize($event);\" class=\"iconOnlyButton material-icons collapseNode\">fullscreen</button> <button data-ng-if=\"node.$$type !== \'throw\' && !node.$$minimized\" data-ng-click=\"minimize($event);\" class=\"iconOnlyButton material-icons collapseNode\">fullscreen_exit</button> <button class=\"iconOnlyButton material-icons jumpToCode\" title=\"{{::\'assemblyJumpToSource\' | translate}}\" aria-label=\"{{::\'assemblyJumpToSource\' | translate}}\" data-ng-click=\"jumpToCode(node.$$type, node.$$instance);\">code</button> <button class=\"iconOnlyButton material-icons copyNode\" title=\"{{::\'assembly_clone_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_clone_node_tooltip\' | translate}}\" data-ng-click=\"cloneNode($event, node);\">content_copy</button> <button class=\"iconOnlyButton material-icons deleteNode\" style=\"margin-left: 0px\" title=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" aria-label=\"{{::\'assembly_delete_node_tooltip\' | translate}}\" data-ng-click=\"deleteNode($event, node);\">delete</button></div></div><div data-ng-if=\"operationFilter && node.$$operations\" class=\"operationCountShell\" ns-popover ns-popover-template=\"errorPopover\" ns-popover-trigger=\"mouseenter\" ns-popover-placement=\"bottom|center\" ns-popover-timeout=\"0\">{{node.$$operations}}</div></div><div class=\"clauseShellContainer\" data-ng-if=\"!node.$$minimized\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/clause.html\'\"></div></div><div class=\"catchShellContainer\" data-ng-if=\"showCatches && node.catch && !node.$$minimized\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/catch.html\'\"></div></div><div data-ng-if=\"false\"><div class=\"dropzoneGroupSpacer\"></div><div class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, $index, -1)\"><div class=\"ghostPolicy\"></div></div><div class=\"inlineContainer\" data-ng-repeat=\"node in node.execute | transformNodeModel: policiesByType\"><div class=\"inlineContainer\"><apim-node></apim-node></div><div class=\"dropzoneGroupSpacer\"></div><div data-ng-if=\"node.type !== \'response\' && node.type !== \'throw\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, $parent.$parent.node, $parent.$parent.$index, $index)\"><div class=\"ghostPolicy\"></div></div></div><div class=\"catchShellContainer\" data-ng-if=\"showCatches && node.catch\" data-ng-class=\"{\'emptyClause\': isClauseEmpty()}\"><div data-ng-include=\"\'src/html/catch.html\'\"></div></div></div></div></div><div data-ng-if=\"node.type == \'response\'\" class=\"dropzoneGroup\" data-ui-on-drop=\"policyDropped($data, node, $index)\"></div><div data-ng-if=\"node.type == \'response\'\" class=\"outputNode\"></div>");
$templateCache.put("src/html/target-connector.html","<md-dialog aria-labelledby=\"{{$id}}_bannerHeading\"><md-toolbar><div class=\"md-toolbar-tools\"><h2 id=\"{{$id}}_bannerHeading\">{{::\'assemblerMapperConfigureTarget\' | translate}}</h2></div></md-toolbar><md-dialog-content style=\"min-width: 900px\"><div data-ng-show=\"sources\" style=\"margin: 10px 0px\"><div class=\"displayInline alignTop\">{{::\'assemblerMapperMappedFrom\' | translate}}</div><div class=\"displayInline alignTop\" style=\"font-weight: bold; margin: 0px 30px\"><div data-ng-repeat=\"from in sources\"><button style=\"margin: -5px 10px 0 0; vertical-align: middle\" class=\"iconOnlyButton material-icons\" data-ng-click=\"removeMapping(from);\" title=\"{{::\'assemblyRemoveMappingTitle\' | translate}}\">delete</button> <span>{{from}}</span></div></div></div><div data-ng-show=\"foreach && iterators.length > 0\" style=\"margin: 10px 0px\"><div class=\"secondaryText\">{{::\'assemblerMapperIterateOutput\' | translate}}</div><div data-ng-repeat=\"(target, source) in foreach\" style=\"margin-top: 5px\"><span>{{\'assemblerMapperOutputArray\' | translate}}: </span><span style=\"font-weight: bold\">{{target}}</span><span style=\"margin-right: 10px\">, {{\'assemblerMapperInputArray\' | translate}}:</span><md-input-container style=\"margin-top: -7px; font-weight: bold\"><md-select data-ng-model=\"foreach[target]\"><md-option data-ng-repeat=\"iterator in iterators\" value=\"{{iterator}}\">{{iterator}}</md-option></md-select></md-input-container></div></div><div data-ng-show=\"mergeable\" style=\"margin: 10px 0px\"><md-checkbox md-no-ink data-ng-model=\"merge\" class=\"md-primary\">{{::\'assemblyMapperMergeMatchingRules\' | translate}}</md-checkbox><button class=\"material-icons iconOnlyButton alignMiddle infoIcon\" data-ng-click=\"showTooltip = !showTooltip;\" data-tooltip-is-open=\"showTooltip\" data-tooltip=\"{{::\'assemblyMapperMergeMatchingRulesDescription\' | translate}}\" data-tooltip-placement=\"right\">info_outline</button></div><label data-ng-show=\"true\">{{::\'assemblerMapperValue\' | translate}}</label><div data-ng-show=\"true\" class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"font-size: 1.0em; min-height: 10.0em\" data-ng-model=\"value\" ui-ace=\"{useWrapMode: true, mode: \'javascript\', theme: \'atom_dark\', require: [\'ace/ext/language_tools\'], advanced: {enableBasicAutocompletion: true, enableLiveAutocompletion: true}, onLoad: aceLoaded}\"></div><md-input-container data-ng-show=\"!emptyString\" ng-switch on=\"valueType\" style=\"width: 100%\"><label>{{::\"assemblerMapperDefault\" | translate}}</label><input ng-switch-when=\"integer|number\" ng-switch-when-separator=\"|\" type=\"number\" data-ng-model=\"$parent.default\"><input ng-switch-default data-ng-model=\"$parent.default\"></md-input-container><div class=\"secondaryText\">{{::\'assemblerMapperDefaultDescription\' | translate}}</div><br><md-checkbox md-no-ink data-ng-model=\"emptyString\" data-ng-show=\"valueType===\'string\'\" class=\"md-primary\">{{::\'assemblerMapperEmptyString\' | translate}}</md-checkbox></md-dialog-content><div class=\"md-actions layout-row\"><button class=\"cancelButton\" data-ng-click=\"cancel();\">{{::\'cancel\' | translate}}</button> <button class=\"createButton\" data-ng-click=\"deleteMapping();\">{{::\'delete\' | translate}}</button> <button class=\"createButton\" data-ng-click=\"updateModel();\">{{::\'ok\' | translate}}</button></div></md-dialog>");
$templateCache.put("src/html/template.html","<div class=\"template {{::template.info.name}}\" tabindex=\"0\" data-drag=\"template\" data-ui-draggable=\"isDraggable()\" title=\"{{::template.info.name}}\" data-ng-show=\"showPolicy(template.info.name, template);\"><div class=\"policyHeader\" data-ng-class=\"{\'expanded\': showPolicyInfo && template.info.description}\"><span class=\"iconShell material-icons\" data-ng-attr-style=\"background-color: {{template.info.display.color}};\">{{::template | iconForNode}}</span> <span class=\"policyName boundedText\" data-ng-bind-html=\"template.info.name | highlight: policyFilter\">{{::template.name}}</span> <span data-ng-if=\"template.custom\" class=\"policyVersion\">{{::template.info.version}}</span> <button class=\"iconOnlyButton policyInfoButton material-icons\" data-ng-if=\"template.info.description\" data-ng-click=\"$parent.showPolicyInfo = !$parent.showPolicyInfo\">info</button></div><div data-ng-if=\"showPolicyInfo && template.info.description\" style=\"margin-top: 10px; padding: 3px\" marked=\"template.info.description\"></div></div>");
$templateCache.put("src/html/test-parameter.html","<div data-ng-controller=\"AssemblerTestParameterController as paramCtrl\"><div data-ng-if=\"parameter.description\">{{parameter.description}}</div><div><md-input-container data-ng-if=\"parameter.in !== \'body\' && parameter.type !== \'boolean\'\" style=\"width: 100%\"><label>{{parameter.name}}</label><input data-ng-model=\"parameterValues[parameter.name]\" data-ng-required=\"parameter.required\"></md-input-container><md-input-container data-ng-if=\"parameter.in === \'body\'\" style=\"width: 100%\"><label>{{parameter.name}}</label><textarea data-ng-model=\"parameterValues[parameter.name]\" data-ng-required=\"parameter.required\"></textarea></md-input-container><md-checkbox style=\"margin: 10px 0\" class=\"md-primary\" data-ng-if=\"parameter.type === \'boolean\' && !!parameter.required\" data-ng-model=\"parameterValues[parameter.name]\" data-ng-init=\"parameterValues[parameter.name] = false\">{{parameter.name}}</md-checkbox><md-input-container data-ng-if=\"parameter.type === \'boolean\' && !parameter.required\" data-ng-model=\"parameterValues[parameter.name]\"><label>{{parameter.name}}</label><md-select data-ng-model=\"parameterValues[parameter.name]\"><md-option data-ng-value=\"true\">true</md-option><md-option data-ng-value=\"false\">false</md-option><md-option data-ng-value=\"omit\">{{::\'explorer_dont_send\' | translate}}</md-option></md-select></md-input-container><div><div><a data-ng-if=\"parameter.schema\" data-ng-click=\"$parent.showSchema = !$parent.showSchema\">{{::\'assemblyShowSchema\' | translate}}</a> <span data-ng-if=\"parameter.schema\">| </span><a data-ng-show=\"canGenerate\" data-ng-click=\"paramCtrl.generateExample()\">{{::\'assemblyGenerateData\' | translate}}</a></div><json-schema-view data-ng-if=\"showSchema\" data-ng-attr-schema=\"schema\" open=\"2\" data-ng-attr-definitions=\"$parent.swaggerDocument.definitions\"></json-schema-view></div></div></div>");
$templateCache.put("src/html/warning-dialog.html","<div class=\"warning-content\"><svg class=\"warning-icon\"></svg> <span class=\"warning-message\">{{warningMessage}}</span> <span class=\"warning-buttons\"><md-button data-ng-repeat=\"button in warningButtons\" data-ng-click=\"runCallback(button.callbackFunction, button.keepDialogOpen)\" md-no-ink=\"true\">{{button.buttonTitle}}</md-button></span></div>");
$templateCache.put("src/html/policies/catch.html","<div data-ng-if=\"showCatches\" data-ng-controller=\"CatchController as catchCtrl\" class=\"infoSection\"><fieldset data-ng-disabled=\"selectedNode.$$readOnly || selectedNode.$$parentReadOnly\"><div class=\"catchCase\" data-ng-repeat=\"catch in selectedNode.catch\" data-ng-controller=\"CatchBlockController as catchBlockCtrl\"><span><div><span class=\"catchIcon\"></span> <span data-ng-if=\"!catch.default\" style=\"margin-right: 10px; line-height: 49px; font-size: 1.2em; min-width: 70px\">{{::\'assemblyCatch\' | translate}} {{$index}}</span> <span data-ng-if=\"catch.default\" style=\"margin-right: 10px; line-height: 49px; font-size: 1.2em; min-width: 70px; flex: 1\">{{::\'policies_default\' | translate}}</span></div><div><button style=\"margin: 0px\" data-ng-if=\"catchCtrl.canMoveUp($index);\" class=\"iconOnlyButton material-icons\" data-ng-click=\"catchCtrl.moveUp($index)\" title=\"{{::\'assemblyMoveUp\' | translate}}\">arrow_upward</button> <button style=\"margin: 0px\" data-ng-if=\"catchCtrl.canMoveDown($index);\" class=\"iconOnlyButton material-icons\" data-ng-click=\"catchCtrl.moveDown($index)\" title=\"{{::\'assemblyMoveDown\' | translate}}\">arrow_downward</button> <button style=\"margin: 0px\" class=\"iconOnlyButton material-icons\" data-ng-click=\"catchCtrl.removeCatch($index)\" title=\"{{::\'assemblyRemoveCatch\' | translate}}\">delete</button></div></span><span class=\"catchContent\"><md-chips data-ng-if=\"!catch.default\" data-ng-model=\"catch.errors\" md-autocomplete-snap md-require-match=\"false\"><md-autocomplete md-min-length=\"0\" md-search-text=\"catchBlockCtrl.searchText\" md-no-cache=\"true\" md-items=\"error in catchBlockCtrl.filter()\" placeholder=\"{{::\'assemblySearchErrors\' | translate}}\"><md-item-template><span md-highlight-text=\"catchBlockCtrl.searchText\">{{error}}</span></md-item-template></md-autocomplete><md-chip-template><span>{{$chip}}</span></md-chip-template></md-chips></span></div><button style=\"margin: 10px\" class=\"floatLeft\" data-ng-click=\"catchCtrl.addCatch()\" title=\"{{::\'assemblyAddCatchTitle\' | translate}}\">{{::\'assemblyAddCatch\' | translate}}</button> <button style=\"margin: 10px\" class=\"floatLeft\" data-ng-show=\"!catchCtrl.hasDefault();\" data-ng-click=\"catchCtrl.addCatchDefault()\" title=\"{{::\'assemblyAddCatchDefaultTitle\' | translate}}\">{{::\'assemblyAddCatchDefault\' | translate}}</button><div class=\"clearBoth\"></div></fieldset></div>");
$templateCache.put("src/html/policies/generator.html","<div class=\"infoSection\"><fieldset data-ng-disabled=\"selectedNode.$$readOnly || selectedNode.$$parentReadOnly\"><div data-ng-show=\"!schema\" style=\"padding: 10px\">{{::\'assembly_empty_schema\' | translate}}</div><div class=\"property_form\" data-ng-show=\"schema\"><form class=\"json-schema-form\" schema-form=\"schema\" data-ng-model=\"model\" data-ng-change=\"formChanged(model);\"></form></div></fieldset></div>");
$templateCache.put("src/html/policies/if.html","<div data-ng-controller=\"ValidationDefinitionController as ctrl\" class=\"infoSection\"><fieldset data-ng-disabled=\"selectedNode.$$readOnly || selectedNode.$$parentReadOnly\"><div><md-input-container><label>{{::\"assemblyTitle\" | translate}}</label><input data-ng-model=\"selectedNode.title\" data-ng-model-options=\"{debounce:200}\"></md-input-container><md-input-container><label>{{::\"assemblyDescription\" | translate}}</label><textarea data-ng-model=\"selectedNode.description\" data-ng-model-options=\"{debounce:200}\"></textarea></md-input-container><label>{{::\"assemblyCondition\" | translate}}</label><div class=\"editor-wrapper ace_editor ace-atom-dark ace_dark\" style=\"min-height: 300px; margin: 10px\" data-ng-model=\"selectedNode.condition\" ui-ace=\"{useWrapMode: true, mode: \'javascript\', theme: \'atom_dark\', require: [\'ace/ext/language_tools\'], advanced: {enableBasicAutocompletion: true, enableLiveAutocompletion: true}}\"></div></div></fieldset></div>");
$templateCache.put("src/html/policies/mapper.html","<div data-ng-controller=\"MapperController as mapperController\"><fieldset data-ng-disabled=\"selectedNode.$$readOnly || selectedNode.$$parentReadOnly\"><div data-ng-if=\"mapperController.currentPage == \'map\'\"><div class=\"mapper-container\"><div class=\"mapper-inputs\"><div class=\"mapper-header\">{{::\'assemblyMapSource\' | translate}} <button class=\"mapperEditIcon iconOnlyButton floatRight material-icons\" data-ng-click=\"mapperController.currentPage = \'inputs\';\" title=\"{{::\'assemblyEditInputs\' | translate}}\" aria-label=\"{{::\'assemblyEditInputs\' | translate}}\">edit</button></div><div class=\"mapper-inputs-container\"><div data-ng-repeat=\"inputSchema in $parent.inputSchemas\" class=\"schema-block\"><apic-mapper-schema class=\"mapper-input-schema\" data-ng-attr-schema=\"inputSchema\" data-editable=\"!map.readOnly\" data-references=\"references\" open=\"5\" data-ng-attr-definitions=\"swaggerDocument\"></apic-mapper-schema><div class=\"clearBoth\"></div></div></div></div><div class=\"mapper-transformation\"><div class=\"mapper-header\"><button class=\"mapperEditIcon iconOnlyButton material-icons\" style=\"float: left\" data-ng-click=\"mapperController.currentPage = \'options\';\" title=\"{{::\'assemblerMapperConfigure\' | translate}}\" aria-label=\"{{::\'assemblerMapperConfigure\' | translate}}\">settings</button> <span>{{::\'assemblyMapTransformation\' | translate}}</span> <button class=\"mapperEditIcon iconOnlyButton floatRight material-icons\" data-ng-click=\"mapperController.constructCanvas();\" title=\"{{::\'assemblyRefresh\' | translate}}\" aria-label=\"{{::\'assemblyRefresh\' | translate}}\">refresh</button></div><svg width=\"300\" height=\"400\" id=\"node-mapper\" class=\"mapper-canvas\"></svg></div><div class=\"mapper-outputs\"><div class=\"mapper-header\">{{::\'assemblyMapTarget\' | translate}} <button class=\"mapperEditIcon iconOnlyButton floatRight material-icons\" data-ng-click=\"mapperController.currentPage = \'outputs\';\" title=\"{{::\'assemblyEditOutputs\' | translate}}\" aria-label=\"{{::\'assemblyEditOutputs\' | translate}}\">edit</button></div><div class=\"mapper-outputs-container\"><div data-ng-repeat=\"outputSchema in $parent.outputSchemas\" class=\"schema-block\"><apic-mapper-schema class=\"mapper-output-schema\" data-ng-attr-schema=\"outputSchema\" data-editable=\"!map.readOnly\" data-references=\"references\" open=\"5\" data-ng-attr-definitions=\"swaggerDocument\"></apic-mapper-schema></div></div></div></div></div><div style=\"margin: 10px\" data-ng-if=\"mapperController.currentPage == \'inputs\'\"><div data-ng-controller=\"MapInputOutputController as inOutController\" data-ng-repeat=\"(name, object) in selectedNode.inputs track by name\"><div class=\"mapObject\"><md-input-container class=\"halfWidth\"><label>{{::\'assemblyContextVariable\' | translate}}</label><input apim-context-variable data-ng-model=\"object.variable\" data-ng-model-options=\"{debounce:200}\"></md-input-container><md-input-container class=\"halfWidth\"><label>{{::\"assemblyMapName\" | translate}}</label><input data-ng-model=\"$inputName\" data-ng-model-options=\"{getterSetter: true, updateOn: \'blur\'}\"></md-input-container><div style=\"width: 88px\"></div></div><div class=\"mapObject\"><div class=\"halfWidth\"><label style=\"padding-left: 3px\" for=\"$id + \'_inputType\'\">{{::\"assemblyContentType\" | translate}}</label><apim-combobox style=\"font-weight: bold\" id=\"$id + \'_inputType\'\" item-list=\"inOutController.contentTypes\" selection=\"contentType\"></apim-combobox></div><md-input-container class=\"halfWidth\"><label for=\"$id + \'_definition\'\">{{::\'assemblyDefinition\' | translate}}</label><md-select required data-ng-model=\"selectedDefinition\"><md-option data-ng-repeat=\"definition in definitions\" data-ng-value=\"definition.value || definition.name\">{{definition.name}}</md-option></md-select></md-input-container><button style=\"margin: 10px\" data-ng-show=\"selectedDefinition == \'inline\'\" class=\"iconOnlyButton material-icons\" data-ng-click=\"inOutController.launchInlineEditor()\" title=\"{{::\'assembly_edit_inline_definition\' | translate}}\">code</button><div style=\"width: 44px\" data-ng-show=\"selectedDefinition !== \'inline\'\"></div><button style=\"margin: 10px\" class=\"iconOnlyButton material-icons\" data-ng-click=\"mapperController.removeInput(name)\" title=\"{{::\'assemblyRemoveInput\' | translate}}\">delete</button></div></div><div><button data-ng-click=\"mapperController.addInput()\" title=\"{{::\'assemblyAddInputTitle\' | translate}}\">{{::\'assemblyAddInputTitle\' | translate}}</button><md-menu><md-button ng-click=\"$mdOpenMenu($event);\" title=\"{{::\'assemblyAddParametersTitle\' | translate}}\">{{::\'assemblyAddParametersTitle\' | translate}}</md-button><md-menu-content><md-menu-item data-ng-repeat=\"operation in swaggerOperations\"><span data-ng-if=\"operation.operationId\" data-ng-click=\"mapperController.addParametersForOperation(operation);\">{{operation.operationId}}</span> <span data-ng-if=\"!operation.operationId\" data-ng-click=\"mapperController.addParametersForOperation(operation);\">{{operation.verb}} {{operation.path}}</span></md-menu-item></md-menu-content></md-menu><button style=\"float: right\" data-ng-click=\"mapperController.switchToMap();\" title=\"{{::\'assemblyDone\' | translate}}\">{{::\'assemblyDone\' | translate}}</button><div class=\"clearBoth\"></div></div></div><div style=\"margin: 10px\" data-ng-if=\"mapperController.currentPage == \'outputs\'\"><div data-ng-controller=\"MapInputOutputController as inOutController\" data-ng-repeat=\"(name, object) in selectedNode.outputs track by name\"><div class=\"mapObject\"><md-input-container class=\"halfWidth\"><label>{{::\'assemblyContextVariable\' | translate}}</label><input apim-context-variable data-ng-model=\"object.variable\" data-ng-model-options=\"{debounce:200}\"></md-input-container><md-input-container class=\"halfWidth\"><label>{{::\"assemblyMapName\" | translate}}</label><input data-ng-model=\"$outputName\" data-ng-model-options=\"{getterSetter: true, updateOn: \'blur\'}\"></md-input-container><div style=\"width: 88px\"></div></div><div class=\"mapObject\"><div class=\"halfWidth\"><label style=\"padding-left: 3px\" for=\"$id + \'_outputType\'\">{{::\"assemblyContentType\" | translate}}</label><apim-combobox style=\"font-weight: bold\" id=\"$id + \'_outputType\'\" item-list=\"inOutController.contentTypes\" selection=\"contentType\"></apim-combobox></div><md-input-container class=\"halfWidth\"><label for=\"$id + \'_definition\'\">{{::\'assemblyDefinition\' | translate}}</label><md-select required data-ng-model=\"selectedDefinition\"><md-option data-ng-repeat=\"definition in definitions\" data-ng-value=\"definition.value || definition.name\">{{definition.name}}</md-option></md-select></md-input-container><button style=\"margin: 10px\" data-ng-show=\"selectedDefinition == \'inline\'\" class=\"iconOnlyButton material-icons\" data-ng-click=\"inOutController.launchInlineEditor()\" title=\"{{::\'assembly_edit_inline_definition\' | translate}}\">code</button><div style=\"width: 44px\" data-ng-show=\"selectedDefinition !== \'inline\'\"></div><button style=\"margin: 10px\" class=\"iconOnlyButton material-icons\" data-ng-click=\"mapperController.removeOutput(name)\" title=\"{{::\'assemblyRemoveOutput\' | translate}}\">delete</button></div></div><div><button data-ng-click=\"mapperController.addOutput()\" title=\"{{::\'assemblyAddOutputTitle\' | translate}}\">{{::\'assemblyAddOutputTitle\' | translate}}</button><md-menu><md-button ng-click=\"$mdOpenMenu($event);\" title=\"{{::\'assemblyAddOutputsTitle\' | translate}}\">{{::\'assemblyAddOutputsTitle\' | translate}}</md-button><md-menu-content><md-menu-item data-ng-repeat=\"operation in swaggerOperations\"><span data-ng-if=\"operation.operationId\" data-ng-click=\"mapperController.addOutputsForOperation(operation);\">{{operation.operationId}}</span> <span data-ng-if=\"!operation.operationId\" data-ng-click=\"mapperController.addOutputsForOperation(operation);\">{{operation.verb}} {{operation.path}}</span></md-menu-item></md-menu-content></md-menu><button style=\"float: right\" data-ng-click=\"mapperController.switchToMap();\" title=\"{{::\'assemblyDone\' | translate}}\">{{::\'assemblyDone\' | translate}}</button><div class=\"clearBoth\"></div></div></div><div style=\"margin: 10px\" data-ng-if=\"mapperController.currentPage == \'options\'\"><md-input-container><label>{{::\"assemblyTitle\" | translate}}</label><input data-ng-model=\"selectedNode.title\" data-ng-model-options=\"{debounce:200}\"></md-input-container><md-input-container style=\"flex: 0.7\"><label>{{::\"assemblyDescription\" | translate}}</label><textarea data-ng-model=\"selectedNode.description\" data-ng-model-options=\"{debounce:200}\"></textarea></md-input-container><label style=\"display: block; margin: 20px 0 10px 0\">{{::\"assemblerMapperConfigureXML\" | translate}}</label><div><md-checkbox md-no-ink aria-label=\"{{::\'assemblerMapperIncludeEmpty\' | translate}}\" data-ng-model=\"includeEmptyXMLElements\" data-ng-model-options=\"{\'getterSetter\': true}\" class=\"flex40 md-primary\"><span>{{::\"assemblerMapperIncludeEmpty\" | translate}}</span><label style=\"display: block\">{{::\"assemblerMapperIncludeEmptyDesc\" | translate}}</label></md-checkbox></div><div><md-checkbox md-no-ink aria-label=\"{{::\'assemblerMapperNamespaceInheritance\' | translate}}\" data-ng-model=\"namespaceInheritance\" data-ng-model-options=\"{\'getterSetter\': true}\" class=\"flex40 md-primary\"><span>{{::\"assemblerMapperNamespaceInheritance\" | translate}}</span><label style=\"display: block\">{{::\"assemblerMapperNamespaceInheritanceDesc\" | translate}}</label></md-checkbox></div><div><md-checkbox md-no-ink aria-label=\"{{::\'assemblerMapperNamespaceInlining\' | translate}}\" data-ng-model=\"inlineNamespaces\" data-ng-model-options=\"{\'getterSetter\': true}\" class=\"flex40 md-primary\"><span>{{::\"assemblerMapperNamespaceInlining\" | translate}}</span><label style=\"display: block\">{{::\"assemblerMapperNamespaceInliningDesc\" | translate}}</label></md-checkbox></div><button style=\"float: right\" data-ng-click=\"mapperController.switchToMap();\" title=\"{{::\'assemblyDone\' | translate}}\">{{::\'assemblyDone\' | translate}}</button><div class=\"clearBoth\"></div></div></fieldset></div>");
$templateCache.put("src/html/policies/switch.html","<div data-ng-controller=\"SwitchController as ctrl\" class=\"infoSection\"><fieldset data-ng-disabled=\"selectedNode.$$readOnly || selectedNode.$$parentReadOnly\"><div class=\"switch\"><md-input-container><label>{{::\"assemblyTitle\" | translate}}</label><input data-ng-model=\"selectedNode.title\" data-ng-model-options=\"{debounce:200}\"></md-input-container><md-input-container><label>{{::\"assemblyDescription\" | translate}}</label><textarea data-ng-model=\"selectedNode.description\" data-ng-model-options=\"{debounce:200}\"></textarea></md-input-container><div class=\"switchCase\" data-ng-repeat=\"case in selectedNode.case\" data-ng-controller=\"CaseController as caseCtrl\"><span><div><span class=\"caseIcon\"></span> <span data-ng-if=\"!case.otherwise\" style=\"margin-right: 10px; line-height: 49px; font-size: 1.2em; min-width: 70px\">{{::\'assemblyCase\' | translate}} {{$index}}</span> <span data-ng-if=\"case.otherwise\" style=\"margin-right: 10px; line-height: 49px; font-size: 1.2em; min-width: 70px\">{{::\'assemblyOtherwise\' | translate}}</span></div><div><button style=\"margin: 0px\" class=\"iconOnlyButton material-icons\" data-ng-click=\"ctrl.removeCase($index)\" title=\"{{::\'assemblyRemoveCase\' | translate}}\">delete</button> <button style=\"margin: 0px\" data-ng-if=\"caseCtrl.canMoveUp($index);\" class=\"iconOnlyButton material-icons\" data-ng-click=\"ctrl.moveUp($index)\" title=\"{{::\'assemblyMoveUp\' | translate}}\">arrow_upward</button> <button style=\"margin: 0px\" data-ng-if=\"caseCtrl.canMoveDown($index);\" class=\"iconOnlyButton material-icons\" data-ng-click=\"ctrl.moveDown($index)\" title=\"{{::\'assemblyMoveDown\' | translate}}\">arrow_downward</button></div></span><span class=\"conditionContent\" data-ng-if=\"!case.otherwise && (!case.condition || highLevelExpression)\"><md-chips style=\"display: inline-block; vertical-align: middle; margin-right: 0px; width: calc(100% - 10px)\" data-ng-model=\"chips\" md-autocomplete-snap md-require-match=\"true\"><md-autocomplete md-min-length=\"0\" md-search-text=\"caseCtrl.searchText\" md-no-cache=\"true\" md-items=\"operation in caseCtrl.filter()\" placeholder=\"{{::\'assemblySearchOperations\' | translate}}\"><md-item-template><span data-ng-if=\"operation.operationId\" md-highlight-text=\"caseCtrl.searchText\">{{operation.operationId}}</span> <span data-ng-if=\"operation.verb\" md-highlight-text=\"caseCtrl.searchText\">{{operation.verb.toUpperCase()}} {{operation.path}}</span></md-item-template></md-autocomplete><md-chip-template><span data-ng-if=\"$chip.operationId\">{{$chip.operationId}}</span> <span data-ng-if=\"$chip.verb && $chip.path\">{{$chip.verb.toUpperCase()}} {{$chip.path}}</span></md-chip-template></md-chips><div style=\"margin: 10px\">{{::\'assemblyOr\' | translate}} <a data-ng-click=\"caseCtrl.launchExpressionEditor()\">{{::\'assemblyLaunchExpressionEditor\' | translate}}</a></div></span><span class=\"conditionContent\" data-ng-if=\"!case.otherwise && !highLevelExpression\"><md-input-container><label>{{::\"assemblyExpression\" | translate}}</label><textarea class=\"expressionTextArea\" data-ng-model=\"case.condition\" data-ng-model-options=\"{debounce:1000}\"></textarea></md-input-container><div data-ng-show=\"!selectedNode.$$readOnly && !selectedNode.$$parentReadOnly\" style=\"margin: 10px\"><a data-ng-click=\"caseCtrl.launchExpressionEditor()\">{{::\'assemblyLaunchExpressionEditor\' | translate}}</a></div></span></div><button style=\"margin: 10px\" data-ng-click=\"ctrl.addCase()\" title=\"{{::\'assemblyAddCaseTitle\' | translate}}\">{{::\'assemblyAddCase\' | translate}}</button> <button style=\"margin: 10px\" data-ng-show=\"!hasOtherwise();\" data-ng-click=\"ctrl.addOtherwise()\" title=\"{{::\'assemblyAddOtherwise\' | translate}}\">{{::\'assemblyAddOtherwise\' | translate}}</button></div></fieldset></div>");
$templateCache.put("src/html/policies/throw.html","<div class=\"infoSection\"><fieldset data-ng-disabled=\"selectedNode.$$readOnly || selectedNode.$$parentReadOnly\"><md-input-container><label>{{::\"assemblyTitle\" | translate}}</label><input data-ng-model=\"selectedNode.title\" data-ng-model-options=\"{debounce:200}\"></md-input-container><md-input-container><label>{{::\"policy.throw.property.name.label\" | translate}}</label><input data-ng-model=\"selectedNode[\'name\']\" data-ng-model-options=\"{debounce:200}\"><div class=\"assemblyDescription\">{{::\"policy.throw.property.name.description\" | translate}}</div></md-input-container><md-input-container><label>{{::\"policy.throw.property.message.label\" | translate}}</label><textarea data-ng-model=\"selectedNode[\'message\']\" data-ng-model-options=\"{debounce:200}\">\n			<div class=\"assemblyDescription\">{{::\"policy.throw.property.message.description\" | translate}}</div>\n		</md-input-container>\n	</fieldset>\n</div>");
$templateCache.put("src/html/mapper-schema/add-property.html","<div class=\"inner addProperty\" data-ng-controller=\"AddPropertyController\"><div style=\"margin-left: 17px\" data-ng-click=\"addProp = true;\" data-ng-show=\"!isArray && !addProp\">{{::\'assembly_add_property\' | translate}}</div><div style=\"margin-left: 17px\" data-ng-click=\"addProp = true;\" data-ng-show=\"isArray && !addProp\">{{::\'assembly_add_item\' | translate}}</div><div style=\"margin-left: 17px; display: flex; line-height: 15px\" data-ng-show=\"addProp\"><md-input-container md-no-float data-ng-show=\"!isArray\" style=\"flex: 0.6; margin-right: 10px; margin-top: -6px\"><input type=\"text\" placeholder=\"{{::\'assembly_add_property_placeholder\' | translate}}\" data-ng-model=\"propertyName\"></md-input-container><md-select style=\"flex: 0.4; margin: 0 10px 0 0;height: 25px\" required aria-label=\"::{{\'type\' | translate}}\" data-ng-model=\"propertyType\"><md-option data-ng-repeat=\"(definitionName, definition) in ::basicTypes\" data-ng-value=\"definitionName\">{{definitionName}}</md-option></md-select><button class=\"iconOnlyButton material-icons\" style=\"line-height: 30px\" data-ng-disabled=\"!isArray && !propertyName\" data-ng-click=\"addProperty();\" title=\"{{::\'add\' | translate}}\">add_circle_outline</button> <button class=\"iconOnlyButton material-icons\" style=\"margin-right: 5px; line-height: 30px\" data-ng-click=\"addProp = false;\" title=\"{{::\'cancel\' | translate}}\">delete</button></div></div>");
$templateCache.put("src/html/mapper-schema/discriminator.html","<div class=\"inner\"><div class=\"discriminator\"><label>{{::\'assemblyDiscriminatorType\' | translate}}</label><md-select aria-label=\"{{::\'assemblyDiscriminatorSelect\' | translate}}\" data-ng-model=\"$discriminatorType\" data-ng-model-options=\"{getterSetter: true}\"><md-option md-option-empty value=\"\">{{::\'none\' | translate}}</md-option><md-option data-ng-repeat=\"extendedType in ::schema.$$extendingTypes\" data-ng-value=\"getUniqueTypeName(extendedType)\">{{getUniqueTypeName(extendedType)}}</md-option></md-select></div></div>");
$templateCache.put("src/html/mapper-schema/enum.html","<div class=\"inner enums\" ng-if=\"!isCollapsed && schema.enum\"><b>Enum:</b><json-formatter class=\"inner\" json=\"schema.enum\" open=\"open\"></json-formatter></div>");
$templateCache.put("src/html/mapper-schema/json-schema-view.html","<div class=\"json-schema-view mapper-schema-path\" ng-class=\"{\'collapsed\': isCollapsed, \'mapper-schema-container\': !isPrimitive && !isRoot}\" data-ng-attr-path=\"{{::getPath()}}\" data-ng-attr-dimensions=\"{{::getDimensionArray()}}\" data-ng-attr-container=\"{{::getContainer()}}\" data-ng-attr-type=\"{{schema.type}}\"><div class=\"primitive\" ng-if=\"isPrimitive\"><span data-ng-if=\"schema.title || schema.$$title || name\" class=\"name\">{{schema.title || schema.$$title || name}}</span> <span class=\"type\">{{schema.type}}</span> <span class=\"required\" ng-if=\"isRequired(schema)\">*</span> <span class=\"format\" ng-if=\"!isCollapsed && schema.format\">({{schema.format}})</span> <span class=\"range minimum\" ng-if=\"!isCollapsed && schema.minimum\">minimum:{{schema.minimum}}</span> <span class=\"range exclusiveMinimum\" ng-if=\"!isCollapsed && schema.exclusiveMinimum\">(ex)minimum:{{schema.exclusiveMinimum}}</span> <span class=\"range maximum\" ng-if=\"!isCollapsed && schema.maximum\">maximum:{{schema.maximum}}</span> <span class=\"range exclusiveMaximum\" ng-if=\"!isCollapsed && schema.exclusiveMaximum\">(ex)maximum:{{schema.exclusiveMaximum}}</span> <span class=\"range minLength\" ng-if=\"!isCollapsed && schema.minLength\">minLength:{{schema.minLength}}</span> <span class=\"range maxLength\" ng-if=\"!isCollapsed && schema.maxLength\">maxLength:{{schema.maxLength}}</span><div class=\"inner description\">{{schema.description}}</div><div ng-include=\"\'src/html/mapper-schema/enum.html\'\" ng-if=\"!isCollapsed && schema.enum\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"!isCollapsed && schema.allOf\" onload=\"type = \'allOf\'\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"!isCollapsed && schema.anyOf\" onload=\"type = \'anyOf\'\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"!isCollapsed && schema.oneOf\" onload=\"type = \'oneOf\'\"></div><button data-ng-if=\"!isRoot && schemaEditable\" class=\"iconOnlyButton material-icons\" data-ng-click=\"deleteProperty();\" title=\"{{::\'delete\' | translate}}\">delete</button></div><div ng-if=\"isArray\" class=\"array\"><a class=\"title\"><span class=\"toggle-handle\" ng-click=\"toggle()\"></span><span data-ng-if=\"schema.title || schema.$$title || name\" class=\"name\">{{schema.title || schema.$$title || name}}</span><span class=\"extender\" data-ng-if=\"schema.$$extender\">{{schema.$$extender}}</span><span class=\"opening bracket\">[</span><span class=\"closing bracket\" ng-if=\"isCollapsed\">]</span> <button data-ng-if=\"!isRoot && schemaEditable\" class=\"iconOnlyButton material-icons\" data-ng-click=\"deleteProperty();\" title=\"{{::\'delete\' | translate}}\">delete</button></a><div class=\"inner\"><div class=\"description\">{{schema.description}}</div><apic-mapper-schema root=\"false\" editable=\"schemaEditable\" data-ng-class=\"{\'array-container\': propertyIsArray(schema.items), \'object-container\': propertyIsObject(schema.items)}\" schema=\"schema.items\" parent-schema=\"schema\" open=\"open - 1\" definitions=\"definitions\" references=\"references\" data-ng-if=\"!isCollapsed && schema.items\"></apic-mapper-schema></div><div ng-include=\"\'src/html/mapper-schema/enum.html\'\" ng-if=\"!isCollapsed && schema.enum\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"schema.allOf\" onload=\"type = \'allOf\'\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"schema.anyOf\" onload=\"type = \'anyOf\'\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"schema.oneOf\" onload=\"type = \'oneOf\'\"></div><div data-ng-include=\"\'src/html/mapper-schema/add-property.html\'\" onload=\"isArray = true\" data-ng-if=\"!isCollapsed && schemaEditable && !schema.items\"></div><span class=\"closing bracket\" style=\"padding-left: 17px\" a ng-if=\"!isCollapsed\">]</span></div><div ng-if=\"!isPrimitive && !isArray\" class=\"object\"><a class=\"title\"><span class=\"toggle-handle\" ng-click=\"toggle()\"></span><span data-ng-if=\"schema.title || schema.$$title || name\" class=\"name\">{{schema.title || schema.$$title || name}}</span><span class=\"extender\" data-ng-if=\"schema.$$extender\">{{schema.$$extender}}</span><span class=\"opening brace\">{</span><span class=\"closing brace\" ng-if=\"isCollapsed\">}</span> <button data-ng-if=\"!isRoot && schemaEditable\" class=\"iconOnlyButton material-icons\" data-ng-click=\"deleteProperty();\" title=\"{{::\'delete\' | translate}}\">delete</button></a><div class=\"inner\"><div class=\"description\">{{schema.description}}</div><div class=\"property\" ng-repeat=\"(propertyName, property) in schema.properties\" data-ng-if=\"showProperty(propertyName)\" data-ng-controller=\"SchemaPropertyController as propCtrl\"><apic-mapper-schema root=\"false\" editable=\"schemaEditable\" data-ng-class=\"{\'array-container\': propertyIsArray, \'object-container\': propertyIsObject}\" schema=\"property\" parent-schema=\"schema\" name=\"propertyName\" open=\"open - 1\" definitions=\"definitions\" references=\"references\"></apic-mapper-schema></div></div><div data-ng-include=\"\'src/html/mapper-schema/discriminator.html\'\" data-ng-if=\"!isCollapsed && schema.$$extendingTypes && isDiscriminator\"></div><div ng-include=\"\'src/html/mapper-schema/enum.html\'\" ng-if=\"!isCollapsed && schema.enum\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"!isCollapsed && schema.allOf\" onload=\"type = \'allOf\'\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"!isCollapsed && schema.anyOf\" onload=\"type = \'anyOf\'\"></div><div ng-include=\"\'src/html/mapper-schema/x_of.html\'\" ng-if=\"!isCollapsed && schema.oneOf\" onload=\"type = \'oneOf\'\"></div><div data-ng-include=\"\'src/html/mapper-schema/add-property.html\'\" data-ng-if=\"!isCollapsed && schemaEditable\"></div><span class=\"closing brace\" style=\"padding-left: 17px\" ng-if=\"!isCollapsed\">}</span></div></div>");
$templateCache.put("src/html/mapper-schema/x_of.html","<div class=\"inner\"><div class=\"xOf\" style=\"margin-left: 14px\">{{convertXOf(type)}}:</div><div class=\"inner\" ng-repeat=\"subSchema in schema[type]\"><apic-mapper-schema root=\"false\" editable=\"schemaEditable\" open=\"open - 1\" schema=\"subSchema\" parent-schema=\"schema\" definitions=\"definitions\" references=\"references\"></apic-mapper-schema></div></div>");}]);