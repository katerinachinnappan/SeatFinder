/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly').factory('SchemaReferences', function () {

    var self = this;

    function findExtendingTypesHelper(refToMatch, definitions, matches, parentTypes) {
    	Object.keys(definitions).forEach(function(definitionName) {
    		var definition = definitions[definitionName];
    		if (!definition.allOf) return false;
    		var filtered = definition.allOf.filter(function(allOfSchema) {
    			return (allOfSchema.$ref === refToMatch);
    		});
    		if (filtered.length > 0) {
    			if (!matches[definitionName]) {
        			var prunedDefinition = angular.copy(definition);
        			// strip out the matching allOf
        			prunedDefinition.allOf = prunedDefinition.allOf.filter(function(allOfSchema) {
        				if (allOfSchema.$ref !== refToMatch) {
        					allOfSchema.$$extender = definitionName;
        					allOfSchema.$$extendedType = definition["x-xsi-type"];
        					allOfSchema.$$extendedParents = parentTypes;
        					return true;
        				}
        				return false;
        			});
        			matches[definitionName] = prunedDefinition;
        			// check for any nested sub-types
    				var lastSlash = refToMatch.lastIndexOf("/");
    				var coreRef = refToMatch.substring(0, lastSlash + 1);
        			var subTypeRef = coreRef + definitionName;
        			var parentSubTypes = {
        					parentTypes: parentTypes,
        					types: []
        			};
        			parentSubTypes.types = parentSubTypes.types.concat(prunedDefinition.allOf);
   					findExtendingTypesHelper(subTypeRef, definitions, matches, parentSubTypes);
    			}
    		}
    	});
    };

    /*
    * Insert referenced schema in place of $ref, where the definitions have been provided
    */
    function findExtendingTypes(schema, definitions) {
    	if (!schema.$ref) {
    		return;
    	}
    	var refToMatch = schema.$ref;
    	var matchingDefinitions = {};
    	if (definitions.definitions) {
    		findExtendingTypesHelper(refToMatch, definitions.definitions, matchingDefinitions, null);
    	}
    	if (definitions['x-ibm-configuration'] && definitions['x-ibm-configuration'].targets) {
    		Object.keys(definitions['x-ibm-configuration'].targets).forEach(function(targetName) {
    			var target = definitions['x-ibm-configuration'].targets[targetName];
    			if (target.definitions) {
    				findExtendingTypesHelper(refToMatch, target.definitions, matchingDefinitions, null);
    			}
    		});
    	}
    	return matchingDefinitions;
    };

    function findRef(ref, definitions, references) {
    	if (references && references[ref]) {
    		return angular.copy(references[ref]);
    	}
    	var sections = ref.split("/");
    	var theSchema = definitions;
    	for (var i = 1; i < sections.length; i++) {
    		theSchema = theSchema[sections[i]];
    		if (!theSchema) return;
    	}
    	var refSchema = angular.copy(theSchema);
    	if (refSchema.properties) {
    		Object.keys(refSchema.properties).forEach(function(propertyName) {
    			refSchema.properties[propertyName].name = propertyName;
    		});
    	}
    	return refSchema;
    };

    /*
    * Insert referenced schema in place of $ref, where the definitions have been provided
    */
    self.unwindRefs = function(schema, definitions, references) {
    	if (!schema || !definitions) {
    		return;
    	}

    	// is it already unwound?
    	if (schema.$$unwound) return;
    	schema.$$unwound = true;

    	if (schema.allOf) {
    		schema.allOf.forEach(function(allOfSchema) {
    			self.unwindRefs(allOfSchema, definitions, references);
    		});
    	}
    	if (schema.anyOf) {
    		schema.anyOf.forEach(function(anyOfSchema) {
    			self.unwindRefs(anyOfSchema, definitions, references);
    		});
    	}
    	if (schema.oneOf) {
    		schema.oneOf.forEach(function(oneOfSchema) {
    			self.unwindRefs(oneOfSchema, definitions, references);
    		});
    	}
    	if (schema.items) {
    		self.unwindRefs(schema.items, definitions, references);
    	}
    	if (schema.$ref) {
    		var refSchema = findRef(schema.$ref, definitions, references);
    		if (refSchema) angular.extend(schema, refSchema);
    	}

    	// now handle discriminators
    	if (schema.discriminator || schema['x-ibm-discriminator']) {
    		// we're a base type - we need to find any extending types
    		var matches = findExtendingTypes(schema, definitions);
    		var extendingTypes = [];
    		if (matches) {
        		Object.keys(matches).forEach(function(definitionName) {
        			extendingTypes.push(matches[definitionName]);
        		});
    		}
    		if (extendingTypes.length > 0) {
    			schema.$$extendingTypes = extendingTypes;
    			// now we've listed the extending types, do we need to add
    			// an x-ibm-discriminator field to the target schema?
    			if (schema['x-ibm-discriminator'] && schema.type === 'object') {
    				if (!schema.properties) schema.properties = {};
    				schema.properties['x-ibm-discriminator'] = {
    						type: 'string'
    				};
					}
					// now make sure that all these schema are valid extensions
					if (!schema.allOf) {
						schema.allOf = [];
					}
    			schema.$$extendingTypes.forEach(function(extendingType) {
						schema.allOf = schema.allOf.concat(extendingType.allOf);
					});
    		} else {
    			schema.$$extendingTypes = [];
    		}
    	}
    };

    function propertyExistsInSchema(property, schema, definitions, references, keepDiscriminator) {
      self.unwindRefs(schema, definitions, references);

      // have we matched the whole thing?
      // properties may themselves contain "." characters...
      var fullPath = property.join(".");
      var title = schema.title || schema.name || schema.$$title;
      if (title) {
        if (title === fullPath) {
          return true;
        }

        // perhaps we're array-mapping a non-repeating type...
        title += ".$item";
        if (title === fullPath) {
          return true;
        }
      }

      // else match parts
      title = schema.title || schema.name || schema.$$title;
			// if we are in the right object, or if the object itself is untitled
			// either due to a missing title or it's use as an anonymous array item
      if ((title === property[0]) || !title || property[0] === '$item') {
        if (property.length === 1) return true;
        // look through properties, which may contain "."
        if (schema.properties) {
          var x = 1;
          var propertySegment = property[x];
          while (x < property.length) {
            x++;
            if (keepDiscriminator && schema["x-ibm-discriminator"]) {
            	return true;
            }
            if (schema.properties[propertySegment]) {
              return propertyExistsInSchema([propertySegment].concat(property.slice(x)), schema.properties[propertySegment], definitions, references, keepDiscriminator);
            }
            // maybe we're looking at an attribute?
            if (propertySegment.indexOf('@') === 0) {
              var attributeName = propertySegment.substring(1);
              if (schema.properties[attributeName] && schema.properties[attributeName].xml &&
              schema.properties[attributeName].xml.attribute === true) {
                return true;
              }
            }
            propertySegment += "." + property[x];
          }
        }
        if (schema.items) {
          if (property[1] === "$item") return true;
          property[0] = "$item";
          return propertyExistsInSchema(property, schema.items, definitions, references, keepDiscriminator);
        }
        if (schema.allOf || schema.anyOf || schema.oneOf) {
          var schemaArray = schema.allOf || schema.anyOf || schema.oneOf;
          for (var i = 0; i < schemaArray.length; i++) {
            if (propertyExistsInSchema(property, schemaArray[i], definitions, references, keepDiscriminator)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    self.propertyExistsInSchemas = function(property, schemas, definitions, keepDiscriminator) {
      if (property.indexOf("#/") === 0) {
          // this is an absolute reference - strip it off
          property = property.substring(2);
      }
      for (var i = 0; i < schemas.length; i++) {
        if (propertyExistsInSchema(property.split(/\\?\./), schemas[i], definitions, null, keepDiscriminator)) return true;
      }
      return false;
    };

    return self;
});
