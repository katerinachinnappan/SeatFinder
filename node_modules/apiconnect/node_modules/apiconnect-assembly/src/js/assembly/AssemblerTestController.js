/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

// Node module: apiconnect-assembly

'use strict';

angular.module('apiconnect-assembly-test', ['apiconnect-assembly']).controller('AssemblerTestController', ['$scope', '$rootScope', '$q', '$filter', '$http', 'Product', 'Gateway', 'ProductUtil', 'DeployedProduct', 'ProviderApp', 'ProviderAppSubscription', 'TestCallGenerator', 'SwaggerOAuth', 'AssemblerTracking', 'GatewayCluster', function($scope, $rootScope, $q, $filter, $http, Product, Gateway, ProductUtil, DeployedProduct, ProviderApp, ProviderAppSubscription, TestCallGenerator, SwaggerOAuth, AssemblerTracking, GatewayCluster) {

	var self = this;

	$scope.environments = $rootScope.environments;
	$scope.publishTargets = $rootScope.publishTargets;
	$scope.matchingGwServices = [];

	$scope.offlineMode = $rootScope.offlineMode;

	if (!$scope.offlineMode) {
		$scope.dataPowerGateways = GatewayCluster.query();

		$q.all([$scope.dataPowerGateways.$promise]).then(function(){
			$scope.gateways = $scope.dataPowerGateways;
			self.restoreSetup(); // Run setup once gateways have loaded
		});
	}

	$scope.scopes = {};
	$scope.authToken = {};

	// auto-transition from setup to test on first load
	$scope.autoTransition = true;

	if ($scope.offlineMode) {
		$scope.clientId = "default";
		$scope.clientSecret = "SECRET";
	}
	$scope.$watch('application', function() {
		if ($scope.application && $scope.application.credentials) {
			$scope.clientId = $scope.application.credentials.clientID;
		}
	});

	// set up defaults
	$scope.currentPage = ($rootScope.offlineMode) ? 2 : 1;
	$scope.repeater = {
		repeat: false,
		count: 10,
		stopOnError: true
	};

	$scope.$on('api_is_dirty', function(event, isDirty) {
		// if the new isDirty flag given here is the same as the one we already have, then we don't need to do anything
		if (isDirty === $scope.apiDirty) {
		    return;
		}

		$scope.apiDirty = isDirty;

		if (!isDirty) {
			// API has been saved...
			$scope.saveSinceLastPublish = true;


			// if we've already got a request for the gateways in flight, let's not make another call
			if ($scope.secureGateways && $scope.secureGateways.$promise && $scope.secureGateways.$resolved === false) {
				return;
			}

			// after the API has been saved, check the swagger and see if the API needs a secure gateway
			self.secureGatewaySetup();

			// if the API needs a secure gateway, get secure gateways, and set the page back to 1
			if($scope.secureGatewayDeploymentInfo.length > 0) {
				$scope.secureGateways = Gateway.query({
					orgId: $rootScope.orgId
				});

				$scope.secureGateways.$promise.then(function() {
					self.setCurrentPage(1);
				});
			}
		}
	});

	$scope.testLoaded = $rootScope.offlineMode;

	self.restoreSetup = function() {
		if ($scope.offlineMode) { return; }
		if (!$scope.gateways) { return; } // If gateways aren't loaded yet.

		if (typeof localStorage === "undefined") { return; }

		// target
		var target = localStorage.getItem('apim.test.target');
		if (target) {
			target = angular.fromJson(target);
			var matchingTargets = $scope.publishTargets.filter(function(candidateTarget) {
				return (candidateTarget.environmentId === target.environmentId && candidateTarget.spaceId === target.spaceId);
			});
			if (matchingTargets.length > 0) {
				$scope.target = matchingTargets[0];
				var matchingCatalogs = $scope.environments.filter(function(environment) {
					return (environment.id === $scope.target.environmentId);
				});
				if (matchingCatalogs.length > 0 ) {
					$scope.catalog = matchingCatalogs[0];
				}
			} else {
				if ($scope.publishTargets.length > 0 ) {
					$scope.target = $scope.publishTargets[0];
					self.targetChange();				
				} else {
					$scope.target = null;
					self.targetChange();
				}
				
			}
		} else {
			$scope.target = $scope.publishTargets[0];
			self.targetChange();
		}

		// gateway
		self.gwServiceChange();

		// product
		var productId = localStorage.getItem('apim.test.product');
		if (productId) {
			var sections = productId.split(':');
			var matchingProducts = $scope.products.filter(function(product) {
				return (product.info.name === sections[0] && product.info.version === sections[1]);
			});
			if (matchingProducts.length > 0) {
				$scope.product = matchingProducts[0];
				$scope.productContainsApi = ProductUtil.containsApi($scope.product, $scope.swaggerDocument);
			}
		}

		// product
		var planName = localStorage.getItem('apim.test.plan');
		if ($scope.product && planName && $scope.product.plans[planName]) { $scope.plan = planName; }

		// application
		var appId = localStorage.getItem('apim.test.application');
		if (appId) {
			$scope.$watch('applications', function() {
				if (!$scope.applications) { return; }
				var matchingApps = $scope.applications.filter(function(application) {
					return (application.id === appId);
				});
				if (matchingApps.length > 0) {
					$scope.application = matchingApps[0];
					if ($scope.secureGatewayDeploymentInfo.length === 0 && $scope.target && $scope.product && $scope.plan) {
						if ($scope.autoTransition) { $scope.currentPage = 2; }
					}
				}
			});
		}

		// if we have a target and product selected, and either:
		// the catalog has a test app enabled, or
		// we have both a plan and an application selected...
		// start on the test page, not the setup page
		if ($scope.secureGatewayDeploymentInfo.length === 0 && $scope.target && $scope.product && ($scope.catalog.testAppEnabled || ($scope.plan && $scope.application))) {
			if ($scope.autoTransition) { $scope.currentPage = 2; }
		}

		$scope.testLoaded = true;
	};

	self.secureGatewaySetup = function() {
		$scope.needSecureGatewaySetup = false;
		$scope.secureGatewayDeploymentInfo = [];

		if ($scope.offlineMode) { return; }

		var config = $scope.swaggerDocument[$scope.config.property];

		if (!config) { return; }

		var assembly = config.assembly;

		if (!assembly) { return; }

		var execute = assembly.execute || [];

		for(var i = 0; i < execute.length; i++) {
			var secureGatewayInfo = {
				gateway: '',
				apiId: $scope.swaggerDocument.info["x-ibm-name"] + ":" + $scope.swaggerDocument.info.version,
				spaceGUID: $rootScope.bluemixExternalSpaceId,
				orgGUID: $rootScope.bluemixExternalOrgId
			};

			if(execute[i].hasOwnProperty('invoke') && execute[i].invoke['secure-gateway']) {
				secureGatewayInfo.destination = execute[i].invoke['target-url'];
				$scope.secureGatewayDeploymentInfo.push(secureGatewayInfo);
				$scope.needSecureGatewaySetup = true;
			} else if(execute[i].hasOwnProperty('proxy') && execute[i].proxy['secure-gateway']) {
				secureGatewayInfo.destination = execute[i].proxy['target-url'];
				$scope.secureGatewayDeploymentInfo.push(secureGatewayInfo);
				$scope.needSecureGatewaySetup = true;
			}
		}
	};

	self.setCurrentPage = function(page) {
		$scope.currentPage = page;

		if (page === 1 && $scope.target.spaceId) { // Reset test environment when going back to page 1 with spaces enabled
			$scope.selectedOperation = undefined;
			$scope.operation = undefined;
			$scope.response = undefined;
		}
		if (page === 3) {
			$scope.setTestMode(true, true);
		} else {
			$scope.setTestMode(true, false);
		}
		$scope.autoTransition = false;
		if (page === 2) {
			self.updateConfig();
		}
	};

    // I'm sorry
    function getScopes() {
        if (!$scope.scopes) return [];
        var selectedScopes = [];
        Object.keys($scope.scopes).forEach(function(scope) {
            if ($scope.scopes[scope]) selectedScopes.push(scope);
        });
        return selectedScopes;
    };

	// check security requirements
	self.updateConfig = function() {
		if (!$scope.operation) return;
		self.config = TestCallGenerator.getConfigurationForOperation($scope.operation, $scope.path, $scope.swaggerDocument, $scope.securityFlow);
		// pre-select all scopes
		if (self.config.oauthScopes) {
			self.config.oauthScopes.forEach(function(scope) {
				$scope.scopes[scope] = true;
			});
		}

		// send debug header for assembly when not in offline mode
		self.config.sendDebugHeader = !$scope.offlineMode;
	};

	self.config = {};
	$scope.updateConfigForOperation = function() {
		if ($scope.selectedOperation) {
			$scope.setOperationFilter($scope.selectedOperation);
			var operationRef = $scope.selectedOperation;
			if (typeof $scope.selectedOperation === "string") { operationRef = $scope.operationMap[$scope.selectedOperation]; }
			if ($scope.selectedOperation.operationId) { operationRef = $scope.operationMap[$scope.selectedOperation.operationId]; }
			$scope.operationRef = operationRef;
			var operation = $scope.swaggerDocument.paths[operationRef.path][operationRef.verb];

			$scope.operation = operation;

			$scope.path = $scope.swaggerDocument.paths[operationRef.path];

			if ($scope.swaggerDocument.schemes) {
				$scope.schemes = $scope.swaggerDocument.schemes;
			} else {
				$scope.schemes = ["https"];
			}
			$scope.scheme = $scope.schemes[0];

			var defaultHost = localStorage.getItem('apim_local_gateway');
			if (!defaultHost) { defaultHost = $scope.scheme + "://localhost:4001"; }

			var baseUrl = "";
			
			// if this is unenforced, try to use the host field
			if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].enforced === false) {
				baseUrl = ($scope.swaggerDocument.host) ? $scope.scheme + "://" + $scope.swaggerDocument.host : defaultHost;
			} else if ($scope.catalog && $scope.catalog.gwServices && $scope.catalog.gwServices.length > 0) {
				if (!$scope.gwServiceTarget) { // No spaces / gateways, use default
					baseUrl = $scope.catalog.gwServices[0].endpointUrl;
				}
				else {
					// Find gateway service id given gateway service Name
					var gwServiceTargetId;
					$scope.gateways.forEach(function(candidateGateway) {
						if (candidateGateway.name === $scope.gwServiceTarget) {
							gwServiceTargetId = candidateGateway.id;
						}
					});

					// Find gateway endpointUrl given gateway service id
					$scope.catalog.gwServices.forEach(function(candidateService) {
						if (candidateService.id === gwServiceTargetId) {
							baseUrl = candidateService.endpointUrl;
						}
					});
				}
			} else if ($scope.catalog && $scope.catalog.customBaseUrl) {
				baseUrl = $scope.catalog.customBaseUrl;
			} else if ($scope.catalog && $scope.catalog.baseUrl) {
				baseUrl = $scope.catalog.baseUrl;
			} else {
				baseUrl = defaultHost;
			}

			var urlSuffix = $scope.swaggerDocument.basePath;
			if (!urlSuffix) { urlSuffix = "/"; }
			if (_.endsWith(urlSuffix, "/") && _.startsWith(operationRef.path, "/")) {
				urlSuffix = urlSuffix.substring(0, urlSuffix.length - 1) + operationRef.path;
			} else {
				urlSuffix += operationRef.path;
			}
			var targetUrlTemplate = baseUrl + urlSuffix;

			// is this SOAP? if so, ditch the operationId from the end...
			if ($scope.operation['x-ibm-soap'] && $scope.operation.operationId && _.endsWith(targetUrlTemplate, "/" + $scope.operation.operationId)) {
				targetUrlTemplate = targetUrlTemplate.substring(0, targetUrlTemplate.length - ($scope.operation.operationId.length + 1));
			}

			$scope.targetUrlTemplate = targetUrlTemplate;

			self.updateConfig();

			// seed scopes if required
			if (self.config.requiresOauth && self.config.oauthScopes) {
				$scope.scopes = self.config.oauthScopes;
			}
		}
	};

	$scope.$watch('selectedOperation', $scope.updateConfigForOperation);
	$scope.$watch('securityFlow', self.updateConfig);

	self.invoke = function() {
		TestCallGenerator.invoke($scope, self.config, $scope.repeater);
	};
	
	$scope.setAuthToken = function(data) {
		$scope.authToken = data;
	};

	$scope.setAuthCode = function(data) {
		$scope.authCode = data;
	};

	$scope.setAuthError = function(error) {
		$scope.authError = error;
	};

	$scope.clearAuthError = function() {
		delete $scope.authError;
	};


    self.authorize = function() {
        var scopes = getScopes();
        $scope.clearAuthError();
        SwaggerOAuth.authorize(self.config, $scope.clientId, $scope.clientSecret, scopes, $scope.username, $scope.password, $scope.redirectUri).then(function(response) {
          angular.extend($scope.authToken, response.data);
        }, function(error) {
          $scope.setAuthError(error);
        });
    };

    self.getToken = function() {
        var scopes = getScopes();
		$scope.clearAuthError();
        SwaggerOAuth.getToken(self.config, $scope.authToken, $scope.clientId, $scope.clientSecret, scopes, $scope.redirectUri).then(function(response) {
            angular.extend($scope.authToken, response.data);
        }, function(error) {
			$scope.setAuthError(error);
        });
    };

    self.refreshToken = function() {
		$scope.clearAuthError();
        SwaggerOAuth.refreshToken(self.config, $scope.authToken, $scope.clientId, $scope.clientSecret).then(function(data) {
            console.log(data);
        }, function(error) {
			$scope.setAuthError(error);
        });
    };

	var appsLoaded = false;
	var productsLoaded = false;

	self.refreshApps = function() {
		$scope.xhrProcessing = true;
		$scope.applications = ProviderApp.query({
			orgId: $rootScope.orgId,
			envId: $scope.catalog.id
		});
		$scope.applications.$promise.then(function() {
			$scope.xhrProcessing = false;
			appsLoaded = true;
			if (productsLoaded) { self.restoreSetup(); }
		});
	};

	$scope.$watch('catalog', function() {
		if (!$scope.catalog) { return; }
		if ($scope.catalog.testAppEnabled === true && $scope.catalog.testAppCredentials) {
			// we have test app credentials - further setup not required
			$scope.testAppCredentials = true;
			delete $scope.application;
			delete $scope.plan;
			$scope.clientId = $scope.catalog.testAppCredentials.clientId;
			$scope.clientSecret = $scope.catalog.testAppCredentials.clientSecret;
		} else {
			delete $scope.clientSecret;
			self.refreshApps();
			self.refreshDeployedProducts();
		}
	});

	self.refresh = function() {
		$scope.xhrProcessing = true;

		$scope.products = Product.query({orgId: $rootScope.orgId});

		$scope.products.$promise.then(function() {
			self.secureGatewaySetup();

			if($scope.secureGatewayDeploymentInfo.length > 0) {
				$scope.secureGateways = Gateway.query({
					orgId: $rootScope.orgId
				});

				return $scope.secureGateways.$promise;
			}
		}).then(function() {
			$scope.xhrProcessing = false;
			productsLoaded = true;
			self.restoreSetup();
		});
	};
	self.refresh();

	self.refreshDeployedProducts = function() {
		$scope.deployedProducts = DeployedProduct.query({
			orgId: $rootScope.orgId,
			envId: $scope.catalog.id
		});
	};

	self.createAndPublishProduct = function() {
		if ($scope.productName && $scope.target) {
			// #1 create a new product and plan containing this API
			var newProduct = {
				product: "1.0.0",
				info: {name: $rootScope.generateName($scope.productName), title: $scope.productName, version: "1.0.0"},
				apis: {},
				plans: {}
			};
			newProduct.apis[$scope.swaggerDocument.info["x-ibm-name"]] = {
				name: $scope.swaggerDocument.info["x-ibm-name"] + ":" + $scope.swaggerDocument.info.version
			};
			newProduct.plans['default'] = {
				title: $filter('translate')("product_default_plan_name")
			};
			var product = new Product(newProduct);
			$scope.creatingProduct = true;
			product.$create({orgId: $rootScope.orgId}).then(function(product) {
				$scope.product = product;
				AssemblerTracking.track('assembly', 'createdProduct');
				self.productChange();
				self.republishProduct();
			}, function() {
				$scope.creatingProduct = false;
			});
		}
	};

	self.republishProduct = function() {
		$scope.republishingProduct = true;
		var url = "";
		if ($scope.target.type === "SPACE") {
			url = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/spaces/' + $scope.target.spaceId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version;
		} else {
			url = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version;
		}
		$http.post(url)
			.success(function() {
				self.refreshDeployedProducts();
				var visibilityData = {};

				if ($scope.product.visibility) {
					visibilityData = {
						visibility: $scope.product.visibility
					};
				} else {
					visibilityData = {
						visibility: {
							view: {
								enabled: true,
								type: "public"
							},
							subscribe: {
								enabled: true,
								type: "authenticated"
							}
						}
					};
				}

				if($scope.secureGatewayDeploymentInfo.length > 0) {
					visibilityData.secureGatewayDeploymentInfo = $scope.secureGatewayDeploymentInfo;
				}

				var publishURL = "";

				if ($scope.target.type === "SPACE") {
					publishURL = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/spaces/' + $scope.target.spaceId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version + '/publish';
				} else {
					publishURL = 'proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/products/' + $scope.product.info.name + ':' + $scope.product.info.version + '/publish';
				}

				$http.post(publishURL, visibilityData).success(function() {
					$scope.republishingProduct = false;
					$scope.creatingProduct = false;
					$scope.saveSinceLastPublish = false;
					delete $scope.productNotPublished;
					AssemblerTracking.track('assembly', 'republishedProduct');
				}).error(function() {
					$scope.republishingProduct = false;
					$scope.creatingProduct = false;
					$scope.xhrProcessing = false;
					delete $scope.productNotPublished;
				});
			}).error(function() {
				$scope.creatingProduct = false;
				$scope.republishingProduct = false;
				$scope.xhrProcessing = false;
			});
	};

	self.addApiToProduct = function() {
		if (!$scope.product) { return; }
		var apiName = $scope.swaggerDocument.info['x-ibm-name'] || $scope.swaggerDocument.info.title;
		if (!$scope.product.apis) { $scope.product.apis = {}; }
		var suffix = 1;
		var apiNameBase = apiName;
		while($scope.product.apis[apiName]) {
			apiName = apiNameBase + "_" + suffix;
			suffix++;
		}
		$scope.product.apis[apiName] = {
			name: apiNameBase + ":" + $scope.swaggerDocument.info.version
		};
		// do we need to explicitly add it to the plan?
		if ($scope.product.plans[$scope.plan] && !_.isEmpty($scope.product.plans[$scope.plan].apis)) {
			// yes we do...
			$scope.product.plans[$scope.plan].apis[apiName] = {};
		}
		$scope.republishingProduct = true;
		$scope.product.$save({
			orgId: $rootScope.orgId,
			productVersion: $scope.product.info.name + ":" + $scope.product.info.version
		}).then(function() {
			$scope.republishingProduct = false;
			$scope.productContainsApi = true;
		}, function() {
			$scope.republishingProduct = false;
			$scope.productContainsApi = true;
		});
	};

	self.createAndSubscribeApp = function() {
		if (!$scope.appName) { return; }
		$scope.creatingApp = true;
		$http.post('proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/providerApps', {name: $scope.appName})
			.success(function(app) {
				$scope.application = app;
				$scope.applicationCreated = true;
				self.applicationChange();
				self.subscribeApp();
			}).error(function() {
				$scope.creatingApp = false;
			});
	};

	self.subscribeApp = function() {
		if (!$scope.application) { return; }
		$scope.subscribingApp = true;
		var deployedProduct = $scope.deployedProducts.filter(function(product) {
			return (product.productName === $scope.product.info.name && product.productVersion === $scope.product.info.version);
		});
		if (deployedProduct.length < 1) {
			$scope.productNotPublished = true;
			$scope.subscribingApp = false;
			return;
		}
		var planURL = deployedProduct[0].url + "/plans/" + $scope.plan;
		$http.post('proxy/orgs/' + $rootScope.orgId + '/environments/' + $scope.target.environmentId + '/providerApps/' + $scope.application.id + '/subscriptions',
			{planURL: planURL})
			.success(function() {
				$scope.creatingApp = false;
				$scope.subscribingApp = false;
			}).error(function() {
				$scope.creatingApp = false;
				$scope.subscribingApp = false;
			});
	};

	self.targetChange = function() {
		if (!$scope.target) { return; }
		if (typeof localStorage === "undefined") { return; }
		$scope.catalog = $scope.environments.filter(function(environment) {
			return (environment.id === $scope.target.environmentId);
		})[0];
		localStorage.setItem('apim.test.target', angular.toJson($scope.target));

		self.gwServiceChange(true);
	};

	self.gwServiceChange = function(targetChanged) {
		if ($scope.offlineMode) { return; }
		if (!$scope.target) { return; }
		if (typeof localStorage === "undefined") { return; }
		if (!$scope.target.spaceId) { return; } // When no spaces are present

		var matchingSpace = $scope.catalog.spaces.filter(function(candidateSpace) {
			return (candidateSpace.id === $scope.target.spaceId);
		});

		if (targetChanged || $scope.matchingGwServices.length === 0) {
			$scope.matchingGwServices = [];

			var services = matchingSpace[0].gwServices;

			if (!services) { // No service assigned to space
				$scope.gwServiceTarget = "";
				return;
			}

			services.forEach(function(service) {
				$scope.gateways.forEach(function(candidateGateway) {
					if (candidateGateway.id === service) {
						$scope.matchingGwServices.push(candidateGateway); //Find matching services
					}
				});
			});

			$scope.gwServiceTarget = $scope.matchingGwServices[0].name; //Auto select first gateway service
		}
	};

	self.secureGatewayDeploymentInfoChange = function() {
		if (!$scope.secureGatewayDeploymentInfo) { return; }

		var numberOfGatewaysNotAssigned = 0;

		for(var i = 0; i < $scope.secureGatewayDeploymentInfo.length; i++) {
			if($scope.secureGatewayDeploymentInfo[i].gateway.length === 0) {
				numberOfGatewaysNotAssigned++;
			}
		}

		if(numberOfGatewaysNotAssigned === 0) {
			$scope.needSecureGatewaySetup = false;
		}
	};

	self.productChange = function() {
		if (!$scope.product) { return; }
		// default the plan to the first in the product
		var plans = Object.keys($scope.product.plans);
		if (plans.length > 0) {
			$scope.plan = plans[0];
			self.planChange();
		}
		delete $scope.productNotPublished;
		$scope.productContainsApi = ProductUtil.containsApi($scope.product, $scope.swaggerDocument);
		if (typeof localStorage === "undefined") { return; }
		localStorage.setItem('apim.test.product', $scope.product.info.name + ':' + $scope.product.info.version);
	};

	self.planChange = function() {
		if (!$scope.plan) { return; }
		if (typeof localStorage === "undefined") { return; }
		localStorage.setItem('apim.test.plan', $scope.plan);
	};

	self.applicationChange = function() {
		if (!$scope.application) { return; }
		if (typeof localStorage === "undefined") { return; }
		localStorage.setItem('apim.test.application', $scope.application.id);
		$scope.clientId = $scope.application.credentials.clientID;
	};

	self.operationChange = function() {
		if (!$scope.selectedOperation) { return; }
		if (typeof localStorage === "undefined") { return; }
		$scope.parameterValues = {};
		localStorage.setItem('apim.test.operation', $scope.selectedOperation.verb + ' ' + $scope.selectedOperation.path);
	};

	self.loadDebugData = function() {
		delete $scope.debugData;
		if (!$scope.response || !$scope.response.transactionId) {return; }
		$scope.loadingDebugData = true;
		$http.get("proxy/orgs/" + $rootScope.orgId + '/analytics/query?eventType=apievent&fields=ALL&size=1000&sort=datetime&timeRange=QUARTER&timeZoneOffset=0&queryString=debug.transid:"' + $scope.response.transactionId + '"').then(
			function(data) {
				$scope.loadingDebugData = false;
				if (data.data && data.data.hits && data.data.hits.length > 0 && data.data.hits[0].debug) {
					$scope.debugData = data.data.hits[0].debug;
				}
			},
			function() {
				$scope.loadingDebugData = false;
			}
		);
	};

	self.focusIndex = -1;
	self.previousPolicy = function() {
		if (self.focusIndex < 0) { return; }
		self.focusIndex--;
		if (self.focusIndex === -1) {
			$("apim-assembler")[0].focus();
		}
		if (self.focusIndex === 0) {
			$("apim-assembler .inputNode")[0].focus();
		}
		// else try to find the policy with the correct name...
		$("apim-assembler apim-node .policyName:contains(PROXY)").parent();
	};

	self.nextPolicy = function() {
		self.focusIndex++;
		if (self.focusIndex === 0) {
			$("apim-assembler .inputNode")[0].focus();
		}
	};

	function getDebugDataByName(name) {
		var filtered = $scope.debugData.filter(function(data) {
			return (data.name === name);
		});
		if (filtered.length > 0) { return filtered[0]; }
		return null;
	}

	self.showDebugForNode = function(event, node) {
		// try to tie the selected node to an entry in debug data
		var debugData;
		if (node === 'input') {
			debugData = getDebugDataByName('Request');
			if (!debugData) { debugData = getDebugDataByName('API Information'); }
		} else if (node === 'output') {
			debugData = getDebugDataByName('Response');
		} else {
			debugData = getDebugDataByName(node.$$type);
			// do something hacky for now
			if (node.title && node.title.toLowerCase().indexOf("proxy") > -1) {
				// probably a proxy then...
				debugData = getDebugDataByName("Assembly Proxy");
			}
		}
		if (debugData && debugData.name) {
			// scroll into view
			$scope.selectedDebugData = debugData;
			$("apim-assembly-test .testItemHeader:contains(" + debugData.name + ")")[0].scrollIntoView();
		}
	};

	$scope.$on('node-selected', self.showDebugForNode);

}]);

angular.module('apiconnect-assembly-test').controller('AssemblerTestParameterController', ['$scope', function($scope) {

	var self = this;

	$scope.canGenerate = true;
	if ($scope.parameter && $scope.parameter.format === "JSON") {
		// generator doesn't know this type...
		$scope.canGenerate = false;
	}
    if ($scope.parameter && $scope.parameter.type === "boolean") {
        // generating booleans isn't very valuable...
        $scope.canGenerate = false;
    }

	// take a copy of the schema so we can de-ref for display without touching the model
	if ($scope.parameter && $scope.parameter.schema) {
		$scope.schema = angular.copy($scope.parameter.schema);
		if ($scope.schema.example) { $scope.parameterValues[$scope.parameter.name] = $scope.schema.example; }
	}

	var path = ($scope.operationRef) ? $scope.operationRef.path : $scope.pathName;
	var verb = ($scope.operationRef) ? $scope.operationRef.verb : $scope.verb;

	self.generateExample = function() {
		$scope.parameterValues[$scope.parameter.name] = window.exampleGenerator.generateExampleParameter($scope.swaggerDocument, path, verb, $scope.parameter, $scope.contentTypeHeader);
	};

}]);

angular.module('apiconnect-assembly-test').controller('AssemblyTestDebugDataController', ['$scope', function($scope) {

	$scope.yamlValue = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.data)), {lineWidth: -1});;

}]);

