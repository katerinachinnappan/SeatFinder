/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

function mapperController($scope, $mdDialog, $timeout, translateFilter, resize, Path, Map, ExtensionType) {

  /*jshint validthis:true */
  var self = this;

  // unnamed item name
  self.unnamed = "$item";

  self.currentPage = "map";

  // set up a definitions array for the dropdowns
  var definitions = [
    {
      name: translateFilter('assembly_inline_definition'),
      value: 'inline'
    },
    {
      name: "integer",
      type: "integer",
      format: "int32"
    },{
      name: "long",
      type: "integer",
      format: "int64"
    },{
      name: "float",
      type: "number",
      format: "float"
    },{
      name: "double",
      type: "number",
      format: "double"
    },{
      name: "string",
      type: "string"
    },{
      name: "byte",
      type: "string",
      format: "byte"
    },{
      name: "binary",
      type: "string",
      format: "binary"
    },{
      name: "boolean",
      type: "boolean"
    },{
      name: "date",
      type: "string",
      format: "date"
    },{
      name: "dateTime",
      type: "string",
      format: "date-time"
    },{
      name: "password",
      type: "string",
      format: "password"
    },{
      name: "array",
      type: "array"
    },{
      name: "object",
      type: "object"
    }
  ];
  var schemas = [];
  if ($scope.swaggerDocument.definitions) {
    Object.keys($scope.swaggerDocument.definitions).forEach(function(definition) {
        definitions.push({name: "#/definitions/" + definition, value:  "#/definitions/" + definition});
    });
    schemas = Object.keys($scope.swaggerDocument.definitions);
    $scope.swaggerDefinitions = angular.copy($scope.swaggerDocument.definitions);
  }
  if ($scope.swaggerDocument['x-ibm-configuration'] && $scope.swaggerDocument['x-ibm-configuration'].targets) {
    Object.keys($scope.swaggerDocument['x-ibm-configuration'].targets).forEach(function(targetName) {
      var target = $scope.swaggerDocument['x-ibm-configuration'].targets[targetName];
      Object.keys(target.definitions).forEach(function(definition) {
        definitions.push({name: "#/" + targetName + "/definitions/" + definition, value: "#/x-ibm-configuration/targets/" + targetName + "/definitions/" + definition});
      });
    });
  }
  $scope.definitions = definitions;
  $scope.schemas = schemas;

  var backoffTime = 0;
  if (window.navigator && (/firefox/i.test(window.navigator.userAgent) || /AppleWebKit/i.test(window.navigator.userAgent))) {
    backoffTime = 1000;
  }

  $scope.includeEmptyXMLElements = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value) {
        if ($scope.selectedNode.options) {
          delete $scope.selectedNode.options.includeEmptyXMLElements;
        }
      } else {
        if (!$scope.selectedNode.options) {
          $scope.selectedNode.options = {};
        }
        $scope.selectedNode.options.includeEmptyXMLElements = false;
      }
    } else {
      // getter
      if (!$scope.selectedNode.options) return true;
      if (typeof $scope.selectedNode.options.includeEmptyXMLElements === "undefined") return true;
      return $scope.selectedNode.options.includeEmptyXMLElements;
    }
  };

  $scope.namespaceInheritance = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value) {
        if ($scope.selectedNode.options) {
          delete $scope.selectedNode.options.namespaceInheritance;
        }
      } else {
        if (!$scope.selectedNode.options) {
          $scope.selectedNode.options = {};
        }
        $scope.selectedNode.options.namespaceInheritance = false;
      }
    } else {
      // getter
      if (!$scope.selectedNode.options) return true;
      if (typeof $scope.selectedNode.options.namespaceInheritance === "undefined") return true;
      return $scope.selectedNode.options.namespaceInheritance;
    }
  };

  $scope.inlineNamespaces = function(value) {
    if (typeof value !== "undefined") {
      // setter
      if (value) {
        if ($scope.selectedNode.options) {
          delete $scope.selectedNode.options.inlineNamespaces;
        }
      } else {
        if (!$scope.selectedNode.options) {
          $scope.selectedNode.options = {};
        }
        $scope.selectedNode.options.inlineNamespaces = false;
      }
    } else {
      // getter
      if (!$scope.selectedNode.options) return true;
      if (typeof $scope.selectedNode.options.inlineNamespaces === "undefined") return true;
      return $scope.selectedNode.options.inlineNamespaces;
    }
  };

  $scope.$on('resize', function() {
    $timeout(self.constructCanvas, backoffTime);
  });

  $scope.markDirty = function() {
    $scope.$emit('mark_api_dirty');
  };

// seem to be unused...
  // $scope.inputSchemaName = "source";
  // $scope.outputSchemaName = "target";

  self.switchToMap = function() {
    self.currentPage = 'map';
    $timeout(self.constructCanvas, backoffTime);
  };

  self.addInput = function(inputName, schema, variable) {
    if (!schema) schema = {type: "object"};
    if (!variable) variable = "request.body";
    if (!inputName) inputName = "input";
    var rootName = inputName;
    var counter = 1;
    while ($scope.selectedNode.inputs.hasOwnProperty(inputName)) {
      inputName = rootName + "_" + counter++;
    }
    $scope.selectedNode.inputs[inputName] = {schema: schema, variable: variable};
  };

  self.addParametersForOperation = function(selectedOperation) {
    var parameters = [];

    var path = $scope.swaggerDocument.paths[selectedOperation.path];
    var operation = path[selectedOperation.verb];

    if (operation.parameters) parameters = parameters.concat(operation.parameters);
    if (path.parameters) parameters = parameters.concat(path.parameters);

    parameters.forEach(function(parameter) {
      var parameterName = parameter.name;
      if (parameter.$ref) {
        parameterName = parameter.$ref.replace("#/parameters/", "");
        parameter = $scope.swaggerDocument.parameters[parameterName];
      }
      var schema = (parameter.schema) ? parameter.schema : {type: parameter.type};
      var variable = (parameter.in === "body") ? "request.body" : (parameter.in === "header") ? "request.headers." + parameterName : "request.parameters." + parameterName;
      self.addInput(parameterName, schema, variable);
    });
  };

  self.addOutputsForOperation = function(selectedOperation) {
    var operation = $scope.swaggerDocument.paths[selectedOperation.path][selectedOperation.verb];

    var output = operation.responses["200"] || operation.responses["201"] || operation.responses["default"];
    if (!output) return;

    var schema = (output.schema) ? output.schema : {type: "object"};
    var variable = "message.body";
    self.addOutput("response", schema, variable);
  };

  self.addOutput = function(outputName, schema, variable) {
    if (!schema) schema = {type: "object"};
    if (!variable) variable = "message.body";
    if (!outputName) outputName = "output";
    var rootName = outputName;
    var counter = 1;
    while ($scope.selectedNode.outputs.hasOwnProperty(outputName)) {
      outputName = rootName + "_" + counter++;
    }
    $scope.selectedNode.outputs[outputName] = {schema: schema, variable: variable};
  };

  self.removeInput = function(inputName) {
    delete $scope.selectedNode.inputs[inputName];
  };

  self.removeOutput = function(outputName) {
    delete $scope.selectedNode.outputs[outputName];
  };

  var mapperConfig = {
    connectorRadius: 4,
    backOff: 4,
    indentFactor: 8,
    curveFactor: 0.3
  };

  var currentLine = null;
  var currentGroup = null;
  var currentInput = null;
  var currentMapping = null;
  var mappings = [];
  var automappable = true;
  var initialScrollOffsetLeft = 0;
  var scrollOffsetLeft = 0;
  var initialScrollOffsetRight = 0;
  var scrollOffsetRight = 0;

  self.updateModelActions = function(actions) {
    $scope.selectedNode.actions = actions;
  };

  $scope.map = new Map($scope.selectedNode, $scope.swaggerDocument, self.updateModelActions);

  self.showTargetDetails = function(target) {
    //$scope.selectedTargetNode = target;
    var targetPath = $scope.paths[target.connectorPath];
    var mapping = $scope.map.getMappingForPath(targetPath);
    var valueType = targetPath.type;

    $mdDialog.show({
      controller: 'TargetConnectorController',
      flex: "50",
      backdrop: 'static',
      keyboard: false,
      templateUrl: 'src/html/target-connector.html',
      parent: angular.element(document.body),
      focusOnOpen: false,
      locals: {
        mapping: mapping,
        target: target,
        paths: $scope.paths,
        valueType: valueType
      }
    }).then(function(response) {

      var responseDefault = '' + response.default;

      if (response.remove === true || (_.isEmpty(response.from) && _.isEmpty(response.value) && _.isEmpty(responseDefault) && !response.emptyString)) {
        $scope.map.deleteMappingForPath(targetPath);
        $scope.markDirty();
      } else {
        // we're creating or modifying the mapping
        if (!mapping) {
          $scope.map.setMappingForPath(targetPath);
          $scope.markDirty();
          mapping = $scope.map.getMappingForPath(targetPath);
        }
        if (!response.from || response.from.length === 0) {
          delete mapping.source;
        } else {
          mapping.source = response.from;
        }
      }

      if (response.value) {
        mapping.value = response.value;
      } else {
        delete mapping.value;
      }
      
      if (response.foreach) {
        mapping.foreach = response.foreach;
      } else if (response.from) {
        // only clear out foreach if the mapping hasn't
        // 1) got a foreach defined, and
        // 2) got sources defined
        // no sources means implicit iteration
        delete mapping.foreach;
      }

      if (response.default !== undefined) {
        if (response.valueType) {
          switch (response.valueType) {
            case 'boolean':
              responseDefault = responseDefault.toLowerCase();
              // only convert boolean values
              if (responseDefault === 'true' || responseDefault === 'false') {
                responseDefault = (responseDefault === 'true');
              }
              break;
            case 'number':
            case 'integer':
              var aNumber = Number(responseDefault);
              // only convert number values
              if (isFinite(aNumber)) {
                responseDefault = aNumber;
              }
              break;
          }
        }

        mapping.default = responseDefault;
      } else {
        delete mapping.default;
      }

      if (response.merge) {
        mapping.merge = true;
      } else {
        delete mapping.merge;
      }

      self.updateModelActions($scope.map.getActions());

      $timeout(self.constructCanvas, backoffTime);
    });
  };

  $scope.paths = {};
  ExtensionType.setHandler($scope);

  function constructInputNodes(cssRule, cssClass, connectorNodeData, clickZoneData) {
    var yOffset = 40; // allow for column headers
    var mappableInputs = $(cssRule);
    var i, position, height, parent, item;
    for (i = 0; i < mappableInputs.length; i++) {
      var input = $(cssRule + ":nth(" + i + ")");
      position = input.position();
      if (position.top === 0 && position.left === 0) {
        // this signifies a collapsed input - do not render any connectors
        continue;
      }
      height = input.height();
      $scope.paths[input.attr("path")] = new Path(input.attr("path"), input.attr("dimensions"), input.attr("container"), input.attr("type"));
      var containerAdjust = 0;
      // if (input.hasClass('mapper-schema-container')) containerAdjust = -24;
      connectorNodeData.push({
        "cx": mapperConfig.connectorRadius * 2,
        "cy": position.top - yOffset + containerAdjust + 12,
        "radius": mapperConfig.connectorRadius,
        "class": (input.hasClass("collapsed")) ? "collapsed-" + cssClass : cssClass,
        "connectorPath": $scope.paths[input.attr("path")].getPath(),
        "connectorDimension": $scope.paths[input.attr("path")].getDimensionality(),
        "connectorParent": parent,
        "connectorItem": item
      });
      if (clickZoneData) {
        clickZoneData.push({
          "width": 30,
          "height": 20,
          "x": 0,
          "y": position.top - yOffset + containerAdjust + 2,
          "class": "click-zone-input",
          "connectorPath": $scope.paths[input.attr("path")].getPath(),
          "connectorDimension": $scope.paths[input.attr("path")].getDimensionality(),
          "connectorParent": parent,
          "connectorItem": item,
          "position": "input"
        });
      }
    }
  };

  function constructOutputNodes(cssRule, cssClass, connectorNodeData, clickZoneData) {
    var yOffset = 40; // allow for column headers
    var canvas = $("svg.mapper-canvas");
    var mappableTargets = $(cssRule);
    var i, position, height, target, className;
    for (i = 0; i < mappableTargets.length; i++) {
      target = $(cssRule + ":nth(" + i + ")");
      position = target.position();
      if (position.top === 0 && position.left === 0) {
        // this signifies a collapsed input - do not render any connectors
        continue;
      }
      height = target.height();
      $scope.paths[target.attr("path")] = new Path(target.attr("path"), target.attr("dimensions"), target.attr("container"), target.attr("type"));
      className = cssClass;
      if ($scope.map.hasMapping($scope.paths[target.attr("path")])) className += " mapped";
      var containerAdjust = 0;
      // if (target.hasClass('mapper-schema-container')) containerAdjust = -24;
      connectorNodeData.push({
        "cx": canvas.width() - mapperConfig.connectorRadius * 2,
        "cy": position.top - yOffset + containerAdjust + 12,
        "radius": mapperConfig.connectorRadius,
        "class":  (target.hasClass("collapsed")) ? "collapsed-" + className : className,
        "connectorPath": $scope.paths[target.attr("path")].getPath(),
        "connectorDimension": $scope.paths[target.attr("path")].getDimensionality()
      });
      if (clickZoneData) {
        clickZoneData.push({
          "width": 30,
          "height": 20,
          "x": canvas.width() - 30,
          "y": position.top - yOffset + containerAdjust + 2,
          "class": "click-zone-output",
          "connectorPath": $scope.paths[target.attr("path")].getPath(),
          "connectorDimension": $scope.paths[target.attr("path")].getDimensionality(),
          "position": "output"
        });
      }
    }
  };

  function selectMapping(e, targetPath) {
      d3.event.stopPropagation();
      if (currentMapping) currentMapping.attr("class", currentMapping.attr("class").replace(" mapper-group-selected", ""));
      e.attr("class", e.attr("class") + " mapper-group-selected");
      currentMapping = e;

      var thisMapping = mappings.filter(function(mapping) {
          return (mapping.target === targetPath);
      });
      if (thisMapping.length > 0 && thisMapping[0].config && thisMapping[0].config.fn) {
          $(".mapper-function textarea")[0].value = thisMapping[0].config.fn;
          $(".mapper-function textarea")[0].connectorPath = targetPath;
      }
  }

  function createPath(startX, startY, endX, endY, connectorPath, isCollapsed) {
      // safety first - string safety
      startX = startX * 1;
      startY = startY * 1;
      endX = endX * 1;
      endY = endY * 1;

      // offset tracking
      if (scrollOffsetLeft > 0) startY -= scrollOffsetLeft;
      // add back in any scroll offset we started with
      if (initialScrollOffsetLeft > 0) startY += initialScrollOffsetLeft;
      // nuance here... if we're given a connector path, that means we've completed a mapping,
      // which means we're trying to connect the line to a circle (which might be offset due to scrolling).
      // If not, we're freeform drawing and don't yet care about offsets
      if (connectorPath && scrollOffsetRight > 0) endY -= scrollOffsetRight;
      // add back in any scroll offset we started with
      if (connectorPath && initialScrollOffsetRight > 0) endY += initialScrollOffsetRight;

      // back the line off from the connector centre
      startX += (mapperConfig.connectorRadius / 2) + 2;
      endX -= (mapperConfig.connectorRadius / 2) + 2;

      // calculate an indent relative to the lines X-length
      // indentLeft must = width / 2 when endX = width
      // add 5% to the left indent. Without this, a map from
      // top left to bottom right
      // will curve off on the right while still within the
      // zone of the function, and look weird
      var indentRight = ((endX - startX) / 2) + ((endX - startX) * 0.05);
      var indentLeft = mapperConfig.curveFactor * (endX - startX);
      var pathString = "M " + endX + " " + endY;

      // draw the curve
      pathString += "L " + (endX - indentRight) + " " + endY;
      pathString += "C " + (endX - indentLeft - indentRight) + " " + endY;
      pathString += " " + (startX + indentLeft) + " " + startY;
      pathString += " " + startX + " " + startY;

      // create the shape
      if (!currentGroup) {
          // create a new group
          var canvas = d3.select("svg.mapper-canvas");
          currentGroup = canvas.append("g");
          currentGroup.attr("class", "mapper-group");
      }
      if (!currentLine) {
          // create a new line
          currentLine = currentGroup.insert("path", ".function-node");
          if (isCollapsed) {
            currentLine.attr("class", "collapsed-mapper-line");
          } else {
            currentLine.attr("class", "mapper-line");
          }
      }
      currentLine.attr("d", pathString);
      if (connectorPath) {
          // line is complete and has a target
          var scopedGroup = currentGroup;
          currentLine.attr("connectorPath", connectorPath);
          currentLine.on("click", function() {
              selectMapping(scopedGroup, connectorPath);
          });
      }
  }

  function restoreMap() {
    var model = $scope.map.getModel();
    var targetConnectors = d3.selectAll("circle.output-node");
    var targetCollapsedConnectors = d3.selectAll("circle.collapsed-output-node");
    var sourceConnectors = d3.selectAll("circle.input-node");
    var sourceCollapsedConnectors = d3.selectAll("circle.collapsed-input-node");
    var targets, sources, targetPath;
    model.forEach(function(mapping) {
      // mappings do not have to have a source...
      if (!mapping.source) return;
      // target doesn't exist (illegal action like in apiconnect-assembly/#416)
      if (!mapping.target) return;
      // find the best target match
      var targetCollapsed = false;
      targets = targetConnectors.filter(function(targetConnector) {
        return (targetConnector.connectorPath === mapping.target ||
                targetConnector.connectorPath + ".$item" === mapping.target ||
                targetConnector.connectorPath === mapping.target + ".$item");
      }).data();
      if (targets.length === 0) {
        targetCollapsed = true;
        // find the most relevant collapsed node
        var targetConnectorSections = mapping.target.split(".");
        while (targets.length === 0 && targetConnectorSections.length > 0) {
          targetPath = targetConnectorSections.join(".");
          targets = targetCollapsedConnectors.filter(function(targetConnector) {
            return (targetConnector.connectorPath === targetPath ||
                targetConnector.connectorPath + ".$item" === targetPath ||
                targetConnector.connectorPath === targetPath + ".$item");
          }).data();
          targetConnectorSections.pop();
        }
      }
      mapping.source.forEach(function(sourcePath) {
        // find the best source match
        var sourceCollapsed = false;
        // handle absolute paths
        if (sourcePath.indexOf("#/") === 0) sourcePath = sourcePath.substring(2);
        sources = sourceConnectors.filter(function(item) {
          return (item.connectorPath === sourcePath ||
            item.connectorPath + ".$item" === sourcePath ||
            item.connectorPath === sourcePath + ".$item");
        }).data();
        if (sources.length === 0) {
          sourceCollapsed = true;
          // find the most relevant collapsed node
          var sourceConnectorSections = sourcePath.split(".");
          while (sources.length === 0 && sourceConnectorSections.length > 0) {
            sourcePath = sourceConnectorSections.join(".");
            sources = sourceCollapsedConnectors.filter(function(sourceConnector) {
              return (sourceConnector.connectorPath === sourcePath ||
                sourceConnector.connectorPath + ".$item" === sourcePath ||
                sourceConnector.connectorPath === sourcePath + ".$item");
            }).data();
            sourceConnectorSections.pop();
          }
        }
        sources.forEach(function(source) {
          targets.forEach(function(target) {
            createPath(source.cx, source.cy, target.cx, target.cy, target.connectorPath, sourceCollapsed || targetCollapsed);
            currentLine = null;
          });
        });
      });
    });
  };

  function restoreMapFromModel() {
    var svgContainer = d3.select("svg.mapper-canvas");
    // restore stored mappings
    svgContainer.selectAll("g").remove();

    restoreMap();
    currentGroup = null;
  };

  function canvasMouseUp() {
    if ($scope.map.readOnly) return;
    if (currentGroup && currentInput) {
        // we're mapping
        var canvas = $("svg.mapper-canvas");
        canvas.unbind("mousemove");
        currentGroup.remove();
    };
    currentLine = null;
    currentGroup = null;
    currentInput = null;
    currentMapping = null;
  }

  var isFF = (window.navigator && /firefox/i.test(window.navigator.userAgent));
  // var isSafari = (window.navigator && /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent));
  function trackMouse(e) {
      var offsetX = e.offsetX;
      var offsetY = e.offsetY;
      if (e.target && e.target.nodeName !== "svg") {
        var position = e.target.getAttribute('position');
        if (position === 'input') {
          //offsetY += (initialScrollOffsetLeft - scrollOffsetLeft);
        } else if (position === 'output') {
          // offsetY += (initialScrollOffsetRight - scrollOffsetRight);
        }
        if (isFF) {
          // firefox defines offsets relative to the event target rather than the absolute parent
          offsetX += (1 * e.target.getAttribute('x'));
          offsetY += (1 * e.target.getAttribute('y'));
        }
      }
      createPath(8, currentInput.y + 10, offsetX - mapperConfig.backOff, offsetY);
  }

  function connectorMouseUp(e) {
    // allow click events - mouse down & mouse up on same element
    d3.event.stopPropagation();
    if (currentInput === e) return;
    if ($scope.map.readOnly) return;
    var canvas = $("svg.mapper-canvas");
    if (e.class === "output-node" || e.class === "click-zone-output" ||
      e.class === "output-node mapped" || e.class === "click-zone-output mapped") {
      // if we aren't mapping, show the target details dialog
      if (!currentInput || !currentGroup) {
          self.showTargetDetails(e);
          return;
      }
      // otherwise add the new mapping
      var sourcePath = $scope.paths[currentInput.connectorPath];
      var targetPath = $scope.paths[e.connectorPath];
      $scope.map.setMappingForPath(targetPath, sourcePath);
      $scope.markDirty();
      $scope.$apply();
      createPath(8, currentInput.y + 10, 192, e.y + 10, e.connectorPath);

      // ensure the connector node now has the mapped class
      $(".output-node:not(.mapped)").filter(function(index, node) { return node.getAttribute('connectorPath') === e.connectorPath; }).attr('class', 'output-node mapped');

      // user has started to interact with the map - let's not do anything annoying with automapping now
      automappable = false;

      canvas.unbind('mousemove');
      currentLine = null;
      currentGroup = null;
      currentInput = null;

      restoreMapFromModel();
    }
  };

  function connectorMouseDown(e) {
    // allow click events - mouse down & mouse up on same element
    if (currentInput === e) return;
    d3.event.stopPropagation();
    if ($scope.map.readOnly) return;
    var canvas = $("svg.mapper-canvas");
    if (e.class === "input-node" || e.class === "click-zone-input") {
      if (currentGroup) {
          // flow through - we're cancelling the existing mapping and starting a new one
          // but we'll just keep using this line to make life easy
      }
      currentInput = e;
      canvas.bind('mousemove', trackMouse);
    }
  };

  // scrolling functions - allow the user to scroll the left and right panes independently,
  // and transform the central mapping panel. This allows mapping from the bottom of a long
  // list on the left, to the top on the right (for example)
  function transformLeftNodes() {
    scrollOffsetLeft = $(".mapper-inputs-container")[0].scrollTop;
    // console.log(scrollOffsetLeft);
    d3.selectAll(".input-node").attr("transform", "translate(0, " + (0 - scrollOffsetLeft + initialScrollOffsetLeft) + ")");
    d3.selectAll(".collapsed-input-node").attr("transform", "translate(0, " + (0 - scrollOffsetLeft + initialScrollOffsetLeft) + ")");
    d3.selectAll(".click-zone-input").attr("transform", "translate(0, " + (0 - scrollOffsetLeft + initialScrollOffsetLeft) + ")");
  }

  function scrollLeft() {
    transformLeftNodes();
    restoreMapFromModel();
  }

  function transformRightNodes() {
    scrollOffsetRight = $(".mapper-outputs-container")[0].scrollTop;
    d3.selectAll(".output-node").attr("transform", "translate(0, " + (0 - scrollOffsetRight + initialScrollOffsetRight) + ")");
    d3.selectAll(".collapsed-output-node").attr("transform", "translate(0, " + (0 - scrollOffsetRight + initialScrollOffsetRight) + ")");
    d3.selectAll(".click-zone-output").attr("transform", "translate(0, " + (0 - scrollOffsetRight + initialScrollOffsetRight) + ")");
  }

  function scrollRight() {
    transformRightNodes();
    restoreMapFromModel();
  }

  // function scrollToTop() {
  //   $(".mapper-inputs-container")[0].scrollTop = 0;
  //   scrollOffsetLeft = 0;
  //   $(".mapper-outputs-container")[0].scrollTop = 0;
  //   scrollOffsetRight = 0;
  // }

  // end scrolling functions

  self.eventsBound = false;
  self.constructCanvas = function(forceClear) {
    if (self.currentPage !== 'map') return;

    // when constructing the canvas, we need to record the initial left and right scroll offsets
    // then we can adjust the rendered heights of the input nodes and wires for the life of the canvas
    var inputsContainer = $(".mapper-inputs-container")[0];
    var outputsContainer = $(".mapper-outputs-container")[0];
    if (!inputsContainer || !outputsContainer) return;
    initialScrollOffsetLeft = (inputsContainer) ? inputsContainer.scrollTop : 0;
    initialScrollOffsetRight = (outputsContainer) ? outputsContainer.scrollTop : 0;

    // listen for scroll events
    if (!self.eventsBound) {
      $(".mapper-inputs-container").on("scroll", _.throttle(scrollLeft, 100, {leading: true}));
      $(".mapper-outputs-container").on("scroll", _.throttle(scrollRight, 100, {leading: true}));
    }

    var canvas = $("svg.mapper-canvas");
    if (!self.eventsBound) {
      canvas.on("mouseup", canvasMouseUp);
    }
    self.eventsBound = true;
    var svgContainer = d3.select("svg.mapper-canvas");
    var connectorNodeData = [];
    var clickZoneData = [];

    constructInputNodes(".mapper-input-schema .mapper-schema-path", "input-node", connectorNodeData, clickZoneData);

    constructOutputNodes(".mapper-output-schema .mapper-schema-path", "output-node", connectorNodeData, clickZoneData);

    // now check that the model is consistent with the available inputs and outputs
    var saveDiscriminator = true;
    if (forceClear) {
    	saveDiscriminator = false;
    }

    if ($scope.map && $scope.inputSchemas && $scope.outputSchemas && !$scope.pruneDialog) {
      var unrecognized = $scope.map.pruneModel($scope.inputSchemas, $scope.outputSchemas, saveDiscriminator, true);
      if (unrecognized.length > 0) {
        // prompt the user if pruning should be performed
        $scope.pruneDialog = $mdDialog.show({
          controller: 'PruneConfirmationController',
          flex: "50",
          backdrop: 'static',
          keyboard: false,
          templateUrl: 'src/html/confirmation-dialog.html',
          parent: angular.element(document.body),
          focusOnOpen: false,
          locals: {
            parentScope: $scope,
            saveDiscriminator: saveDiscriminator,
            unrecognized: unrecognized
          }
        });
      }
    }

    svgContainer.selectAll("circle").remove();
    var circles = svgContainer.selectAll("circle")
      .data(connectorNodeData)
      .enter()
      .append("circle");
    circles
      .attr("cx", function (d) { return d.cx; })
      .attr("cy", function (d) { return d.cy; })
      .attr("r", function (d) { return d.radius; })
      .attr("class", function (d) { return d.class; })
      .attr("connectorPath", function (d) { return d.connectorPath; });
    svgContainer.selectAll("rect").remove();
    var rects = svgContainer.selectAll("rect")
      .data(clickZoneData)
      .enter()
      .append("rect");
    rects
      .attr("x", function (d) { return d.x; })
      .attr("y", function (d) { return d.y; })
      .attr("width", function (d) { return d.width; })
      .attr("height", function (d) { return d.height; })
      .attr("class", function (d) { return d.class; })
      .attr("connectorPath", function (d) { return d.connectorPath; })
      .attr("position", function (d) { return d.position; })
      // .on("click", connectorClick)
      .on("mousedown", connectorMouseDown)
      .on("mouseup", connectorMouseUp);

      // TODO - offsets are being incorrectly applied... scrolling to top for now
    // // initialize and act on any current scroll offsets
    transformLeftNodes();
    transformRightNodes();

    restoreMapFromModel();
  };

  function getSchema(definition) {
    var schema;
    // var schema, shortName;
    // do we have an inline definition, a definition reference, or a basic type
    if (definition.properties || definition.items || definition.allOf) {
      // inline definition, so just use it as is
      schema = definition;
    } else if (definition.$ref) {
      // reference, just use it as is
      schema = definition;
      // definition
      // if (definition.$ref.indexOf("#/definitions/") === 0) {
      //   shortName = definition.$ref.replace("#/definitions/", "");
      //   schema = angular.copy($scope.swaggerDocument.definitions[shortName]);
      //   schema.$$ref = definition.$ref;
      //   if (!schema) return;
      // } else if (definition.$ref.indexOf("#/x-ibm-configuration/targets/") === 0) {
      //   shortName = definition.$ref.replace("#/x-ibm-configuration/targets/", "");
      //   var sections = shortName.split("/");
      //   if (sections.length < 3) return;
      //   var targets = $scope.swaggerDocument['x-ibm-configuration'].targets;
      //   if (!targets) return;
      //   var target = targets[sections[0]];
      //   if (!target) return;
      //   var targetDefs = target.definitions;
      //   if (!targetDefs) return;
      //   if (!targetDefs[sections[2]]) return;
      //   schema = angular.copy(targetDefs[sections[2]]);
      //   schema.$$ref = definition.$ref;
      // }
    } else if (definition.type) {
      // basic type
      // var schemas = $scope.definitions.filter(function(thisSchema) {
      //   return (thisSchema.name === definition.type);
      // });
      // if (schemas.length === 0) return;
      // schema = angular.copy(schemas[0]);
      definition.$$byref = true;
      schema = definition;
    }
    return schema;
  }

  function constructInputs(force) {
    if (!$scope.selectedNode.inputs) return;
    if (!force && self.currentPage === 'map' && $scope.inputSchemas) {
      // inputs aren't being added or removed in this view, so no need to re-generate
      return;
    }
    var inputSchemas = [];
    Object.keys($scope.selectedNode.inputs).forEach(function(input) {
      var definition = $scope.selectedNode.inputs[input].schema;
      var schema = getSchema(definition);
      if (!schema) return;
      // take a copy if this is a reference to avoid dereferencing it in the model
      schema = (schema.$ref) ? angular.copy(schema) : schema;
      schema.$$title = input;
      inputSchemas.push(schema);
    });
    $scope.inputSchemas = inputSchemas;
  }

  function constructOutputs(force) {
    if (!$scope.selectedNode.outputs) return;
    if (!force && self.currentPage === 'map' && $scope.outputSchemas) {
      // inputs aren't being added or removed in this view, so no need to re-generate
      return;
    }
    var outputSchemas = [];
    Object.keys($scope.selectedNode.outputs).forEach(function(output) {
      var definition = $scope.selectedNode.outputs[output].schema;
      var schema = getSchema(definition);
      if (!schema) return;
      // take a copy if this is a reference to avoid dereferencing it in the model
      schema = (schema.$ref) ? angular.copy(schema) : schema;
      schema.$$title = output;
      outputSchemas.push(schema);
    });
    $scope.outputSchemas = outputSchemas;
  }

  $scope.$on('input-output-modified', function() {
    constructInputs();
    constructOutputs();
  });

  $scope.$watch('inputSchemas', function() {
    $timeout(self.constructCanvas, backoffTime);
  });
  $scope.$watch('outputSchema', function() {
    $timeout(self.constructCanvas, backoffTime);
  });

  $scope.$watch('selectedNode.inputs', function() {
    constructInputs();
  }, true);
  $scope.$watch('selectedNode.outputs', function() {
    constructOutputs();
  }, true);

  $scope.$on('json-schema-view-property-collapsed', function() {
    $timeout(self.constructCanvas, backoffTime);
  });

  $scope.$on('json-schema-view-property-modified', function() {
    constructInputs(true);
    constructOutputs(true);
  });

  $scope.$on('json-schema-view-refresh', function(event, forceClear) {
	  $timeout(function() {
		  self.constructCanvas(forceClear);
	  }, backoffTime);
  });

  var hashKey;
  $scope.$watch('selectedNode.$$hashKey', function() {
    if (hashKey === $scope.selectedNode.$$hashKey) return;
    if (!hashKey) hashKey = $scope.selectedNode.$$hashKey;
    $timeout(function() {
      $scope.map = new Map($scope.selectedNode, $scope.swaggerDocument, self.updateModelActions);
      constructInputs(true);
      constructOutputs(true);
      self.constructCanvas();
    }, backoffTime);
  }, true);
};

angular.module('apiconnect-assembly').controller('MapperController', ['$scope', '$mdDialog', '$timeout', 'translateFilter', 'resize', 'Path', 'Map', 'ExtensionType', mapperController]);

function targetConnectorController($scope, $mdDialog, mapping, target, paths, valueType) {
  if (mapping && mapping.source) {
    $scope.sources = angular.copy(mapping.source);
  }

  $scope.valueType = valueType;

  $scope.merge = (mapping && mapping.merge === true) ? true : false;

  $scope.emptyString = (mapping && mapping.default === "") ? true : false;

  if (mapping) {
    if (mapping.default !== undefined) {
      $scope.default = mapping.default;
    }
  }

  if (mapping && mapping.value) {
    $scope.value = mapping.value;
  }

  // issue 411 - record the dimensionality of the target
  // this will be used to control whether or not to show users the merge checkbox
  // we can't rely on looking at source iterators here as there is an edge case
  // where the user is only setting a default value - no sources at all
  // instead, we should show the merge option for any connector with a positive
  // dimensionality
  $scope.mergeable = target.connectorDimension > 0;

  if (mapping && mapping.target) {
    $scope.target = mapping.target;
    var outputPath = paths[mapping.target];

    var foreach = {};
    if (outputPath.getDimensionality() > 0 && $scope.sources) {
      var dimensions = outputPath.dimensionality;
      dimensions.forEach(function(dimension) {
        foreach[dimension] = null;
      });
      if (mapping && mapping.foreach) {
        var sourceContext = "", targetContext = "";
        mapping.foreach.forEach(function(foreachObj) {
          foreach[targetContext + foreachObj.target] = sourceContext + foreachObj.source;
          sourceContext += foreachObj.source + ".";
          targetContext += foreachObj.target + ".";
        });
      }
      $scope.foreach = foreach;
    }
  }

  // allow iterating over any input property - not just array types
  var iterators = [];
  if ($scope.sources && $scope.sources.length > 0) {
    $scope.sources.forEach(function(inputPath) {
      if (!inputPath) return;
      var sections = inputPath.split(".");
      if (sections.length === 1) {
        iterators.push(sections[0]);
      } else {
        for (var i = 0; i < sections.length - 1; i++) {
          var section = sections.slice(0, i + 1).join(".");
          if (iterators.indexOf(section) < 0) iterators.push(section);
        }
      }
    });
  }
  if (iterators.length > 0) $scope.iterators = iterators;

  if (mapping) $scope.value = angular.copy(mapping.value);
  $scope.removeMapping = function(from) {
    $scope.sources = $scope.sources.filter(function(source) {
      return (from !== source);
    });
    if ($scope.sources.length === 0) delete $scope.sources;
  };
  $scope.removeStaticValue = function() {
    delete $scope.value;
  };
  $scope.deleteMapping = function() {
    $mdDialog.hide({
      remove: true
    });
  };
  $scope.updateModel = function() {
    var response = {
      from: $scope.sources,
      value: $scope.value,
      remove: $scope.remove
    };
    if ($scope.valueType) {
      response.valueType = $scope.valueType;
    }
    if ($scope.emptyString === true) {
      response.default = "";
      response.emptyString = $scope.emptyString;
    } else if ($scope.default !== undefined) {
      response.default = $scope.default;
    }
    if ($scope.merge === true) {
      response.merge = $scope.merge;
    }
    if ($scope.foreach) {
      response.foreach = [];
      var sourceContext = "", targetContext = "";
      Object.keys($scope.foreach).forEach(function(key) {
        if (!$scope.foreach[key]) return;
        response.foreach.push({
          target: key.replace(targetContext, ""),
          source: $scope.foreach[key].replace(sourceContext, "")
        });
        targetContext = key + ".";
        sourceContext = $scope.foreach[key] + ".";
      });
      if (response.foreach.length === 0) delete response.foreach;
    }
    $mdDialog.hide(response);
  };
  $scope.cancel = function() {
    $mdDialog.cancel();
  };
  $scope.aceLoaded = function(editor) {
	  editor.focus();
  };
}

angular.module('apiconnect-assembly').controller('TargetConnectorController', ['$scope', '$mdDialog', 'mapping', 'target', 'paths', 'valueType', targetConnectorController]);

function pruneConfirmationController($scope, $mdDialog, parentScope, saveDiscriminator, unrecognized) {
  $scope.unrecognized = unrecognized;
  $scope.prune = function() {
    parentScope.map.pruneModel(parentScope.inputSchemas, parentScope.outputSchemas, saveDiscriminator, false);
    $mdDialog.cancel();
    parentScope.pruneDialog = null;
    parentScope.$emit('json-schema-view-refresh', false);	// trigger canvas update
  };
  $scope.cancel = function() {
    $mdDialog.cancel();
    parentScope.pruneDialog = null;
  };
}

angular.module('apiconnect-assembly').controller('PruneConfirmationController', ['$scope', '$mdDialog', 'parentScope', 'saveDiscriminator', 'unrecognized', pruneConfirmationController]);

function MapInputOutputController($scope, $modal, translateFilter) {

  var self = this;

  if ($scope.object.schema) {
    if (_.isEmpty($scope.object.schema)) {
      $scope.selectedDefinition = "";
    } else if ($scope.object.schema.$ref) {
      $scope.selectedDefinition = $scope.object.schema.$ref;
    } else if ($scope.object.schema.type && !$scope.object.schema.items && !$scope.object.schema.properties && !$scope.object.schema.allOf) {
      $scope.selectedDefinition = $scope.object.schema.type;
    } else {
      $scope.selectedDefinition = 'inline';
    }
  }

  self.contentTypes = [{
    value: "none",
    name: translateFilter('assemblyContentTypeNone')
  },{
    value: "application/json",
    name: "application/json"
  },{
    value: "application/xml",
    name: "application/xml"
  },{
    value: "text/xml",
    name: "text/xml"
  },{
    value: "text/plain",
    name: "text/plain"
  }];

  $scope.$contentType = function(type) {
    if (arguments.length) {
      // Setter
      if (type === "" || type === "none") {
        delete $scope.object.content;
      } else {
        $scope.object.content = type;
      }
    } else {
      // Getter
      return $scope.object.content || "none";
    }
  };

  $scope.contentType = $scope.object.content || "none";
  $scope.$watch('contentType', function() {
    if (typeof $scope.contentType === "string") $scope.$contentType($scope.contentType);
  });

  $scope.$inputName = function(newName) {
    if (arguments.length) {
      // Setter
      var updatedInputs = {};
      for(var input in $scope.selectedNode.inputs) {
        if (input === $scope.name) {
          updatedInputs[newName] = $scope.selectedNode.inputs[input];
          $scope.map.inputRenamed(newName,input);
        } else {
          updatedInputs[input] = $scope.selectedNode.inputs[input];
        }
      }
      $scope.selectedNode.inputs = updatedInputs;
      $scope.name = newName;
    } else {
      // Getter
      return $scope.name;
    }
  };
  $scope.$outputName = function(newName) {
    if (arguments.length) {
      // Setter
      var updatedOutputs = {};
      for(var output in $scope.selectedNode.outputs) {
        if(output === $scope.name) {
          updatedOutputs[newName] = $scope.selectedNode.outputs[output];
          $scope.map.outputRenamed(newName,output);
        } else {
          updatedOutputs[output] = $scope.selectedNode.outputs[output];
        }
      }
      $scope.selectedNode.outputs = updatedOutputs;
      $scope.name = newName;
    } else {
      // Getter
      return $scope.name;
    }
  };
  var firstWatchSelectedDefinition = false;
  $scope.$watch('selectedDefinition', function() {
    if (!firstWatchSelectedDefinition) {
      firstWatchSelectedDefinition = true;
      return;
    }
    if ($scope.selectedDefinition === "inline") {
      self.launchInlineEditor();
    } else if ($scope.selectedDefinition.indexOf("#/") === 0) {
      $scope.object.schema = {
        $ref: $scope.selectedDefinition
      };
    } else {
      $scope.object.schema = {
        type: $scope.selectedDefinition
      };
    }
    $scope.$emit('input-output-modified');
  });
  self.launchInlineEditor = function() {
    $modal.open({
      templateUrl: 'src/html/inline-schema.html',
      windowTemplateUrl: 'apim/partials/main-template.html',
      controller: 'InlineSchemaController',
      size: 'lg',
      scope: $scope
    });
  };
}

angular.module('apiconnect-assembly').controller('MapInputOutputController', ['$scope', '$modal', 'translateFilter', MapInputOutputController]);

function InlineSchemaController($scope, $modalInstance) {

  var x2js;
  if (typeof window.X2JS === "function") {
    x2js = new window.X2JS({
      attributePrefix: '@'
    });
  } else {
    x2js = {
      xml2js: function(xml) {
        return xml;
      }
    };
  }

  // default to YAML
  $scope.selectedTabIndex = 0;
  if (!_.isEmpty($scope.object.schema)) {
    $scope.inlineJsonSchema = angular.toJson($scope.object.schema, true);
    $scope.inlineYamlSchema = jsyaml.safeDump(angular.fromJson(angular.toJson($scope.object.schema)), {lineWidth: -1});
    if ($scope.object.schema.example) {
      // JSON or XML?
      try {
        JSON.parse($scope.object.schema.example);
        $scope.inlineJsonObject = $scope.object.schema.example;
      } catch (e) {
        $scope.inlineXMLObject = $scope.object.schema.example;
      }
    }
  }

  $scope.validSchema = false;
  $scope.$watch('inlineYamlSchema', function() {
    if ($scope.selectedTabIndex !== 0) return;
    try {
      jsyaml.safeLoad($scope.inlineYamlSchema);
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });
  $scope.$watch('inlineJsonSchema', function() {
    if ($scope.selectedTabIndex !== 1) return;
    try {
      JSON.parse($scope.inlineJsonSchema);
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });
  $scope.$watch('inlineJsonObject', function() {
    if ($scope.selectedTabIndex !== 2) return;
    try {
      window.jsonSchemaGenerator(JSON.parse($scope.inlineJsonObject));
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });
  $scope.$watch('inlineXMLObject', function() {
    if ($scope.selectedTabIndex !== 3) return;
    try {
      var asJson = x2js.xml2js($scope.inlineXMLObject);
      if (asJson === null) {
        $scope.validSchema = false;
        return;
      }
      window.jsonSchemaGenerator(asJson);
      $scope.validSchema = true;
    } catch (error) {
      $scope.validSchema = false;
    }
  });

  $scope.generate = function() {
    var schema = {
      "type": "object",
      "allOf": []
    };
    $scope.inputSchemas.forEach(function(input) {
      schema.allOf.push(input);
    });
    $scope.inlineSchema = ($scope.asJson) ? JSON.stringify(schema) : jsyaml.safeDump(schema);
  };

  var cleanJsonSchema = function(schema, object) {
    if (!schema || typeof object === "undefined") return;
    delete schema.required;
    delete schema.$schema;

    // have we worked our way down to a basic type?
    if (typeof object !== "object") {
      delete schema.properties;
      schema.type = (typeof object);
      return;
    }

    if (schema.type === "array") {
      delete schema.uniqueItems;
      delete schema.minItems;
      // look for a missing type property
      if (schema.items && schema.items.properties && !schema.items.type) {
        schema.items.type = 'object';
      }
      cleanJsonSchema(schema.items, object[0]);
      return;
    }
    for (var property in schema.properties) {
      delete schema.properties[property].minLength;
      cleanJsonSchema(schema.properties[property], object[property]);
    }
  };

  var namespaceMap = {};

  // ensures namespaces, prefixes, properties ordering
  function xmlSortFunction(a, b) {
      if ((a.indexOf('@') === 0 && b.indexOf('@') === 0) ||
          (a.indexOf('__') === 0 && b.indexOf('__') === 0)) {
        return 0;
      }
      if (a.indexOf('@') === 0 && b.indexOf('@') === 0) {
        return 0;
      }
      if (a.indexOf('@') === 0) {
        return -1;
      }
      if (a.indexOf('__') === 0 && b.indexOf('__') === 0) {
        return 0;
      }
      if (a.indexOf('__') === 0 && b.indexOf('@') === 0) {
        return 1;
      }
      if (a.indexOf('__') === 0) {
        return -1;
      }
      if (b.indexOf('@') === 0 || b.indexOf('__') === 0) {
        return 1;
      }
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
  };

  var injectXmlConfig = function(schema, object, currentNamespace) {
    if (!schema || typeof object === "undefined") return;

    delete schema.required;
    delete schema.$schema;

    // have we worked our way down to a basic type?
    if (typeof object !== "object") {
      delete schema.properties;
      schema.type = (typeof object);
      if (currentNamespace !== "") {
        // we have no namespace prefix here, but our parent does
        // so override...
        schema.xml = {
          namespace: ''
        };
      }
      return;
    }
    if (schema.type === "array") {
      delete schema.uniqueItems;
      delete schema.minItems;
      // look for a missing type property
      if (schema.items && schema.items.properties && !schema.items.type) {
        schema.items.type = 'object';
      }
      injectXmlConfig(schema.items, object[0], currentNamespace);
      return;
    }
    // ensure iteration order
    // this way we pick up namespaces first
    var keys = Object.keys(schema.properties).sort(xmlSortFunction);

    // default override of parent namespace
    schema.xml = {
      namespace: ''
    };

    keys.forEach(function(property) {
      delete schema.properties[property].minLength;
      if (property.indexOf('@') === 0) {
        // we have an attribute
        var nsName;
        var attrProperty = property.substring(1);
        if (attrProperty.indexOf("xmlns") === 0) {
          delete schema.properties[property];
          schema.xml = {
            namespace: object[property]
          };
          nsName = attrProperty.split(":");
          nsName = (nsName.length > 1) ? nsName[1] : '';
          namespaceMap[nsName] = object[property];
        } else {
          // is the attribute namespaced?
          if (attrProperty.indexOf(':') > 0) {
            var split = attrProperty.split(':');
            attrProperty = split[1];
            nsName = split[0];
          }
          schema.properties[attrProperty] = schema.properties[property];
          delete schema.properties[property];
          schema.properties[attrProperty].xml = {attribute: true};
          if (nsName) {
            schema.properties[attrProperty].xml.prefix = nsName;
          }
        }
      } else if (property.indexOf('__') === 0) {
        // could be __prefix or __text
        // if it's __prefix, we want to add it to the xml config
        if (property === "__prefix") {
          if (object[property] !== currentNamespace) {
            currentNamespace = object[property];
            if (!schema.xml) schema.xml = {};
            schema.xml.prefix = object[property];
            if (namespaceMap[schema.xml.prefix]) {
              schema.xml.namespace = namespaceMap[schema.xml.prefix];
            }
          } else {
            // inherit...
            delete schema.xml;
          }
        } else if (property === "__text") {
          // we're a text leaf node
          schema.type = "string";
        }
        delete schema.properties[property];
      } else {
        if (!object[property] || typeof object[property] === "function") {
          delete schema.properties[property];
        } else {
          injectXmlConfig(schema.properties[property], object[property], currentNamespace);
        }
      }
    });
    // we may have cleaned out all properties if those properties were namespace-related
    if (schema.properties && Object.keys(schema.properties).length === 0) delete schema.properties;
  };

  $scope.generateAndShow = function() {
    var definition = '';
    var object;
    switch($scope.selectedTabIndex) {
      case 2:
        object = JSON.parse($scope.inlineJsonObject);
        definition = window.jsonSchemaGenerator(object);
        cleanJsonSchema(definition, object);
        var sanitizedExampleJSON = JSON.stringify(object);
        definition.example = sanitizedExampleJSON;
        break;
      case 3:
        object = x2js.xml2js($scope.inlineXMLObject);
        definition = window.jsonSchemaGenerator(object);
        // clear any existing namespace map
        namespaceMap = {};
        injectXmlConfig(definition, object, '');
        definition.example = $scope.inlineXMLObject;
        break;
    }
    try {
      $scope.inlineYamlSchema = jsyaml.safeDump(definition);
    } catch (e) {
      $scope.inlineYamlSchema = jsyaml.dump(definition);
    }
    $scope.inlineJsonSchema = JSON.stringify(definition);
    $scope.object.schema = definition;
    $scope.selectedTabIndex = 0;
  };

  $scope.commit = function() {
    var definition = '';
    var object;
    switch($scope.selectedTabIndex) {
      case 0:
        definition = jsyaml.safeLoad($scope.inlineYamlSchema);
        break;
      case 1:
        definition = JSON.parse($scope.inlineJsonSchema);
        break;
      case 2:
        object = JSON.parse($scope.inlineJsonObject);
        definition = window.jsonSchemaGenerator(object);
        cleanJsonSchema(definition, object);
        definition.example = $scope.inlineJsonObject;
        break;
      case 3:
        object = x2js.xml2js($scope.inlineXMLObject);
        definition = window.jsonSchemaGenerator(object);
        // clear any existing namespace map
        namespaceMap = {};
        injectXmlConfig(definition, object, '');
        definition.example = $scope.inlineXMLObject;
        break;
    }
    $scope.object.schema = definition;
    $modalInstance.close();
  };

  $scope.cancel = function() {
    $modalInstance.close();
  };

}

angular.module('apiconnect-assembly').controller('InlineSchemaController', ['$scope', '$modalInstance', InlineSchemaController]);
