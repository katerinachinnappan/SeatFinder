/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly


'use strict';

angular.module('apiconnect-assembly').factory('Assembly', ['$resource',
    function ($resource) {
      return $resource('proxy/orgs/:orgId/assemblies/:assemblyId/', {}, {
        query: {
          method: 'GET',
          params: {
            orgId: '@orgId'
          },
          isArray: true
        },
        get: {
          method: 'GET',
          params: {
            orgId: '@orgId',
            assemblyId: '@assemblyId'
          },
          isArray: false
        },
        update: {
          method: 'PUT',
          params: {
            orgId: '@orgId',
            assemblyId: '@assemblyId'
          },
          isArray: false
        }
      });
    }
  ]).factory('Path', function () {
    return function (path, dimensionality, container, type) {
      var self = this;
      self.path = path;
      if (typeof dimensionality === "string") {
        dimensionality = JSON.parse(dimensionality);
      }
      self.dimensionality = dimensionality;
      self.container = container;
      self.type = type;

      // var unnamed = "$item";
      // var unnamedRe = new RegExp("\\$item", "g");

      self.getPath = function () {
        return path;
      };

      // getDimensionality
      // get the dimension of the given path
      // items[0].items[2].name has dimension 2 - two nested arrays
      self.getDimensionality = function () {
        return self.dimensionality.length;
      };

      self.getType = function () {
        return self.type;
      };

      return self;
    };
  }).factory('Map', ['SchemaReferences', function (SchemaReferences) {
    return function (map, definitions, callback) {
      var self = this,
        model = [];

      self.readOnly = !!map.$$readOnly || !!map.$$parentReadOnly;

      function processMapping(mapping) {
        if (mapping.actions) {
          // go deeper
          mapping.actions.forEach(function (nextMapping) {
            nextMapping.$$parent = mapping;
            processMapping(nextMapping);
          });
        } else {
          // we're at a root
          var foreach = [],
            source = angular.copy(mapping.from),
            target = mapping.set || mapping.create,
            parentMapping = mapping;

          if (typeof source === "string") {
            source = [source];
          }
          var merge = false;
          while (parentMapping.$$parent) {
            parentMapping = parentMapping.$$parent;
            if (source) {
              for (var i = 0; i < source.length; i++) {
                if (source[i].indexOf("#/") !== 0) {
                  // if the source is not absolute, prepend the context
                  source[i] = (parentMapping.foreach || parentMapping.source) + "." + source[i];
                } else {
                  merge = true;
                }
              }
            }
            target = (parentMapping.set || parentMapping.create) + "." + target;
            foreach.splice(0, 0, {
              source: (parentMapping.foreach || parentMapping.source),
              target: (parentMapping.set || parentMapping.create)
            });
          }
          var item = {
            target: target
          };
          if (source) {
            item.source = source;
          }
          if (mapping.create) {
            item.$$create = true;
          }

          if (merge === true) {
            item.merge = true;
          }

          if (mapping.value) {
            item.value = mapping.value;
          }
          if (mapping.default !== undefined) {
            item.default = mapping.default;
          }
          if (foreach.length > 0) {
            item.foreach = foreach;
          }
          model.push(item);
        }
      }

      if (map.actions) {
        map.actions.forEach(function (mapping) {
          processMapping(mapping);
        });
      }

      self.getMapping = function (targetPath) {
        var filtered = model.filter(function (mapping) {
          return mapping.target === targetPath;
        });
        if (filtered.length > 0) {
          return filtered[0];
        }
        return null;
      };

      // determine if a given path has a mapping
      // if a path is mapped, return the mapping for that path
      // direct parameter (defaults to true) - only consider a direct mapping
      // as true - sub-element mappings would not be considered true
      // otherwide return null
      self.hasMapping = function (path) {
        if (self.getMapping(path.getPath()) !== null) {
          return true;
        } else {
          return (self.getMapping(path.getPath() + ".$item") !== null);
        }
      };

      // gets the mapping for this path, creating where necessary
      self.getMappingForPath = function (path) {
        return self.getMapping(path.getPath());
      };

      // gets the mapping for this path, creating where necessary
      self.setMappingForPath = function (targetPath, sourcePath) {
        var mapping = self.getMapping(targetPath.getPath());

        // subtle case - if the user has set a default value on the target
        // path already, and that target path resides within an array, it's
        // hard to retro-fit the existing mapping with all the necessary
        // foreach iterators. But the existing mapping is simpley a default
        // value string, so the simplest thing to do is to remember the default,
        // clear out the existing mapping, and recreate it with the default value.
        // It's an edge case, so get it out of the way...
        var defaultValue;
        if (mapping &&
          mapping.default !== undefined &&
          mapping.foreach &&
          mapping.foreach.length > 0 &&
          !mapping.foreach[0].source) {
          // this is such a mapping...
          defaultValue = mapping.default;
          self.deleteMappingForPath(targetPath);
          mapping = null;
        }

        // now continue as normal, safe in the knowledge that that awkward
        // case is no longer lying around to trip us up
        if (mapping) {
          if (sourcePath) {
              if (!mapping.source) mapping.source = [];
              mapping.source.push(sourcePath.getPath());
          }
        } else {
          mapping = {
            target: targetPath.getPath()
          };
          if (sourcePath) {
            mapping.source = [sourcePath.getPath()];
          }
          // re-instate any previously set defaultValue from the edge case above
          if (defaultValue) {
            mapping.default = defaultValue;
          }

          // do we have any dimensionality to address?
          var foreach = [];
          if (targetPath.getDimensionality() > 0) {
            // indeed we do...
            // take a simple approach and map each level on the source to the equivalent on the right
            // this will be right most of the time, I swear...
            var index = 0,
              targetContext = "",
              sourceContext = "";
            while (index < targetPath.getDimensionality()) {
              var sourceDimension = "$item";
              if (sourcePath) {
                if (sourcePath.getDimensionality() > index) {
                  sourceDimension = sourcePath.dimensionality[index].replace(sourceContext, "");
                  sourceContext = sourcePath.dimensionality[index] + ".";
                } else {
                  sourceDimension = sourcePath.getPath();
                }
              }
              // if there is no sourcePath, there is nothing to iterate over
              var foreachObj = {
                target: targetPath.dimensionality[index].replace(targetContext, "")
              };
              if (sourcePath) foreachObj.source = sourceDimension;
              foreach.push(foreachObj);
              targetContext = targetPath.dimensionality[index] + ".";
              index++;
            }
          }
          if (foreach.length > 0) {
            mapping.foreach = foreach;
          }
          model.push(mapping);
        }
        callback(self.getActions());
        return mapping;
      };

      self.deleteMappingForPath = function (targetPath) {
        self.deleteMapping(targetPath.getPath());
      };

      self.deleteMapping = function (targetPath) {
        model = model.filter(function (mapping) {
          return (mapping.target !== targetPath);
        });
        callback(self.getActions());
      };

      function serializeMapping(mapping, actions) {
        var action = {},
          contextualizedSources = [];
        if (!mapping.foreach || mapping.foreach.length === 0) {
          // simple case
          // are we within a target context?
          var target = (mapping.targetContext) ? mapping.target.replace(mapping.targetContext + ".", "") : mapping.target;
          // are we mapping something simple within a target context?
          if (mapping.targetContext === mapping.target) {
            target = "$item";
          }
          action[(mapping.$$create) ? "create" : "set"] = target;
          if (mapping.source) {
            mapping.source.forEach(function (source) {
              var contextualizedSource = (mapping.sourceContext) ? source.replace(mapping.sourceContext + ".", "") : source;
                            
              if (contextualizedSource.indexOf(".$item") > 0) {
                  contextualizedSource = contextualizedSource.replace(".$item", "");
              } else if (contextualizedSource.indexOf("$item.") === 0) {
                  contextualizedSource = contextualizedSource.replace("$item.", "");
              }
              
              contextualizedSources.push(contextualizedSource);
            });
            action.from = (contextualizedSources.length > 1) ? contextualizedSources : contextualizedSources[0];
          }
          if (mapping.value) {
            action.value = mapping.value;
          }
          if (mapping.default !== undefined) {
            action.default = mapping.default;
          }
        } else {
          action = {
            create: mapping.foreach[0].target
          };

          if (mapping.merge) {
            action.$$merge = true;
          }

          if (mapping.foreach[0].source) action.foreach = mapping.foreach[0].source;
          if (mapping.source) {
            mapping.source.forEach(function (source) {
              var contextualizedSource = (mapping.sourceContext) ? source.replace(mapping.sourceContext + ".", "") : source;
              if (contextualizedSource === action.foreach) {
                // ok, our source is the same as the iterator, so either
                // 1) this is a simple object, not an array, and we want to iterate on the object
                // or 2) we want to merge this with another iterator and use an absolute path
                if (mapping.merge) {
                  contextualizedSource = "#/" + contextualizedSource;
                } else {
                  contextualizedSource = "$item";
                }
              }
              contextualizedSources.push(contextualizedSource);
            });
            if (mapping.foreach[0].source) {
              action.from = (mapping.foreach[0].source.length > 1) ?
                mapping.foreach[0].source :
                mapping.foreach[0].source[0];
            }
          }

          // Prevent UI deletion of the 'from' property in the create action when child only has default mapping
          // apiconnect-assembly/#409
          if (!mapping.source && mapping.default !== undefined) {
            if (mapping.foreach[0].source) {
                action.from = (mapping.foreach[0].source.length > 1) ?
                mapping.foreach[0].source :
                mapping.foreach[0].source[0];
            }
          }

          action.actions = [];
          var subMapping = {
            source: contextualizedSources,
            target: (mapping.targetContext) ? mapping.target.replace(mapping.targetContext + ".", "") : mapping.target,
            foreach: mapping.foreach.slice(1),
            targetContext: mapping.foreach[0].target
          };

          if (mapping.$$create) {
            subMapping.$$create = true;
          }
          if (mapping.foreach[0].source) {
            subMapping.sourceContext = mapping.foreach[0].source;
          }
          if (mapping.value) {
            subMapping.value = mapping.value;
          }
          if (mapping.default !== undefined) {
            subMapping.default = mapping.default;
          }
          if (mapping.merge) {
            subMapping.merge = true;
          }
          serializeMapping(subMapping, action.actions);
        }
        actions.push(action);
      };

      function actionsMatch(firstAction, secondAction, mergeable) {
        if (!firstAction.actions || !secondAction.actions) {
          return false;
        }
        var firstActionTarget = firstAction.create || firstAction.set,
          secondActionTarget = secondAction.create || secondAction.set;
        if (firstAction.$$merge || secondAction.$$merge) {
          // user wants to merge, therefore the foreach does not have to match
          return (firstActionTarget === secondActionTarget);
        }  else if (!mergeable) {
          // Extension type selection. No consolidation.
          return (firstActionTarget === secondActionTarget &&
            firstAction.foreach === secondAction.foreach);
        }  else {
          // Merge all actions with same target #apiconnect-assembly/411
          return (firstActionTarget === secondActionTarget &&
            (firstAction.foreach === secondAction.foreach || firstAction.foreach === undefined || secondAction.foreach === undefined));
        }
      };

      /*
       * Consolidates the mapping rules down to a canonical set
       * by merging rules with common ancestors
       */
      function consolidateActions(actions) {
        var index = 0,
          currentAction,
          compareAction,
          consolidated,
          action = 0;

        // if merge checkbox is checked. Extension type selection shouldn't consolidate actions.
        var mergeable = false;
        while (action < actions.length) {
          if (actions[action].$$merge) {
            mergeable = true;
          }
          action++;
        }

        while (index < actions.length) {
          currentAction = actions[index];
          if (!currentAction.actions) {
            // no actions means no iteration nesting, so no consolidation required
            index++;
            continue;
          }
          var i = index + 1;
          while (i < actions.length) {
            consolidated = false;
            compareAction = actions[i];
            if (!compareAction.actions) {
              i++;
              continue;
            }
            // do currentAction and compareAction have anything in common?
            if (actionsMatch(currentAction, compareAction, mergeable)) {
              consolidated = true;
              currentAction.actions = currentAction.actions.concat(compareAction.actions);
              currentAction.actions = consolidateActions(currentAction.actions);
              actions.splice(i, 1);
              currentAction.from = currentAction.from || compareAction.from;
              currentAction.foreach = currentAction.foreach || compareAction.foreach;
            }
            if (!consolidated) {
              i++;
            }
          }
          index++;
        }
        return actions;
      };

      self.getActions = function () {
        var actions = [];
        model.forEach(function (mapping) {
          serializeMapping(mapping, actions);
        });
        return angular.fromJson(angular.toJson(consolidateActions(actions)));
      };

      self.getModel = function () {
        return model;
      };

      self.pruneModel = function (inputs, outputs, saveDiscriminator, checkOnly) {
        if (self.readOnly) return;
        var prunedModel = [];
        var modelChanged = false;
        var keepDiscriminator = true;
        if (saveDiscriminator === false) {
        	keepDiscriminator = false;
        }
        var unrecognized = [];
        model.forEach(function (mapping) {

          var source = [];
          // check the sources
          if (mapping.source) {
            for (var i = 0; i < mapping.source.length; i++) {
              if (!SchemaReferences.propertyExistsInSchemas(mapping.source[i], inputs, definitions, keepDiscriminator)) {
                if (unrecognized.indexOf(mapping.source[i]) === -1) {
                  unrecognized.push(mapping.source[i]);
                }
                modelChanged = true;
              } else {
                source.push(mapping.source[i]);
              }
            }
            if (source.length === 0) return;
          }

          // check the target
          if (mapping.target && !SchemaReferences.propertyExistsInSchemas(mapping.target, outputs, definitions, keepDiscriminator)) {
            if (unrecognized.indexOf(mapping.target) === -1) {
              unrecognized.push(mapping.target);
            }
            modelChanged = true;
            return;
          } else if (!mapping.target) { // target doesn't exist (illegal action like in apiconnect-assembly/#416)
              if (unrecognized.indexOf(mapping.source[0]) === -1) {
                  unrecognized.push(mapping.source[0]);
              }
              modelChanged = true;
              return;
          }

          // it exists, keep it
          if ((source.length === 0) || (source.length === mapping.source.length)) {
            // no changes to source, so we can use the existing mapping
            prunedModel.push(mapping);
          } else {
            // one (or more) of the source schemas was not found, so we need to create a new
            // mapping object that can be used if the user decides to perform the pruning
            var newMapping = angular.fromJson(angular.toJson(mapping));
            newMapping.source = source;
            prunedModel.push(newMapping);
          }
        });

        if (modelChanged) {
          if (!checkOnly) {
            model = prunedModel;
            callback(self.getActions());
          }
        }

        return unrecognized;
      };

      function updateSource(obj,newText,oldText) {
        var changed = false;
        if (obj && obj.source) {
          if (typeof obj.source === 'string') {
            if (obj.source === oldText) {
              obj.source = newText;
              changed = true;
            } else if (obj.source.indexOf(oldText+'.') === 0) {
              obj.source = newText + obj.source.substring(oldText.length);
              changed = true;
            }
          } else {
            for (var i=0; i<obj.source.length; i++) {
              if (obj.source[i] === oldText) {
                obj.source[i] = newText;
                changed = true;
              } else if (obj.source[i].indexOf(oldText+'.') === 0) {
                obj.source[i] = newText + obj.source[i].substring(oldText.length);
                changed = true;
              }
            }
          }
        }
        return changed;
      };

      function updateTarget(obj,newText,oldText) {
        var changed = false;
        if (obj && obj.target) {
          if (obj.target === oldText) {
            obj.target = newText;
            changed = true;
          } else if (obj.target.indexOf(oldText+'.') === 0) {
            obj.target = newText + obj.target.substring(oldText.length);
            changed = true;
          }
        }
        return changed;
      };

      function updateValue(obj,newText,oldText) {
        var changed = false;
        if (obj.value) {
          var i = obj.value.indexOf(oldText);
          while (i > -1) {
            obj.value = obj.value.substring(0,i) + newText + obj.value.substring(i+oldText.length);
            i=obj.value.indexOf(oldText,i+newText.length);
            changed = true;
          }
        }
        return changed;
      };

      self.inputRenamed = function(newName, oldName) {
        var newPath = newName.replace(/\./g,'\\.');
        var oldPath = oldName.replace(/\./g,'\\.');
        var newAbsolute = '#/' + newPath;
        var oldAbsolute = '#/' + oldPath;
        var modelChanged = false;
        model.forEach(function (mapping) {
          if (mapping.source) {
            if (updateSource(mapping,newPath,oldPath)) modelChanged = true;
            if (updateSource(mapping,newAbsolute,oldAbsolute)) modelChanged = true;
          }
          if (mapping.value) {
            if (updateValue(mapping,'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
          }
          if (mapping.foreach) {
            if (mapping.foreach[0]) {
              if (mapping.foreach[0].source) {
                if (updateSource(mapping.foreach[0],newPath,oldPath)) modelChanged = true;
              }
              if (mapping.foreach[0].value) {
                if (updateValue(mapping.foreach[0],'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
                if (updateValue(mapping.foreach[0],'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
              }
            }
            mapping.foreach.forEach(function(fe){
              if (fe.source) {
                if (updateSource(fe,newAbsolute,oldAbsolute)) modelChanged = true;
              }
              if (fe.value) {
                if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
                if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
              }
            });
          }
        });
        if (modelChanged) {
          callback(self.getActions());
        }
      };

      self.outputRenamed = function(newName, oldName) {
        var newPath = newName.replace(/\./g,'\\.');
        var oldPath = oldName.replace(/\./g,'\\.');
        var newAbsolute = '#/' + newPath;
        var oldAbsolute = '#/' + oldPath;
        var modelChanged = false;
        model.forEach(function (mapping) {
          if (mapping.target) {
            if (updateTarget(mapping,newPath,oldPath)) modelChanged = true;
            if (updateTarget(mapping,newAbsolute,oldAbsolute)) modelChanged = true;
          }
          if (mapping.value) {
            if (updateValue(mapping,'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
            if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
          }
          if (mapping.foreach) {
            if (mapping.foreach[0]) {
              if (mapping.foreach[0].target) {
                if (updateTarget(mapping.foreach[0],newPath,oldPath)) modelChanged = true;
              }
              if (mapping.foreach[0].value) {
                if (updateValue(mapping.foreach[0],'$('+newPath+')','$('+oldPath+')')) modelChanged = true;
                if (updateValue(mapping.foreach[0],'$('+newPath+'.','$('+oldPath+'.')) modelChanged = true;
              }
            }
            mapping.foreach.forEach(function(fe){
              if (fe.target) {
                if (updateTarget(fe,newAbsolute,oldAbsolute)) modelChanged = true;
              }
              if (fe.value) {
                if (updateValue(mapping,'$('+newAbsolute+')','$('+oldAbsolute+')')) modelChanged = true;
                if (updateValue(mapping,'$('+newAbsolute+'.','$('+oldAbsolute+'.')) modelChanged = true;
              }
            });
          }
        });
        if (modelChanged) {
          callback(self.getActions());
        }
      };

      return self;
    };
  }]).service('ExtensionType', ['Path', function (Path) {
	  var handler = null;
	  var self = this;

	  self.setHandler = function(inHandler) {
		  handler = inHandler;
	  };

	  self.getValueForPath = function (path) {
		  var targetPath = handler.paths[path];
		  var mapping = null;
		  if (targetPath) {
			  mapping = handler.map.getMappingForPath(targetPath);
		  }
		  return mapping ? mapping.default : null;
	  };

	  self.setValueForPath = function(path, value) {
		  var targetPath = handler.paths[path];
		  if (!value) {
			  // remove the mapping
			  if (targetPath) {
				  handler.map.deleteMappingForPath(targetPath);
			  }
		  } else {
			  if (!targetPath) {
				  targetPath = new Path(path, 0);
				  handler.paths[path] = targetPath;
			  }
			  var mapping = handler.map.getMapping(targetPath);
			  if (!mapping) {
				  mapping = handler.map.setMappingForPath(targetPath);	// creates the output target path
				  mapping.default = value;
				  handler.map.setMappingForPath(targetPath);	// updates and serialises the new mapping value
			  } else {
				  mapping.default = value;
				  handler.map.setMappingForPath(targetPath);
			  }
		  }
		  handler.markDirty();
		  handler.selectedNode.actions = handler.map.getActions();
	  };
  }]).service('policyService', function () {
    var self = this;
    self.createPolicyInstance = function (policy, injectVersion) {
      if (!policy.info) {
        // we don't have a schema here, assume it's already an instance
        return policy;
      }
      var node = {};
      if (!policy.info.name) {
        return node;
      }

      // policy.info.name is e.g. "SAP", "operation-switch", "m
      var properties = policy.properties,
        action = {
          $$type: policy.info.name,
          $$categories: policy.info.categories,
          $$display: policy.info.display,
          $$schema: properties
        };
      // default a title if there are any properties defined
      if (properties) {
        // be careful - display is not required
        if (policy.info.display && policy.info.display.name) {
          action.title = policy.info.display.name;
        } else {
          action.title = policy.info.name;
        }
      }
      if (policy.info.name === 'operation-switch') {
        angular.extend(action, {
          case: [{
            operations: [],
            execute: []
          }],
          otherwise: []
        });
      } else if (policy.info.name === 'switch') {
        angular.extend(action, {
          case: [{
            condition: "",
            execute: []
          }]
        });

        // Load if with else statement if in AppC
        if (policy.info.categories && policy.info.categories.indexOf('AppConnect') > -1) {
          action.case.push({otherwise: []});
        }
      } else if (policy.info.name === 'if') {
        angular.extend(action, {
          condition: "true",
          execute: []
        });
      } else if (policy.info.name === 'map') {
        angular.extend(action, {
          inputs: {},
          outputs: {},
          actions: []
        });
      } else if (policy.info.name === 'set-variable') {
        angular.extend(action, {
          actions: []
        });
      } else if (policy.info.name === 'Application') {
        angular.extend(action, {
          selectedApplication: {},
          selectedAction: {},
          $$advanced: false
        });
      } else if (policy.info.name === 'Trigger') {
        angular.extend(action, {
          selectedApplication: {},
          selectedTrigger: {}
        });
      } else {
        // there may not be any properties...
        if (properties) {
          angular.extend(action, jsonSchemaDefaults(properties));
        }
        // fix stop-on-error bug
        if (policy.info.name === 'invoke' && node && node.invoke) {
          delete node.invoke['stop-on-error'];
        }
      }
      if ((policy.custom || injectVersion) && policy.info.version) {
        // also inject the version
        action.version = policy.info.version;
      }
      node[policy.info.name] = action;
      return node;
    };
  }).service('triggerService', function () {
    var self = this;

    self.deleteTrigger = function (trigger) {
      trigger.selectedApplication = {};
      trigger.selectedTrigger = {};
      delete trigger.accountName;
      delete trigger.$$touched;
      delete trigger.$$errors;
      delete trigger.auth;
      delete trigger.options;
      delete trigger.outputSchema;
    };

    self.setTriggerApplication = function (trigger, selectedApplication) {
      delete trigger.$$errors;
      var triggerApplication = {
        name: selectedApplication.name,
        displayName: selectedApplication.displayName
      };

      trigger.selectedApplication = angular.copy(triggerApplication);

      // Single target object
      trigger.selectedTrigger.name = selectedApplication.task.name;
      trigger.selectedTrigger.displayName = selectedApplication.task.displayName;
      trigger.selectedTrigger.dataModel = selectedApplication.task.dataModel;
      trigger.selectedTrigger.hasConfig = selectedApplication.task.hasConfig;
    };
  }).factory('errorFactory', ['$rootScope', '$mdDialog', '$mdPanel', function ($rootScope, $mdDialog, $mdPanel) {
    return {
      throwError: function (errorObject) {
        // Setup scope for error dialog directive
        var $newScope = $rootScope.$new();
        $newScope.errorObject = errorObject;
        $mdDialog.show({
          fullscreen: true,
          parent: document.body,
          scope: $newScope,
          template: '<md-dialog class="error-dialog"><error-dialog></error-dialog></md-dialog>'
        });
      },

      showWarning: function (warningObject) {
        // Setup scope for error dialog directive
        var $newScope = $rootScope.$new();
        $newScope.warningObject = warningObject;
        $newScope.panelReference = $mdPanel.create({
          attachTo: document.body.querySelector("apim-assembler"),
          panelClass: "warning-dialog",
          scope: $newScope,
          template: '<warning-dialog></warning-dialog>',
          trapFocus: false
        });
        $newScope.panelReference.open();

        return $newScope.panelReference;
      }
    };
  }])
  .factory('AssemblerTracking', [
    '$rootScope',
    function (
      $rootScope
    ) {
      var svc = {};

      svc.track = function (ns, key, data) {
        $rootScope.$emit('event:track', ns, key, data);
      };

      return svc;
    }
  ]).service('canvasAnimationService', [function () {

    var self = this;
    self.canvasXPosition = 0;

    self.reset = function () {
      self.initialPositionSet = false;
      self.canvasXPosition = 0;
    };

    self.animateCanvasSlide = function () {
      var newPosition = self.canvasXPosition || 0;
      var bounds = {};
      var windowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var focusNodeElement = document.querySelector('.isSelected');

      // Only animate to selected nodes
      if (focusNodeElement) {
        bounds = focusNodeElement.getBoundingClientRect();
        newPosition = (windowWidth / 2) - bounds.right + (bounds.width / 2);
        newPosition += self.canvasXPosition;
        self.canvasXPosition = newPosition;
      }

      return newPosition;
    };
  }]).service('assemblyModel', function() {
    var self = this;
    self.flow = {
      trigger: null,
      nodes: [],
      request: null,
      response: null
    };

    self._searchForSelectedNode = function(nodesArray) {

      // Remove top level keys from nodes array
      var nodes = nodesArray.map( function(node) {
        return node.$$type ? node : node[Object.keys(node)[0]];
      });

      // loop through top level nodes
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].$$isSelected) {
          return nodes[i];
        }

        if (nodes[i].$$type === 'switch') {
          // loop through each case statement
          for (var j = 0; j < nodes[i].case.length; j++) {
            var foundNode = self._searchForSelectedNode(nodes[i].case[j].execute || nodes[i].case[j].otherwise);
            if (foundNode) {
              return foundNode;
            }
          }
        }
      }
      return;
    };

    self._searchForNode = function(nodes, nodeToFind) {

      // loop through top level nodes
      for (var i = 0; i < nodes.length; i++) {

        // Remove any top level keys (i.e 'Application')
        var keys = Object.keys(nodes[i]);
        var currentNode = keys.length === 1 ? nodes[i][keys[0]] : nodes[i];

        if (currentNode === nodeToFind) {
          return true;
        }

        if (currentNode.$$type === 'switch') {
          // loop through each case statement
          for (var j = 0; j < currentNode.case.length; j++) {
            var nodesArray = currentNode.case[j].execute || currentNode.case[j].otherwise;
            var foundNode = self._searchForNode(nodesArray, nodeToFind);
            if (foundNode) {
              return true;
            }
          }
        }
      }
      return false;
    };

    self.getSelectedNode = function() {
      if (self.flow.trigger && self.flow.trigger.$$isSelected) {
        return self.flow.trigger;
      } else if (self.flow.response && self.flow.response.$$isSelected) {
        return self.flow.response;
      } else {
        return self._searchForSelectedNode(self.flow.nodes);
      }
    };

    self.containsSelectedNode = function (node) {
      return self._searchForSelectedNode([node]) ? true : false;
    };

    self.containsNode = function (node, nodeToFind) {
      return self._searchForNode([node], nodeToFind);
    };

    self.countInnerActions = function(node) {
      var count = 0;

      if (node.$$type !== 'switch') {
        return 0;
      }

      var recursiveCount = function (node) {
        // loop through each case statement
        for (var i = 0; i < node.case.length; i++) {
          var nodeBranch = (node.case[i].execute || node.case[i].otherwise);

          for(var j = 0; j < nodeBranch.length; j++) {

            if (nodeBranch[j].switch) {
              recursiveCount(nodeBranch[j].switch);
            } else {
              count++;
            }
          }
        }
      };

      recursiveCount(node);
      return count;

    };
  });
