/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-assembly

'use strict';

function AssemblerInfoController($scope, SchemaForm) {
  $scope.minorTab = 'configure';
  SchemaForm.options = {
    'ajax': true,
    'theme': 'bootstrap3',
    'show_errors': 'change',
    'no_additional_properties': true,
    'disable_edit_json': true,
    'required_by_default': true
  };

  $scope.aceLoaded = function() {
    window.e.setOption('enableBasicAutocompletion', false);
    window.e.setOption('enableLiveAutocompletion', false);
  };

  var modelChanged = function(model, updateInScope) {
    if (updateInScope) { $scope.model = model; }
    angular.extend($scope.selectedNode, model);
    // clear out any properties present in the selected node which aren't present in the new node
    Object.keys($scope.selectedNode).forEach(function(key) {
      if (key.indexOf('$$') !== 0) {
        if ($scope.selectedNode.hasOwnProperty(key) && !model.hasOwnProperty(key)) {
          delete $scope.selectedNode[key];
        }
      }
    });
  };

  $scope.policyAsYaml = function(newYaml) {
    if (arguments.length) {
      // Setter
      modelChanged(jsyaml.safeLoad(newYaml), true);
    } else {
      // Getter
      var cleanObject = JSON.parse(angular.toJson($scope.selectedNode));
      if (_.isEmpty(cleanObject)) return "";
      return jsyaml.safeDump(cleanObject, {lineWidth: -1});
    }
  };

  $scope.formChanged = _.debounce(modelChanged, 200);
  $scope.aceChanged = _.debounce(modelChanged, 200);

  var currentHash;
  // deep watch the object
  $scope.$watch('selectedNode', function() {
    if (!$scope.selectedNode) { return; }

    // remove anything explicitly set to null
    Object.keys($scope.selectedNode).forEach(function(key) {
      if ($scope.selectedNode.hasOwnProperty(key) && $scope.selectedNode[key] === null) {
        delete $scope.selectedNode[key];
      }
    });
    if (!currentHash || currentHash !== $scope.selectedNode.$$hashKey) {
      currentHash = $scope.selectedNode.$$hashKey;
      $scope.schema = $scope.selectedNode.$$schema;
      $scope.model = angular.copy($scope.selectedNode);
    }
  }, true);
};

angular.module('apiconnect-assembly').controller('AssemblerInfoController', ['$scope', 'SchemaForm', AssemblerInfoController]);

function OperationSwitchController($scope) {
  var self = this;
  self.addCase = function() {
    $scope.selectedNode.case.push({operations: [], execute: []});
  };
  self.removeCase = function(index) {
    $scope.selectedNode.case.splice(index, 1);
  };
};

angular.module('apiconnect-assembly').controller('OperationSwitchController', ['$scope', OperationSwitchController]);

function OperationCaseController($scope) {
  if (!$scope.case.operations) $scope.case.operations = [];
  if (!$scope.case.execute) $scope.case.execute = [];
  var self = this;
  self.filter = function() {
    var search = this.searchText.toLowerCase();
    return $scope.swaggerLegacyOperations.filter(function(operation) {
      if (typeof operation === "string") {
        if (operation.toLowerCase().indexOf(search) === -1) return false;
      } else {
        if (operation.verb.toLowerCase().indexOf(search) === -1 && operation.path.toLowerCase().indexOf(search) === -1) return false;
      }
      // we match, so return true only if the operation isn't used elsewhere already
      for (var i = 0; i < $scope.selectedNode.case.length; i++) {
        for (var j = 0; j < $scope.selectedNode.case[i].operations.length; j++) {
          var usedOperation = $scope.selectedNode.case[i].operations[j];
          if (typeof operation === "string" && operation === usedOperation) return false;
          if (typeof operation === "object" && operation.verb === usedOperation.verb && operation.path === usedOperation.path) return false;
        }
      }
      return true;
    });
  };
};

angular.module('apiconnect-assembly').controller('OperationCaseController', ['$scope', OperationCaseController]);

function SwitchController($scope) {
  var self = this;
  self.addCase = function() {
    if ($scope.hasOtherwise()) {
      $scope.selectedNode.case.splice($scope.selectedNode.case.length - 1, 0, {condition: "", execute: []});
    } else {
      $scope.selectedNode.case.push({condition: "", execute: []});
    }
  };
  self.removeCase = function(index) {
    $scope.selectedNode.case.splice(index, 1);
  };
  self.moveUp = function(index) {
    if (index <= 0) return;
    var newCases = [];
    $scope.selectedNode.case.forEach(function(thisCase, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index - 1) {
        newCases.push($scope.selectedNode.case[index]);
        newCases.push(thisCase);
      } else {
        newCases.push(thisCase);
      }
    });
    $scope.selectedNode.case = newCases;
  };
  self.moveDown = function(index) {
    if (index >= $scope.selectedNode.case.length - 1) return;
    var newCases = [];
    $scope.selectedNode.case.forEach(function(thisCase, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index + 1) {
        newCases.push(thisCase);
        newCases.push($scope.selectedNode.case[index]);
      } else {
        newCases.push(thisCase);
      }
    });
    $scope.selectedNode.case = newCases;
  };
  $scope.hasOtherwise = function() {
    return $scope.selectedNode.case[$scope.selectedNode.case.length - 1].otherwise !== undefined;
  };
  self.addOtherwise = function() {
    $scope.selectedNode.case.push({otherwise: []});
  };
};

angular.module('apiconnect-assembly').controller('SwitchController', ['$scope', SwitchController]);

function CaseController($scope, $mdDialog, Expressions) {
  if (!$scope.case.otherwise && !$scope.case.execute) $scope.case.execute = [];
  var self = this;

  self.filter = function() {
    if (!$scope.chips || $scope.chips.length === 0) return $scope.swaggerOperations;
    var search = this.searchText.toLowerCase();
    return $scope.swaggerOperations.filter(function(operation) {
      if (operation.operationId && operation.operationId.toLowerCase().indexOf(search) === -1) return false;
      if (operation.verb && operation.path && operation.verb.toLowerCase().indexOf(search) === -1 && operation.path.toLowerCase().indexOf(search) === -1) return false;
      // we match, so return true only if the operation isn't used elsewhere already
      for (var i = 0; i < $scope.chips.length; i++) {
        if (operation.verb && $scope.chips[i].verb && $scope.chips[i].verb.toLowerCase() === operation.verb.toLowerCase() &&
          operation.path && $scope.chips[i].path && $scope.chips[i].path === operation.path) return false;
        if (operation.operationId && $scope.chips[i].operationId === operation.operationId) return false;
      }
      return true;
    });
  };
  self.canMoveUp = function($index) {
    if ($scope.case.otherwise) return false;
    return $index > 0;
  };
  self.canMoveDown = function($index) {
    if ($scope.case.otherwise) return false;
    if ($scope.hasOtherwise()) return $index < $scope.selectedNode.case.length - 2;
    return $index < $scope.selectedNode.case.length - 1;
  };
  self.convertToExpression = function() {
    // empty case
    var expression;
    if (!$scope.case.condition.operations || $scope.case.condition.operations.length === 0) {
      delete $scope.case.condition.operations;
      $scope.case.condition.expression = "(function() {\n  return false;\n})();";
      return;
    }
    $scope.case.condition.operations.forEach(function(operation) {
      if (typeof operation === "string") {
        expression += "$(operation.operationId) === '" + operation + "' || ";
      } else {
        expression += "($(operation.verb) === '" + operation.verb + "' && $(operation.path) === '" + operation.path + "') || ";
      }
    });
    expression = expression.substring(0, expression.length - 4) + ");\n})();";
    delete $scope.case.condition.operations;
    $scope.case.condition.expression = expression;
  };
  self.launchExpressionEditor = function() {
    $mdDialog.show({
      templateUrl: 'src/html/expression-editor.html',
      controller: 'ConditionEditorController',
      locals: {
        expression: $scope.case.condition
      }
    }).then(function(response) {
      $scope.case.condition = response;
    });
  };
  if (!$scope.case.otherwise) {
    $scope.$watch('case.condition', function() {
      if ($scope.case.condition && $scope.case.condition !== "") {
        $scope.expression = window.jsep($scope.case.condition);
        $scope.highLevelExpression = Expressions.highLevelExpression($scope.expression);
        if ($scope.highLevelExpression) $scope.chips = Expressions.expressionAsChips($scope.expression);
      } else {
        $scope.highLevelExpression = true;
        $scope.chips = [];
      }
    });

    $scope.$watchCollection('chips', function() {
      if (!$scope.highLevelExpression) return;
      if (!$scope.chips || $scope.chips.length === 0) {
        $scope.case.condition = "";
      } else {
        $scope.case.condition = Expressions.chipsAsExpressionString($scope.chips);
      }
    });
  }
};

angular.module('apiconnect-assembly').controller('CaseController', ['$scope', '$mdDialog', 'Expressions', CaseController]);

function ConditionEditorController($scope, $mdDialog, expression) {

  $scope.expressionString = expression;

  $scope.$on("condition-change", function($event, expression) {
    $scope.expressionString = expression;
  });

  $scope.commit = function() {
    $mdDialog.hide($scope.expressionString);
  };

  $scope.cancel = function() {
    $mdDialog.cancel();
  };

};

angular.module('apiconnect-assembly').controller('ConditionEditorController', ['$scope','$mdDialog', 'expression', ConditionEditorController]);

function CatchController($scope) {
  var self = this;
  self.addCatch = function() {
    if (!$scope.selectedNode.catch) $scope.selectedNode.catch = [];
    var insertIndex = $scope.selectedNode.catch.length;
    if (self.hasDefault()) insertIndex--;
    $scope.selectedNode.catch.splice(insertIndex, 0, {errors: [], execute: []});
  };
  self.hasDefault = function() {
    var lastCatch = $scope.selectedNode.catch.length - 1;
    if (lastCatch < 0) return false;
    return ($scope.selectedNode.catch[lastCatch].default !== undefined);
  };
  self.addCatchDefault = function() {
    if (self.hasDefault()) return;
    $scope.selectedNode.catch.push({default: []});
  };
  self.removeCatch = function(index) {
    $scope.selectedNode.catch.splice(index, 1);
  };
  self.moveUp = function(index) {
    if (index <= 0) return;
    var newCatches = [];
    $scope.selectedNode.catch.forEach(function(thisCatch, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index - 1) {
        newCatches.push($scope.selectedNode.catch[index]);
        newCatches.push(thisCatch);
      } else {
        newCatches.push(thisCatch);
      }
    });
    $scope.selectedNode.catch = newCatches;
  };
  self.moveDown = function(index) {
    if (index >= $scope.selectedNode.catch.length - 1) return;
    var newCatches = [];
    $scope.selectedNode.catch.forEach(function(thisCatch, currentIndex) {
      if (currentIndex === index) return;
      if (currentIndex === index + 1) {
        newCatches.push(thisCatch);
        newCatches.push($scope.selectedNode.catch[index]);
      } else {
        newCatches.push(thisCatch);
      }
    });
    $scope.selectedNode.catch = newCatches;
  };
  self.canMoveUp = function($index) {
    if ($scope.selectedNode.catch[$index].default !== undefined) return false;
    return $index > 0;
  };
  self.canMoveDown = function($index) {
    if ($scope.selectedNode.catch[$index].default !== undefined) return false;
    if (self.hasDefault()) return $index < $scope.selectedNode.catch.length - 2;
    return $index < $scope.selectedNode.catch.length - 1;
  };
};

angular.module('apiconnect-assembly').controller('CatchController', ['$scope', CatchController]);

function ErrorFilterController($scope) {
  var self = this;
  self.errors = {
    'ConnectionError': true,
    'SOAPError': true,
    'OperationError': true
  };

  $scope.selectedNode.$$stopOnError = ($scope.selectedNode['stop-on-error'] !== undefined);

  $scope.$watch('selectedNode.$$stopOnError', function() {
    if ($scope.selectedNode.$$stopOnError) {
      if (!$scope.selectedNode['stop-on-error'][0]) $scope.selectedNode['stop-on-error'] = [];
    } else {
      delete $scope.selectedNode['stop-on-error'];
    }
  });

  self.filter = function() {
    var search = this.searchText.toLowerCase();
    return Object.keys(self.errors).filter(function(error) {
      if (error.toLowerCase().indexOf(search) === -1) return false;
      if (!$scope.selectedNode['stop-on-error']) return true;
      return $scope.selectedNode['stop-on-error'].indexOf(error) < 0;
    });
  };
};

angular.module('apiconnect-assembly').controller('ErrorFilterController', ['$scope', ErrorFilterController]);

function CatchBlockController($scope) {
  var self = this;
  self.errors = {
    'ConnectionError': true,
    'JavaScriptError': true,
    'PropertyError': true,
    'RedactionError': true,
    'TransformError': true,
    'RuntimeError': true,
    'SOAPError': true,
    'OperationError': true,
    'BadRequestError': true,
    'UnauthorizedError': true,
    'ForbiddenError': true,
    'ValidateError': true
  };

  // bring in any errors defined on the policies themselves
  if ($scope.policies) {
    $scope.policies.forEach(function(policy) {
      if (policy.errors) {
        policy.errors.forEach(function(error) {
          self.errors[error] = true;
        });
      }
    });
  }

  var unwrapAndFlattenNodes;

  var flattenNodes = function(nodeArray, flattenedModel) {
    nodeArray.forEach(function(node) {
      if (node.$$type === "throw" && node.name) flattenedModel[node.name] = true;
      if (node.execute) unwrapAndFlattenNodes(node.execute, flattenedModel);
      if (node.otherwise) unwrapAndFlattenNodes(node.otherwise, flattenedModel);
      if (node.case) flattenNodes(node.case, flattenedModel);
    });
  };

  unwrapAndFlattenNodes = function(nodeArray, flattenedModel) {
    nodeArray.forEach(function(node) {
      var policyInstance = null;
      Object.keys(node).forEach(function(policyName) {
        policyInstance = node[policyName];
        if (policyInstance.$$type === "throw" && policyInstance.name) flattenedModel[policyInstance.name] = true;
        if (policyInstance.execute) unwrapAndFlattenNodes(policyInstance.execute, flattenedModel);
        if (policyInstance.case) flattenNodes(policyInstance.case, flattenedModel);
      });
    });
  };

  unwrapAndFlattenNodes($scope.nodes, self.errors);

  if (!$scope.catch.default && !$scope.catch.errors) $scope.catch.errors = [];
  if (!$scope.catch.default && !$scope.catch.execute) $scope.catch.execute = [];

  self.filter = function() {
    var search = this.searchText.toLowerCase();
    return Object.keys(self.errors).filter(function(error) {
      if (error.toLowerCase().indexOf(search) === -1) return false;
      // we match, so return true only if the operation isn't used elsewhere already
      for (var i = 0; i < $scope.selectedNode.catch.length; i++) {
        if ($scope.selectedNode.catch[i].default) continue;
        for (var j = 0; j < $scope.selectedNode.catch[i].errors.length; j++) {
          var usedError = $scope.selectedNode.catch[i].errors[j];
          if (error === usedError) return false;
        }
      }
      return true;
    });
  };
  self.isDefault = function() {
    return ($scope.catch.default !== undefined);
  };
};

angular.module('apiconnect-assembly').controller('CatchBlockController', ['$scope', CatchBlockController]);

function ValidationDefinitionController($scope) {
  var definitions = [{
    name: "request"
  },{
    name: "response"
  }];
  if ($scope.swaggerDocument.definitions) {
    Object.keys($scope.swaggerDocument.definitions).forEach(function(definition) {
      definitions.push({name: "#/definitions/" + definition});
    });
  }
  $scope.definitions = definitions;
};

angular.module('apiconnect-assembly').controller('ValidationDefinitionController', ['$scope', ValidationDefinitionController]);

function TLSProfileController($rootScope, $scope, SSLProfile) {
  var tlsProfiles = [];
  var tlsProfile = $scope.selectedNode['tls-profile'];

  if (!$rootScope.offlineMode) {
    SSLProfile.query({orgId: $rootScope.orgId}).$promise.then(function(profiles) {
      profiles.forEach(function(profile) {
        tlsProfiles.push({name: profile.title, value: profile.name});
      });
    });
  }

  this.tlsProfiles = tlsProfiles;

  $scope.$watch("selectedNode['secure-gateway']", function() {
    if ($scope.selectedNode['secure-gateway']) {
      $scope.tlsStyle = { color: '#e0e0e0' };
      tlsProfile = $scope.selectedNode['tls-profile'];
      delete $scope.selectedNode['tls-profile'];
    } else {
      $scope.selectedNode['tls-profile'] = tlsProfile;
      $scope.tlsStyle = {};
    }
  });
};

angular.module('apiconnect-assembly').controller('TLSProfileController', ['$rootScope', '$scope', 'SSLProfile', TLSProfileController]);

function UserRegistryController($rootScope, $scope, UserRegistry) {
    var userRegistries = [];
    if (!$rootScope.offlineMode) {
        UserRegistry.query({orgId: $rootScope.orgId}).$promise.then(function(registries) {
            registries.forEach(function(registry) {
                userRegistries.push({name: registry.title, value: registry.name});
            });
        });
    }
    this.userRegistries = userRegistries;
};

angular.module('apiconnect-assembly').controller('UserRegistryController', ['$rootScope', '$scope', 'UserRegistry', UserRegistryController]);

function SetVariableController($scope) {
  var self = this;
  self.addAction = function() {
    $scope.selectedNode.actions.push({
      set: "",
      value: ""
    });
  };
  self.removeAction = function($index) {
    $scope.selectedNode.actions.splice($index, 1);
  };
};

angular.module('apiconnect-assembly').controller('SetVariableController', ['$scope', SetVariableController]);

function SetVariableActionController($scope) {
  var self = this;

  $scope.valueType = "string";
  if ($scope.action.value !== undefined) {
    if (typeof $scope.action.value === "boolean") {
      $scope.valueType = "boolean";
    } else if (typeof $scope.action.value === "number") {
      $scope.valueType = "number";
    }
  }
  if ($scope.action.add) {
    $scope.actionValue = 'add';
  } else if ($scope.action.clear) {
    $scope.actionValue = 'clear';
  } else {
    $scope.actionValue = 'set';
  }
  var firstWatch = false;
  $scope.$watch('actionValue', function() {
    if (!firstWatch) {
      firstWatch = true;
      return;
    }
    // no value field for a clear
    if ($scope.actionValue === 'clear') {
      delete $scope.action.value;
    }

    // keep any previously entered action value
    ['set', 'add', 'clear'].forEach(function(actionValue) {
      if (actionValue === $scope.actionValue) return;
      if ($scope.action[actionValue] !== undefined) {
        $scope.action[$scope.actionValue] = $scope.action[actionValue];
        delete $scope.action[actionValue];
      }
    });
  });
  self.modifyValue = function() {
    if ($scope.valueType === "boolean" && typeof $scope.action.value !== "boolean") {
      $scope.action.value = true;

    } else if ($scope.valueType === "number" && typeof $scope.action.value !== "number") {
      $scope.action.value = 0;

    } else if ($scope.valueType === "string" && typeof $scope.action.value !== "string") {
      $scope.action.value = "";
    }
  };
};

angular.module('apiconnect-assembly').controller('SetVariableActionController', ['$scope', SetVariableActionController]);

function RedactController($scope) {
  var self = this;
  self.addRedact = function() {
    $scope.selectedNode.actions.push({from: [], action: 'redact'});
  };
  self.removeRedact = function($index) {
    $scope.selectedNode.actions.splice($index, 1);
  };
};

angular.module('apiconnect-assembly').controller('RedactController', ['$scope', RedactController]);

function RedactItemController($scope) {
  this.allFields = function() {
    if (!$scope.action.from) return false;
    return ($scope.action.from.length === 1 && $scope.action.from[0] === 'all');
  };
  $scope.$watch('action.from', function() {
    if (!$scope.action.from) return;
    if ($scope.action.from.indexOf('all') > -1 && $scope.action.from.length > 1) $scope.action.from = ['all'];
  }, true);
};

angular.module('apiconnect-assembly').controller('RedactItemController', ['$scope', RedactItemController]);

