/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const Promise = require('bluebird');
const spawn   = require('child_process').spawn;

const ResolveOn = (emitter, event) => new Promise((resolve, reject) => {
  emitter.on(event, resolve);
});

const run = (cmd, args, opts) => new Promise((resolve, reject) => {
  let cmdstr = [cmd].concat(args).join(' ');

  let stdout = '';
  let stderr = '';

  if (typeof args === 'object' && !Array.isArray(args)) {
    opts = args;
    args = [];
  }

  args = args || [];
  opts = opts || {};

  let inherit = opts.stdio === 'inherit';
  //opts.stdio = 'pipe';

  let child = spawn(cmd, args, opts);

  // If the error promise resolves, we should reject immediately
  let error = ResolveOn(child, 'error').then(reject);

  // Otherwise, wait for the child to exit and for its stdio to close.
  // Reject if the child wrote to stderr or exited with a non-zero status.
  // Resolve otherwise.
  let exit      = ResolveOn(child, 'exit');
  let stdoutEnd = Promise.resolve();
  let stderrEnd = Promise.resolve();

  if (inherit !== true) {
    child.stdout.on('data', data => {
      stdout += data.toString('utf8');
    });

    child.stderr.on('data', data => {
      stderr += data.toString('utf8');
    });

    stdoutEnd = ResolveOn(child.stdout, 'end');
    stderrEnd = ResolveOn(child.stderr, 'end');
  }
  
  Promise.all([exit, stdoutEnd, stderrEnd])
    .timeout(opts.timeout || 60000)
    .then(() => {
      let result = {
        cmd: cmd,
        args: args,
        opts: opts,
        cmdstr: cmdstr,
        stdout: stdout,
        stderr: stderr,
        exitStatus: exit.isFulfilled ? exit.value() : null
      };
      resolve(result);
    })
    .catch(Promise.TimeoutError, () => {
      let err = new Error(`"${cmdstr}" timed-out`);
      err.result = {
        cmd: cmd,
        args: args,
        opts: opts,
        cmdstr: cmdstr,
        stdout: stdout,
        stderr: stderr,
        exitStatus: null //exit.isFulfilled ? exit.value() : null
      };
      reject(err);
    })
    .catch(err => {
      err.result = {
        cmd: cmd,
        args: args,
        opts: opts,
        cmdstr: cmdstr,
        stdout: stdout,
        stderr: stderr,
        exitStatus: null //exit.isFulfilled ? exit.value() : null
      };
      reject(err);
    });
});

module.exports = run;
