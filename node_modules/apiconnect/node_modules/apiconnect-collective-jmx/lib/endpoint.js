// Copyright IBM Corp. 2015,2017. All Rights Reserved.
// Node module: apiconnect-collective-jmx
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var debug = require('../util/debug')('endpoint');
var extend = require('../util/extend');
var mandatory = require('../util/mandatory');
var request = require('request');
var url = require('url');
var util = require('util');

module.exports = Endpoint;

/**
 * Represents a target server and resource to submit requests against.
 * @param {string} host - The IP address of the host.
 * @param {number|string} port - The port to connect to.
 * @param {object=} options - Additional options for function overrides and
 * for request-specific configuration vars.
 * @property {string} options.acceptUnauthorized - Accept unauthorized HTTPS
 * certificates if the server uses them. Common during initial join.
 * @property {string} options.checkServerIdentity - Whether to verify
 * that server's hostname matches the CN in the TLS certificate.
 * Defaults to `true`.
 * @property {string} options.ca - A PEM encoded CA certificate to trust as
 * as an HTTPS certificate issuer.
 * @property {string} options.username - The username used for Basic auth with
 * the endpoint.
 * @property {string} options.password - The password used for Basic auth with
 * the endpoint.
 * @property {string} options.pfx - The client identity.
 * @property {string} options.pfxPassphrase - The pfx passphrase.
 * @property {function} options.request - Inject a request function compatible
 * with the request module (useful for faking calls to a remote target).
 * @constructor
 */
function Endpoint(host, port, options) {
  this.host = mandatory(host, 'missing host');
  this.port = mandatory(port, 'missing port');
  this._request = options.request || request;
  this._options = {
    rejectUnauthorized: !options.acceptUnauthorized,
    json: true,
    agent: false,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  if (options.checkServerIdentity === false) {
    if (/^v0\.10\./.test(process.version)) {
      if (!options.rejectUnauthorized) {
        // Node v0.10 does not support checkServerIdentity
        // We have to fall back to `rejectUnauthorized:false`
        console.warn(
          'Disabling TLS certification validation, because Node v0.10 does ' +
          'not support overriding TLS server identity checks only.');
        options.rejectUnauthorized = true;
      }
    } else {
      options.checkServerIdentity = function(servername, cert) {
        // Accept all identities, return `undefined` meaning "no errors".
        return undefined;
      };
    }
  }

  var o = this._options;

  // Authentication of one form or the other is mandatory.
  if (options.username || options.password) {
    this._options.auth = {
      username: mandatory(options.username),
      password: mandatory(options.password),
    };
    debug('options: %j', this._options);
  } else {
    debug('options: %j', this._options);
    this._options.agentOptions = {
      pfx: mandatory(options.pfx || options.serverIdentity),
      passphrase: mandatory(options.pfxPassphrase),
      checkServerIdentity: options.checkServerIdentity,
    };
    debug('options: pfx length %d passphrase %j',
          o.agentOptions.pfx.length, o.agentOptions.passphrase);
  }

  if (options.ca) {
    // An array of CA PEM is expected.
    this._options.ca = [String(options.ca)];
    debug('options: ca %s', debug.json(this._options.ca[0]));
  }
}

/**
 * Submit JMX requests to target endpoint.
 * @param {Payload} payload  - The JMX payload to submit to the endpoint.
 * @param {object} options - The options object.
 * @param {function} cb - Handle the server's response.
 * */
Endpoint.prototype.request = function(payload, options, cb) {
  if (options) {
    debug('request: extra options %j', options);
  }

  options = extend(this._options, options);

  options.url = url.format({
    hostname: this.host,
    port: this.port,
    protocol: 'https',
    pathname: mandatory(payload.path),
  });
  options.method = mandatory(payload.verb, 'missing payload.verb');
  options.body = mandatory(payload.data, 'missing payload.data');

  debug('request: %s %s', payload.verb, payload.path);
  debug('request: body %s', debug.json(payload.data));

  // XXX(sam) I wouldn't expose the raw response object back to the caller, I
  // would return either an error, or the json response.
  this._request(options, function(err, res, data) {
    if (err) {
      debug('request %s %s error: %s', payload.verb, payload.path, err.message);
      return cb(err);
    }

    if (res.statusCode !== 200) {
      var stackTrace = data && data.stackTrace;

      // If stackTrace is absent, or is zero-length, synthesize a message.
      if (!stackTrace || !stackTrace.length) {
        debug('err: no stack trace, code %d', res.statusCode);
        return cb(new E('Unexpected HTTP Response Code %d', res.statusCode));
      }

      // If stackTrace is not multi-line, use entire trace as a message. Note
      // that stacktraces may use CRLF if controller is running on Windows.
      var match = /^([^\r\n]+)\r?\n/.exec(stackTrace);

      if (!match) {
        debug('err: single-line trace: %j', stackTrace);
        return cb(new E('%s', stackTrace));
      }

      // If it looks like a java stack trace, pull the useable information out
      // of it.
      var message = match[1];
      debug('err: try to parse <%s>', message.substr(0, 300));
      match = /.*Exception: (.*)/.exec(message);
      if (!match) {
        debug('err: unparseable trace: %j', message);
        return cb(new E('%s', message));
      }
      message = match[1];

      debug('err: parsed trace: %j', message);
      return cb(new E('%s', message));

    }

    function E(/* fmt[, ...] */) {
      var message = util.format.apply(null, arguments);
      var err = new Error(message);
      err.statusCode = res.statusCode;
      err.body = data;
      return err;
    }
    util.inherits(E, Error);

    debug('request %s %s ok(%s): %s',
          payload.verb, payload.path, res.statusCode, debug.json(data));
    return cb(null, res, data);
  });
};
