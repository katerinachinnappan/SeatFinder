// Copyright IBM Corp. 2015,2017. All Rights Reserved.
// Node module: apiconnect-collective-jmx
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var Encoder = require('./encoder');
var Payload = require('./payload');
var _ = require('lodash');
var encodeLiberty = require('../util/encode-liberty-path');
var jmxTypes = require('./encoder').types;
var mandatory = require('../util/mandatory');

// MBeans
var APIC_CLUSTER_PATH = '/sys.wlpn.internal';

var CLUSTER_MEMBER =
  'WebSphere%3Afeature%3DclusterMember%2Ctype%3D' +
  'ClusterMember%2Cname%3DClusterMember';

var SCALING_MEMBER = encodeURIComponent(
  'WebSphere:feature=scalingMember,' + 'type=ScalingMember,name=ScalingMember'
);

var CLUSTER_TREE_PATH = '/sys.was.groups/types/cluster';

var CLUSTER_MBEAN_PATH =
  '/IBMJMXConnectorREST/mbeans/' +
  encodeURIComponent(
    'WebSphere:feature=collectiveController,' +
      'type=ClusterManager,name=ClusterManager'
  ) +
  '/operations';

var COLLECTIVE_MBEAN_PATH =
  '/IBMJMXConnectorREST/mbeans/' +
  'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository/operations';

var CREATE =
  '/IBMJMXConnectorREST/mbeans/' +
  'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository' +
  '/operations/create';

var DELETE =
  '/IBMJMXConnectorREST/mbeans/' +
  'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository' +
  '/operations/delete';

var EXISTS =
  '/IBMJMXConnectorREST/mbeans/' +
  'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository' +
  '/operations/exists';

var GET_DESC =
  '/IBMJMXConnectorREST/mbeans/' +
  'WebSphere%3Afeature%3DcollectiveController%2Cname%3DCollectiveRepository' +
  '%2Ctype%3DCollectiveRepository/operations/getDescendantData';

/**
 * Provides functions for creating and deleting application clusters
 * within a Liberty Collective.
 * Utility functions are also available for modifying cluster scaling
 * policies.
 */
module.exports = Cluster;

function Cluster() {}

Cluster._endpoints = {
  APIC_CLUSTER_PATH: APIC_CLUSTER_PATH,
  CLUSTER_MEMBER: CLUSTER_MEMBER,
  CLUSTER_TREE_PATH: CLUSTER_TREE_PATH,
  CREATE: CREATE,
  DELETE: DELETE,
  EXISTS: EXISTS,
  GET_DESC: GET_DESC,
};

/**
 * Create a new cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.CreateCluster = function(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();

  var mbeanResource = '/sys.was.groups/types/cluster/' + options.clusterName;
  encoder.addString(mbeanResource);
  encoder.addSimpleValue(null, null, jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
};

/**
 * Register with a cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.Register = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();

  var tuple = [
    options.hostName.toLowerCase(),
    encodeLiberty(options.userDir),
    options.serverName,
  ].join(',');

  var mbeanResource =
    '/sys.was.groups/types/cluster/' +
    options.clusterName +
    '/sys.members/' +
    tuple;

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(null, null, jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
};

/**
 * Unregister from a cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.Unregister = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();

  var tuple = [
    options.hostName.toLowerCase(),
    encodeLiberty(options.userDir),
    options.serverName,
  ].join(',');

  var mbeanResource =
    '/sys.was.groups/types/cluster/' +
    options.clusterName +
    '/sys.members/' +
    tuple;

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Delete a cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to delete.
 * @memberof Cluster
 */
Cluster.DeleteCluster = function(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();

  var mbeanResource = '/sys.was.groups/types/cluster/' + options.clusterName;
  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Add or change a member's cluster.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.SetMemberClusterMBean = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getClusterMBean(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(
    options.clusterName,
    jmxTypes.String,
    jmxTypes.JavaObject
  );
  return new Payload(CREATE, 'POST', encoder.encodeJson());
};

/**
 * Change a member server's cluster membership on a target collective.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.SetMemberClusterFeature = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getClusterFeature(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(
    options.clusterName,
    jmxTypes.String,
    jmxTypes.JavaObject
  );
  return new Payload(CREATE, 'POST', encoder.encodeJson());
};

/**
 * Remove a member's cluster.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.DeleteMemberClusterMBean = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getClusterMBean(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Remove a member server's cluster membership on a target collective.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 * @memberof Cluster
 */
Cluster.DeleteMemberClusterFeature = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getClusterFeature(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Add or change a member's scaling configuration.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 * @param {string} options.scalingMember - boolean value to set if scalable
 * @memberof Cluster
 */
Cluster.SetMemberScalingMBean = function(options) {
  checkMandatory(options, 'missing options');
  mandatory(options.scalingEnable, 'missing scalingEnable');

  var encoder = new Encoder();
  var mbeanResource = Cluster.getScalingMBean(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(
    options.scalingEnable.toString(),
    jmxTypes.String,
    jmxTypes.JavaObject
  );
  return new Payload(CREATE, 'POST', encoder.encodeJson());
};

/**
 * Change a member server's type of scaling feature.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 * @param {string} options.scalingFeature - type of scaling feature
 * @memberof Cluster
 */
Cluster.SetMemberScalingFeature = function(options) {
  checkMandatory(options, 'missing options');
  mandatory(options.scalingType, 'missing scalingType');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getScalingFeature(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(
    options.scalingType,
    jmxTypes.String,
    jmxTypes.JavaObject
  );
  return new Payload(CREATE, 'POST', encoder.encodeJson());
};

/**
 * Remove a member's auto-scaling feature.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 * @memberof Cluster
 */
Cluster.DeleteMemberScalingMBean = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getScalingMBean(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Remove a member's auto-scaling type.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 * @memberof Cluster
 */
Cluster.DeleteMemberScalingFeature = function(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getScalingFeature(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Retrieve a list of descendant data elements from the CollectiveRepository
 * based on the specified node.
 * @param {string} node - The string that represents the node to query for
 * child nodes, represented in a path-like format.
 * (eg. /sys.was.groups/types/cluster).
 * @returns {object} - A hash of nodes and their values (if applicable).
 * @memberof Cluster
 */
Cluster.GetDescendantData = function(node) {
  var encoder = new Encoder();
  encoder.addString(node);
  return new Payload(GET_DESC, 'POST', encoder.encodeJson());
};
/**
 * Check whether or not the CollectiveRepository node exists.
 * @param {string} node - The string that represents the node to query for
 * child nodes, represented in a path-like format.
 * @returns {object} - A JMX payload for querying a CollectiveRepository.
 * @memberof Cluster
 */
Cluster.Exists = function(node) {
  var encoder = new Encoder();
  encoder.addString(node);
  return new Payload(EXISTS, 'POST', encoder.encodeJson());
};

/**
 * Returns the formatted string that uniquely identifies a server within a
 * Collective.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @return {String} - The encoded identity string.
 * @memberof Cluster
 */
Cluster.formatIdentity = function(options) {
  mandatory(options.hostName, 'options.hostName is required!');
  mandatory(options.userDir, 'options.userDir is required!');
  mandatory(options.serverName, 'options.serverName is required!');

  return [
    options.hostName.toLowerCase(),
    encodeLiberty(options.userDir),
    options.serverName,
  ].join(',');
};

/**
 * Takes a CollectiveRepository tree key (in path-like format) that represents
 * a cluster and returns the cluster name.
 * @param {string} treeKey - The CollectiveRepository key.
 * @returns {string|null} - Returns a name, or null if no name is found.
 * @memberof Cluster
 */
Cluster.getClusterName = function(treeKey) {
  if (!treeKey) return null;
  var match = treeKey.match(/cluster\/(.*)\/sys.members/i);
  return match && match[1] ? match[1] : null;
};

/**
 * Takes a CollectiveRepository tree key (in path-like format) that represents
 * a cluster and returns the cluster name.
 * @param {string} treeKey - The CollectiveRepository key.
 * @returns {string|null} - Returns a server identity,
 * or null if no identity is found.
 * @memberof Cluster
 */
Cluster.getClusterIdentity = function(treeKey) {
  if (!treeKey) return null;
  var match = treeKey.match(/cluster\/sys.members\/(.*)/i);
  // Only the first item matters.
  return match && match[1] ? match[1].split('/')[0] : null;
};

/**
 * Takes a CollectiveRepository tree and returns a list of cluster identities.
 * @param tree - The hash of CollectiveRepository keys.
 * @param clusterName - The name of the cluster to search the keys for.
 * @returns {Array} - An array of cluster member identities.
 * @memberof Cluster
 */
Cluster.listClusterMembers = function(tree, clusterName) {
  mandatory(tree, 'You must provide a non-null tree!');
  mandatory(clusterName, 'You must provide a clusterName parameter!');
  var identities = [];
  var payload;
  // If they pass the entire object, we'll assign the value property to payload.
  if (tree.value) payload = tree.value;
  else payload = tree;
  if (payload) {
    var keys = Object.getOwnPropertyNames(payload);
    _.forEach(keys, function(key) {
      var name = Cluster.getClusterName(key);
      if (name === clusterName) {
        var id = Cluster.getClusterIdentity(key);
        if (id) identities.push(id);
      }
    });
  }
  return identities;
};

/**
 * Find the first key that contains the given server identity.
 * @param tree - The hash of CollectiveRepository keys.
 * @param identity - The name of the server identity to search for.
 * @returns {string|null} - The key which contains the identity, or null if none
 * exists.
 * @memberof Cluster
 */
Cluster.getKeyByIdentity = function(tree, identity) {
  mandatory(tree, 'You must provide a non-null tree!');
  mandatory(identity, 'You must provide an identity!');
  var payload;
  if (tree.value) payload = tree.value;
  else payload = tree;

  var keys = Object.getOwnPropertyNames(payload);
  return _.find(keys, function(key) {
    return _.includes(key, identity);
  });
};

/**
 * Generate the resource string for getClusterMBean operations.
 * @param options
 * @returns {string}
 * @memberof Cluster
 */
Cluster.getClusterMBean = function(options) {
  // Generate the internal resource path (not the URL's path!)
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.mbeans',
    CLUSTER_MEMBER,
    'attributes/Name',
  ].join('/');
  return mbeanResource;
};

/**
 * Generate the resource string for getClusterFeature operations.
 * @param options
 * @returns {string}
 * @memberof Cluster
 */
Cluster.getClusterFeature = function(options) {
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.features/data/clusterMember/name',
  ].join('/');
  return mbeanResource;
};

/**
 * Generate the resource string for scaling MBean operations.
 * @param options
 * @returns {string}
 * @memberof Cluster
 */
Cluster.getScalingMBean = function(options) {
  // Generate the internal resource path (not the URL's path!)
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.mbeans',
    SCALING_MEMBER,
    'attributes/Enabled',
  ].join('/');
  return mbeanResource;
};

/**
 * Gets list of stored data for a cluster.
 * @param clusterName - The name of the cluster identity to search for.
 * @memberof Cluster
 */
Cluster.listClusterData = function(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  var mbeanResource = Cluster.getClusterPath(options);
  encoder.addString(mbeanResource);
  return new Payload(
    [COLLECTIVE_MBEAN_PATH, 'getDescendantData'].join('/'),
    'POST',
    encoder.encodeJson()
  );
};

/**
 * Generate the resource string for scaling feature operations.
 * @param {string} options.hostName - name of host
 * @param {string} options.userDir - directory of server on member host
 * @param {string} options.serverName - name of server
 * @returns {string}
 * @memberof Cluster
 */
Cluster.getScalingFeature = function(options) {
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.features/data/scalingMember/mode/child',
  ].join('/');
  return mbeanResource;
};

/**
 * Generate the resource string for cluster environment path
 * @param {string} options.clusterName - name of cluster
 * @returns {string}
 * @memberof Cluster
 */
// FIXME rename to getClusterEnvPath
Cluster.getClusterPath = function(options) {
  mandatory(options.clusterName, 'clusterName is required!');
  return [APIC_CLUSTER_PATH, 'cluster', options.clusterName, 'env'].join('/');
};

/**
 * Removes path prefix from returned data when getting environment variables.
 * @param {string} options.clusterName - name of cluster
 * @returns {string}
 * @memberof Cluster
 */
Cluster.removeClusterPrefix = function(options, data) {
  mandatory(options.clusterName, 'missing clusterName');
  var path = Cluster.getClusterPath(options);

  var regex = new RegExp(path + '/', 'gi');
  data = JSON.parse(JSON.stringify(data).replace(regex, ''));
  // MBeans always gives us a null value and key is root of path, we clean
  // up by deleting.
  delete data[path];
  return data;
};

/**
 * @private
 */
function checkMandatory(options) {
  mandatory(options.hostName, 'missing hostName');
  mandatory(options.userDir, 'missing userDir');
  mandatory(options.serverName, 'missing serverName');
  mandatory(options.clusterName, 'missing clusterName');
}

/**
 * Starts all members registered to a cluster
 * @param {string} options.clusterName - name of cluster
 * @memberof Cluster
 */
Cluster.startCluster = function(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  encoder.addString(options.clusterName);
  encoder.addString('');
  return new Payload(
    [CLUSTER_MBEAN_PATH, 'startCluster'].join('/'),
    'POST',
    encoder.encodeJson()
  );
};

/**
 * Stops all members registered to a cluster. This is a simple stop, if a
 * scaling policy exists, it may cause all the members to be started again.
 * This is useful, it provides a robust way of implementing "restart" for
 * auto-scaled clusters. If the cluster is auto-scaled, to permanently stop a
 * cluster, a new scalingPolicy must be uplaoded to the controller with an
 * `enabled="false"` attribute.
 * @param {string} options.clusterName - name of cluster
 * @memberof Cluster
 */
Cluster.stopCluster = function(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  encoder.addString(options.clusterName);
  encoder.addString('');
  return new Payload(
    [CLUSTER_MBEAN_PATH, 'stopCluster'].join('/'),
    'POST',
    encoder.encodeJson()
  );
};

/**
 * List all members of a cluster
 * @param {string} options.clusterName - name of cluster
 * @memberof Cluster
 */
Cluster.listMembers = function(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  encoder.addString(options.clusterName);
  return new Payload(
    [CLUSTER_MBEAN_PATH, 'listMembers'].join('/'),
    'POST',
    encoder.encodeJson()
  );
};

/**
 * List all clusters registered with controller
 * @memberof Cluster
 */
Cluster.listClusterNames = function(options) {
  var encoder = new Encoder();
  return new Payload(
    [CLUSTER_MBEAN_PATH, 'listClusterNames'].join('/'),
    'POST',
    encoder.encodeJson()
  );
};
