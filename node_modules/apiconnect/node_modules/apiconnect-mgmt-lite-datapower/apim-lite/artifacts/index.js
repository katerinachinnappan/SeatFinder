/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

let Promise  = require('bluebird');
let fs       = Promise.promisifyAll(require('fs'));
let glob     = Promise.promisify(require('glob'));
let os       = require('os');
let Path     = require('path');
let YAML     = require('js-yaml');
let crypto   = require('crypto');
let logger   = require('../../common/logger');
let Config   = require('../../common/config');
let chokidar = require('chokidar');
let utils    = require('./utils');

const API           = exports.API           = require('./api');
const Product       = exports.Product       = require('./product');
const TLSProfile    = exports.TLSProfile    = require('./tls-profile');
const Subscription  = exports.Subscription  = require('./subscription');
const OAuthProvider = exports.OAuthProvider = require('./oauth-provider');

const FS_WATCHERS = new Map();

let catalog = require('./catalog').defaults();

exports.catalog = catalog;

exports.clear = () => {
  FS_WATCHERS.forEach((watcher, defDir) => {
    logger.log('Unwatching', defDir);
    watcher.close();
  });
  FS_WATCHERS.clear();
  flush();
};

exports.load = readConfigDir;

function flush () {
  logger.log('Flushing artifacts');
  utils.clearPaths();
  API.clear();
  Product.clear();
  TLSProfile.clear();
  Subscription.clear();
  OAuthProvider.clear();
}

function readConfigDir (configDir, emitter) {
  let config = new Config(configDir);

  const watchDefinitions = (defsDir) => {
    if (FS_WATCHERS.has(defsDir))
      return defsDir;

    // Always watch the definitions directory
    let watchPaths = [Path.resolve(defsDir, '*.yaml')];

    let nonexistPaths = [];

    // Determine if it is safe to watch the config files. If so, add them
    let p = Promise.map(config.listConfigs(), path => fs.statAsync(path).then(() => {
      watchPaths.push(path);
    }).catch(err => {
      if (err.code === 'ENOENT') {
        nonexistPaths.push(path);
      } else {
        logger.error(`Could not add watch path ${path}:`, err);
      }
    }));

    // Create the watcher
    return p.then(() => {
      let watcher = chokidar.watch(watchPaths, {
        persistent: true,
        ignoreInitial: true
      });

      FS_WATCHERS.set(defsDir, watcher);

      let debounce = Promise.resolve();
      const doFlush = () => {
        flush();
        logger.log('Reloading', defsDir);
        loadArtifacts(defsDir).then(emitter);
      };

      watcher.on('all', (event, path) => {
        logger.log(`File change: ${path} (${event})`);
        // Debounce until we've gone 250 ms since last file change
        let delay = debounce = debounce
          .then(() => Promise.delay(250))
          .then(() => {
            if (debounce === delay) {
              doFlush();
            }
          });
      });

      // Dynamically dd config files which didn't exist on startup
      if (nonexistPaths.length !== 0) {
        // We need to watch parent directory to get the proper events
        chokidar.watch(nonexistPaths.map(path=>Path.dirname(path)))
          .on('add', path => {
            if (nonexistPaths.indexOf(path) > -1) {
              watcher.add(path);
              doFlush();
            }
          });
      }

      return new Promise((resolve, reject) => {
        let timeout = setTimeout(() => {
          reject(new Error(`Timeout while doing initial scan of files in ${defsDir}`));
        }, 1000 * 60); // 1 min should be enough for initial scan
        watcher.on('error', err => {
          logger.error('Watcher error:', err);
          clearTimeout(timeout);
          reject(err);
        });
        watcher.on('ready', () => {
          logger.debug('Watching the project directory for changes');
          clearTimeout(timeout);
          resolve(defsDir);
        });
      });
    });
  };

  const selectDefinitionsDir = () => {
    let confPath = Path.resolve(configDir);
    let defsPath = Path.resolve(confPath, 'definitions');
    return fs.statAsync(defsPath)
      .then(stat => stat.isDirectory() ? defsPath : confPath)
      .catch(err => confPath)
      .then(defsDir => {
        let normalizedDefsDir = Path.normalize(defsDir);
        process.env.IBM_APICONNECT_APIM_LITE_DEFINITIONS = normalizedDefsDir;
        return normalizedDefsDir;
      });
  };

  const loadyaml = f => new Promise((resolve, reject) => {
    let normalizedPath;
    try {
      normalizedPath = Path.normalize(f);
      logger.log('Loading project artifact', Path.posix.basename(normalizedPath));
      let document = YAML.safeLoad(fs.readFileSync(normalizedPath, 'utf8'));
      resolve({ path: normalizedPath, document: document });
    }
    catch (err) {
      logger.error('Error loading',
                   Path.posix.basename(normalizedPath),
                   ':', err.message || err);
      resolve(null);
    }
  });

  const parseartifacts = data => {
    data.filter(d => !!d).forEach(d => {
      let loaded = false;
      [API, Product, TLSProfile, OAuthProvider].forEach(a => {
        if (d && !loaded && a.isArtifact(d.document)) {
          a.load(d.document, catalog, d.path);
          loaded = true;
        }
      });

      if (!loaded)
        logger.log('Unrecognized file', d);
    });

    Product.adjustForAPIs(catalog);
    return config.load().then(configData => {
      Subscription.generate(catalog, configData);
    });
  };

  const loadArtifacts = defsdir => glob(`${defsdir}/*.yaml`)
    .then(files => Promise.all(files.map(loadyaml)))
    .then(parseartifacts);

  return selectDefinitionsDir()
    .then(watchDefinitions)
    .then(loadArtifacts);
}
