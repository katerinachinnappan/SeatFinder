/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const crypto = require('crypto');
const utils  = require('./utils');
const logger = require('../../common/logger');
const genid  = require('../../common/genid');
const escapeStringRegexp = require('escape-string-regexp');

const APIs = new Map();
const APIbyName = new Map();

exports.isArtifact = d => d.swagger === '2.0';

exports.load = (d, catalog, defPath) => {
  let id   = genid.hash(defPath);

  const APIC_DEV_HOSTIP = process.env.IBM_APICONNECT_APIC_DEV_HOSTIP;
  const DOCKER_HOST     = process.env.IBM_APICONNECT_APIM_LITE_DOCKER_HOST || '127.0.0.1';
  const API_PORT        = process.env.PORT;

  const DEFAULT_PROPERTIES = {
    'catalog.host': DOCKER_HOST + (API_PORT ? `:${API_PORT}` : ''),
    'catalog.apic-dev.hostip': APIC_DEV_HOSTIP,
    'TARGET_URL': process.env.TARGET_URL
  };

  // Always rewrite the host to point to the Gateway
  d.host = DEFAULT_PROPERTIES['catalog.host'];

  resolveVariables(d, DEFAULT_PROPERTIES);

  let api = APIs.get(id);
  if (!api) {
    api = generate(d, catalog, id);
    APIs.set(api.id, api);
    let info = api.document.info;
    APIbyName.set(info['x-ibm-name'] + ':' + info.version, api);
    utils.addPath(api.id, defPath);
    logger.debug('Loaded API ' + utils.nameVers(api));
  }
  else {
    api.document = d;
    logger.debug('Reloaded API ' + utils.nameVers(api));
  }
};

exports.delete = id => {
  // If `id` isn't in the Map, assume it's the definition path
  return APIs.delete(id) || APIs.delete(genid.hash(id));
};

exports.clear = () => {
  APIs.clear();
};

exports.get = id => APIs.get(id);

exports.getByName = name => APIbyName.get(name);

exports.size = () => APIs.size;

exports.array = () => Array.from(APIs.values());

function generate (document, catalog, id) {
  id = id || genid();
  return {
    'id': id,
    'url': `https://mgmt-lb:2443/v1/catalogs/${catalog.id}/apis/${id}`,
    'state': 'running',
    'organization': catalog.organization,
    'catalog': catalog,
    'spaces': catalog.spaces,
    'document': document
  };
};

function rewriteVariables (document, variables) {
  variables = variables || {};
  const writers = Object
    .keys(variables)
    .map(k => variableWriter(k, variables[k]));

  rewrite(document);

  function rewrite (obj) {
    Object.keys(obj).forEach(k => {
      let child = obj[k];
      if (typeof child === 'object' && child !== null)
        rewrite(child);
      else if (typeof child === 'string') {
        obj[k] = writers.reduce((str, writer) => writer(str), child);
      }
    });
  }
}

function variableWriter (name, value) {
  const pattern = `$(${name})`;
  const regex = new RegExp(escapeStringRegexp(pattern), 'g');
  // Don't replace with an empty string
  value = ('' + value) || pattern;
  return str => str.replace(regex, value);
}

function getApicDevProperties (document, hoist) {
  let cfg = document['x-ibm-configuration'];
  if (cfg !== undefined) {
    let catalogs = cfg.catalogs;
    let apicdev  = catalogs && catalogs['apic-dev'];
    apicdev = apicdev && apicdev.properties || {};
    delete cfg.catalogs;
    if (hoist === true && Object.keys(apicdev).length > 0) {
      if (cfg.properties === undefined)
        cfg.properties = {};
      Object.assign(cfg.properties, apicdev);
    }
    return apicdev;
  }
  return {};
}

function resolveVariables (document, variables) {
  const VARIABLES = Object.assign({}, variables);

  const apicdev = getApicDevProperties(document, true);
  rewriteVariables(apicdev, VARIABLES);

  Object.assign(VARIABLES, apicdev);
  rewriteVariables(document, VARIABLES);
}

