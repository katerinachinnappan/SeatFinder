/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const _      = require('lodash');
const crypto = require('crypto');
const Path   = require('path');
const utils  = require('./utils');
const logger = require('../../common/logger');
const genid  = require('../../common/genid');

const API = require('./api');

const PRODUCTS = new Map();

exports.isArtifact = d => typeof d.product === 'string';

exports.load = (d, catalog, defPath) => {
  let id   = genid.hash(defPath);

  let product = PRODUCTS.get(id);
  if (!product) {
    product = generate(d, catalog, id);
    PRODUCTS.set(product.id, product);
    utils.addPath(product.id, defPath);
    logger.debug('Loaded Product ' + utils.nameVers(product));
  }

  else {
    product.document = d;
    logger.debug('Reloaded Product ' + utils.nameVers(product));
  }
};

exports.delete = id => {
  // If `id` isn't in the Map, assume it's the definition path
  return PRODUCTS.delete(id) || PRODUCTS.delete(genid.hash(id));
};

exports.clear = () => {
  PRODUCTS.clear();
};

exports.get = id => PRODUCTS.get(id);

exports.size = () => PRODUCTS.size;

exports.array = () => Array.from(PRODUCTS.values());

function generate (document, catalog, id) {
  id = id || genid();
  document.apis = document.apis || {};
  return {
    'id': id,
    'url': `https://mgmt-lb:2443/v1/catalogs/${catalog.id}/products/${id}`,
    'state': 'published',
    'visibility': {
      'view': {
        'enabled': true,
        'type': 'public',
        'tags': [],
        'orgs': []
      },
      'subscribe': {
        'enabled': true,
        'type': 'authenticated',
        'tags': [],
        'orgs': []
      }
    },
    'organization': catalog.organization,
    'catalog': catalog,
    'spaces': catalog.spaces,
    'document': document
  };
}

exports.adjustForAPIs = catalog => {
  let APIwithProduct = new Set();
  exports.array().forEach(p => {
    Object.keys(p.document.apis).forEach(k => {
      let api = p.document.apis[k];
      let apiPath = Path.resolve(Path.dirname(utils.getPath(p.id)), api.$ref);
      let apiObj = API.get(utils.getId(apiPath));
      if (apiObj) {
        APIwithProduct.add(apiObj.id);
        api.name = utils.nameVers(apiObj);
      } else {
        logger.log('Product refers to a none existing api', p.document.api);
        api.name = api.$ref.replace('_', ':').replace('.yaml', '');
      }
      delete api.$ref;
    });
  });

  API.array().forEach(a => {
    if (!APIwithProduct.has(a.id)) {
      let apiPath = utils.getPath(a.id);
      let prodPath = Path.resolve(Path.dirname(apiPath),
                      Path.basename(apiPath).replace('_', '-product_'));
      let name = utils.realName(a);
      let prodDoc = _.cloneDeep(DEFAULT_PRODUCT);
      prodDoc.info.name = `${name}-product`;
      prodDoc.info.title = `${name} product`;
      prodDoc.apis[`${name}`] = {
        'name': utils.nameVers(a)
      };
      exports.load(prodDoc, catalog, prodPath);
    }
  });
};

const DEFAULT_PRODUCT = {
  'product': '1.0.0',
  'info': {
    'version': '1.0.0'
  },
  'apis': {
  },
  'visibility': {
    'view': {
      'type': 'public'
    },
    'subscribe': {
      'type': 'authenticated'
    }
  },
  'plans': {
    'default': {
      'title': 'Default Plan',
      'description': 'Default Plan',
      'approval': false,
      'rate-limit': {
        'value': '100/hour',
        'hard-limit': false
      }
    }
  }
};

