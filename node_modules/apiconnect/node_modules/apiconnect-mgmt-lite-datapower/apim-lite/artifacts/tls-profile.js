/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const fs     = require('fs');
const path   = require('path');
const crypto = require('crypto');
const utils  = require('./utils');
const logger = require('../../common/logger');
const genid  = require('../../common/genid');

const TLSProfiles = new Map();
const TLSProfileNames = new Set();
const DefPaths = new Map();

exports.isArtifact = d => {
  /* eslint-disable operator-linebreak */
  return (typeof d.name === 'string'
       && typeof d.title === 'string'
       && typeof d.public === 'boolean'
       && Array.isArray(d.ciphers)
       && Array.isArray(d.protocols)
       && Array.isArray(d.features)
       && Array.isArray(d.certs)
       && (d.certs.length === 0 || (
         typeof d.certs[0].name === 'string'
         && (typeof d.certs[0].cert === 'string' || (
             typeof d.certs[0].cert === 'object'
             && typeof d.certs[0].cert.$ref === 'string'))
         && typeof d.certs[0]['cert-type'] === 'string'
       ))
       &&  typeof d['mutual-auth'] === 'boolean'
       && (typeof d['private-key'] === 'string' || (
           typeof d['private-key'] === 'object'
           && typeof d['private-key'].$ref === 'string'))
  );
  /* eslint-enable operator-linebreak */
};

exports.load = (d, catalog, defPath) => {
  let id = genid.hash(defPath);
  let tlsprofile = generate(d, catalog, id);
  utils.addPath(tlsprofile.id, defPath);

  if (!TLSProfiles.has(id)) {
    TLSProfiles.set(tlsprofile.id, tlsprofile);
    TLSProfileNames.add(tlsprofile.name);
    catalog['tls-profile'].count = TLSProfiles.size;
    logger.debug('Loaded TLS Profile', tlsprofile.name);
  }

  else {
    let old = TLSProfiles.get(id);
    TLSProfileNames.delete(old.name);
    TLSProfiles.set(id, tlsprofile);
    TLSProfileNames.add(tlsprofile.name);
    logger.debug('Reloaded TLS Profile', tlsprofile.name);
  }
};

exports.delete = id => {
  // If `id` isn't in the Map, assume it's the definition path
  let tlsprofile = TLSProfiles.get(id) || TLSProfiles.get(genid.hash(id));
  if (!tlsprofile)
    return false;
  TLSProfiles.delete(tlsprofile.id);
  TLSProfileNames.delete(tlsprofile.name);
  return true;
};

exports.clear = () => {
  TLSProfiles.clear();
  TLSProfileNames.clear();
};

exports.get = id => TLSProfiles.get(id);

exports.size = () => TLSProfiles.size;

exports.array = () => Array.from(TLSProfiles.values());

function generate (provided, catalog, id) {
  id = id || provided.id || genid();

  let generated = {
    'id': id,
    'url': `https://mgmt-lb:2443/v1/catalogs/${catalog.id}/tls-profiles/${id}`,
    'org-id': catalog.organization.id
  };

  let combined = Object.assign(generated, provided);
  let defsDir = process.env.IBM_APICONNECT_APIM_LITE_DEFINITIONS;

  combined._name = `${catalog.organization.name}-${combined.name}`;

  combined.certs = combined.certs.map(data => {
    let cert = data.cert;
    if (typeof cert === 'object') {
      let $ref = cert.$ref;
      let certpath = path.isAbsolute($ref) ?
        $ref : path.resolve(defsDir, $ref);
      data.cert = fs.readFileSync(certpath, 'utf-8');
    }
    return data;
  });

  if (typeof combined['private-key'] === 'object') {
    let $ref = combined['private-key'].$ref;
    let keypath = path.isAbsolute($ref) ?
      $ref : path.resolve(defsDir, $ref);
    combined['private-key'] = fs.readFileSync(keypath, 'utf-8');
  }

  return combined;
};

