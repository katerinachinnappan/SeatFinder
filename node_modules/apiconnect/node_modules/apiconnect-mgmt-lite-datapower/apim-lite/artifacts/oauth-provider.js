/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const fs     = require('fs');
const path   = require('path');
const crypto = require('crypto');
const utils  = require('./utils');
const logger = require('../../common/logger');
const genid  = require('../../common/genid');
const apic2dp = require('apiconnect-config-to-datapower');

const OAuthProviders = new Map();
const OAuthProviderNames = new Set();

exports.isArtifact = d => {
  /* eslint-disable operator-linebreak */
  if (process.env.IBM_APICONNECT_APIM_LITE_EXPERIMENTAL !== 'true')
    return false;
  let apicTokenSecret = d['apic-token-secret'];
  return (typeof d.name === 'string'
       && typeof d.title === 'string'
       && typeof d['provider-type'] === 'string'
       && typeof d['apic-authorize-endpoint'] === 'string'
       && typeof d['apic-token-endpoint'] === 'string'
       && (apicTokenSecret === undefined
           || apicTokenSecret === null
           || (typeof apicTokenSecret === 'object'
             && typeof apicTokenSecret.name === 'string'
             && (apicTokenSecret.key === undefined
             ||  typeof apicTokenSecret.key === 'string'
             || (typeof apicTokenSecret.key === 'object'
                 && typeof apicTokenSecret.key.$ref === 'string'))))
       && Array.isArray(d.grants)
       && (d.grants.length === 0 || typeof d.grants[0] === 'string')
       && typeof d['apic-access-token-ttl'] === 'number'
       && typeof d['apic-maximum-consent-ttl'] === 'number'
       //&& Array.isArray(d.scopes)
       //&& (d.scopes.length === 0 || (
       //  typeof d.scopes[0].name === 'string'
       //  // && typeof d.scopes[0].description === 'string'
       //))
       //&& (!d['apic-refresh-token'] || typeof d['apic-refresh-token'] === 'number')
       //&& (!d['apic-refresh-token-ttl'] || typeof d['apic-refresh-token-ttl'] === 'number')

       // Additional optional parameters:
       //  apic-enable-introspection: true or false (default is false)
       //  apic-introspect-endpoint: /oauth2/introspect  <-- This is the default value
       //  clients:
       //    - confidential
       //    - public
       //  apic-enable-refresh-token: true or false (default is false)
       //  apic-refresh-token-ttl: 3600 <-- default value
       //  apic-refresh-token-limit: 10  <--- default value
  );
  /* eslint-enable operator-linebreak */
};

exports.load = (d, catalog, defPath) => {
  let id = genid.hash(defPath);
  let oap = generate(d, catalog, id);
  utils.addPath(oap.id, defPath);

  if (!OAuthProviders.has(id)) {
    OAuthProviders.set(oap.id, oap);
    OAuthProviderNames.add(oap.name);
    logger.debug('Loaded OAuth Provider', oap.name);
  }

  else {
    let old = OAuthProviders.get(id);
    OAuthProviderNames.delete(old.name);
    OAuthProviders.set(id, oap);
    OAuthProviderNames.add(oap.name);
    logger.debug('Reloaded OAuth Provider', oap.name);

    /*
     * Per discussion with @belyi, we will not remove old APIs so users do not lose any
     * work. This way users can just replace the newly created `${oap.name}-api.yaml` with
     * the `${old.name}-api.yaml` file.
     *
     * We should improve this behavior
     */
    //if (oap.name !== old.name) {
    //  let oldApiFilePath = path.resolve(path.dirname(defPath), `${old.name}-api.yaml`);
    //  if (fs.existsSync(oldApiFilePath)) {
    //    fs.unlinkSync(oldApiFilePath);
    //  }
    //}
  }

  let options = {
    catalog: catalog,
    gatewayName: 'tkgw',
    routingPrefix: '/'
  };
  let compiled = apic2dp.compileOAuthProvider(oap, options);
  oap._cfg = compiled.cfg;
  oap._tokenSecret = compiled.tokenSecret;
  let oapApiFilePath = path.resolve(path.dirname(defPath), `${oap.name}-api.yaml`);
  if (!fs.existsSync(oapApiFilePath)) {
    fs.writeFileSync(oapApiFilePath, compiled.api, 'utf-8');
  }
};

exports.delete = id => {
  // If `id` isn't in the Map, assume it's the definition path
  let oap = OAuthProviders.get(id) || OAuthProviders.get(genid.hash(id));
  if (!oap)
    return false;
  OAuthProviders.delete(oap.id);
  OAuthProviderNames.delete(oap.name);
  return true;
};

exports.clear = () => {
  OAuthProviders.clear();
  OAuthProviderNames.clear();
};

exports.get = id => OAuthProviders.get(id);

exports.size = () => OAuthProviders.size;

exports.array = () => Array.from(OAuthProviders.values());

function generate (document, catalog, id) {
  id = id || document.id || genid();
  document.id = id;

  let defsDir = process.env.IBM_APICONNECT_APIM_LITE_DEFINITIONS;

  document.scopes = document.scopes || {};

  // FIXME this temporarily compensates for an error in how OAuth Provider definitions are generated
  ['authorize', 'token'].forEach(k => {
    let key = `apic-${k}-endpoint`;
    let val = document[key];
    if (val[0] !== '/')
      document[key] = '/' + val;
  });

  // Toolkit only... Just need something
  let defaultKey = '0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

  let apicTokenSecret = document['apic-token-secret'];
  let key = apicTokenSecret.key;
  if (!key || (typeof key !== 'string' && !key.$ref)) {
    // FIXME this temporarily compensates for an error in how OAuth Provider definitions are generated
    key = {
      $ref: apicTokenSecret.name
    };
  }

  if (typeof key === 'object' && typeof key.$ref === 'string') {
    let $ref = key.$ref;
    let keypath = path.isAbsolute($ref) ?
        $ref : path.resolve(defsDir, $ref);
    if (fs.existsSync(keypath))
      key = fs.readFileSync(keypath, 'utf-8');
    else {
      key = defaultKey;
      fs.writeFileSync(keypath, defaultKey, 'utf-8');
    }
  }

  apicTokenSecret.key = key;

  return document;
}
