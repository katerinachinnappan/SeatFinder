#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

// Node module: apiconnect-mgmt-lite-datapower

'use strict';

process.env.IBM_APICONNECT_APIM_LITE_EXPERIMENTAL = 'true';

let Promise    = require('bluebird');
let pem        = require('pem');

let artifacts = require('./artifacts');
let logger = require('../common/logger');
let fs = require('fs-extra');
let path = require('path');
let apic2dp = require('apiconnect-config-to-datapower');

const CONFIG_DIR = process.env.CONFIG_DIR || process.cwd();
const dir = '/tmp/generated';
const localDir = path.resolve(dir, 'local');
const certDir = path.resolve(dir, 'usrcerts');

const app = require('./apim-app');

function writeCertFile(url, data) {
  let outputFile = path.resolve(certDir, url.replace(/^cert:(\/{2,3})?/, ''));
  fs.ensureDirSync(path.dirname((outputFile)));
  fs.writeFileSync(outputFile, data);
}

let generatedCertificate;

const createCertificate = () => new Promise((resolve, reject) => {
  if (generatedCertificate)
    return resolve(generatedCertificate);
  pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) => {
    if (err) {
      logger.error(err);
      return reject(err);
    }
    let options = {
      key: keys.serviceKey,
      cert: keys.certificate
    };
    generatedCertificate = options;
    resolve(options);
  });
});

let ee = () => createCertificate().then(cert => new Promise((resolve, reject) => {
  let apis = artifacts.API.array().map(api => api.document);
  let products = artifacts.Product.array().map(p => p.document);
  let subscriptions = artifacts.Subscription.array();
  let tlsProfiles = artifacts.TLSProfile.array();
  let oauthProviders = artifacts.OAuthProvider.array();
  let _artifacts = {
    apis: apis.length !== 0 ? apis : null,
    products: products.length !== 0 ? products : null,
    subscriptions: subscriptions.length !== 0 ? subscriptions : null,
    'tls-profiles': tlsProfiles.length !== 0 ? tlsProfiles : null,
  };
  let options = {
    catalog: artifacts.catalog,
    gatewayName: 'tkgw',
    routingPrefix: '/',
    port: 9443,
    https: {
      port: 9443,
      cert: {
        ignoreExpiration: true,
        data: cert.cert
      },
      key: {
        data: cert.key
      }
    }
  };

  let result = apic2dp.compileArtifacts(_artifacts, options);
  let oapCfgs = oauthProviders.filter(oap => !!oap._cfg).map(oap => oap._cfg);
  let oapTokenSecrets = oauthProviders.filter(oap => !!oap._tokenSecret).map(oap => oap._tokenSecret);

  result.files.forEach(f => {
    let name = f.location.replace(/^local:(\/{2,3})?/, '');
    let location = path.resolve(localDir, path.normalize(name));
    fs.ensureDirSync(path.dirname(location));
    fs.writeFileSync(location, f.content);
  });
  (result.privateKeys || []).forEach(k => writeCertFile(k.url, k.key));
  (result.publicCerts || []).forEach(c => writeCertFile(c.url, c.cert));
  (result.trustStores || []).forEach(c => writeCertFile(c.url, c.cert));
  (oapTokenSecrets    || []).forEach(s => writeCertFile(s.url, s.key));

  let cfg = oapCfgs.concat(result.cfg).join('\n');

  fs.ensureDirSync(localDir);
  fs.writeFileSync(
    path.resolve(localDir, `${artifacts.catalog.name}.cfg`), cfg);

  resolve();
}));

function start () {
  return artifacts.load(CONFIG_DIR, ee)
    .then(() => app.start())
    .then(ee)
    .then(() => Promise.delay(10 * 1000))
    .then(() => {
      logger.log('DataPower API Connect Gateway is on-line');
    });
}

exports.start = start;

if (require.main === module)
  start().catch(err => {
    logger.error(err);
    logger.error('Exiting with 1');
    process.exit(1);
  });
