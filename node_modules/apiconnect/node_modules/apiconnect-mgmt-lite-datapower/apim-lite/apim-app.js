#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

// Node module: apiconnect-mgmt-lite-datapower

'use strict';

let Promise    = require('bluebird');
let pem        = require('pem');
let https      = require('https');
let bodyParser = require('body-parser');
let express    = require('express');
let crypto     = require('crypto');

let artifacts = require('./artifacts');
let logger = require('../common/logger');
let fs = require('fs');
let path = require('path');
let apic2dp = require('apiconnect-config-to-datapower');
let apigw = require('apiconnect-apigateway-framework');

const CONFIG_DIR = process.env.CONFIG_DIR || process.cwd();

let app = exports = module.exports = express();

app.use((req, res, next) => {
  logger.debug(req.method, req.path);
  next();
});

let onDataPowerReady = () => Promise.resolve();
let datapowerReady = false;
app.get('/v1/catalogs/status', (req, res) => {
  // Flush the document cache once to pre-warm the DataPower
  // REST management interface as the initial request takes
  // over 20 seconds.
  if (!datapowerReady) {
    onDataPowerReady();
    datapowerReady = true;
  }
  res.set('Content-Type', 'application/xml');
  res.send(['<?xml version="1.0"?>', '<status>ok</status>'].join('\n'));
});

app.head('/v1/catalogs/cloud-metadata', (req, res) => {
  res.sendStatus(200);
});

app.get('/v1/catalogs/cloud-metadata', (req, res) => {
  res.send(require('./artifacts/cloud-metadata.json'));
});

app.get('/v1/catalogs', (req, res) => {
  let catalogs = [artifacts.catalog];
  res.send(catalogs);
});

app.get('/v1/catalogs/:catalogid/tls-profiles', (req, res) => {
  let tlsprofiles = artifacts.TLSProfile.array();
  res.send(tlsprofiles);
});

app.get('/v1/catalogs/:catalogid/products', (req, res) => {
  let products = artifacts.Product.array();
  res.send(products);
});

app.get('/v1/catalogs/:catalogid/subscriptions', (req, res) => {
  let subscriptions = artifacts.Subscription.array();
  res.send(subscriptions);
});

app.get('/v1/catalogs/:catalogid/managed-objects', (req, res) => {
  res.send([]);
});

app.get('/v1/catalogs/:catalogid/registries', (req, res) => {
  res.send([]);
});

app.get('/v1/catalogs/:catalogid/apis', (req, res) => {
  let apis = artifacts.API.array();
  res.send(apis);
});

app.get('/v1/catalogs/:catalogid/apis/:apiid', (req, res) => {
  let api = artifacts.API.get(req.params.apiid);
  if (!api)
    res.sendStatus(404);
  else
    res.send(api);
});

app.get('/apigateway.zip', (req, res) => {
  let custom = path.resolve(CONFIG_DIR, 'apigateway.zip');
  if (fs.existsSync(custom)) {
    let hash = crypto.createHash('sha1');
    let stream = fs.createReadStream(custom);
    stream.on('data', function (data) {
      hash.update(data, 'utf8');
    });
    stream.on('end', function () {
      let sha1 = hash.digest('hex');
      logger.log(`Using project specific API Gateway framework (sha1: ${sha1})`);
    });
    res.sendFile(custom);
  } else {
    apigw().then(buf => {
      res.set('Content-Type', 'application/zip');
      res.send(buf);
    });
  }
});

app.use('/x2020/v1/events/monitoringevent', (req, res) => {
  res.sendStatus(200);
});

app.use('/x2020/v1/events/_bulk',
  bodyParser.text({ type: () => { return true; } }),  // do not parse the body
  (req, res) => {
    req.body.split('\n').forEach(tx => {
      if (tx.length < 5) return;
      try {
        let r = JSON.parse(tx);
        if (r.requestMethod)
          logger.log(`${r.requestMethod} ${r.uriPath} ${r.statusCode}, ` +
                     `Transaction ID ${r.transactionId}, ` +
                     `Latency ${r.timeToServeRequest} ms, ${r.resourceId}`);
      } catch (err) {
        logger.error('Failed to parse transaction record:', err.message || err, req.body);
      }
    });
    res.sendStatus(200);
  }
);

let server;

const createCertificate = () => new Promise((resolve, reject) => {
  pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) => {
    if (err) {
      logger.error(err);
      return reject(err);
    }
    let options = {
      key: keys.serviceKey,
      cert: keys.certificate
    };
    resolve(options);
  });
});

function start (onDpReady) {
  if (typeof onDpReady === 'function')
    onDataPowerReady = onDpReady;
  return createCertificate().then(options => {
    server = https.createServer(options, app).listen(2443);
  });
}

exports.start = start;
