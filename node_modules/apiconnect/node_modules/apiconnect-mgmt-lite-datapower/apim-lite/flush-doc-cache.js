/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

let Promise = require('bluebird');
let https   = require('https');
let artifacts = require('./artifacts');
let logger = require('../common/logger');
let fs = Promise.promisifyAll(require('fs-extra'));
let path = require('path');
let apic2dp = require('apiconnect-config-to-datapower');

const rmiRequest = (method, path, bodyobj, debugMsg) => new Promise((resolve, reject) => {
  logger.debug(debugMsg);

  let options = {
    hostname: 'datapower-api-gateway',
    port: 5554,
    path: path,
    method: method,
    auth: 'admin:admin',
    rejectUnauthorized: false,
    headers: {
      'Content-Type': 'application/json'
    }
  };

  let bodystr = JSON.stringify(bodyobj);

  let req = https.request(options, res => {
    logger.debug(`${debugMsg} status: ${res.statusCode}`);
    resolve(res.statusCode);
  });

  req.on('error', err => {
    reject(err);
  });

  req.write(bodystr, 'utf8');

  req.end();
});

const flush = xmlmgr => rmiRequest('POST', '/mgmt/actionqueue/apiconnect',
  {
    FlushDocumentCache: {
      XMLManager: xmlmgr,
      MatchPattern: '*'
    }
  },
  `Flush doc cache: ${xmlmgr}`
);

const createUpdateConfig = (type, name, props) => {
  var bodyobj = { [type]: Object.assign(props, { name: name }) };
  return rmiRequest('POST', `/mgmt/config/apiconnect/${type}`, bodyobj, `Create ${type}: ${name}`)
    .then(rc => {
      // retry with update if create request returns 'invalid state' error code.
      if (rc === 409)
        return rmiRequest('PUT', `/mgmt/config/apiconnect/${type}/${name}`, bodyobj, `Update ${type}: ${name}`);
    });
};

const createKey = (name, url) => createUpdateConfig('CryptoKey', name,
  {
    Filename: url
  }
);

const createCert = (name, url) => createUpdateConfig('CryptoCertificate', name,
  {
    Filename: url
  }
);

const createIdentCred = (name, key, cert) => createUpdateConfig('CryptoIdentCred', name,
  {
    Key: key,
    Certificate: cert
  }
);

const createValCred = (name, trustStore) => createUpdateConfig('CryptoValCred', name,
  {
    Certificate: trustStore.map(c => { return {value: c._name}; })
  }
);

const createSSLClient = (name, sslclient) => {
  var request = {
    Protocols: sslclient.protocols.split('+').reduce((r, v) => {
      r[v] = 'on';
      return r;
    }, {}),
    Ciphers: sslclient.ciphers,
    Idcred: `${name}-idcred`,
    SSLClientFeatures: {}
  };
  if (sslclient.mutualAuth) {
    request.ValidateServerCert = 'on';
    request.Valcred = `${name}-valcred`;
  } else {
    request.ValidateServerCert = 'off';
  }
  if (sslclient.useSNI) {
    request.SSLClientFeatures['use-sni'] = 'on';
  }

  return createUpdateConfig('SSLClientProfile', name, request);
};

function generateTLSProfiles() {
  let profiles = artifacts.TLSProfile.array();
  if (profiles.length == 0)
    return Promise.resolve();
  let dir = '/tmp/generated';
  logger.debug('Generating TLS profile configurations to', dir);

  function writeFile(url, data) {
    let outputFile = path.resolve(dir, url.replace(/^cert:(\/{2,3})?/, ''));
    return fs.writeFileAsync(outputFile, data);
  }

  return Promise.resolve(fs.ensureDirAsync(dir))
    .then(() => Promise.map(profiles, profile => {
      let r = apic2dp.compileTLSProfile(profile,
        {
          catalog: artifacts.catalog
        });
      let p = Promise.resolve();
      if (r.privateKey)
        p = p.then(() => writeFile(r.privateKey.url, r.privateKey.key)
          .then(() => createKey(r.privateKey._name, r.privateKey.url)));
      if (r.publicCert)
        p = p.then(() => writeFile(r.publicCert.url, r.publicCert.cert)
          .then(() => createCert(r.publicCert._name, r.publicCert.url)));
      if (r.privateKey && r.publicCert)
        p = p.then(() => createIdentCred(`${profile._name}-idcred`, r.privateKey._name, r.publicCert._name));
      if (r.trustStores && r.trustStores.length > 0)
        p = p.then(() => Promise.map(r.trustStores, c => writeFile(c.url, c.cert)
          .then(() => createCert(c._name, c.url))))
          .then(() => createValCred(`${profile._name}-valcred`, r.trustStores));
      p = p.then(() => createSSLClient(profile._name, r.sslclient));
      return p;
    }));
}

module.exports = () => {
  if (process.env.APICONNECT_MGMT_LITE_NO_DATAPOWER) {
    return Promise.resolve();
  }
  return flush('webapi-internal')
    .then(() => flush('webapi'))
    .then(() => generateTLSProfiles())
    .then(() => {
      logger.log('DataPower API Connect Gateway is on-line');
    })
    .catch(err => {
      logger.error('Error while flushing doc cache:', err);
      logger.error('Continuing');
    });
};
