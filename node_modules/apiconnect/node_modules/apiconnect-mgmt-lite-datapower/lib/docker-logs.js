/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const _       = require('lodash');
const Promise = require('bluebird');
const Stream  = require('stream');
const ll      = require('../common/log-level');

const DP_TO_APIC_LEVEL_MAP = {
  debug   : 'debug',
  info    : 'info',
  notice  : 'info',
  warn    : 'warn',
  error   : 'error',
  severe  : 'error',
  critical: 'fatal',
  fatal   : 'fatal'
};

const LOG_LEVELS = ll.LOG_LEVELS;
const LOG_LEVEL  = ll.LOG_LEVEL;

const LOG_TIMESTAMP = process.env.LOG_TIMESTAMP === 'true' || process.env.LOG_TIMESTAMP === '1';
const LOG_ANSI_STYLES = process.env.LOG_ANSI_STYLES === 'true' || process.env.LOG_ANSI_STYLES === '1';

const parseTimestamp = ts => {
  let regex = /(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2}).(\d{3})Z/;
  let date;
  ts.replace(regex, function () {
    let year  = arguments[1];
    let month = arguments[2];
    let day   = arguments[3];
    let hour  = arguments[4];
    let min   = arguments[5];
    let sec   = arguments[6];
    let ms    = arguments[7];
    date = Date.UTC(year, month, day, hour, min, sec, ms);
  });
  return date;
};

const dpregex = (() => {
  let ts = '(\\d{8}T\\d{6}\\.\\d{3}Z)';
  let category = '\\[([^\\]]+)\\]';
  let categories = `(?:${category})?${category.repeat(3)}`;
  return new RegExp(`${ts} ${categories}`);
})();

const parseDpMsg = msg => {
  let parsed = null;
  msg.replace(dpregex, function () {
    let matched   = arguments[0];
    let timestamp = arguments[1];
    let domain    = arguments[2];
    let msgid     = arguments[3];
    let source    = arguments[4];
    let level     = arguments[5];
    parsed = {
      type: 'datapower',
      timestamp: parseTimestamp(timestamp),
      level: DP_TO_APIC_LEVEL_MAP[level] || 'debug',
      messageid: msgid,
      message: msg
    };
  });
  return parsed;
};

const apimLiteRegex = (() => {
  let ts = '(\\d{8}T\\d{6}\\.\\d{3}Z)';
  let level = '\\[([^\\]]+)\\]';
  return new RegExp(`${ts} \\[apim-lite\\]${level}`);
})();

const parseApimLiteMsg = msg => {
  let parsed = null;
  msg.replace(apimLiteRegex, function () {
    let matched   = arguments[0];
    let timestamp = arguments[1];
    let level     = arguments[2];
    parsed = {
      type: 'apim-lite',
      timestamp: parseTimestamp(timestamp),
      level: level,
      message: msg
    };
  });
  return parsed;
};

let filterState = 0;
let filterBlacklist = ['0x00340018'];
let filterWhitelist = ['0x8040001c', '0x8100003b'];
const filterlog = msg => {
  if (msg.type === 'datapower') {
    if (filterState < 2) {
      let msgid = msg.messageid;
      if (msgid === '0x8100003b') {
        filterState += 1;
        return true;
      }
      if (_.includes(filterWhitelist, msgid))
        return true;
      if (msg.level >= LOG_LEVELS.error && !_.includes(filterBlacklist, msgid))
        return true;
      return false;
    }
  }
  //if (msg.type === 'apim-lite' &&
  //    /DataPower API Connect Gateway is on-line/.test(msg.message)) {
  if (/DataPower API Connect Gateway is on-line/.test(msg.message)) {
    return true;
  }
  return LOG_LEVELS[msg.level] >= LOG_LEVEL;
};

const configureLogStream = (container, logstream, options) => {
  return new Promise((resolve, reject) => {
    container.logs(options, (err, stream) => {
      if (err)
        return reject(err);
      container.modem.demuxStream(stream, logstream, logstream);
      resolve();
    });
  });
};

const scrubMessage = msg => {
  if (!LOG_TIMESTAMP)
    msg = msg.replace(/\d{8}T\d{6}\.\d{3}Z /, '');
  if (!LOG_ANSI_STYLES)
    msg = msg.replace(/\x1b\[(?:\d+;?)+m/g, '');
  return msg;
};

const LogStream = exports.LogStream = () => new Stream.Transform({
  readableObjectMode: true,
  transform (chunk, encoding, callback) {
    try {
      let str = chunk.toString('utf8').replace(/\s+$/g, '');
      let parsed = parseDpMsg(str) || parseApimLiteMsg(str) || {
        type: 'other',
        timestamp: new Date(),
        level: 'debug',
        message: str
      };
      if (filterlog(parsed)) {
        parsed.message = scrubMessage(parsed.message);
        callback(null, parsed);
      }
      else
        callback(null, null);
    }
    catch (err) {
      callback(err);
    }
  }
});

const logs = exports.logs = (containers, options) => {
  options = options || {
    follow: true,
    stdout: true,
    stderr: true
  };
  let logstream = LogStream();
  let p = Promise.map(containers,
    c => configureLogStream(c, logstream, options));
  return p.then(() => logstream);
};

