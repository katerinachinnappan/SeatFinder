/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
'use strict';

const Promise = require('bluebird');
const http = Promise.promisifyAll(require('needle'));
const logger = require('../common/logger');

let PORT = null;
let URL = null;

exports.defaults = (url, port) => {
  URL = url;
  PORT = port;
};

exports.updateClusterSize = () => {
  return getProcessList()
    .then(findMyProcess)
    .then(updateClusterSize)
    .then(checkResponse)
    .catch(err => {
      logger.error('Error attempting to stop the cluster', err);
      throw err;
    });
};

exports.updatePort = (opts) => {
  let clear = opts && opts.clear;
  return getProcessList()
    .then(findMyProcess)
    .then(clear ? clearListeningSocket : addListeningSocket)
    .then(checkResponse)
    .catch(err => {
      logger.error('Error while updating port!', err);
      throw err;
    });
};

const getProcessList = () => {
  return http.getAsync(URL + '/api/ServiceProcesses', { timeout: 60 * 1000 });
};
const findMyProcess = (res) => {
  if (res.statusCode !== 200) {
    throw new Error('Failed to fetch process list');
  }
  for (let p of res.body) {
    if (+p.pid === +process.pid)
      return Promise.resolve(p);
  }
};
const clearListeningSocket = (proc) => {
  if (proc.id === undefined) {
    throw new Error('Failed to find current process id');
  }
  return http.patchAsync(URL + '/api/ServiceProcesses/' + proc.id, {
    listeningSockets: []
  }, {
    json: true
  });
};
const addListeningSocket = (proc) => {
  if (proc.id === undefined) {
    throw new Error('Failed to find current process id');
  }
  return http.patchAsync(URL + '/api/ServiceProcesses/' + proc.id, {
    listeningSockets: [{ port: PORT }]
  }, {
    json: true
  });
};
const updateClusterSize = (proc) => {
  if (proc.id === undefined) {
    throw new Error('Failed to update cluster size');
  }
  return http.postAsync(URL + '/api/Services/' + proc.serviceInstanceId + 'setClusterSize?size=-1');
};
const checkResponse = (res) => {
  if (res.statusCode !== 200) {
    throw new Error('Request to update Process Manager failed');
  }
  return Promise.resolve({ success: true });
};

