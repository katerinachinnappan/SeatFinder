/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const _       = require('lodash');
const Promise = require('bluebird');
const fs      = Promise.promisifyAll(require('fs'));
const os      = require('os');
const spawn   = require('child_process').spawn;
const Path    = require('path');
const which   = require('which');
const logger  = require('../common/logger');
const StringDecoder = require('string_decoder').StringDecoder;

const decoder = new StringDecoder('utf8');

let ResolveOn = (emitter, event) => new Promise((resolve, reject) => {
  emitter.on(event, resolve);
});

let getStdout = (cmd, args, opts) => new Promise((resolve, reject) => {
  let cmdstr = [cmd].concat(args).join(' ');

  let stdout = '';
  let stderr = '';

  if (typeof args === 'object' && !Array.isArray(args)) {
    opts = args;
    args = [];
  }

  args = args || [];
  opts = opts || {};
  let child = spawn(cmd, args, opts);

  child.stdout.on('data', data => {
    stdout += decoder.write(data);
  });

  child.stderr.on('data', data => {
    stderr += decoder.write(data);
  });

  // If the error promise resolves, we should reject immediately
  let error = ResolveOn(child, 'error').then(reject);

  // Otherwise, wait for the child to exit and for its stdio to close.
  // Reject if the child wrote to stderr or exited with a non-zero status.
  // Resolve otherwise.
  let exit      = ResolveOn(child, 'exit');
  let stdoutEnd = ResolveOn(child.stdout, 'end');
  let stderrEnd = ResolveOn(child.stderr, 'end');

  Promise.all([exit, stdoutEnd, stderrEnd])
    .timeout(10000)
    .then(() => {
      let code = exit.value();
      if (stderr.length) logger.debug('Docker', stderr.trim());
      if (code !== 0) {
        let msg = `"${cmdstr}" exited with non-zero status: ${code}\n\nstdout: ${stdout}\n\nstderr: ${stderr}`;
        let err = new Error(msg);
        err.exitStatus = code;
        err.stdout = stdout;
        err.stderr = stderr;
        reject(err);
      }
      else
        resolve(stdout);
    })
    .catch(Promise.TimeoutError, () => {
      reject(new Error(`"${cmdstr} timed-out`));
    })
    .catch(err => {
      // Should never happen, but to be on the safe side...
      reject(err);
    });
});

const findCmdPath = cmd => new Promise((resolve, reject) => which(cmd, (err, cmdPath) => {
  if (err) {
    reject(new Error(`${cmd} must be installed!`));
  } else {
    resolve(cmdPath);
  }
}));

const existsAndExecutable = cmdpath => {
  const F_OK = fs.F_OK || (fs.constants && fs.constants.F_OK) || 0;
  const X_OK = fs.X_OK || (fs.constants && fs.constants.X_OK) || 1;
  return fs.accessAsync(cmdpath, F_OK | X_OK).then(() => cmdpath);
};

const parseVersion = (cmd, stdout) => {
  let regex = new RegExp(`^${cmd} version (\\d+(?:\\.\\d+)+).*, build [\\da-f]+`, 'i');
  return stdout.replace(regex, (m, v) => v);
};

const getVersion = cmdpath => getStdout(cmdpath, ['--version']).then(stdout => {
  stdout = stdout.replace(/^\s*|\s*$/g, '');
  let cmd = Path.basename(cmdpath.toLowerCase(), '.exe');
  let vers = parseVersion(cmd, stdout);
  if (vers !== stdout)
    return vers;
  throw new Error(`Could not find version string for ${cmd} in output: "${stdout}"`);
});

const compareVersion = (cmd, actual, minimum) => {
  let actualParts  = actual.split('.').map(v => parseInt(v));
  let minimumParts = minimum.split('.').map(v => parseInt(v));

  while (minimumParts.length > 0 || actualParts.length > 0) {
    let m = minimumParts.shift() || 0;
    let a = actualParts.shift()  || 0;

    if (a > m)
      return true;

    if (a < m) {
      let msg = `${cmd} version ${minimum} or greater is required. ` +
                `Current version: ${actual}`;
      throw new Error(msg);
    }
  }

  return true;
};

const validateGroups = () => {
  if (process.platform !== 'win32' &&
      process.platform !== 'darwin')
    return getStdout('groups').then(stdout => {
      let groups = stdout.split(/\s/);
      if (!_.includes(groups, 'docker'))
        throw new Error('Current user must be a member of docker group');
      return;
    });
};

const validateSystem = () => {
  let args = ['info'];
  return getStdout('docker', args).then(stdout => {
    let info = {};
    let mem = stdout.match(/Total Memory: (.*) ?GiB/);
    if (mem) info.MemTotal = mem[1] * 1.073741824;

    let cpus = stdout.match(/CPUs: (\d+)/);
    if (cpus) info.NCPU = cpus[1];

    if (!info.NCPU || info.NCPU < 2) {
      let msg = 'Must have at least 2 CPUs available to docker, ' +
                `your system has ${info.NCPU}`;
      throw new Error(msg);
    }

    if (!info.MemTotal || +info.MemTotal < 4) {
      let msg = 'Must have at least 4 GB of memory available to docker, ' +
                `your system has ${info.MemTotal} GB`;
      throw new Error(msg);
    }
  });
};

const commands = {
  'docker'        : '1.12',
  'docker-compose': '1.9'
};

exports.validate = () => {
  let promises = _.map(commands, (minvers, cmd) => {
    return findCmdPath(cmd)
      .then(getVersion)
      .then(vers => compareVersion(cmd, vers, minvers));
  });
  return Promise.all(promises).then(validateSystem).then(validateGroups);
};

// https://github.com/docker/compose/issues/5874
exports.dockerComposeSanitizesProjectNames = () => findCmdPath('docker-compose')
  .then(getVersion)
  .then(vers => {
    try {
      compareVersion('docker-compose', vers, '1.21.0');
      return false;
    } catch (err) {
      if (err.message.startsWith('docker-compose version 1.21.0 or greater is required.')) {
        return true;
      }
      throw err;
    }
  });

exports.getStdOut = getStdout;
exports.compareVersion = compareVersion;

