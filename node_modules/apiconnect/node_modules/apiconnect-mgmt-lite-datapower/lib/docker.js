/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-mgmt-lite-datapower

'use strict';

const _       = require('lodash');
const Promise = require('bluebird');
const Docker  = require('dockerode');
const spawn   = require('child_process').spawn;
const YAML    = require('js-yaml');
const Path    = require('path');
const fs      = require('fs');
const validate = require('./docker-validate').validate;
const shouldSanitize = require('./docker-validate').dockerComposeSanitizesProjectNames;
const dockerLogs = require('./docker-logs');
const logger = require('../common/logger');
const Config = require('../common/config');
const getHostIpAddress = require('./get-host-ip-address');

let docker = null;
let dockerConfig = {
  DOCKER_HOST: [getHostIpAddress()]
};

if (dockerConfig.DOCKER_HOST[0] === '0.0.0.0')
  dockerConfig.DOCKER_HOST[0] = '127.0.0.1';
const imagePrefix = 'ibm-apiconnect-toolkit/datapower-';
exports.imagePrefix = imagePrefix;

exports.dockerode = docker;

const packageRoot = Path.resolve(__dirname, '..');
let dockerComposeYml = 'docker-compose.yml';

const initialize = () => new Promise((resolve, reject) => {
  if (docker)
    return resolve();
  if (process.platform === 'win32')
    process.env.CHOKIDAR_USEPOLLING = '1';
  if (process.platform !== 'win32' ||
      !process.env.DOCKER_TOOLBOX_INSTALL_PATH) {
    docker = new Docker();
    exports.dockerode = docker;
    return resolve();
  }
  const stdoutData = [];
  const cmd = Path.resolve(process.env.DOCKER_TOOLBOX_INSTALL_PATH, 'docker-machine.exe');
  const args = ['env', '--shell=bash', '--no-proxy', 'default'];
  const de = spawn(cmd, args, { cwd: packageRoot });
  de.stdout.on('data', (data) => { stdoutData.push(data.toString('utf8')); });
  de.stderr.on('data', (data) => { logger.error(data.toString('utf8')); });
  de.on('error', reject);
  de.on('exit', code => {
    de.removeListener('error', reject);
    if (code !== 0)
      reject(code);
    let config = _.reduce(stdoutData.join('').split('\n'), (config, line) => {
      if (!line.startsWith('export '))
        return config;
      let confarr = line.replace('export ', '').split('=');
      let key = confarr[0];
      let val = confarr[1].replace(/"/g, '');
      config[key] = val;
      process.env[key] = val;
      return config;
    }, {});
    config.DOCKER_HOST = config.DOCKER_HOST.replace('tcp://', '').split(':');
    let resolveCertPath = f => Path.resolve(config.DOCKER_CERT_PATH, f);
    docker = new Docker({
      protocol: `http${config.DOCKER_TLS_VERIFY === '1' ? 's' : ''}`,
      host: config.DOCKER_HOST[0],
      port: config.DOCKER_HOST[1],
      ca: fs.readFileSync(resolveCertPath('ca.pem')),
      cert: fs.readFileSync(resolveCertPath('cert.pem')),
      key: fs.readFileSync(resolveCertPath('key.pem'))
    });
    exports.dockerode = docker;
    dockerConfig = config;
    resolve();
  });
});

const config = new Config(process.env.PROJECT_DIR || process.env.CONFIG_DIR || process.cwd());
exports.initialize = () => validate()
  .then(initialize)
  .then(() => config.load())
  .then(config => {
    if (config.useExperimental()) {
      dockerComposeYml = 'docker-compose-v6.yml';
    }
  });

exports.config = () => dockerConfig;

const listImages = options => new Promise((resolve, reject) => {
  docker.listImages(options || {}, (err, images) => {
    if (err)
      return reject(err);
    resolve(images);
  });
});

const listByTag = tags => {
  if (!tags) {
    tags = [];
  } else if (typeof tags === 'string') {
    tags = tags.split(',');
  } else if (!Array.isArray(tags)) {
    throw new TypeError('Invalid type for images');
  }
  const globalTag = process.env.APICONNECT_MGMT_LITE_DOCKER_TAG || 'latest';
  return listImages().then(images => {
    return _.filter(images, image => {
      return _.some(image.RepoTags, imageTag => {
        return _.some(tags, tag => _.isEqual(imageTag.split(':'), [tag, globalTag]));
      });
    });
  });
};

exports.listImagesByTag = listByTag;

const listContainers = options => new Promise((resolve, reject) => {
  docker.listContainers(options || {}, (err, containers) => {
    if (err)
      return reject(err);
    resolve(containers);
  });
});

exports.list = listContainers;

const listByImage = exports.listByImage = images => {
  if (!images)
    images = [];
  else if (typeof images === 'string')
    images = images.split(',');
  else if (!Array.isArray(images))
    throw new TypeError('Invalid type for images');
  return listContainers().then(containers => {
    return _.filter(containers, c => {
      return _.some(images, i => c.Image.indexOf(i) >= 0);
    });
  });
};

const listByName = exports.listByName = names => {
  if (!names)
    names = [];
  else if (typeof names === 'string')
    names = names.split(',');
  let options = {
    filters: { name: names }
  };
  return listContainers(options);
};

const listAll = () => listByImage(imagePrefix);

exports.listAll = listAll;

const loadYaml = path => new Promise((resolve, reject) => {
  fs.readFile(path, 'utf8', (err, data) => {
    if (err)
      return reject(err);
    try {
      let obj = YAML.safeLoad(data);
      resolve(obj);
    }
    catch (err) {
      reject(err);
    }
  });
});

// https://github.com/docker/compose/issues/5874
const normalize = proj => shouldSanitize().then(sanitize => {
  let normalized = (proj || '').toLowerCase();
  if (sanitize === true) {
    // https://github.com/docker/compose/pull/5896/files#diff-4a66a27bc9c5bf80e5e65f077569a3a9R114
    normalized = normalized.replace(/[_-]/g, '');
  }
  return normalized;
});

const ports = exports.ports = project => {
  let serviceNames;
  return loadYaml(Path.resolve(packageRoot, dockerComposeYml))
    .then(dcyaml => {
      serviceNames = _.keys(dcyaml.services);
      return normalize(project).then(p => listByName(_.map(serviceNames, sn => `${p}_${sn}`)));
    })
    .then(containers => {
      let ports = _.map(containers, c => c.Ports);
      ports = _.flatten(ports);
      return _.reduce(ports, (portmap, p) => {
        portmap[`port${p.PrivatePort}`] = p.PublicPort;
        return portmap;
      }, {});
    });
};

const logGatewayVersion = () => {
  if (config.useExperimental()) {
    logger.log('Using experimental DataPower API Gateway');
    logger.log('For more details or to provide feedback, please visit');
    logger.log('https://github.com/ibm-apiconnect/apigateway-experimental');
  }
  else {
    logger.debug('Using API Connect v5 DataPower API Gateway');
  }
};

const getComposeEnv = () => _.assign({}, process.env, {
  IBM_APICONNECT_APIM_LITE_DOCKER_HOST: dockerConfig.DOCKER_HOST[0],
  IBM_APICONNECT_APIC_DEV_HOSTIP: process.env.IBM_APICONNECT_APIC_DEV_HOSTIP || getHostIpAddress()
});

const doCompose = args => new Promise((resolve, reject) => {
  const env = getComposeEnv();
  args = ['-f', dockerComposeYml].concat(args);
  const dc = spawn('docker-compose', args, { cwd: packageRoot, env: env });
  let stdout = '';
  let stderr = '';
  dc.stdout.on('data', (data) => {
    let str = data.toString('utf8').trim();
    stdout += str;
    logger.debug('Docker', str);
  });
  dc.stderr.on('data', (data) => {
    let str = data.toString('utf8').trim();
    stderr += str;
    logger.debug('Docker', str);
  });
  let onError = err => {
    err.stdout = stdout;
    err.stderr = stderr;
    reject(err);
  };
  dc.on('error', onError);
  dc.on('exit', code => {
    dc.removeListener('error', onError);
    if (code === 0)
      resolve();
    else {
      let errstr = `docker-compose exited with non-zero status: ${code}\n\n` +
        `args: ${args.join(' ')}\n\nstdout: ${stdout}\n\nstderr: ${stderr}`;
      onError(new Error(errstr));
    }
  });
});

const doComposeDetached = args => new Promise((resolve, reject) => {
  const env = getComposeEnv();
  const dc = spawn('docker-compose', ['-f', dockerComposeYml].concat(args), {
    cwd: packageRoot,
    env: env,
    detached: true,
    stdio: 'ignore'
  });
  dc.unref();
  resolve();
});

const compose = exports.compose = {
  build () {
    return doCompose(['build']);
  },
  buildNoCache () {
    return doCompose(['build', '--no-cache']);
  },
  up (project, build) {
    let args = ['up', '-d'];
    if (typeof project === 'string')
      args = ['-p', project].concat(args);
    if (build === true)
      args.push('--build');
    logGatewayVersion();
    return doCompose(args);
  },
  down (project) {
    let args = ['down', '-v'];
    if (typeof project === 'string')
      args = ['-p', project].concat(args);
    return doCompose(args);
  },
  downDetached (project) {
    let args = ['down', '-v'];
    if (typeof project === 'string')
      args = ['-p', project].concat(args);
    return doComposeDetached(args);
  }
};

const logs = exports.logs = (project, services, options) => {
  if (typeof services === 'string')
    services = [services];
  return normalize(project)
    .then(p => listByName(_.map(services || [''], s => `${p}_${s}`)))
    .then(containers => {
      return _.map(containers, c => {
        return docker.getContainer(c.Id);
      });
    })
    .then(containers => dockerLogs.logs(containers, options));
};

const details = exports.details = project => normalize(project).then(p => {
  let promises = [
    listByName(p).then(c => ({ containers: c })),
    ports(p)
  ];
  return Promise.all(promises).then(values => _.reduce(values, _.assign, {}));
});

