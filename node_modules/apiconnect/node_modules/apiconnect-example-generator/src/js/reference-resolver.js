/********************************************************* {COPYRIGHT-TOP} ***
* Licensed Materials - Property of IBM
*
* (C) Copyright IBM Corporation 2016, 2018
*
* All Rights Reserved.
* US Government Users Restricted Rights - Use, duplication or disclosure
* restricted by GSA ADP Schedule Contract with IBM Corp.
********************************************************** {COPYRIGHT-END} **/
(function () {

  var JsonRefs = require('../../node_modules/json-refs');
  var jsonPointer = require("jsonpointer");

  var refResolver = {};

  refResolver.resolveReferences = function(schema) {

    return new Promise(function(resolve, reject) {

      /*
        Resolve references in the schema by inlining the referenced type. Also
        add a description to the copy of the type of its original path, so we know
        where it came from.
      */

      var jsonOpts = {includeInvalid: true, resolveCirculars: false};
      // first add uri description to all types that are going to be inlined,
      // these are the unresolved references found below.
      // pointer to true if the type has had the description changed
      var captioned = {};
      // pointer to original description if there was a description
      var originalDescriptions = {};
      var refs = JsonRefs.findRefs(schema, jsonOpts);
      var keys = Object.keys(refs);
      keys.forEach(function(ptr){
        var ref = refs[ptr];
        // add description to the referenced thing, no need to clone the doc
        if(ref.uri.indexOf('#') === 0) {
          // chop hash off for json pointer
          var pointer = ref.uri.substring(1);
          // check if done already
          if (captioned[pointer] === undefined || !captioned[pointer]) {
            // use json pointer to get object of the definition
            var definitionObject = jsonPointer.get(schema, pointer);
            if(definitionObject) {
              // add/change description
              if(definitionObject.description) {
                // store original description
                originalDescriptions[pointer] = definitionObject.description;
                definitionObject.description += " " + ref.uri;
              } else {
                definitionObject.description = ref.uri;
              }
              // store as captioned
              captioned[pointer] = true;
            }
          }
        }
      });

      JsonRefs.resolveRefs(schema, jsonOpts)
      .then(function(res) {
        var ret = res.resolved;
        // remove caption from top level elements
        var pointers = Object.keys(captioned);
        pointers.forEach(function(pointer){
          var originalDescription = originalDescriptions[pointer];
          var definitionObject = jsonPointer.get(ret, pointer);
          if(definitionObject) {
            // need to alter a clone
            var cloneDefinitionObject = _.cloneDeep(definitionObject);
            if(originalDescription) {
              cloneDefinitionObject.description = originalDescription;
            } else {
              // no description
              delete cloneDefinitionObject.description;
            }
            // set back the clone
            jsonPointer.set(ret, pointer, cloneDefinitionObject);
          }
        });
        resolve(ret);
      }, function(err) {
        console.error("Error during resolving references");
        console.error(err);
        if(err.stack) {
          console.error(err.stack);
        }
        reject(err);
      });
    })
  };

  // CommonJS module
  if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = refResolver;
      }
      exports.refResolver = refResolver;
  }

  // Register as an anonymous AMD module
  if (typeof define === 'function' && define.amd) {
      define([], function () {
          return refResolver;
      });
  }

  // If there is a window object, that at least has a document property,
  // instantiate and define chance on the window
  if (typeof window === "object" && typeof window.document === "object") {
    window.refResolver = refResolver;
  }

  return refResolver;

})();
