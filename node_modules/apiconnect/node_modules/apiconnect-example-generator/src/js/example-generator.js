/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
(function () {

    var jsonPointer = require("jsonpointer");
    var jsyaml = require("js-yaml");
    var _ = require('lodash');
    var Chance = require('chance');
    var chance = new Chance();

    var exampleGen = {};

    // Used to prevent circular references from being resolved.
    var referencePath = [];

    var json2xml;

    function json2xmlInstance() {
        if (!json2xml) json2xml = new (window.X2JS || window.x2js)();
        return json2xml;
    }

    /**
     * Does this operation return XML?
     * @param operation
     * @param api
     * @returns {boolean}
     */
    function returnsXML(operation, api) {

        var result = false; // default to JSON

        if(api.openapi) {
          // openapi v3 - there is no 'produces' and 'consumes' just responses with mediatypes
          if (operation.responses) {
            Object.keys(operation.responses).forEach(function (response) {
              if (response.content) {
                Object.keys(response.content).forEach(function (mediatype) {
                  if (mediatype.indexOf('xml') > -1) {
                    result = true;
                  }
                });
              }
            });
          }
        }
        else {
          // assume JSON
          if (operation.produces || api.produces) {
            result = (JSON.stringify(operation.produces || api.produces).indexOf('xml') > -1)
          }
        }

        return result;
    }

    /**
     * Does this operation return JSON?
     * @param operation
     * @param api
     * @returns {boolean}
     */
    function returnsJSON(operation, api) {
      var result = false; // default to JSON

      if(api.openapi) {
        // openapi v3 - there is no 'produces' and 'consumes' just responses with mediatypes
        if (operation.responses) {
          Object.keys(operation.responses).forEach(function (response) {
            if (response.content) {
              Object.keys(response.content).forEach(function (mediatype) {
                if (mediatype.indexOf('json') > -1) {
                  result = true;
                }
              });
            }
          });
        }
      }
      else {
        // assume JSON
        if (operation.produces || api.produces) {
          result = (JSON.stringify(operation.produces || api.produces).indexOf('json') > -1)
        }
      }

      return result;
    }

    /**
     * Does this operation accept XML?
     * @param operation
     * @param api
     * @returns {boolean}
     */
    function acceptsXML(operation, api) {
        // assume JSON
        if (!operation.consumes && !api.consumes) return false;
        return (JSON.stringify(operation.consumes || api.consumes).indexOf('xml') > -1);
    }

    /**
     * Does this operation accept JSON?
     * @param operation
     * @param api
     * @returns {boolean}
     */
    function acceptsJSON(operation, api) {
        // assume JSON
        if (!operation.consumes && !api.consumes) return true;
        return (JSON.stringify(operation.consumes || api.consumes).indexOf('json') > -1);
    }

    /**
     *
     * @param operation
     * @param api
     * @returns {*}
     */
    function getDefaultContentType(operation, api) {
        // assume JSON
        if (!operation.consumes && !api.consumes) return 'application/json';
        var consumes = operation.consumes || api.consumes;
        var json = null;
        var xml = null;
        consumes.forEach(function (consume) {
            if (consume.indexOf('json') > -1) {
                json = consume;
            } else if (consume.indexOf('xml') > -1) {
                xml = consume;
            }
        });
        if (json) {
            return json;
        } else if (xml) {
            return xml;
        } else {
            return consumes[0];
        }
    }

    /**
     *
     * @param operation
     * @param api
     * @returns {*}
     */
    function getDefaultAccept(operation, api) {
        // assume JSON
        if (!operation.produces && !api.produces) return 'application/json';
        var produces = operation.produces || api.produces;
        var json = null;
        var xml = null;
        produces.forEach(function (produce) {
            if (produce.indexOf('json') > -1) {
                json = produce;
            } else if (produce.indexOf('xml') > -1) {
                xml = produce;
            }
        });
        if (json) {
            return json;
        } else if (xml) {
            return xml;
        } else {
            return produces[0];
        }
    }

    /**
     *
     * @param propertyName
     * @param property
     * @param empty
     * @returns {*}
     */
    function createDummyValue(propertyName, property, empty) {
        var defaultValues = {
            string: '',
            number: 0.0,
            integer: 0,
            boolean: true,
            date: '1970-01-01',
            dateTime: '1970-01-01T00:00:00Z',
            'date-time': '1970-01-01T00:00:00Z',
            password: '',
            binary: '00000000',
            byte: 0
        };
        if (!property.type) {
            property.type = 'string';
        }
        if (empty === true) {
            if (typeof(defaultValues[property.type]) !== 'undefined') {
                if (property.type === 'string') {
                    if (property.format && (property.format === 'date' || property.format === 'date-time' || property.format === 'password' || property.format === 'binary' || property.format === 'byte')) {
                        return defaultValues[property.format];
                    } else {
                        return defaultValues[property.type];
                    }
                } else {
                    return defaultValues[property.type];
                }
            } else {
                return null;
            }
        } else {
            if (property.enum && property.enum.length > 0) {
                var enumLength = property.enum.length - 1;
                var index = chance.natural({min: 0, max: enumLength});
                return property.enum[index];
            } else if (property.type === 'integer') {
                var max = 100;
                var min = 1;
                if (propertyName && (propertyName.toLowerCase().indexOf('quantity') > -1 || propertyName.toLowerCase().indexOf('number') > -1)) {
                    if (property.maximum && property.maximum > 0) {
                        if (property.exclusiveMaximum) {
                            max = property.maximum;
                        } else {
                            max = property.maximum - 1;
                        }
                    }
                    if (property.minimum && property.minimum >= 0) {
                        if (property.exclusiveMinimum) {
                            min = property.minimum;
                        } else {
                            min = property.minimum + 1;
                        }
                    }
                    if (min > max) {
                        if (property.maximum) {
                            min = max - 1;
                        } else {
                            max = min + 1;
                        }
                    }
                    return chance.integer({min: min, max: max});
                } else {
                    // int32 && int64
                    max = 99999999;
                    min = 10000000;
                    if (property.maximum && property.maximum > 0) {
                        if (property.exclusiveMaximum) {
                            max = property.maximum;
                        } else {
                            max = property.maximum - 1;
                        }
                    }
                    if (property.minimum && property.minimum >= 0) {
                        if (property.exclusiveMinimum) {
                            min = property.minimum;
                        } else {
                            min = property.minimum + 1;
                        }
                    }
                    if (min > max) {
                        if (property.maximum) {
                            min = max - 1;
                        } else {
                            max = min + 1;
                        }
                    }
                    return chance.natural({min: min, max: max});
                }
            } else if (property.type === 'boolean') {
                // random boolean
                return JSON.stringify(chance.bool());
            } else if (property.type === 'number') {
                if (propertyName && (propertyName.toLowerCase().indexOf('price') > -1 || propertyName.toLowerCase().indexOf('cost') > -1)) {
                    return chance.floating({min: 0, max: 100, fixed: 2});
                } else {
                    return chance.floating({min: 0, max: 100, fixed: 8});
                }
            } else if (property.type === 'object') {
                return {'id': chance.natural()};
            } else {
                // string
                if (property.format && (property.format === 'date' || property.format === 'date-time')) {
                    // random date (or date time) between 2000 and now
                    var start = new Date(2000, 0, 1);
                    var end = new Date();
                    var date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
                    if (property.format === 'date-time') {
                        return date.toISOString();
                    } else {
                        return date.toDateString().slice(0, 10);
                    }
                } else if (property.format && property.format === 'password') {
                    return 'Passw0rd';
                } else if (property.format && property.format === 'binary') {
                    return (Math.floor(Math.random() * (127 - 1) + 1)).toString(2);
                } else if (property.format && property.format === 'byte') {
                    return (Math.floor(Math.random() * (8 - 1) + 1)).toString(16);
                } else if (property.format && property.format === 'uri') {
                    return chance.url();
                } else {
                    if (propertyName) {
                        var lowerCasePropName = propertyName.toLowerCase();
                        if (lowerCasePropName.indexOf('ip') > -1 && lowerCasePropName.indexOf('address') > -1) {
                            return chance.ip();
                        } else if (lowerCasePropName.indexOf('address') > -1) {
                            return chance.address();
                        } else if (lowerCasePropName.indexOf('phone') > -1) {
                            return chance.phone();
                        } else if (lowerCasePropName.indexOf('areacode') > -1) {
                            return chance.areacode();
                        } else if (lowerCasePropName.indexOf('post') > -1) {
                            return chance.postal();
                        } else if (lowerCasePropName.indexOf('city') > -1) {
                            return chance.city();
                        } else if (lowerCasePropName.indexOf('province') > -1) {
                            return chance.province();
                        } else if (lowerCasePropName.indexOf('street') > -1) {
                            return chance.street();
                        } else if (lowerCasePropName.indexOf('state') > -1) {
                            return chance.state();
                        } else if (lowerCasePropName.indexOf('accept') > -1 && lowerCasePropName.indexOf('encoding') > -1) {
                            return 'gzip';
                        } else if (lowerCasePropName.indexOf('accept') > -1 && lowerCasePropName.indexOf('charset') > -1) {
                            return 'utf-8';
                        } else if (lowerCasePropName.indexOf('user') > -1 && lowerCasePropName.indexOf('agent') > -1) {
                            return 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36';
                        } else if (lowerCasePropName.indexOf('content') > -1 && lowerCasePropName.indexOf('type') > -1) {
                            return 'application/json';
                        } else if (lowerCasePropName.indexOf('countrycode') > -1 || lowerCasePropName.indexOf('language') > -1) {
                            return chance.country();
                        } else if (lowerCasePropName.indexOf('country') > -1) {
                            if(property.description && property.description.toLowerCase().indexOf('code') > -1) {
                              return chance.country();
                            } else {
                              return chance.country({full: true});
                            }
                        } else if (lowerCasePropName.indexOf('zip') > -1) {
                            return chance.zip();
                        } else if (lowerCasePropName.indexOf('coordinate') > -1) {
                            return chance.coordinates();
                        } else if (lowerCasePropName.indexOf('latitude') > -1 || lowerCasePropName === 'lat') {
                            return chance.latitude().toString();
                        } else if (lowerCasePropName.indexOf('longitude') > -1 || lowerCasePropName === 'lon') {
                            return chance.longitude().toString();
                        } else if (lowerCasePropName.indexOf('geo') > -1 && lowerCasePropName.indexOf('location') > -1) {
                            return 'GEO:' + chance.latitude().toString() + ',' + chance.longitude().toString();
                        } else if (lowerCasePropName.indexOf('cc') > -1 || lowerCasePropName.indexOf('credit') > -1) {
                            return chance.cc();
                        } else if (lowerCasePropName.indexOf('expiry') > -1) {
                            return chance.exp();
                        } else if (lowerCasePropName.indexOf('currency') > -1) {
                            return chance.currency().code;
                        } else if (lowerCasePropName.indexOf('iban') > -1) {
                            return 'DE89 3704 0044 0532 0130 00';
                        } else if (lowerCasePropName.indexOf('color') > -1 || lowerCasePropName.indexOf('colour') > -1) {
                            return chance.color({format: 'hex'});
                        } else if (lowerCasePropName.indexOf('domain') > -1 || lowerCasePropName.indexOf('host') > -1) {
                            return chance.domain();
                        } else if (lowerCasePropName.indexOf('mail') > -1) {
                            return chance.email();
                        } else if (lowerCasePropName.indexOf('url') > -1 || (lowerCasePropName.indexOf('redirect') > -1 && lowerCasePropName.indexOf('uri') > -1)) {
                            return chance.url();
                        } else if (lowerCasePropName.indexOf('twitter') > -1) {
                            return chance.twitter();
                        } else if (lowerCasePropName.indexOf('birth') > -1 || lowerCasePropName.indexOf('bday') > -1) {
                            return chance.birthday({string: true});
                        } else if (lowerCasePropName.indexOf('age') > -1) {
                            return chance.age().toString();
                        } else if (lowerCasePropName.indexOf('first') > -1 || lowerCasePropName.indexOf('fname') > -1 || lowerCasePropName.indexOf('user') > -1) {
                            return chance.first();
                        } else if (lowerCasePropName.indexOf('last') > -1 || lowerCasePropName.indexOf('lname') > -1) {
                            return chance.last();
                        } else if (lowerCasePropName.indexOf('gender') > -1 || lowerCasePropName.indexOf('sex') > -1) {
                            return chance.gender();
                        } else if (lowerCasePropName.indexOf('prefix') > -1) {
                            return chance.prefix();
                        } else if (lowerCasePropName.indexOf('ssn') > -1 || lowerCasePropName.indexOf('social') > -1) {
                            return chance.ssn();
                        } else if (lowerCasePropName.indexOf('token') > -1) {
                            return chance.apple_token();
                        } else if (lowerCasePropName.toLowerCase().indexOf('price') > -1 || lowerCasePropName.toLowerCase().indexOf('cost') > -1 || lowerCasePropName.indexOf('value') > -1) {
                            return chance.floating({min: 0, max: 100, fixed: 2}).toString();
                        } else if (lowerCasePropName.indexOf('number') > -1 || lowerCasePropName.indexOf('amount') > -1) {
                            return chance.natural().toString();
                        } else if (lowerCasePropName.indexOf('temp') > -1) {
                            return chance.natural({min: 0, max: 100}) + ' C';
                        } else if (lowerCasePropName.indexOf('pressure') > -1) {
                            return chance.natural({min: 500, max: 1500}) + ' hPa';
                        } else if (lowerCasePropName.indexOf('humidity') > -1) {
                            return chance.natural({min: 0, max: 100}) + ' %';
                        } else if (lowerCasePropName.indexOf('year') > -1) {
                            return chance.year({min: 1900, max: 2100}).toString();
                        } else if (lowerCasePropName.indexOf('month') > -1) {
                            return chance.month();
                        } else if (lowerCasePropName.indexOf('date') > -1) {
                            return chance.date({string: true});
                        } else if (lowerCasePropName.indexOf('timestamp') > -1) {
                            return chance.timestamp().toString();
                        } else if (lowerCasePropName.indexOf('time') > -1) {
                            var hour = chance.hour({twentyfour: true}).toString();
                            if(hour < 10){hour = 0 + hour;}
                            var minute = chance.minute().toString();
                            if(minute < 10) {
                              minute = "0" + minute;
                            }
                            return hour + ':' + minute;
                        } else if (lowerCasePropName.indexOf('hour') > -1) {
                            var hour = chance.hour({twentyfour: true}).toString();
                            if(hour < 10){hour = 0 + hour;}
                            return hour;
                        } else if (lowerCasePropName.indexOf('minute') > -1) {
                            var minute = chance.minute().toString();
                            if(minute < 10) {
                              minute = "0" + minute;
                            }
                            return minute.toString();
                        } else if (lowerCasePropName.indexOf('sunrise') > -1) {
                            var hour = chance.natural({min: 5, max: 10});
                            if(hour < 10){hour = 0 + hour;}
                            var minute = chance.minute().toString();
                            if(minute < 10){minute = "0" + minute;}
                            return hour + ':' + minute;
                        } else if (lowerCasePropName.indexOf('sunset') > -1) {
                            var minute = chance.minute().toString();
                            if(minute < 10) {
                              minute = "0" + minute;
                            }
                            return chance.natural({min: 17, max: 22}) + ':' + minute;
                        } else if (lowerCasePropName.indexOf('string') > -1) {
                            return chance.string();
                        } else if (lowerCasePropName.indexOf('desc') > -1 || lowerCasePropName.indexOf('summary') > -1) {
                            return chance.paragraph({sentences: 1});
                        } else if (lowerCasePropName.indexOf('message') > -1) {
                            return chance.sentence();
                        } else if (lowerCasePropName.indexOf('name') > -1) {
                            return chance.name();
                        } else if (lowerCasePropName.indexOf('ip') > -1) {
                            return chance.ip();
                        } else if (lowerCasePropName === 'tel' || lowerCasePropName.indexOf('fax') > -1) {
                            return chance.phone();
                        } else if(lowerCasePropName === 'version') {
                            return chance.natural({ min: 1, max: 9}).toString() + '.' + chance.natural({ min: 1, max: 9}).toString() + '.' + chance.natural({ min: 1, max: 9}).toString();
                        } else if (lowerCasePropName === 'identity_provider') {
                            return chance.word().toString() + '-idp';
                        } else if (lowerCasePropName === 'x-client-certificate' || lowerCasePropName.indexOf('certificate') > -1) {
                            return '-----BEGIN CERTIFICATE-----\nxxxEXAMPLExxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxx\nxxxEXAMPLExxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxx\nxxxEXAMPLExxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxx\nxxxEXAMPLExxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxxxxxxxxEXAMPLExxxx\n-----END CERTIFICATE-----';
                        } else if (lowerCasePropName.indexOf('id') > -1) {
                            return chance.natural().toString();
                        } else {
                            var stringMax = 8;
                            var stringMin = 4;
                            if (property.maxLength && property.maxLength > 0) {
                                stringMax = property.maxLength;
                            }
                            if (property.minLength && property.minLength >= 0) {
                                stringMin = property.minLength;
                            }
                            if (stringMin > stringMax) {
                                if (property.maxLength) {
                                    stringMin = stringMax - 1;
                                } else {
                                    stringMax = stringMin + 1;
                                }
                            }
                            var length = chance.natural({min: stringMin, max: stringMax});
                            if (length < 1) {
                                length = 1;
                            }
                            return chance.word({length: length});
                        }
                    } else {
                        var mystringMax = 8;
                        var mystringMin = 4;
                        if (property.maxLength && property.maxLength > 0) {
                            mystringMax = property.maxLength;
                        }
                        if (property.minLength && property.minLength >= 0) {
                            mystringMin = property.minLength;
                        }
                        if (mystringMin > mystringMax) {
                            if (property.maxLength) {
                                mystringMin = mystringMax - 1;
                            } else {
                                mystringMax = mystringMin + 1;
                            }
                        }
                        var mylength = chance.natural({min: mystringMin, max: mystringMax});
                        if (mylength < 1) {
                            mylength = 1;
                        }
                        return chance.word({length: mylength});
                    }
                }
            }
        }
    }

    function expandLocalRef(schema, api, references) {
        if (!schema || !schema.$ref || !api) {
            return;
        }
        var ref = schema.$ref;
        if (ref.indexOf('#') === 0) {
            ref = ref.substring(1);
        }
        var refSchema = jsonPointer.get(api, ref);
        if (!refSchema) {
            schema.type = "string";
            schema.enum = ["missing reference: " + schema.$ref];
            return;
        }
        if (refSchema.schema && refSchema.schema.$ref) {
            expandLocalRef(refSchema.schema, api, references);
        }
        _.extend(schema, refSchema);
    }

    /**
     *
     * @param schema
     * @param api
     * @param references
     * @returns {*}
     */
    function unwindRefs(schema, api, references) {
        if (!schema) {
            return;
        }
        var refName, refSchema;
        // take a deep copy
        schema = JSON.parse(JSON.stringify(schema));

        if (schema.$ref) {
            if (references && references[schema.$ref]) {
                refSchema = JSON.parse(JSON.stringify(references[schema.$ref]));
                _.extend(schema, refSchema);
            } else {
                expandLocalRef(schema, api, references);
            }
        }
        if (schema.type === 'array' && schema.items && (schema.items.$ref || ( schema.items[0] && schema.items[0].$ref))) {
            if (references && references[schema.items[0].$ref]) {
                refSchema = JSON.parse(JSON.stringify(references[schema.items[0].$ref]));
                _.extend(schema.items, refSchema);
            } else if (references && references[schema.items.$ref]) {
                refSchema = JSON.parse(JSON.stringify(references[schema.items.$ref]));
                _.extend(schema.items, refSchema);
            } else {
                if (schema.items[0] && schema.items[0].$ref) {
                    expandLocalRef(schema.items[0], api, references);
                } else {
                    expandLocalRef(schema.items, api, references);
                }
            }
        }

        return schema;
    }

    /**
     *
     * @param param
     * @param api
     * @param references
     * @returns {*}
     */
    function unwindParamRef(param, api, references) {
        if (!param) {
            return;
        }
        if (param.$ref) {
            if (references && references[param.$ref]) {
                refSchema = JSON.parse(JSON.stringify(references[param.$ref]));
                _.extend(schema, refSchema);
            } else {
                var refName = param.$ref.replace("#/parameters/", "");
                if (api.parameters && api.parameters[refName]) {
                    var refSchema = JSON.parse(JSON.stringify(api.parameters[refName]));
                    _.extend(param, refSchema);
                    // delete schema.$ref;
                }
            }
        }

        return param;
    }

    /**
     * Checks if schema.$ref already appears in the current referencePath.
     * If it doesn't, allow the reference to be unwound and processed further.
     * If it does, return null to prevent a circular reference.
     * @param schema
     * @param api
     * @param references
     */
    function possiblyUnwindRefs(schema, api, references) {
      var result = null;
      if(schema.$ref){
        if(recordReferencePath(schema.$ref)){
          result = unwindRefs(schema, api, references);
        }
      }
      return result;
    }

    /**
     * Checks the current referencePath for the provided schemaRef. If found,
     * return false. If not found, add the schemaRef to the referencePath and
     * return true;
     *
     * @param schemaRef
     */
    function recordReferencePath(schemaRef) {
      // Do nothing with invalid data
      if(!schemaRef) {
        return true;
      }
      if(referencePath.indexOf(schemaRef) > -1){
        return false;
      }
      else {
        referencePath.push(schemaRef);
        return true;
      }
    }

    /**
     * Removes the provided schemaRef from the referencePath if and only if
     * it is the end of the current path.
     *
     * @param schemaRef
     */
    function removeReferencePath(schemaRef) {
      // Do nothing with invalid data
      if(!schemaRef) {
        return;
      }
      if(referencePath[referencePath.length - 1] === schemaRef){
        referencePath.pop();
      }
    }

    /**
     *
     * @param isXml
     * @param schema
     * @param prefix
     * @param namespace
     * @param api
     * @param references
     * @returns {{}}
     */
    function resolveNS(isXml, schema, prefix, namespace, api, references) {
        var ret = {};
        // prefix value has to be contained within the object value for this property name
        var newPrefix = undefined;
        var newNamespace = undefined;
        if (isXml) {
            if (schema.$ref) schema = unwindRefs(schema, api, references);
            if (schema.items && schema.items[0] && schema.items[0].$ref) schema = unwindRefs(schema.items[0], api, references);
            if (schema.items && schema.items.$ref) schema = unwindRefs(schema.items, api, references);
            if (schema.xml) {
                newPrefix = schema.xml.prefix;
                newNamespace = schema.xml.namespace;
            }
        }
        // specifically check for undefined as we want to pick up prefix if it is the
        // empty string as that will override and turn off the prefix
        if (newPrefix === undefined) {
            newPrefix = prefix;
            newNamespace = namespace;
        }
        ret.prefix = newPrefix;
        ret.namespace = newNamespace;
        return ret;
    }

    /**
     * Generates an empty object for the specified schema
     * @param schema
     * @param api
     * @param empty
     * @param isXml whether the example is for XML or not
     * @param prefix the prefix string for this property
     * @param namespace the namespace string for this property
     * @param namespaces the list of namespaces discovered so far
     * @param depth count to prevent indefinite cycles
     * @param references the list of external references
     *
     * @returns {*}
     */
    function createExampleObject(schema, api, empty, isXml, prefix, namespace, namespaces, depth, references) {
        var schemaRef = null;

        // before we potentially unwind the schema we need to store any example or examples properties.
        // this is because example or examples at the object level override schema level examples as per the OAI3 spec.
        var preservedExample = schema.example;
        var preservedExamples = schema.examples;
        if (schema.schema) { schema = schema.schema; }
        if (schema.$ref) {
            schemaRef = schema.$ref;
            schema = possiblyUnwindRefs(schema, api, references);
            if(schema === null){
              return {"circular_reference": schemaRef};
            }
            if (schema.schema) schema = schema.schema;
        }

        // put the examples back if they exist - and override anything that was just added via unwinding
        if(preservedExample || preservedExamples) { delete schema.example; delete schema.examples; }
        if(preservedExample) { schema.example = preservedExample; }
        if(preservedExamples) { schema.examples = preservedExamples;}

        if (empty == null) {
            empty = false;
        }
        if (depth == null) {
            depth = 0;
        }
        depth++;
        var result = {};
        // handle loose schema'd objects which are missing their 'type'
        if (!schema.type && schema.properties) {
            schema.type = 'object';
        }
        // only nest to a certain depth (blocks huge trees and runaway cycles)
        if (depth >= 9) {
            removeReferencePath(schema.$ref);
            return "ERROR_MAXDEPTH";
        }
        if (schema.type === 'object') {
            if (typeof(schema.default) !== 'undefined') {
                result = schema.default;
            } else if (typeof(schema.example) !== 'undefined') {
              result = schema.example;
            } else if (typeof(schema['x-example']) !== 'undefined') {
                result = schema['x-example'];
            } else if (typeof(schema.examples) !== 'undefined') {
              result = schema.examples[Object.keys(schema.examples)];
            } else {
                // If schema has no properties (loose schema), return the empty object
                if (!schema.properties) {
                    result = createDummyValue("", schema, empty);
                } else {
                    Object.keys(schema.properties).forEach(function (propertyName) {
                        var thisSchema = schema.properties[propertyName];
                        // if this property is a schema ref, unwind...
                        if (thisSchema.$ref) thisSchema = unwindRefs(thisSchema, api, references);
                        if (thisSchema.items && thisSchema.items[0] && thisSchema.items[0].$ref) thisSchema = unwindRefs(thisSchema.items[0], api, references);
                        if (isXml && thisSchema.xml && thisSchema.xml.attribute === true) {
                            // special case for attributes - prop name should be preceded by underscore
                            var attrValue = createDummyValue(propertyName, thisSchema, empty);
                            result["_" + propertyName] = attrValue;
                        } else {
                            if (prefix) {
                                result["__prefix"] = prefix;
                                // track all namespaces we use
                                namespaces[prefix] = namespace;
                            }
                            if (thisSchema.allOf) {
                                var sampleObj = {};
                                thisSchema.allOf.forEach(function (subschema) {
                                    var ns = resolveNS(isXml, subschema, prefix, namespace, api, references);
                                    _.extend(sampleObj, createExampleObject(subschema, api, false, isXml, ns.prefix, ns.namespace, namespaces, depth, references));
                                });
                                result[propertyName] = sampleObj;
                            } else if (thisSchema.type === 'object' || thisSchema.type === 'array' || (!thisSchema.type && thisSchema.properties)) {
                                // handle loose schema'd objects which are missing their 'type'
                                if (!thisSchema.type) {
                                    thisSchema.type = 'object';
                                }
                                var ns = resolveNS(isXml, thisSchema, prefix, namespace, api, references);
                                result[propertyName] =
                                    createExampleObject(thisSchema, api, empty, isXml, ns.prefix, ns.namespace, namespaces, depth, references);
                                // otherwise use the dummy values
                            } else {
                                var ns = resolveNS(isXml, thisSchema, prefix, namespace, api, references);
                                if (typeof(thisSchema.default) !== 'undefined') {
                                    if (isXml && ns.prefix) {
                                        result[propertyName] = {
                                            "__prefix": ns.prefix,
                                            "__text": thisSchema.default
                                        };
                                        // track all namespaces we use
                                        namespaces[ns.prefix] = ns.namespace;
                                    } else {
                                        result[propertyName] = thisSchema.default;
                                    }
                                } else if (typeof(thisSchema.example) !== 'undefined') {
                                    result[propertyName] = thisSchema.example;
                                } else if (typeof(thisSchema['x-example']) !== 'undefined') {
                                    result[propertyName] = thisSchema['x-example'];
                                } else if (isXml && thisSchema.xml && thisSchema.xml.name) {
                                    // special case for XML - use custom name
                                    var attrValue = createDummyValue(thisSchema.xml.name, thisSchema, empty);
                                    result[thisSchema.xml.name] = attrValue;
                                } else {
                                    if (isXml && ns.prefix) {
                                        result[propertyName] = {
                                            "__prefix": ns.prefix,
                                            "__text": createDummyValue(propertyName, thisSchema, empty)
                                        };
                                        // track all namespaces we use
                                        namespaces[ns.prefix] = ns.namespace;
                                    } else {
                                        result[propertyName] = createDummyValue(propertyName, thisSchema, empty);
                                    }
                                }
                            }
                        }
                    });
                }
            }
        } else if (schema.type === 'array') {
            if (typeof(schema.default) !== 'undefined') {
                result = schema.default;
            } else if (typeof(schema.example) !== 'undefined') {
                result = schema.example;
            } else if (typeof(schema['x-example']) !== 'undefined') {
                result = schema['x-example'];
            } else if (typeof(schema.examples) !== 'undefined') {
              result = schema.examples[Object.keys(schema.examples)];
            } else {
                var list = [];
                if (!schema.items) {
                    return list;
                }
                var obj;
                var objRef;
                var ns;
                if (schema.items[0]) {
                    obj = schema.items[0];
                } else {
                    obj = schema.items;
                }

                // unwind if necessary
                if (obj.$ref){
                  objRef = obj.$ref;
                  obj = possiblyUnwindRefs(obj, api, references);
                  if(obj === null){
                    return {"circular_reference": objRef};
                  }
                }

                // fixes https://github.ibm.com/apimesh/apiconnect-example-generator/issues/9
                // array of array has no "properties" but is also more than just a simple object
                if(obj.type && obj.type === "array"){
                  var ns = resolveNS(isXml, obj, prefix, namespace, api, references);
                  result = createExampleObject(obj, api, empty, isXml, ns.prefix, ns.namespace, namespaces, depth, references);
                }

                else if(obj.type && obj.type === 'object' && obj.example) {
                  result = obj.example;
                }

                // If schema has no properties (loose schema), return the empty object
                else if (!obj.properties) {
                    ns = resolveNS(isXml, schema, prefix, namespace, api, references);
                    if (typeof(obj.default) !== 'undefined') {
                        if (isXml && ns.prefix) {
                            result = {
                                "__prefix": ns.prefix,
                                "__text": obj.default
                            };
                            // track all namespaces we use
                            namespaces[ns.prefix] = ns.namespace;
                        } else {
                            result = obj.default;
                        }
                    } else if (typeof(obj.example) !== 'undefined') {
                        result = obj.example;
                    } else if (typeof(obj['x-example']) !== 'undefined') {
                        result = obj['x-example'];
                    } else {
                        if (isXml && ns.prefix) {
                            result = {
                                "__prefix": ns.prefix,
                                "__text": createDummyValue("", obj, empty)
                            };
                            // track all namespaces we use
                            namespaces[ns.prefix] = ns.namespace;
                        } else {
                            result = createDummyValue("", obj, empty);
                        }
                    }
                } else {
                    Object.keys(obj.properties).forEach(function (propertyName) {
                        var thisSchema = obj.properties[propertyName];
                        // if this property is a schema ref, unwind...
                        if (thisSchema.$ref) thisSchema = unwindRefs(thisSchema, api, references);
                        if (thisSchema.items && thisSchema.items[0] && thisSchema.items[0].$ref) thisSchema = unwindRefs(thisSchema, api, references);
                        if (thisSchema.items && thisSchema.items.$ref) thisSchema = unwindRefs(thisSchema, api, references);
                        if (isXml && thisSchema.xml && thisSchema.xml.attribute === true) {
                            // special case for attributes - prop name should be preceded by underscore
                            var attrValue = createDummyValue(propertyName, thisSchema, empty);
                            result["_" + propertyName] = attrValue;
                        } else if (isXml && thisSchema.xml && thisSchema.xml.name) {
                            // special case for XML - use custom name
                            var attrValue = createDummyValue(thisSchema.xml.name, thisSchema, empty);
                            result[thisSchema.xml.name] = attrValue;
                        } else {
                            if (prefix) {
                                result["__prefix"] = prefix;
                                // track all namespaces we use
                                namespaces[prefix] = namespace;
                            }
                            if (thisSchema.allOf) {
                                var sampleObj = {};
                                thisSchema.allOf.forEach(function (subschema) {
                                    var ns = resolveNS(isXml, subschema, prefix, namespace, api, references);
                                    _.extend(sampleObj, createExampleObject(subschema, api, false, isXml, ns.prefix, ns.namespace, namespaces, depth, references));
                                });
                                result[propertyName] = sampleObj;
                            } else if (thisSchema.type === 'object' || thisSchema.type === 'array' || (!thisSchema.type && thisSchema.properties)) {
                                // handle loose schema'd objects which are missing their 'type'
                                if (!thisSchema.type) {
                                    thisSchema.type = 'object';
                                }
                                var ns = resolveNS(isXml, thisSchema, prefix, namespace, api, references);
                                result[propertyName] =
                                    createExampleObject(thisSchema, api, empty, isXml, ns.prefix, ns.namespace, namespaces, depth, references);
                                // otherwise use the defaultValues hash
                            } else {
                                var ns = resolveNS(isXml, thisSchema, prefix, namespace, api, references);
                                if (typeof(thisSchema.default) !== 'undefined') {
                                    if (isXml && ns.prefix) {
                                        result[propertyName] = {
                                            "__prefix": ns.prefix,
                                            "__text": thisSchema.default
                                        };
                                        // track all namespaces we use
                                        namespaces[ns.prefix] = ns.namespace;
                                    } else {
                                        result[propertyName] = thisSchema.default;
                                    }
                                } else if (typeof(thisSchema.example) !== 'undefined') {
                                    result[propertyName] = thisSchema.example;
                                } else if (typeof(thisSchema['x-example']) !== 'undefined') {
                                    result[propertyName] = thisSchema['x-example'];
                                } else {
                                    if (isXml && ns.prefix) {
                                        result[propertyName] = {
                                            "__prefix": ns.prefix,
                                            "__text": createDummyValue(propertyName, thisSchema, empty)
                                        };
                                        // track all namespaces we use
                                        namespaces[ns.prefix] = ns.namespace;
                                    } else {
                                        result[propertyName] = createDummyValue(propertyName, thisSchema, empty);
                                    }
                                }
                            }
                        }
                    });
                }

                list.push(result);
                result = list;
            }
            removeReferencePath(objRef);
        } else if (typeof(schema.default) !== 'undefined') {
            result = schema.default;
        } else if (typeof(schema.example) !== 'undefined') {
            result = schema.example;
        } else if (typeof(schema['x-example']) !== 'undefined') {
            result = schema['x-example'];
        } else if (typeof(schema.examples) !== 'undefined') {
            // used for responses that have an examples object with mimetypes as the key - return first one
            result = schema.examples[Object.keys(schema.examples)[0]];
        } else if (schema.type === 'string' || schema.type === 'integer' || schema.type === 'number' || schema.type === 'boolean') {
            ns = resolveNS(isXml, schema, prefix, namespace, api, references);
            if (isXml && ns.prefix) {
                result = {
                    "__prefix": ns.prefix,
                    "__text": createDummyValue(schema.name, schema, empty)
                };
                // track all namespaces we use
                namespaces[ns.prefix] = ns.namespace;
            } else {
                result = createDummyValue(schema.name, schema, empty);
            }
        } else if(schema.type === 'file') {
           return null;
        } else if (schema.allOf) {
            var sampleObj = {};
            schema.allOf.forEach(function (subschema) {
                var ns = resolveNS(isXml, subschema, prefix, namespace, api, references);
                _.extend(sampleObj, createExampleObject(subschema, api, false, isXml, ns.prefix, ns.namespace, namespaces, depth, references));
            });
            result = sampleObj
        } else if (schema.anyOf) {
            result = createExampleObject(schema.anyOf[0], api, false, isXml, prefix, namespace, namespaces, depth, references);
        } else if (schema.oneOf) {
            result = createExampleObject(schema.oneOf[0], api, false, isXml, prefix, namespace, namespaces, depth, references);
        } else {
            throw new TypeError('schema should be a basic type, an object, an array, or an allOf / anyOf / oneOf.');
        }

        removeReferencePath(schemaRef);
        return result;
    }

    /**
     * Adds the namespace declaration to the first element in the output
     * @param example the example to edit
     * @param namespaces the list of namespaces to add
     * @returns the edited output
     */
    function insertNamespaceDeclaration(example, namespaces) {
        for (var elementName in example) {
            var element = example[elementName];
            for (var prefix in namespaces) {
                var namespace = namespaces[prefix];
                attrName = "_xmlns:" + prefix;
                element[attrName] = namespace;
            } // end for
        } // end for
    }

     /**
     * Generate the code snippets
     * @param api
     * @param topicName
     * @param kafkaConfig
     * @param languages
     * @returns {{}}
     */
    exampleGen.generateEventCodeSnippets = function (api, topicName, kafkaConfig, languages) {
        var content = {};
        languages.forEach(function (language) {
            content[language + "Content"] = eventCodeSnippetGeneration(api, topicName, kafkaConfig, language);
        });

        return content;
    };

    function eventCodeSnippetGeneration(api, topicName, kafkaConfig, language) {
        var username = 'REPLACE_USERID';
        var password = 'REPLACE_PASSWORD';
        var apikey = 'REPLACE_APIKEY';
        var groupName = 'REPLACE_KAFKA_GROUP_NAME';

        switch (language) {
        /*--------------------------------------------------------------------------------*/
        /*                                                                                */
        /* kafkacat code snippet                                                          */
        /*                                                                                */
        /*--------------------------------------------------------------------------------*/
        case 'kafkacat': {
            return 'kafkacat -C \\\n' +
                    '         -b "' + kafkaConfig.bootstrapServers.toString() + '" \\\n' +
                    '         -X "api.version.request=true" \\\n' +
                    '         -X "security.protocol=sasl_ssl" \\\n' +
                    '         -X "ssl.ca.location=rootcerts.pem" \\\n' +
                    '         -X "sasl.mechanisms=PLAIN" \\\n' +
                    '         -X "sasl.username=' + username + '" \\\n' +
                    '         -X "sasl.password=' + password + '" \\\n' +
                    '         -G ' + groupName + ' ' + topicName;
        }
        /*--------------------------------------------------------------------------------*/
        /*                                                                                */
        /* python code snippet                                                            */
        /*                                                                                */
        /*--------------------------------------------------------------------------------*/
        case 'python': {
            return  'from confluent_kafka import Consumer\n' +
                    '\n' +
                    '# For more information about the Python Kafka Client, visit:\n' +
                    '#     https://github.com/confluentinc/confluent-kafka-python\n' +
                    'consumer_opts = {\n' +
                    '    \'client.id\': \'kafka-python-console-sample-consumer\',\n' +
                    '    \'group.id\': \'kafka-python-console-sample-group\',\n' +
                    '    \'bootstrap.servers\': \'' + kafkaConfig.bootstrapServers.toString() + '\',\n' +
                    '    \'security.protocol\': \'SASL_SSL\',\n' +
                    '    \'ssl.ca.location\': \'rootcerts.pem\',\n' +
                    '    \'sasl.mechanisms\': \'PLAIN\',\n' +
                    '    \'sasl.username\': \'' + username + '\',\n' +
                    '    \'sasl.password\': \'' + password + '\',\n' +
                    '    \'api.version.request\': True\n' +
                    '}\n' +
                    '\n' +
                    'consumer = Consumer(consumer_opts)\n' +
                    'consumer.subscribe([\'' + topicName + '\'])\n' +
                    '\n' +
                    'while True:\n' +
                    '    msg = consumer.poll(1)\n' +
                    '    if msg is not None and msg.error() is None:\n' +
                    '        print(\'Message consumed: topic={0}, partition={1}, offset={2}, key={3}, value={4}\'.format(\n' +
                    '                msg.topic(),\n' +
                    '                msg.partition(),\n' +
                    '                msg.offset(),\n' +
                    '                msg.key().decode(\'utf-8\'),\n' +
                    '                msg.value().decode(\'utf-8\')));\n'
        }

        /*--------------------------------------------------------------------------------*/
        /*                                                                                */
        /* java code snippet                                                              */
        /*                                                                                */
        /*--------------------------------------------------------------------------------*/
        case 'java': {
            return 'import java.util.Arrays;\n' +
                   'import java.util.Properties;\n' +

                   'import org.apache.kafka.clients.consumer.ConsumerRecord;\n' +
                   'import org.apache.kafka.clients.consumer.ConsumerRecords;\n' +
                   'import org.apache.kafka.clients.consumer.KafkaConsumer;\n' +
                   '\n' +
                   '// For more information about the Java Kafka API, visit:\n' +
                   '//     https://kafka.apache.org/0100/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html\n' +
                   'public final class Consumer {\n' +
                   '\n' +
                   '    // put this in jaas.conf \n' +
                   '    //\n' +
                   '    // KafkaClient {\n' +
                   '    //     org.apache.kafka.common.security.plain.PlainLoginModule required\n' +
                   '    //     serviceName="kafka"\n' +
                   '    //     username="' + username + '"\n' +
                   '    //     password="' + password + '";\n' +
                   '    // };\n' +
                   '\n' +
                   '    public static void main(final String[] args) {\n' +
                   '\n' +
                   '        final Properties props = new Properties();\n' +
                   '        props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n' +
                   '        props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n' +
                   '        props.put("client.id", "kafka-java-console-sample-consumer");\n' +
                   '        props.put("group.id", "kafka-java-console-sample-group");\n' +
                   '        props.put("security.protocol", "SASL_SSL");\n' +
                   '        props.put("sasl.mechanism", "PLAIN");\n' +
                   '        props.put("ssl.protocol", "TLSv1.2");\n' +
                   '        props.put("ssl.enabled.protocols", "TLSv1.2");\n' +
                   '        props.put("ssl.endpoint.identification.algorithm", "HTTPS");\n' +
                   '        props.put("auto.offset.reset", "latest");\n' +
                   '        props.put("bootstrap.servers", "' + kafkaConfig.bootstrapServers.toString() + '");\n' +
                   '\n' +
                   '        final KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);\n' +
                   '        consumer.subscribe(Arrays.asList("' + topicName + '"));\n' +
                   '\n' +
                   '        while (true) {\n' +
                   '            final ConsumerRecords<String, String> records = consumer.poll(1000);\n' +
                   '\n' +
                   '            for (final ConsumerRecord<String, String> record : records)\n' +
                   '                System.out.println(record.value());\n' +
                   '        }\n' +
                   '    }\n' +
                   '}';
        }
        /*--------------------------------------------------------------------------------*/
        /*                                                                                */
        /* node code snippet                                                              */
        /*                                                                                */
        /*--------------------------------------------------------------------------------*/
        case 'node': {
            return 'var Kafka = require(\'node-rdkafka\');\n' +
                   '\n' +
                   '// For more information about the Node Kafka Client, visit:\n' +
                   '//     https://github.com/Blizzard/node-rdkafka\n' +
                   'var driver_options = {\n' +
                   '    \'metadata.broker.list\': \'' + kafkaConfig.bootstrapServers.toString() + '\',\n' +
                   '    \'security.protocol\': \'sasl_ssl\',\n' +
                   '    \'ssl.ca.location\': \'rootcerts.pem\',\n' +
                   '    \'sasl.mechanisms\': \'PLAIN\',\n' +
                   '    \'sasl.username\': \'' + username + '\',\n' +
                   '    \'sasl.password\': \'' + password + '\',\n' +
                   '    \'api.version.request\': true,\n' +
                   '    \'socket.timeout.ms\': 10000,\n' +
                   '    \'client.id\': \'sample-consumer\',\n' +
                   '    \'group.id\': \'sample-group\'\n' +
                   '};\n' +
                   '\n' +
                   'var consumer = new Kafka.KafkaConsumer(driver_options);\n' +
                   '\n' +
                   'consumer.on(\'ready\', function() {\n' +
                   '    consumer.subscribe([\'' + topicName + '\']);\n' +
                   '    consumer.consume();\n' +
                   '});\n' +
                   '\n' +
                   'consumer.on(\'data\', function(m) {\n' +
                   '    console.log(m.value.toString());\n' +
                   '});\n' +
                   '\n' +
                   'consumer.connect();'
        }
        /*--------------------------------------------------------------------------------*/
        /*                                                                                */
        /* unsupported language switch statement                                          */
        /*                                                                                */
        /*--------------------------------------------------------------------------------*/
        default: {
            return 'Unsupported Language';
        }
        }
    }

    /**
     * Generate the code snippets
     * @param api
     * @param path
     * @param verb
     * @param operation
     * @param config
     * @param clientId
     * @param clientSecret
     * @param languages
     * @param references
     * @param values an object containing key=value property pairs that provide values for parameters used instead of place holder REPLACE_THIS_KEY text
     * @returns {{}}
     */
    exampleGen.generateCodeSnippets = function (api, path, verb, operation, config, clientId, clientSecret, languages, references, endpoint, values) {
        if (!clientId) clientId = "REPLACE_THIS_KEY";
        if (!clientSecret) clientSecret = "REPLACE_THIS_KEY";

        if (!endpoint) {
            if (api.endpoint) {
                endpoint = api.endpoint;
            } else if (api['x-ibm-configuration'] && api['x-ibm-configuration']['servers'] && api['x-ibm-configuration']['servers'][0] && api['x-ibm-configuration']['servers'][0]['url']) {
                endpoint = api['x-ibm-configuration']['servers'][0]['url'];
            } else if (api['x-ibm-endpoints'] && api['x-ibm-endpoints'][0] && api['x-ibm-endpoints'][0].endpointUrl) {
                endpoint = api['x-ibm-endpoints'][0].endpointUrl;
                endpoint += (api.basePath) ? api.basePath : "";
            } else if (api.openapi && api.servers && api['servers'][0] && api['servers'][0].url) {
                endpoint = api['servers'][0].url;
            } else {
                // derive it from the api
                endpoint = "://" + api.host;
                if (api.schemes) {
                    endpoint = api.schemes[0] + endpoint;
                } else {
                    endpoint = "https" + endpoint;
                }
                endpoint += (api.basePath) ? api.basePath : "";
            }
        }

        // For OAI3 the endpoint is passed in as an object containing a URL.  It looks
        // like it might contain multiple, so just take the last one and make it a
        // string like the code expects
        if(typeof(endpoint) == 'object') {
            for(var url in endpoint) {
                var ep = endpoint[url];
            }
            endpoint = ep;
        }

        endpoint = endpoint.replace(/\/$/, "");
        // add the path
        var url = endpoint + path;

        var headersarray = [];
        var queryarray = [];
        var body = null;

        if(!values) {
          values = {};
        }

        if (config && config.requiresClientId) {
            if (config.clientIdLocation == 'query') {
                if (config.clientIdName) {
                    queryarray.push({'name': config.clientIdName, 'value': clientId});
                } else {
                    queryarray.push({'name': 'client_id', 'value': clientId});
                }
            } else if (config.clientIdLocation == 'header') {
                if (config.clientIdName) {
                    headersarray.push({'name': config.clientIdName, 'value': clientId});
                } else {
                    headersarray.push({'name': 'X-IBM-Client-Id', 'value': clientId});
                }
            }
        }
        if (config && config.requiresClientSecret) {
            if (config.clientSecretLocation == 'query') {
                if (config.clientSecretName) {
                    queryarray.push({'name': config.clientSecretName, 'value': clientSecret});
                } else {
                    queryarray.push({'name': 'client_secret', 'value': clientSecret});
                }
            } else if (config.clientSecretLocation == 'header') {
                if (config.clientSecretName) {
                    headersarray.push({'name': config.clientSecretName, 'value': clientSecret});
                } else {
                    headersarray.push({'name': 'X-IBM-Client-Secret', 'value': clientSecret});
                }
            }
        }
        if (config && config.requiresBasicAuth) {
            if(values.basicAuth) {
                headersarray.push({'name': 'Authorization', 'value': 'Basic ' + values.basicAuth});
            }
            else {
                headersarray.push({'name': 'Authorization', 'value': 'Basic ' + 'REPLACE_BASIC_AUTH'});
            }
        }
        if (config && config.requiresOauth) {
            if(values.oauthToken) {
                headersarray.push({'name': 'Authorization', 'value': 'Bearer ' + values.oauthToken});
            }
            else {
                headersarray.push({'name': 'Authorization', 'value': 'Bearer ' + 'REPLACE_BEARER_TOKEN'});
            }
        }
        if (config && config.requiresHttpBearerToken) {
            if(config.httpBearerToken) {
                headersarray.push({'name': 'Authorization', 'value': 'Bearer ' + config.httpBearerToken});
            }
            else {
                headersarray.push({'name': 'Authorization', 'value': 'Bearer ' + 'REPLACE_BEARER_TOKEN'});
            }
        }


        var parameters = config.parametersArray;
        if (!parameters) parameters = [];
        // path parameters
        var pathParameters = parameters.filter(function (parameter) {
            return (parameter.in == "path");
        });
        if (pathParameters.length > 0) {
            pathParameters.forEach(function (parameter) {
                var value = 'REPLACE_' + parameter.name.toUpperCase();
                if(values[parameter.name]) {
                  value = values[parameter.name];
                }
                if (parameter.default) {
                    value = parameter.default.toString();
                } else if (parameter['x-example']) {
                    value = parameter['x-example'].toString();
                }
                url = url.replace("{" + parameter.name + "}", value);
            });
        }
        // query parameters
        var queryParameters = parameters.filter(function (parameter) {
            return (parameter.in == "query");
        });
        if (queryParameters.length > 0) {
            queryParameters.forEach(function (parameter) {
                var value = 'REPLACE_THIS_VALUE';
                if(values[parameter.name]) {
                  value = values[parameter.name];
                }
                if (parameter.default) {
                    value = parameter.default.toString();
                } else if (parameter['x-example']) {
                    value = parameter['x-example'].toString();
                }
                queryarray.push({'name': parameter.name, 'value': value});
            });
        }
        // handle external security
        if (config.externalApiKeys && Object.keys(config.externalApiKeys).length !== 0) {
            for (var prop in config.externalApiKeys){
                var key = config.externalApiKeys[prop];
                var value = 'REPLACE_THIS_VALUE';
                if(values[key.name]) {
                  value = values[key.name];
                }
                if (key.in == 'query') {
                    queryarray.push({'name': key.name, 'value': value});
                } else if (key.in == 'header') {
                    headersarray.push({'name': key.name, 'value': value});
                }
            }
        }

        // is this SOAP? if so, ditch the operationId from the end...
        if (config.soapAction !== undefined) {
            var suffix = "/" + operation.operationId;
            if (url.indexOf(suffix, this.length - suffix.length) !== -1) {
                url = url.substring(0, url.length - suffix.length);
            }
        }
        if (config.soapAction !== undefined) {
            headersarray.push({'name': 'SOAPAction', 'value': config.soapAction});
        }

        // headers
        var contenttype = getDefaultContentType(operation, api);
        var accept = getDefaultAccept(operation, api);

        // allow for overrides
        if(config.contenttype) {
          contenttype = config.contenttype;
        }
        if(config.accept) {
          accept = config.accept;
        }

        var headerParameters = parameters.filter(function (parameter) {
            return (parameter.in == "header");
        });
        if (headerParameters.length > 0) {
            headerParameters.forEach(function (parameter) {
                var value = 'REPLACE_THIS_VALUE';
                if(values[parameter.name]) {
                  value = values[parameter.name];
                }
                if (parameter.default) {
                    value = parameter.default.toString();
                } else if (parameter['x-example']) {
                    value = parameter['x-example'].toString();
                }
                headersarray.push({'name': parameter.name, 'value': value});
            });
        }

        // body
        var bodyParameters = parameters.filter(function (parameter) {
            return (parameter.in == "body");
        });
        var formDataParameters = parameters.filter(function (parameter) {
            return (parameter.in == "formData");
        });
        if (bodyParameters.length > 0) {
            // we have a body parameter - take from values or generate a sample
            if(values[bodyParameters[0].name]) {
              body = values[bodyParameters[0].name];
            }
            else {
              body = exampleGen.generateExampleParameter(api, path, verb, bodyParameters[0], contenttype, true, references);
            }
        } else if (formDataParameters.length > 0) {
            var formDataArray = [];
            var formDataParams = [];
            formDataParameters.forEach(function (parameter) {
                var value = values[parameter.name];
                if(!value) {
                  value = createDummyValue(parameter.name, parameter, false);
                }
                formDataArray.push(parameter.name + ': ' + value);
                formDataParams.push({'name': parameter.name, 'value': value});
            });
            body = formDataArray.join('\n');
        }

        // insert contenttype and accept headers as well
        if (contenttype && body) {
            // only add content type if we're sending content
            headersarray.push({'name': 'content-type', 'value': contenttype});
        }
        if (accept) {
            headersarray.push({'name': 'accept', 'value': accept});
        }

        // create the HAR request configuration
        var confHAR = {
            "method": verb.toUpperCase(),
            "url": url,
            "headers": headersarray,
            "queryString": queryarray
        };

        if (body) {
            confHAR["postData"] = {
                "mimeType": contenttype,
                "text": body
            };
            if (formDataParameters.length > 0) {
                confHAR["postData"]['params'] = formDataParams;
            }
        }
        // We must pre-process the URL to replace any $(var) inserts that may be contained in the
        // host part of the URL as the URL parser will think they are part of the path rather than
        // part of the host.
        var subLookup = {};
        var increment = 0;
        if (api.host) {
            var matches = api.host.match(/(\$\([^\)]*\))/g);
            if (matches) {
                var newURL = confHAR.url;
                // switch each match with a generated hostname-safe value
                var len = matches.length;
                for (var i = 0; i < len; i++) {
                    increment += 1;
                    var fakeHost = "azazaz090909-" + increment;
                    subLookup[fakeHost] = matches[i];
                    newURL = newURL.replace(matches[i], fakeHost);
                } // end for
                confHAR.url = newURL;
            }
        }
        // use the lookup table to switch the fake values with real ones in the actual output
        var restoreURL = function (snippet) {
            var ret = snippet;
            if (increment > 0) {
                for (var key in subLookup) {
                    var replacement = subLookup[key];
                    ret = ret.replace(key, replacement);
                } // end for
            }
            return ret;
        };

        // get a new instance of httpSnippet
        var mySnippet = new window.HTTPSnippetInstance(confHAR);

        if (!languages) languages = ["curl", "ruby", "python", "php", "java", "node", "go", "swift", "c", "csharp"];

        var content = {};
        languages.forEach(function (language) {
            if (language === "curl") {
                content.curlContent = restoreURL(mySnippet.convert('shell', 'curl'));
            } else if (language === "httpie") {
                content.curlContent = restoreURL(mySnippet.convert('shell', 'httpie'));
            } else if (language === "wget") {
                content.curlContent = restoreURL(mySnippet.convert('shell', 'wget'));
            } else if (language === "java") {
                content.javaContent = restoreURL(mySnippet.convert('java', 'okhttp'));
            } else if (language === "node") {
                content.nodeContent = restoreURL(mySnippet.convert('node', 'request'));
            } else {
                content[language + "Content"] = restoreURL(mySnippet.convert(language));
            }
        });

        return content;
    };

    /**
     * Generate a specific response
     * @param api
     * @param path
     * @param verb
     * @param responseCode
     * @param mediaType i.e. the 'accept' header / the type of response you want to get back
     * @param references
     */
    exampleGen.generateResponse = function (api, path, verb, responseCode, mediaType, references) {
        var operation = api.paths[path][verb];

        var response = operation.responses[responseCode];
        var retXML = returnsXML(operation, api) && !returnsJSON(operation, api);
        return responseGenerator(api, response, retXML, mediaType, references);
    };

    /**
     * Generate a specific event response
     * @param api
     * @param eventName
     * @param mediaType i.e. the 'accept' header / the type of response you want to get back
     * @param references
     */
    exampleGen.generateEventResponse = function (api, eventName, mediaType, references) {
        var eventData;
        Object.keys(api).forEach(function(openApiKey) {
            if (openApiKey.toLowerCase() === 'x-ibm-events') {
                eventData = api[openApiKey];
            }
        });
        return responseGenerator(api, eventData[eventName], false, mediaType, references);
    };


    /**
     * Generate a specific response
     * @param api
     * @param response
     * @param returnXML - will be overridden if using openapi3
     * @param mediaType i.e. the 'accept' header / the type of response you want to get back
     * @param references
     */
    function responseGenerator(api, response, returnXML, mediaType, references) {

        // if we have an OpenAPI 3.0 multiple type response...
        if (response.content) {
          if (mediaType && response.content[mediaType]) {
            // and we've been given a valid content type option
            response = response.content[mediaType];
          } else if (Object.keys(response.content).length > 0) {
            // else pick the first one
            mediaType = Object.keys(response.content)[0]
            response = response.content[mediaType];
          }
        }

        // return XML if the media type provided is an XML type
        returnXML = mediaType.indexOf('xml') > -1;

        var namespaces = {};
        var example = createExampleObject(response, api, false, returnXML, "", "", namespaces, 0, references);
        if (returnXML) {
            insertNamespaceDeclaration(example, namespaces);
        }

        if (!example) return;

        if (returnXML) {
            example = window.vkbeautify.xml(json2xmlInstance().js2xml(example));
            example = _.unescape(example);
        } else {
            if (mediaType === "application/yaml") {
                example = jsyaml.safeDump(example, {lineWidth: -1});
            } else {
                example = JSON.stringify(example, null, 2);
            }
        }
        return example;
    }

    exampleGen.generateEventExampleResponse = function (api, streamName) {
        var result = {};
        Object.keys(api).forEach(function(key) {
            if (key.toLowerCase() === 'x-ibm-events') {
                // For now only expect a single content type for the event data.
                var eventContentTypes = Object.keys(api[key][streamName].content);
                var example = createExampleObject(api[key][streamName].content[eventContentTypes[0]], api, false, false, "", "", {}, 0);
                result = JSON.stringify(example, null, 2);
            }
        });
        return result;
    };

    /**
     * Generate the examples
     * @param api
     * @param path
     * @param verb
     * @param references
     */
    exampleGen.generateExampleResponse = function (api, path, verb, references) {

        var operation = api.paths[path][verb];

        var retXML = returnsXML(operation, api) && !returnsJSON(operation, api);
        var example;
        var namespaces = {};

        if (operation.responses["200"] && (operation.responses["200"].schema || operation.responses["200"].examples)) {
            // example = operation.getResponse("200").getSample();
            example = createExampleObject(operation.responses["200"], api, false, retXML, "", "", namespaces, 0, references);
            if (retXML) {
                insertNamespaceDeclaration(example, namespaces);
            }
        } else if (operation.responses["201"] && (operation.responses["201"].schema || operation.responses["201"].examples)) {
            // example = operation.getResponse("201").getSample();
            example = createExampleObject(operation.responses["201"], api, false, retXML, "", "", namespaces, 0, references);
            if (retXML) {
                insertNamespaceDeclaration(example, namespaces);
            }
        } else if (operation.responses["202"] && (operation.responses["202"].schema || operation.responses["202"].examples)) {
            // example = operation.getResponse("201").getSample();
            example = createExampleObject(operation.responses["202"], api, false, retXML, "", "", namespaces, 0, references);
            if (retXML) {
                insertNamespaceDeclaration(example, namespaces);
            }
        } else if (operation.responses["default"] && (operation.responses["default"].schema || operation.responses["default"].examples)) {
            // example = operation.getResponse("default").getSample();
            example = createExampleObject(operation.responses["default"], api, false, retXML, "", "", namespaces, 0, references);
            if (retXML) {
                insertNamespaceDeclaration(example, namespaces);
            }
        }

        if (!example) return;

        if (retXML) {
            example = window.vkbeautify.xml(json2xmlInstance().js2xml(example));
            example = _.unescape(example);
        } else {
            example = JSON.stringify(example, null, 2);
        }
        return example;
    };

    /**
     * Generate example for a single parameter (e.g. body)
     * @param api
     * @param path
     * @param verb
     * @param parameter
     * @param contentType
     * @param skipBeautify
     * @param references
     * @returns {*}
     */
    exampleGen.generateExampleParameter = function (api, path, verb, parameter, contentType, skipBeautify, references) {

        var operation = api.paths[path][verb];

        if (!parameter) {
            var parameters = [];
            // use operation specific parameters
            if (api.paths[path][verb].parameters) parameters = parameters.concat(JSON.parse(JSON.stringify(api.paths[path][verb].parameters)));
            // only check for path level parameters if didn't have an operation specific example
            if (parameters.length < 1) {
                if (api.paths[path].parameters) parameters = parameters.concat(JSON.parse(JSON.stringify(api.paths[path].parameters)));
            }

            parameters.forEach(function (param) {
                if (param.$ref) param = unwindParamRef(param, api, references);
            });

            var theParameter = parameters.filter(function (param) {
                return (param.name == parameter.name)
            });

            if (theParameter.length !== 1) return;

            parameter = theParameter[0];
        }

        // For OAI3, parameters can have either an 'example' or 'examples' property containing user specified examples
        // If present, we should use them
        if (api.openapi) {
          if (parameter.example){
            return parameter.example;
          } else if (parameter.examples) {
            return parameter.examples[Object.keys(parameter.examples)[0]];
          } else if (parameter['x-example']){
            return parameter['x-example'];
          } else if (parameter.schema && parameter.schema.examples) {
            return parameter.schema.examples[Object.keys(parameter.schema.examples)[0]];
          } else if (parameter.schema && parameter.schema.example) {
            return parameter.schema.example;
          } else if (parameter.schema && parameter.schema['x-example']) {
            return parameter.schema['x-example'];
          }
        }

        var retXML = acceptsXML(operation, api) && !acceptsJSON(operation, api);
        var retYAML = false;
        // if we have been passed a content type header, override
        if (contentType) {
            if (contentType.indexOf('json') >= 0) {
                retXML = false;
            } else if (contentType.indexOf('xml') >= 0) {
                retXML = true;
            }
            retYAML = (contentType.indexOf('yaml') >= 0);
        }

        var namespaces = {};
        var example = createExampleObject(parameter, api, false, retXML, "", "", namespaces, 0, references);

        if (retXML) {
            if (parameter.schema) {
                var schema = parameter.schema;
                if (schema.example) return schema.example;
                var wrapName = "";
                // unwind references so we can access the top-level data
                var topRef = null;
                if (schema.$ref) {
                    topRef = schema.$ref;
                    schema = unwindRefs(schema, api, references);
                }
                if (schema.items && (schema.items[0] && schema.items[0].$ref) || (schema.items && schema.items.$ref)) {
                    schema = unwindRefs(schema, api, references);
                }
                if (schema.xml && schema.xml.name) {
                    wrapName = schema.xml.name;
                } else if (!(schema.properties && schema.properties.Envelope)) {
                    // dont wrap Envelope types
                    if (topRef) {
                        var lastSlash = topRef.lastIndexOf("/");
                        wrapName = topRef.substr(lastSlash + 1);
                    } else {
                        wrapName = parameter.name;
                    }
                }
                if (wrapName) {
                    // wrap it up inside the top-level element
                    var wrappedExample = {};
                    wrappedExample[wrapName] = example;
                    insertNamespaceDeclaration(wrappedExample, namespaces);
                    example = json2xmlInstance().js2xml(wrappedExample);
                    if (!skipBeautify) {
                        example = window.vkbeautify.xml(example);
                        example = _.unescape(example);
                    }
                } else {
                    insertNamespaceDeclaration(example, namespaces);
                    example = json2xmlInstance().js2xml(example);
                    if (!skipBeautify) {
                        example = window.vkbeautify.xml(example);
                        example = _.unescape(example);
                    }
                }
            } else {
                insertNamespaceDeclaration(example, namespaces);
                example = json2xmlInstance().js2xml(example);
                if (!skipBeautify) {
                    example = window.vkbeautify.xml(example);
                    example = _.unescape(example);
                }
            }
        } else {
            // beautify body parameters and objects only
            if (parameter.in == "body" || typeof example == "object") {
                if (skipBeautify) {
                    if (retYAML) {
                        example = jsyaml.safeDump(example, {lineWidth: -1});
                    } else {
                        example = JSON.stringify(example);
                    }
                } else {
                    if (retYAML) {
                        example = jsyaml.safeDump(example, {lineWidth: -1});
                    } else {
                        example = JSON.stringify(example, null, 2);
                    }
                }
            }
        }
        return example;
    };

    // CommonJS module
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = exampleGen;
        }
        exports.exampleGen = exampleGen;
    }

    // Register as an anonymous AMD module
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return exampleGen;
        });
    }

    // If there is a window object, that at least has a document property,
    // instantiate and define chance on the window
    if (typeof window === "object" && typeof window.document === "object") {
        window.exampleGenerator = exampleGen;
    }

    return exampleGen;
})();
