#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-drafts


var Promise = require('bluebird');
var drafts = require('apiconnect-apim-client').drafts;
var formatter = require('./formatter');
var f = require('util').format;
var g = require('strong-globalize')();

var codes = drafts.codes;

module.exports.draftsClear = function draftsClear(options) {
  if (options.confirm !== 'drafts') {
    throw new Error(g.f('The {{--confirm}} drafts option is required'));
  }
  return drafts.clear(options).then(formatter.clear);
};

module.exports.draftsDelete = function draftsDelete(nameVersion, options) {
  var nv = nameVersion.split(':');
  options.name = nv[0];
  options.version = nv[1];

  return drafts.delete(options)
    .then(formatter.delete)
    .catch(function(err) {
      switch (err.code) {
        case codes.PRODUCT_ONLY_NO_PRODUCT:
          err = new Error(g.f('The {{--product-only}} option requires a product to delete.'));
          break;
        case codes.AMBIGUOUS_REQUEST:
          err = new Error(g.f('The product or API must be qualified with version to be sufficiently disambiguated.'));
          break;
        // The cli sliently returns in the case where nothing is found!?
        case codes.NOT_FOUND:
          err = null;
          break;
      };
      if (err) {
        return;
      }
      return Promise.reject(err);
    });
};

module.exports.draftsGet = function draftsGet(nameVersion, options) {
  var nv = nameVersion.split(':');
  options.name = nv[0];
  options.version = nv[1];

  return drafts.get(options).then(formatter.get);
};

module.exports.draftsList = function draftsList(options) {
  if (options.allOrganizations) {
    options.organization = null;
  } else if (!options.organization) {
    throw new Error(g.f('Either the {{--organization}} or {{--all-organizations}} option is required.'));
  }
  return drafts.list(options).then(formatter.list);
};

module.exports.draftsPublish = function draftsPublish(nameVersion, options) {
  var nv = nameVersion.split(':');
  options.name = nv[0];
  options.version = nv[1];

  return drafts.publish(options)
    .then(formatter.publish)
    .catch(function(err) {
      switch (err.code) {
        case codes.AMBIGUOUS_PRODUCT:
          err = new Error(g.f('The product %s must be qualified with version to be sufficiently disambiguated.',
            nameVersion));
          break;
        case codes.NOT_FOUND:
          err = new Error(g.f('The product %s was not found.', nameVersion));
          break;
        case codes.CATALOG_NOT_FOUND:
          err = new Error(g.f('The catalog %s was not found.', options.catalog));
          break;
      };
      return Promise.reject(err);
    });
};

module.exports.draftsStage = draftsStage;
function draftsStage(nameVersion, options) {
  options.stage = true;
  return module.exports.draftsPublish(nameVersion, options);
};

module.exports.draftsClone = function draftsClone(options) {
  // Use pull formatter as clone just calls pull [n] times
  return drafts.clone(options).then(formatter.pull);
};

module.exports.draftsPull = function draftsPull(nameVersion, options) {
  var nv = nameVersion.split(':');
  options.name = nv[0];
  options.version = nv[1];

  return drafts.pull(options)
    .then(formatter.pull)
    .catch(function(err) {
      switch (err.code) {
        case codes.AMBIGUOUS_REQUEST:
          var m = g.f('The provided definition %s must be qualified with version to be sufficiently disambiguated.',
            nameVersion);
          err = new Error(m);
          break;
        case codes.NOT_FOUND:
          break;
      };
      return Promise.reject(err);
    });
};

module.exports.draftsPush = function draftsPush(filename, options) {
  options.filename = filename;

  if (!options.filename) {
    throw new Error(g.f('The file name is required.'));
  }

  return drafts.push(options)
    .then(formatter.push)
    .catch(function(err) {
      switch (err.code) {
        case codes.ERROR_PROCESSING_FILE:
          // ick
          var errors = [];
          err.obj.errs.forEach(function(error) {
            error.errors.forEach(function(e) {
              errors.push(e.err);
            });
          });
          err = new Error(g.f('%s', errors));
          break;
        case codes.API_NOT_FOUND:
          err = new Error(g.f('The API %s was not found.', f('%s:%s', err.obj.name, err.obj.version)));
          break;
        case codes.AMBIGUOUS_API:
          err = new Error(g.f('The API must be qualified with version to be sufficiently disambiguated.'));
          break;
        case codes.PRODUCT_NOT_FOUND:
          err = new Error(g.f('The product %s was not found.', f('%s:%s', err.obj.name, err.obj.version)));
          break;
        case codes.AMBIGUOUS_PRODUCT:
          err = new Error(g.f('The API must be qualified with version to be sufficiently disambiguated.'));
          break;
      };
      return Promise.reject(err);
    });
};

