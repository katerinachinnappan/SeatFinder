#!/usr/bin/env node
// Copyright IBM Corp. 2016. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

// This file is created for our internal testing purposes.

var Parser = require('posix-getopt').BasicParser;
var VERSION = require('../package.json').version;
var basename = require('path').basename;
var fs = require('fs');

var optind = 1;
var $0 = basename(process.argv[optind++]);
var command = process.argv[optind++];

var commands = {
  help: help,
  start: require('../lib/server-command').start,
  stop: require('../lib/server-command').stop,
  status: require('../lib/server-command').status,
  list: require('../lib/server-command').list,
  deleteClusterData: require('../lib/server-command').deleteClusterData,
  clearClusterData: require('../lib/server-command').clearClusterData,
  listClusterData: require('../lib/server-command').listClusterData,
  getClusterData: require('../lib/server-command').getClusterData,
  setClusterData: require('../lib/server-command').setClusterData,
  getData: require('../lib/server-command').getData,
  setData: require('../lib/server-command').setData,
  version: version,
  setIhsInfo: require('../lib/server-command').setIhsInfo,
  listIhsInfo: require('../lib/server-command').listIhsInfo,
  getHosts: require('../lib/server-command').getHosts,
};

if (!command) {
  printHelp($0, console.error);
  return exit(1);
}

var commandFn = commands[command];

if (!commandFn) {
  console.error('Unknown action: %s', command);
  printHelp($0, console.error);
  return exit(1);
}

var serverCommandParser = new Parser([
  ':',
  'A(autoAcceptCertificates)',
  'H:(host)',
  'P:(port)',
  'U:(user)',
  'c:(clusterName)',
  'd:(data)',
  'h:(hostName)',
  'k:(key)',
  'p:(password)',
  's:(serverName)',
  't:(path)',
  'u:(wlpnUserDir)',
  'i:(ihsIp)',
  'I:(ihsPort)',
].join(''), process.argv, optind);

var option;
var args = {};

while ((option = serverCommandParser.getopt()) !== undefined) {
  switch (option.option) {
    case 'A': args.autoAcceptCertificates = true; break;
    case 'H': args.host = option.optarg; break;
    case 'P': args.port = option.optarg; break;
    case 'U': args.user = option.optarg; break;
    case 'c': args.clusterName = option.optarg; break;
    case 'd': args.data = option.optarg; break;
    case 'h': args.hostName = option.optarg; break;
    case 'k': args.key = option.optarg; break;
    case 'p': args.password = option.optarg; break;
    case 's': args.serverName = option.optarg; break;
    case 't': args.path = option.optarg; break;
    case 'u': args.wlpnUserDir = option.optarg; break;
    case 'i': args.ihsIp = option.optarg; break;
    case 'I': args.ihsPort = option.optarg; break;
    default:
      console.error('Invalid usage at ' + option.optopt);
      return exit(1);
  }
}

console.log('args:', args);
commandFn(args, function(err, result) {
  if (err) {
    if (err.message) {
      console.error('Error: %s', err.message);
    }
    exit(1);
  }
  if (result) {
    console.log('%s', JSON.stringify(result));
  }
  exit(0);
});

function version() {
  console.log('%s', VERSION);
  exit(0);
}

function help(argv, optind, options, cb) {
  var action = process.argv[optind++];

  if (!action) {
    printHelp($0, console.log);
    exit(0);
  }

  try {
    printHelp($0, console.error);
  } catch (err) {
    console.error(err);
    printHelp($0, console.error);
    exit(1);
  }
}

function exit(code) {
  return setImmediate(process.exit, code);
}

function printHelp($0, prn) {
  var USAGE = fs.readFileSync(require.resolve('./server.txt'), 'utf-8')
    .replace(/%MAIN%/g, $0)
    .trim();
  prn(USAGE);
}
