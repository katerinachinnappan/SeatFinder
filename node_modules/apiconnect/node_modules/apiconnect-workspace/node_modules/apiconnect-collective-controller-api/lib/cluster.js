// Copyright IBM Corp. 2016. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var async = require('async');
var cluster = require('apiconnect-collective-jmx').cluster;
var debug = require('./debug')('apiconnect-collective-controller-api:upload');
var fileService = require('./file-service');
var jmx = require('apiconnect-collective-jmx');
var mandatory = require('./util').mandatory;
var parseConfig = require('./parse-config');

var GROUP = 'apic';

exports.listClusterNames = listClusterNames;
exports.listMembers = listMembers;
exports.restartCluster = restartCluster;
exports.stopCluster = stopCluster;
exports.startCluster = startCluster;


/**
 * List all clusters registered to controller.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 *
 * Returns array of members in the form `host,userdir,servername`
 */
function listClusterNames(options, cb) {
  options = parseConfig(options);

  // Override for testing.
  var _sendRequest = options.request || sendRequest;

  _sendRequest(options, null, cluster.listClusterNames,
    function(err, result) {
      if (err) { return cb(err); }
      return cb(null, result);
    });
}

/**
 * Lists all members of a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster.
 *
 * Returns a simple array of strings with members registed to cluster in the
 * form `host,userdir,servername`.
 * Example:
 *   ['hostname,userdir,servername','hostname,userdir,servername2'].
 */
function listMembers(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName);

  // Override for testing.
  var _sendRequest = options.request || sendRequest;

  options.clusterName = [GROUP, options.clusterName].join('.');
  _sendRequest(options, null, cluster.listMembers,
    function(err, result) {
      if (err) { return cb(err); }
      return cb(null, result);
    });
}

/**
 * Restarts all members in a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster.
 *
 * Returns array of clusters in the form `["cluster1","cluster2"]`.
 */
function restartCluster(options, cb) {
  async.series([
    stopCluster.bind(null, options),
    startCluster.bind(null, options),
  ], cb);
}

function stopCluster(options, cb) {
  async.waterfall([
    _getScalingPolicy.bind(null, options),
    getUserDefinedInstances,
    _stop,
  ], cb);

  // TODO: Below `setTimeout()` is because Liberty's scalingController does
  // not pick up new scalingPolicy.xml changes immediately. We add a delay so
  // that when scalingController won't try to spawn a new member because it
  // thinks the old member died.
  function _stop(instances, cb) {
    options.instances = instances;
    options.scalingEnabled = 'false';
    async.waterfall([
      fileService.uploadScalingPolicy.bind(null, options),
      function(cb) { setTimeout(function() { return cb(null); }, 15000); },
      _stopCluster.bind(null, options),
    ], cb);
  }
}

/**
 * Lower level stop function.
 * Stops all members registered to a cluster. This is a simple stop, if the
 * cluster is auto-scaled, to permanently stop a cluster, a new scalingPolicy
 * must be uplaoded to the controller with an `enabled="false"` attribute.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster
 *
 * Returns object consisting of results from each known member in the cluster.
 * The signature being result:
 *  {
 *   "<host>,<userdir>,<servername>": {
 *     returnCode: {string} <number>
 *     stdout: {string} <text>
 *     stderr: {string} <text>
 *    }
 *  }
 */
function _stopCluster(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName);

  options.clusterName = [GROUP, options.clusterName].join('.');
  sendRequest(options, null, cluster.stopCluster,
    function(err, result) {
      if (err) { return cb(err); }
      return cb(null, result);
    });
}

function startCluster(options, cb) {
  async.waterfall([
    _getScalingPolicy.bind(null, options),
    getUserDefinedInstances,
    _start,
  ], cb);

  function _start(instances, cb) {
    options.instances = instances;
    options.scalingEnabled = 'true';
    async.series([
      _startCluster.bind(null, options),
      fileService.uploadScalingPolicy.bind(null, options),
    ], function(err, results) {
      if (err) { return cb(err); }
      if (!results[0]) {
        err = new Error('No servers returned from startCluster command');
        return cb(err);
      }
      return cb(null, results[0]);
    });
  }
}

function _getScalingPolicy(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName);

  var appDir = '${wlp.user.dir}/servers/controller/configDropins/overrides';
  var fileName = [
    GROUP,
    options.clusterName,
    'scalingPolicy.xml',
  ].join('.');

  options.srcFile = [appDir, fileName].join('/');

  fileService.download(options, cb);
}

function _getInstancesFromXml(data) {
  return data.match(/min="([0-9]+)"/i)[1];
}

/**
 * Starts all members registered to a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster
 *
 * Returns object consisting of results from each known member in the cluster.
 * The signature being result:
 *  {
 *   "<host>,<userdir>,<servername>": {
 *     returnCode: {string} <number>
 *     stdout: {string} <text>
 *     stderr: {string} <text>
 *    }
 *  }
 */
function _startCluster(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName);

  options.clusterName = [GROUP, options.clusterName].join('.');
  sendRequest(options, null, cluster.startCluster,
    function(err, result) {
      if (err) { return cb(err); }
      return cb(null, result);
    });
}

function getUserDefinedInstances(data, cb) {
  var err = new Error('No data from XML');
  if (!data) return cb(err);

  var min = _getInstancesFromXml(data);
  return cb(null, min);
}

function sendRequest(options, operation, jmxMethod, callback) {
  mandatory(options.host, 'host is missing');
  mandatory(options.port, 'port is missing');
  mandatory(options.username, 'user is missing');
  mandatory(options.password, 'password is missing');
  debug('Attempting request on controller host %s', options.host);
  var myJmx = options.jmx || jmx;
  var req = jmxMethod(options, operation);
  var endpoint = new myJmx.Endpoint(options.host, options.port, {
    acceptUnauthorized: options.autoAcceptCertificates,
    username: options.username,
    password: options.password,
  });
  debug('The request being sent is: %s', JSON.stringify(req));
  endpoint.request(req, null, function(err, rsp, body) {
    if (err) {
      debug('The request returned with an error response: %s', err);
      return callback(err);
    }
    return callback(null, rsp.body.value);
  });
}
