// Copyright IBM Corp. 2016. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var async = require('async');
var cluster = require('apiconnect-collective-jmx').cluster;
var debug = require('debug')('apiconnect-collective-controller-api');
var mandatory = require('apiconnect-collective-jmx').util.mandatory;
var jmx = require('apiconnect-collective-jmx');
var request = require('request');
var url = require('url');

exports.start = start;
exports.stop = stop;
exports.status = status;
exports.list = list;
exports.createNode = createNode;
exports.deleteNode = deleteNode;
exports.getData = getData;
exports.setData = setData;
exports.deleteClusterData = deleteClusterData;
exports.clearClusterData = clearClusterData;
exports.listClusterData = listClusterData;
exports.getClusterData = getClusterData;
exports.setClusterData = setClusterData;
exports.setIhsInfo = setIhsInfo;
exports.listIhsInfo = listIhsInfo;
exports.getHosts = getHosts;

// Exported for testing purposes.
exports.sendRequest = sendRequest;

/**
 * Implements the server start commands.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The host on which the server is running.
 * @param {string} options.wlpnUserDir - The user directory in which the server
 * is set up.
 * @param {string} options.serverName - The server name identifying a server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function start(options, callback) {
  mandatory(options);
  mandatory(options.hostName, 'hostName is missing');
  mandatory(options.wlpnUserDir, 'wlpnUserDir is missing');
  mandatory(options.serverName, 'serverName is missing');
  var serverCommand = jmx.serverCommand;

  sendRequest(options, serverCommand.SERVER_COMMAND_OPERATIONS.startServer,
    serverCommand.getServerOperation, callback);
};

/**
 * Implements the server stop commands.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The host on which the server is running.
 * @param {string} options.wlpnUserDir - The user directory in which the server
 * is set up.
 * @param {string} options.serverName - The server name identifying a server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function stop(options, callback) {
  mandatory(options);
  mandatory(options.hostName, 'hostName is missing');
  mandatory(options.wlpnUserDir, 'wlpnUserDir is missing');
  mandatory(options.serverName, 'serverName is missing');
  var serverCommand = jmx.serverCommand;

  sendRequest(options, serverCommand.SERVER_COMMAND_OPERATIONS.stopServer,
    serverCommand.getServerOperation, callback);

};

/**
 * Implements the server status commands.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The host on which the server is running.
 * @param {string} options.wlpnUserDir - The user directory in which the server
 * is set up.
 * @param {string} options.serverName - The server name identifying a server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function status(options, callback) {
  mandatory(options);
  mandatory(options.hostName, 'hostName is missing');
  mandatory(options.wlpnUserDir, 'wlpnUserDir is missing');
  mandatory(options.serverName, 'serverName is missing');
  var serverCommand = jmx.serverCommand;

  sendRequest(options, serverCommand.SERVER_COMMAND_OPERATIONS.getServerStatus,
    serverCommand.getServerOperation, callback);
};

/**
 * Implements the server list commands.
 * @param {object} options - The options object.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function list(options, callback) {
  options.absolutePath = false;
  var serverCommand = jmx.serverCommand;
  var serverListResult = {};

  sendRequest(options, null, serverCommand.getDescendantData,
    function(err, resultList) {
      if (err) {
        callback(err);
      }
      for (var key in resultList) {
        var parsedHost = key.split('/');
        if (parsedHost.length === 9) {
          var host = serverListResult[parsedHost[4]];
          if (host === undefined) {
            host = serverListResult[parsedHost[4]] = {};
            host.name = parsedHost[4];
            host.userDirs = {};
          }
          var userDir = host.userDirs[parsedHost[6]];
          if (userDir === undefined) {
            userDir = host.userDirs[parsedHost[6]] = {};
            userDir.name = parsedHost[6];
            userDir.servers = {};
          }
          var server = userDir.servers[parsedHost[8]];
          if (server === undefined) {
            server = userDir.servers[parsedHost[8]] = {};
            server.name = parsedHost[8];
          }
        }
      }
      callback(null, serverListResult);
    });
};

/**
 * Retrieve a key-value pair from the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function getData(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  var serverCommand = jmx.serverCommand;
  sendRequest(options, 'getData', serverCommand.getSetDataInRegistry, callback);
};

/**
 * Delete a node in Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function deleteNode(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  var serverCommand = jmx.serverCommand;
  sendRequest(options, 'delete', serverCommand.getSetDataInRegistry, callback);
};

/**
 * Sets the data (a key-value pair) in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to set the data.
 * @param {string} options.data - The data to be stored in the path specified
 * above. The data could be an environmental variable formatted as 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function setData(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  mandatory(options.data, 'data is missing');
  var serverCommand = jmx.serverCommand;
  sendRequest(options, 'setData', serverCommand.getSetDataInRegistry, callback);
};

/**
 * Creates a node in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to set the data.
 * @param {string} options.data - The data to be stored in the path specified
 * above. The data could be an environmental variable formatted as 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
function createNode(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  mandatory(options.data, 'data is missing');
  var serverCommand = jmx.serverCommand;
  sendRequest(options, 'create', serverCommand.getSetDataInRegistry, callback);
};

/**
 * Retrieve a key-value pair from the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
// FIXME rename to listClusterEnv
function listClusterData(options, callback) {
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = cluster.getClusterPath(options);
  sendRequest(options, null, cluster.listClusterData, removePrefix);

  // Existing keys are returned with a prefix, we need to clean up.
  function removePrefix(err, results) {
    if (err) {
      debug(err);
      return callback(err);
    }
    results = cluster.removeClusterPrefix(options, results);
    return callback(null, results);
  }
};

/**
 * Retrieve a key-value pair from the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to get from.
 * @param {string} options.key - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * FIXME not 'could be', *is*
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
// FIXME rename to getClusterEnv
function getClusterData(options, callback) {
  mandatory(options.key, 'key is required');
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = [
    cluster.getClusterPath(options),
    options.key,
  ].join('/');
  getData(options, callback);
};

/**
 * Sets the data (a key-value pair) in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to store data.
 * @param {string} options.key - The name of the variable to set the data.
 * @param {string} options.data - The data to be stored in the variable
 */
// FIXME rename to setClusterEnv
function setClusterData(options, callback) {
  mandatory(options.key, 'key is required');
  mandatory(options.data, 'data is required');
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = [cluster.getClusterPath(options), options.key].join('/');
  var serverCommand = jmx.serverCommand;
  sendRequest(options, null, serverCommand.createDataInRegistry,
    function(err, result) {
      if (err) {
        return callback(err);
      }
      setData(options, callback);
    });
};

// FIXME(sam) this is NOT safe to call for anything other than than IHS, since
// it isn't atomic (delete, create), it needs to be rewritten to be
//   if create() fails: update;
function setDataInPath(args, callback) {
  async.series([deleteN, createN], function(err, message) {
    if (err) {
      return callback(err);
    }
    return callback(err, 'The data is successfully set in the path.');
  });

  function deleteN(callback) {
    deleteNode(args, callback);
  }

  function createN(callback) {
    createNode(args, callback);
  }
}

/**
 * Deletes the data (a key-value pair) in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to remove data
 * from.
 * @param {string} options.key - The name of the variable to delete.
 * @callback
 * @param callback
 */
function deleteClusterData(options, callback) {
  mandatory(options.key, 'key is required');
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = [cluster.getClusterPath(options), options.key].join('/');
  deleteNode(options, callback);
}

/**
 * Deletes all of data (the key-value pairs) for a cluster in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to clear data
 * from.
 * @callback
 * @param callback
 */
function clearClusterData(options, callback) {
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = cluster.getClusterPath(options);
  deleteNode(options, callback);
}

function sendRequest(options, operation, jmxMethod, callback) {
  mandatory(options.host, 'host is missing');
  mandatory(options.port, 'port is missing');
  mandatory(options.user, 'user is missing');
  mandatory(options.password, 'password is missing');
  debug('Attempting request on controller host %s', options.host);
  var myJmx = options.jmx || jmx;
  var req = jmxMethod(options, operation);
  var endpoint = new myJmx.Endpoint(options.host, options.port, {
    acceptUnauthorized: options.autoAcceptCertificates,
    username: options.user,
    password: options.password,
  });
  debug('The request being sent is: %s', JSON.stringify(req));
  endpoint.request(req, null, function(err, rsp, body) {
    if (err) {
      debug('The request returned with an error response: %s', err);
      return callback(err);
    }
    return callback(null, rsp.body.value);
  });
}

var IHS_PATH = '/sys.wlpn.internal/ihs';

/**
 * Sets a IHS IP/name to a port.
 * @param {string} options.ihsIp - The IP of the IHS server.
 * @param {string} options.ihsPort - The port of the IHS server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 */
function setIhsInfo(options, callback) {
  // write me a test later.
  mandatory(options.ihsIp, 'ihsIp is required');
  mandatory(options.ihsPort, 'ihsPort is required');
  options.path = [IHS_PATH, options.ihsIp].join('/');
  options.data = options.ihsPort;
  setDataInPath(options, callback);
};

/**
 * Gets the IHS IP/name to port mappings
 *
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 *
 * Return looks like
 *   {
 *      '1.2.3.4': '8080',
 *      ...
 *   }
 */
function listIhsInfo(options, callback) {
  options.path = IHS_PATH;
  options.absolutePath = false;
  var list = {};
  var serverCommand = jmx.serverCommand;
  sendRequest(options, null, serverCommand.getSubTree, removeTailItems);

  function removeTailItems(err, resultList) {
    if (err) {
      return callback(err);
    }
    for (var key in resultList) {
      var ip = key.replace(options.path, '');
      if (ip.length > 0)
        list[ip.replace('/', '')] = resultList[key];
    }
    callback(null, list);
  }
};

// FIXME delIhsInfo() needed?

function addStackGroupName(clusterName) {
  var group = 'apic';
  return [group, clusterName].join('.');
}

/**
 * Gets a list of hosts registered to the controller.
 *
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's admin password.
 *
 * Returned data looks like:
 * { allServersRunning: 1,
 * allServersStopped: 0,
 * allServersUnknown: 0,
 * someServersRunning: 0,
 * noServers: 0,
 * type: 'hosts',
 * ids: [ 'hostname1', 'hostname2' ] }
 */
function getHosts(options, callback) {
  mandatory(options);
  mandatory(options.host, 'missing host!');
  mandatory(options.port, 'missing port!');
  mandatory(options.user, 'missing user!');
  mandatory(options.password, 'missing password!');

  var _request = options.request || request;

  var uri = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: '/ibm/api/collective/v1/hosts',
  });

  var reqOpts = {
    url: uri,
    method: 'GET',
    rejectUnauthorized: false,
    auth: {
      user: options.user,
      pass: options.password,
      sendImmediately: false,
    },
  };

  _request(reqOpts, function(err, res, body) {
    if (err) return callback(err);
    var results = JSON.parse(body);

    return callback(null, results);
  });
}
