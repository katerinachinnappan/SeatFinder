// Copyright IBM Corp. 2016. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var async = require('async');
var debug = require('./debug')('apiconnect-collective-controller-api:upload');
var fs = require('fs');
var mandatory = require('./util').mandatory;
var parseConfig = require('./parse-config');
var path = require('path');
var pump = require('pump');
var request = require('request');
var streamifier = require('streamifier');
var url = require('url');

exports.deploy = deploy;
exports.download = download;
exports.uploadPackage = uploadPackage;
exports.uploadScalingPolicy = uploadScalingPolicy;
exports.uploadDeployRules = uploadDeployRules;

var GROUP = 'apic';

/**
 * Upload to controller.
 * @param {string} [appDir] - Application directory on controller to place file.
 * @param {string} host - Hostname of controller.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} srcFile - local file you are uploading.
 * @param {string} username - Admin username for controller.
 */
function upload(options, cb) {
  options = parseConfig(options);
  options.appDir = options.appDir || '${wlp.user.dir}/file-upload';
  mandatory(options.host, 'need a host!');
  mandatory(options.password, 'need a password!');
  mandatory(options.port, 'need a port!');
  mandatory(options.srcFile, 'need a file to upload!');
  mandatory(options.username, 'need a username!');

  var _request = options.request || request;

  var filePath;
  var fileBase;
  var fileStream;
  if (typeof options.srcFile === 'string') {
    filePath = path.resolve(options.srcFile);
    fileBase = mandatory(path.basename(options.srcFile));
    fileStream = fs.createReadStream(filePath);
  } else if (typeof options.srcFile === 'object') {
    fileBase = options.srcFile.fileName;
    fileStream = streamifier.createReadStream(options.srcFile.data);
  }


  var targetFile = [options.appDir, fileBase].join('/');
  var pathname = '/IBMJMXConnectorREST/file/' + encodeURIComponent(
    targetFile);

  options.url = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: pathname,
    query: {
      expandOnCompletion: false,
    },
  });

  fileStream.pipe(_request.post({
    url: options.url,
    auth: {
      user: options.username,
      pass: options.password,
    },
    cache: false,
    data: '',
    dataType: 'json',
    headers: buildHeaders(options),
    processData: false,
    rejectUnauthorized: false,
    type: 'POST',
  }, function(err, httpResponse, body) {
    // Liberty doesn't seem to return err, returns stacktrace in body instead
    // err should be used as a networking error, not if upload went through
    // but failed for another reason. Should expose external body parsing
    // utility function from:
    // apiconnect-collective-jmx/blob/master/lib/endpoint.js#L104-L136
    if (err || body.length > 0) {
      err = err || parseJsonError(body);
      debug(err);
      console.error('Upload failed!');
      return cb(err);
    }
    console.log('Upload successful: %s', fileBase);
    return cb(null);
  }));
}

function buildHeaders(options) {
  var headers = {
    'Content-Type': 'application/octet',
    'com.ibm.websphere.jmx.connector.rest.asyncExecution': true,
  };
  return headers;
}

function parseJsonError(data) {
  var _err;
  if (data.match('stackTrace')) {
    try {
      _err = new Error(JSON.parse(data).stackTrace);
    } catch (err) {
      _err = new Error(data);
    }
  }
  return _err;
}

/**
 * Deploy to member (creates new member), must have package already uploaded.
 * @param {string} appDir - Application directory on controller to place file.
 * @param {string} appPackage - The name of the package being deployed. Should
 * already be on the server in the specified appDir.
 * @param {string} [clusterName] - The name of the deployed cluster to affect,
 * also used for file naming for file being uploaded. If no clusterName is
 * specified, will take the filename from package srcFile (if specified) or
 * appPackage, if that is used instead.
 * @param {string} host - Hostname of controller.
 * @param {string} [instances] - number of instances to set for cluster scaling
 * (both min and max). If not specified, will default to 1.
 * @param {string} keystorePassword - Keystore Password for joining new member
 * to the collective.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} serverName - Name of new member.
 * @param {string} [srcFile] - local file to upload before deploy. If this is
 * not provided, the appPackage must be passed into the function call.
 * @param {string} username - Admin username for controller.
 */
function deploy(options, cb) {
  options = parseConfig(options);
  mandatory(options.srcFile || options.appPackage,
    'need an appPackage or srcFile!');
  mandatory(options.host, 'need a host!');
  mandatory(options.keystorePassword, 'need keystorePassword!');
  mandatory(options.password, 'need a password!');
  mandatory(options.port, 'need a port!');
  mandatory(options.serverName, 'need a serverName!');
  mandatory(options.username, 'need a username!');
  options.instances = parseInt(options.instances, 10) || 1;

  // TODO(Phong): Below `setTimeout()` is because Liberty's scalingController
  // does not pick up new scalingPolicy.xml changes immediately. We add a delay
  // so that scalingController evaluates changes after deploy.xml is evaluated.
  // This will be fixed by Liberty so need to follow up in Q2
  async.waterfall([
    uploadPackage.bind(null, options),
    uploadDeployRules.bind(null, options),
    function(cb) { setTimeout(function() { return cb(null); }, 15000); },
    uploadScalingPolicy.bind(null, options),
  ], _deployResults);

  function _deployResults(err, results) {
    if (err) {
      debug(err);
      return cb(err);
    }
    return cb(null, results);
  }
}

/**
 * Upload Package to controller stackGroup location.
 * @param {string} host - Hostname of controller.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} srcFile - local file to upload before deploy. If this is
 * not provided, the other parameters must be passed into the function call
 * @param {string} username - Admin username for controller.
 * member.
 */
function uploadPackage(options, cb) {
  options = parseConfig(options);
  if (options.srcFile) {
    mandatory(options.host, 'need a host!');
    mandatory(options.port, 'need a port!');
    mandatory(options.username, 'need a username!');
    mandatory(options.password, 'need a password!');
    mandatory(options.srcFile, 'need a password!');

    options.appDir = '${wlp.user.dir}/shared/stackGroups/' +
      GROUP + '/packages';
    options.appPackage = mandatory(path.basename(options.srcFile));
    return upload(options, cb);
  }
  cb(null);
}

/**
 * Upload deploy.xml to controller to stackGroup location. This file is used to
 * feed data into the controller's deployRule.xml.
 * @param {string} appPackage - The name of the package being deployed. Should
 * already be on the server in the specified appDir. If an appPackage is not
 * specified, will use clusterName if specified. If clusterName is specified,
 * will overwrite appPackage for file naming. One or the other is required.
 * @param {string} [clusterName] - The name of the deployed cluster to affect,
 * also used for file naming for file being uploaded.
 * scaling policy for. If this is not specified, it will use
 * @param {string} host - Hostname of controller.
 * @param {string} [instances] - number of instances to set for cluster scaling
 * (both min and max). If not specified, will default to 1.
 * @param {string} keystorePassword - Keystore Password for joining new member
 * to the collective.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} serverName - Name of new member.
 * @param {string} username - Admin username for controller.
 * member.
 */
function uploadDeployRules(options, cb) {
  options = parseConfig(options);
  var packageName = options.clusterName || removeExt(options.appPackage);
  mandatory(packageName, 'Must provide a clusterName or appPackage!');
  mandatory(options.appPackage, 'need an appPackage!');
  mandatory(options.host, 'need a host!');
  mandatory(options.port, 'need a port!');
  mandatory(options.username, 'need a username!');
  mandatory(options.password, 'need a password!');
  mandatory(options.keystorePassword, 'need keystorePassword!');
  mandatory(options.serverName, 'need a serverName!');
  options.appDir = '${wlp.user.dir}/shared/stackGroups/' +
    GROUP + '/packages';

  var data = [
    '<deploy>',
    '<useRule id="StrongLoop Member Rule" />',
    '<variable name="application.package" value="',
    options.appPackage, '"/>',
    '<variable name="serverName" value="', options.serverName, '"/>',
    '<variable name="keystore.password" value="',
    options.keystorePassword, '"/>',
    '<variable name="wlpn.application.dir" value="',
    encodeURIComponent(options.appDir), '"/>',
    '<variable name="wlpn.cluster.name" value="', GROUP, '.', packageName,
    '"/>', '</deploy>',
  ].join('');

  options.srcFile = {
    fileName: packageName + '.deploy.xml',
    data: data,
  };

  return upload(options, cb);
}

/**
 * Upload Scaling Policy to controller configDropins/overrides folder.
 * @param {string} appPackage - The name of the package being deployed. Should
 * already be on the server in the specified appDir. If an appPackage is not
 * specified, will use clusterName if specified. One or the other is required.
 * @param {string} [clusterName] - The name of the deployed cluster to affect,
 * also used for file naming for file being uploaded.
 * @param {string} host - Hostname of controller.
 * to the collective.
 * @param {string} instances - number of instances to set for cluster scaling.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * not provided, the other parameters must be passed into the function call
 * @param {string} username - Admin username for controller.
 * member.
 */
function uploadScalingPolicy(options, cb) {
  options = parseConfig(options);

  var packageName = options.clusterName || removeExt(options.appPackage);
  mandatory(packageName, 'Must provide a clusterName or appPackage!');
  mandatory(options.instances, 'Must provide number of instances!');
  mandatory(options.host, 'need a host!');
  mandatory(options.port, 'need a port!');
  mandatory(options.username, 'need a username!');
  mandatory(options.password, 'need a password!');

  var data = [
    '<?xml version="1.0" encoding="UTF-8" ?>',
    '<server>',
    '<scalingDefinitions>',
    '<scalingPolicy id="', GROUP, '.', packageName,
    '" min="', options.instances,
    '" max="', options.instances,
    '" enabled="', options.scalingEnabled || 'true',
    '"><bind clusters="', GROUP, '.', packageName,
    '"/>',
    '</scalingPolicy>',
    '</scalingDefinitions>',
    '</server>',
  ].join('');

  options.srcFile = {
    fileName: [
      GROUP,
      packageName,
      'scalingPolicy.xml',
    ].join('.'),
    data: data,
  };

  options.appDir = '${wlp.user.dir}/servers/controller/' +
    'configDropins/overrides';

  return upload(options, cb);
}

function download(options, cb) {
  options = parseConfig(options);

  mandatory(options.host, 'missing host!');
  mandatory(options.port, 'missing port!');
  mandatory(options.username, 'missing username!');
  mandatory(options.password, 'missing password!');
  mandatory(options.srcFile, 'missing srcFile!');

  options.srcFile = /%2F/gi.test(options.srcFile) ? options.srcFile :
    encodeURIComponent(options.srcFile);
  var _request = options.request || request;

  var pathname = '/IBMJMXConnectorREST/file/' + options.srcFile;

  var _url = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: pathname,
  });

  var reqOpts = {
    url: _url,
    method: 'GET',
    rejectUnauthorized: false,
    auth: {
      user: options.username,
      pass: options.password,
      sendImmediately: false,
    },
  };

  // download() used differently by getPackage and getScalingPolicy, the latter
  // of which does not save the file, but parses contents for values.
  if (options.outputFile) {
    var targetFile = path.resolve(process.cwd(), options.outputFile);
    var file = fs.createWriteStream(targetFile);

    pump(_request(reqOpts), file, cb);
    return;
  } else {
    _request(reqOpts, function(err, res, body) {
      if (err) return cb(err);
      return cb(null, body);
    });
  }
}

function removeExt(file) {
  return path.basename(file, path.extname(file));
}
