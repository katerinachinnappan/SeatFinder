/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var codes = require('./codes');
var f = require('util').format;
var fs = require('fs');
var get = require('./get');
var path = require('path');
var project = require('apiconnect-project');
var reqOptions = require('../req-options');
var request = require('../request');
var validator = require('../opts-validator');

/**
 * @param {object} options
 * @param {string} options.filename
 * @param {string} options.organization
 * @param {boolean} options.replace
 *
 * @throws ERROR_PROCESSING_FILE, API_NOT_FOUND, AMBIGUOUS_API, FILE_NOT_FOUND, AMBIGUOUS_PRODUCT
 * @reject array<error>
 */
function push(options) {
  return validator(options, [ 'filename', 'organization' ])
    .then(_.bind(project.loadProject, null, options.filename, { resolveExternalApiRefs: true }))
    .then(function(artifacts) {
      var errs = _.filter(artifacts, 'err');
      if (errs && errs.length > 0) {
        var e = new Error(f('Error(s) processing %s', options.filename));
        e.code = codes.ERROR_PROCESSING_FILE;
        e.obj = { errs: errs };

        throw e;
      }
      var products = _.filter(artifacts, { type: 'product' });
      if (options.productOnly) {
        // If only product, don't worry about looking for errors in ref'd apis
        return pushProducts(products, options);
      }
      // Walk through each product's refs and make sure there aren't any problems
      var productApiErrs = _.filter(products.map(function(product) {
        var e = _.filter(product.refs, 'err');
        if (e.length > 0) {
          return { filename: product.filePath, errors: e };
        }
      }));
      if (productApiErrs.length > 0) {
        var err = new Error(f('Error(s) processing %s', options.filename));
        err.code = codes.ERROR_PROCESSING_FILE;
        err.obj = { errs: productApiErrs };

        throw err;
      }
      var apis = _.filter(artifacts, { type: 'swagger' });
      // Process each product and add any unique apis to the apis array
      products.forEach(function(product) {
        product.refs.forEach(function(ref) {
          if (!_.find(apis, ref, eq)) {
            apis.push(ref);
          }
        });
      });

      var apiOpts = options;
      if (products.length > 0) {
        // If we're pushing both products and apis, that means the replace
        // option is for the product and not the api.
        apiOpts = _.cloneDeep(options);
        delete apiOpts.replace;
      }
      // Need to push the APIs prior to Products for the backend
      apis = pushAPIs(apis, apiOpts);
      products = apis.then(_.bind(pushProducts, null, products, options));

      return Promise.all([ apis, products ])
        .then(_.flatten);
    });

  function eq(left, right) {
    if (left.info && !right.info || !left.info && right.info) {
      return false;
    }
    return left.info[ 'x-ibm-name' ] === right.info[ 'x-ibm-name' ] &&
      left.info.version === right.info.version;
  }
};


/**
 * @param {Array<Artifacts>}
 * @param {object} options
 * @param {string} options.productOnly
 *
 * @return
 */
function pushAPIs(apiArtifacts, options) {
  return Promise.map(apiArtifacts, function(apiArtifact) {
    if (apiArtifact.data[ 'x-ibm-configuration' ].type === 'wsdl') {
      return processWSDL(apiArtifact, options)
        .then(_.bind(pushAPI, null, _, options));
    }
    return pushAPI(apiArtifact, options);
  });
}

function pushAPI(artifact, options) {
  var data = artifact.data;
  // string name:version
  var replace = options.replace;
  if (data.basePath && data.basePath.charAt(0) !== '/') {
    data.basePath = '/' + data.basePath;
  }
  var apiName;
  var apiVersion;
  if (options.replace) {
    var nv = options.replace.split(':');
    apiName = nv[0];
    apiVersion = nv[1];
  } else {
    apiName = data.info[ 'x-ibm-name' ];
    apiVersion = data.info.version;
  }
  return get(_.defaults({ type: 'api', name: apiName, version: apiVersion }, options))
    .then(function(res) {
      if (res.apis.length === 0) {
        if (replace) {
          var err = new Error(f('The API %s was not found.', f('%s:%s', apiName, apiVersion)));
          err.code = codes.API_NOT_FOUND;
          err.obj = { name: apiName, version: apiVersion };
          return Promise.reject(err);
        }
        return pushNewAPI(data, artifact.filePath, options);
      } else if (res.apis.length > 1) {
        err = new Error(f('The API %s must be qualified with version to be sufficiently disambiguated.',
          replace));
        err.code = codes.AMBIGUOUS_API;
        err.obj = { apis: res.apis };
        return Promise.reject(err);
      }
      var guid = res.apis[0].id;
      return pushExistingAPI(guid, data, artifact.filePath, options);
    });
}

/**
 * @param {string} name to search for
 * @param {string} version (optional) to search for
 * @param {string} org
 * @param {object} options
 * @param {string} options.nameVersion
 * @param {string} options.organization

 */
var pushNewAPIURLFormat = '/v1/apimanager/orgs/%s/apis?basePath=%s';
function pushNewAPI(data, filename, options) {
  var org = options.organization;
  var url = f(pushNewAPIURLFormat, org, data.basePath);
  options = reqOptions(_.defaults({ url: url }, options));
  options.method = 'POST';
  options.headers[ 'content-type' ] = 'application/vnd.ibm-apim.swagger2+json';
  options.json = data;

  return request(options)
    .return({ api: true, org: org, name: data.info[ 'x-ibm-name' ], version: data.info.version, filename: filename });
}

var apiURL = '/v1/apimanager/orgs/%s/apis/%s';
function pushExistingAPI(guid, data, filename, options) {
  var org = options.organization;
  var url = f(apiURL, org, guid);
  options = reqOptions(_.defaults({
    url: url,
    headers: {
      accept: 'application/yml',
      'content-type': 'application/vnd.ibm-apim.swagger2+yaml',
    },
    json: data,
    method: 'PUT',
  }, options));
  return request(options)
    .return({ api: true, org: org, name: data.info[ 'x-ibm-name' ], version: data.info.version, filename: filename });
}

function processWSDL(apiArtifact, options) {
  var wsdl = apiArtifact.data[ 'x-ibm-configuration' ][ 'wsdl-definition' ].wsdl;
  var filePath = path.resolve(path.dirname(apiArtifact.filePath), wsdl);
  if (!fs.existsSync(filePath)) {
    var err = new Error(f('The file name %s was not found.', filePath));
    err.code = codes.FILE_NOT_FOUND;
    err.obj = { file: filePath };
    return Promise.reject(err);
  }
  return uploadWsdlFile(filePath, options)
    .then(function(wsdlId) {
      apiArtifact.data[ 'x-ibm-configuration' ][ 'wsdl-definition' ].wsdl = wsdlId;
      return apiArtifact;
    });
}

var updateWsdlFileURLFormat = '/v1/orgs/%s/apis/wsdl';
function uploadWsdlFile(filePath, options) {
  var url = f(updateWsdlFileURLFormat, options.organization);
  options = reqOptions(_.defaults({
    url: url,
    method: 'POST',
    json: true,
  }, options));
  options.formData = {
    attachments: [ fs.createReadStream(filePath) ],
  };
  return request(options)
    .then(function(res) {
      return res.wsdlId;
    });
};

function pushProducts(products, options) {
  return Promise.map(products, _.bind(pushProduct, null, _, options));
};

function pushProduct(product, options) {
  var data = product.data;
  var productName;
  var productVersion;
  if (options.replace) {
    var nv = options.replace.split(':');
    productName = nv[0];
    productVersion = nv[1];
  } else {
    productName = product.data.info.name;
    productVersion = product.data.info.version;
  }
  var productDir = path.dirname(product.filePath);
  // Add $refs.name to map from filepath -> product[$ref] -> name:version
  _.keys(data.apis).forEach(function(api) {
    var refInstance = _.find(product.refs, function(apiRef) {
      return apiRef.filePath === path.resolve(productDir, data.apis[api].$ref);
    });
    data.apis[api].name = f('%s:%s', refInstance.name, refInstance.version);
  });

  return get(_.defaults({ type: 'product', name: productName, version: productVersion }, options))
    .then(function(res) {
      if (res.products.length === 0) {
        if (options.replace) {
          var err = new Error(f('The product %s was not found.', f('%s:%s', productName, productVersion)));
          err.code = codes.PRODUCT_NOT_FOUND;
          err.obj = { name: productName, version: productVersion };
          return Promise.reject(err);
        }
        return pushNewProduct(data.info.name, data.info.version, data, product.filePath, options);
      } else if (res.products.length > 1) {
        err = new Error(f('The product must be qualified with version to be sufficiently disambiguated.'));
        err.code = codes.AMBIGUOUS_PRODUCT;
        err.obj = { products: res.products };
        return Promise.reject(err);
      }
      // We have one product, push it
      var guid = res.products[0].id;
      return pushExistingProduct(guid, data, product.filePath, options);
    });
};

var pushNewProductURLFormat = '/v1/orgs/%s/products';
function pushNewProduct(productName, productVersion, data, filename, options) {
  var org = options.organization;
  var url = f(pushNewProductURLFormat, org);
  options = reqOptions(_.defaults({
    url: url,
    method: 'POST',
    json: data,
    accept: 'application/json',
    'content-type': 'application-json',
  }, options));

  return request(options).return({
    product: true, org: org, name: productName, version: productVersion,
    filename: filename,
  });
};

var pushExistingProductURLFormat = '/v1/orgs/%s/products/%s';
function pushExistingProduct(guid, data, filename, options) {
  var org = options.organization;
  var url = f(pushExistingProductURLFormat, org, guid);
  options = reqOptions(_.defaults({
    url: url,
    method: 'PUT',
    json: data,
  }, options));
  options.headers.accept = 'application/json';
  options.headers[ 'content-type' ] = 'application/json';
  // Make sure the document name:version matches what we want it to be. Will be diff
  return request(options)
    .return({ product: true, org: org, name: data.info.name, version: data.info.version, filename: filename });
};

module.exports = push;

