/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-products


'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var catalogAPI = require('./catalogs');
var config = require('apiconnect-config');
var f = require('util').format;
var fs = Promise.promisifyAll(require('fs'));
var g = require('strong-globalize')();
var jsYaml = require('js-yaml');
var logger = require('apiconnect-cli-logger');
var path = require('path');
var project = require('apiconnect-project');
var reqOpts = require('./req-options');
var request = require('./request');
var validator = require('./opts-validator');

var PRODUCT_TYPE = 'productVersion';

/**
 * List products based on options
 *
 * @param {object} options
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Products> */
function list(options) {
  return catalogAPI.listAll(options).then(function(catalogs) {
    if (catalogs.length === 0) {
      var err = new Error(f('No such catalog %s in organization %s', options.catalog, options.organization));
      err.code = 'CATALOG_NOT_FOUND';
      err.obj = { catalog: options.catalog, org: options.organization };
      throw err;
    }
    return Promise.map(catalogs, function(catalog) {
      if (!catalog.spaceEnabled) {
        var reqOptions = reqOpts(_.defaults({
          url: f('/v1/orgs/%s/environments/%s/products?resolveApiRef=false', catalog.orgId, catalog.id),
          headers: {
            Accept: 'application/json',
          },
          json: true,
        }, options));
        reqOptions.ignoreErrors = [ 'checkPermissions.unauthorisedException' ];
        return request(reqOptions).map(function(product) {
          product.orgName = catalog.orgName;
          product.catalogName = catalog.shortName;
          return product;
        });
      } else {
        var spaces = catalog.spaces;
        if (options.space) {
          spaces = _.filter(spaces, function(s) {
            return s.name === options.space || s.id === options.space;
          });
        }

        return Promise.map(spaces, function(space) {
          reqOptions = reqOpts(_.defaults({
            url: f(
              '/v1/orgs/%s/environments/%s/spaces/%s/products?resolveApiRef=false',
              catalog.orgId,
              catalog.id,
              space.id
            ),
            json: true,
          }, options));
          reqOptions.ignoreErrors = [ 'checkPermissions.unauthorisedException' ];
          return request(reqOptions).map(function(product) {
            product.orgName = catalog.orgName;
            product.catalogName = catalog.shortName;
            product.spaceEnabled = catalog.spaceEnabled;
            product.spaceName = space.name;
            return product;
          });
        });
      }
    });
  }).then(function(products) {
    products = _.flattenDeep(products);
    return _.values(_.reduce(products, mapSpaces, {}));
  });

  function mapSpaces(accum, product) {
    var key = product.orgName + ':' + product.catalogName + ':' + product.productName + product.productVersion;
    if (accum[key] == null) {
      product.spaceNames = product.spaceName != null ? [ product.spaceName ] : [];
      accum[key] = product;
    } else if (product.spaceName != null) {
      accum[key].spaceNames.push(product.spaceName);
    }
    //delete product.spaceName;
    return accum;
  }
};

/**
 * Get information on a specific product
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Product> */
function get(options) {
  return validator(options, [ 'organization', 'catalog', 'productNameVersion' ]).then(function(options) {
    return getProduct(options);
  });
};

/**
 * Set status on a product
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Product>
 */
function set(options) {
  return validator(options, [ 'organization', 'catalog', 'productNameVersion' ]).then(function(options) {
    return getProduct(options);
  }).then(function(product) {
    var reqOptions;

    if (product.spaceName) {
      reqOptions = reqOpts(_.defaults({
        url: f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s',
          product.orgName, product.catalogName, product.spaceName, product.id),
        headers: {
          'content-type': 'application/json',
        },
        returnHTTPResponse: true,
        json: true,
      },
      options));
    } else {
      reqOptions = reqOpts(_.defaults({
        url: f('/v1/orgs/%s/environments/%s/products/%s',
          product.orgName, product.catalogName, product.id),
        headers: {
          'content-type': 'application/json',
        },
        returnHTTPResponse: true,
        json: true,
      },
      options));
    }

    var operation = options.operation;

    if (operation && operation !== 'set') {
      reqOptions.json = {};
      reqOptions.url += '/' + operation;
      reqOptions.method = 'post';

      var promise = Promise.resolve(reqOptions);

      if (options.secureGateway) {
        promise = promise.then(function(reqOptions) {
          return createSecureGatewayDeploymentInfo(options, reqOptions);
        });
      }

      return promise.then(request).then(function(rsp) {
        var body = rsp.body;
        var responseBody = typeof body === 'string' ? JSON.parse(body) : body;
        return responseBody;
      });
    } else {
      //check values
      reqOptions.json = createVisibility(options);
      reqOptions.method = 'put';

      return request(reqOptions).then(function(rsp) {
        var body = rsp.body;
        var responseBody = typeof body === 'string' ? JSON.parse(body) : body;
        return responseBody;
      });
    }
  });

  function createVisibility(options) {
    var rsp = {};
    if (options.visibility || options.subscribability) {
      rsp.visibility = {};
    }
    if (options.visibility) {
      var vType;
      var vOrgsOrTags = [];
      if (options.visibility === 'authenticated' || options.visibility === 'public') {
        vType = options.visibility;
      } else {
        vType = 'custom';
        vOrgsOrTags = options.visibility.split(' ');
      }
      rsp.visibility.view = {
        enabled: true,
        type: vType,
        tags: vOrgsOrTags,
        orgs: vOrgsOrTags,
      };
    }

    if (options.subscribability) {
      var mType;
      var orgsOrTags = [];
      if (options.subscribability === 'authenticated') {
        mType = options.subscribability;
      } else {
        mType = 'custom';
        orgsOrTags = options.subscribability.split(' ');
      }

      rsp.visibility.subscribe = {
        enabled: true,
        type: mType,
        orgs: orgsOrTags,
        tags: orgsOrTags,
      };
    }
    return rsp;
  }
}

function createSecureGatewayDeploymentInfo(options, reqOptions) {
  return project.loadProject(options.filename).then(function(artifacts) {
    var prods = _.filter(artifacts, { type: 'product' });
    var prod = prods && prods.length > 0 ? prods[0] : null;

    if (!prod) {
      throw (new Error(g.f('The product file name `%s` was not found.', options.filename)));
    }

    var product = findProduct({
      productName: prod.name,
      productVersion: prod.version,
    }, prods);

    if (!product) {
      throw new Error(g.f('The product file provided does not contain a valid product definition'));
    }

    if (!product.refs) {
      throw new Error(g.f('The product must contain APIs to be published.'));
    }

    var apis = product.refs;
    var secureGatewayDeploymentInfo = [];

    for (var apiKey in apis) {
      var api = apis[apiKey];

      if (api.err) {
        throw api.err;
      }

      var config = api.data['x-ibm-configuration'];

      if (!config) {
        continue;
      }

      var assembly = config.assembly;

      if (!assembly) {
        continue;
      }

      var execute = assembly.execute || [];

      for (var i = 0; i < execute.length; i++) {
        var secureGatewayInfo = {
          gateway: options.secureGateway,
          apiId: api.data.info['x-ibm-name'] + ':' + api.data.info.version,
        };

        if (execute[i].hasOwnProperty('invoke') && execute[i].invoke['secure-gateway']) {
          secureGatewayInfo.destination = execute[i].invoke['target-url'];
          secureGatewayDeploymentInfo.push(secureGatewayInfo);
        } else if (execute[i].hasOwnProperty('proxy') && execute[i].proxy['secure-gateway']) {
          secureGatewayInfo.destination = execute[i].proxy['target-url'];
          secureGatewayDeploymentInfo.push(secureGatewayInfo);
        }
      }
    }

    if (secureGatewayDeploymentInfo.length === 0) {
      throw new Error(g.f(
        'The API invoke or proxy policy must contain secure-gateway set to true ' +
        'in order to publish with a secure gateway.'
      ));
    }

    reqOptions.json.secureGatewayDeploymentInfo = secureGatewayDeploymentInfo;

    return reqOptions;
  });
}

/**
 * Delete a specific product
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<ProductAndAPIs> */
function del(options) {
  return validator(options, [ 'organization', 'catalog', 'productNameVersion' ]).then(function(options) {
    return getProduct(options);
  }).then(function(product) {
    var reqOptions;
    if (product.spaceName) {
      reqOptions = reqOpts(_.defaults({
        url: f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s',
          product.orgName, product.catalogName, product.spaceName, product.id),
        method: 'delete',
        json: true,
      },
      options));
    } else {
      reqOptions = reqOpts(_.defaults({
        url: f('/v1/orgs/%s/environments/%s/products/%s',
          product.orgName, product.catalogName, product.id),
        method: 'delete',
        json: true,
      },
      options));
    }

    return request(reqOptions);
  });
};

/**
 * Clear all products
 *
 * @param {object} options
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Products> Products being cleared
 */
function clear(options) {
  return validator(options, [ 'organization', 'catalog' ]).then(function(options) {
    var reqOptions;
    if (options.space) {
      reqOptions = reqOpts(_.defaults({
        url: f('/v1/orgs/%s/environments/%s/spaces/%s/products?confirm=%s',
          options.organization, options.catalog, options.space, options.catalog),
        method: 'delete',
        json: true,
      },
      options));
    } else {
      reqOptions = reqOpts(_.defaults({
        url: f('/v1/orgs/%s/environments/%s/products?confirm=%s',
          options.organization, options.catalog, options.catalog),
        method: 'delete',
        json: true,
      },
      options));
    }

    return request(reqOptions);
  });
};

/**
 * Stage a product
 *
 * @param {object} options
 * @param {object} options.filename Filename of product to be staged
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Product> Product being staged
 */
function stage(options) {
  var loadOptions = { resolveExternalApiRefs: true };
  var result = {};
  return project.loadProject(options.filename, loadOptions).then(function(artifacts) {
    var prods = _.filter(artifacts, { type: 'product' });
    var prod = prods && prods.length > 0 ? prods[0] : null;
    if (!prod) {
      throw (new Error(g.f('The product file name `%s` was not found.', options.filename)));
    }

    //extract apis
    var opts = _.defaults({
      productName: prod.name,
      productVersion: prod.version,
    }, options);

    var product = findProduct(opts, prods);
    if (!product) {
      throw new Error(g.f('The product file provided does not contain a valid product definition'));
    }

    if (!product.refs) {
      throw new Error(g.f('The product must contain APIs to be published.'));
    }

    if (!product.data.plans) {
      product.plans = [];
    }

    result.product = product.data;
    result.apis = {};
    processProductForUpload(product);
    var apis = product.refs;
    for (var apiKey in apis) {
      var api = apis[apiKey];
      if (api.err) {
        var err = new Error('error in referenced api');
        err.code = 'REF_API_ERR';
        err.obj = { api: api };
        err.cause = api.err;
        throw err;
      }

      var apiNameVersion = api.name + ':' + api.version;
      result.apis[apiNameVersion] = api.data;
    }
    return processStaging(options, result);
  });
};

/**
 * Publish a product
 *
 * @param {object} options
 * @param {object} options.filename Filename of product to be staged
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Product> Product being staged
 */
function publish(options) {
  var result = {};

  return validator(options, [ 'organization', 'catalog' ]).then(function(options) {
    return stage(options);
  }).then(function(stagedResult) {
    result.stage = stagedResult;
    options.operation = 'publish';
    options.productNameVersion = stagedResult.productName + ':' + stagedResult.productVersion;
    return set(options);
  }).then(function(publishResult) {
    result.publish = publishResult;
    return Promise.resolve(result);
  });
};

/**
 * Pull a product and its APIs
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<ProductAndAPIs>
 */
function pull(options) {
  return validator(options, [ 'organization', 'catalog', 'productNameVersion' ]).then(function(options) {
    return getProduct(options);
  }).then(function(product) {
    if (!product) {
      var error = new Error(g.f('The product %s was not found.', product.productName));
      return Promise.reject(error);
    } else {
      return pullProductById(options, product);
    }
  }).then(function(productAndAPI) {
    // Save the files on disk
    var product = processProductForDownload(productAndAPI.product);
    var apis = productAndAPI.apis;

    // Generate the product file name and write it to disk
    var productFilename = generateProductFileName(product.document.info.name, product.document.info.version);
    product.productFilename = productFilename;
    validateWriteFile(path.resolve(productFilename), jsYaml.safeDump(product.document), true);
    if (!options.productOnly && apis) {
      return Promise.map(apis, function(api) {
        return downloadAPIAndWSDL(api, product.orgName, options);
      })
        .then(function(apis) {
          var productAndAPIs = {};
          productAndAPIs.product = productAndAPI.product;
          productAndAPIs.apis = apis;
          return productAndAPIs;
        });
    }
    ;
    var productAndAPIs = {};
    productAndAPIs.product = productAndAPI.product;
    productAndAPIs.apis = null;
    return productAndAPIs;
  });
}

/**
 * Clone products based on options
 *
 * @param {object} options
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<Products> */
function clone(options) {
  var concurrency = parseInt(config.loadConfig().getOne('concurrency'), 10) || config.DEFAULT_CONCURRENCY;
  logger.debug('Concurrency used: %d', concurrency);
  return list(options).then(function(products) {
    return Promise.map(products, function(product) {
      return pullProductById(options, product);
    }, { concurrency: concurrency });
  }).then(function(productsAndAPIs) {
    return Promise.map(productsAndAPIs, function(productAndAPIs) {
      var product = processProductForDownload(productAndAPIs.product);
      // Generate the product file name and write it to disk
      var productFilename = generateProductFileName(product.document.info.name, product.document.info.version);
      product.productFilename = productFilename;
      validateWriteFile(path.resolve(productFilename), jsYaml.safeDump(product.document), true);
      return Promise.map(productAndAPIs.apis, function(api) {
        return downloadAPIAndWSDL(api, product.orgName, options);
      }).then(function(apis) {
        productAndAPIs = {};
        productAndAPIs.product = product;
        productAndAPIs.apis = apis;
        return productAndAPIs;
      });
    });
  });
};

/**
 * Replace a product
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<object>.fromProd product being replaced
 * @return Promise.<object>.toProd product replacing
 * @return Promise.<object>.subscriptions response which is used to check pendingDeploymentState
 */
function replace(options) {
  return validator(options,
    [ 'organization', 'catalog', 'fromNameVersion', 'toNameVersion', 'planMappings' ])
    .then(function(options) {
      var newPlanMappings = [];
      var planMappings = options.planMappings;
      var fromOpts = _.cloneDeep(options);
      var toOpts = _.cloneDeep(options);
      fromOpts.productNameVersion = options.fromNameVersion;
      toOpts.productNameVersion = options.toNameVersion;

      return Promise.map([ fromOpts, toOpts ], getProduct, { concurrency: 1 })
      .then(function(result) {
        var fromProd = result[0];
        var toProd = result[1];

        // Use space option in replace API if available
        var fromProdName = fromProd.productName;
        var toProdName = toProd.productName;
        // Use product versions when available
        var fromProdVersion = fromProd.productVersion;
        var toProdVersion = toProd.productVersion;

        var reqOptions;
        if (options.space) {
          reqOptions = reqOpts(_.defaults({
            url: f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s:%s/replace',
              options.organization, options.catalog, options.space, toProdName, toProdVersion),
            method: 'post',
          },
          options));
        } else {
          reqOptions = reqOpts(_.defaults({
            url: f('/v1/orgs/%s/environments/%s/products/%s:%s/replace',
              options.organization, options.catalog, toProdName, toProdVersion),
            method: 'post',
          },
          options));
        }

        reqOptions.json = {};
        reqOptions.json.oldProduct = { name: fromProdName, version: fromProdVersion };
        reqOptions.json.planMappings = [];

        if (planMappings && (typeof planMappings === 'string')) {
          var planStrArray = planMappings.split(' ');
          planStrArray.forEach(function(plan) {
            var strArray = plan.split(':');
            if (strArray.length === 2) {
              newPlanMappings.push({ from: strArray[0], to: strArray[1] });
            } else {
              throw new Error(g.f(
                'The value of the {{--plans}} option is invalid; ' +
                'plan mappings must be a list of source plan and target plan pairs, ' +
                'i.e., {{--plans "bronze:freemium silver:premium gold:premium"}}'));
            }
          });
        }
        ;

        reqOptions.json.planMappings = newPlanMappings;

        return request(reqOptions).then(function(rsp) {
          var body = rsp.body;
          var subscriptions = typeof body === 'string' ? JSON.parse(body) : body;
          return {
            fromProd: result[0],
            toProd: result[1],
            subscriptions: subscriptions,
          };
        });
      });
    });
};

/**
 * Supersede a product
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<object>.fromProd product being replaced
 * @return Promise.<object>.toProd product replacing
 * @return Promise.<object>.subscriptions response which is used to check pendingDeploymentState
 */
function supersede(options) {
  return validator(options,
    [ 'organization', 'catalog', 'fromNameVersion', 'toNameVersion', 'planMappings' ])
    .then(function(options) {
      var newPlanMappings = [];
      var planMappings = options.planMappings;
      var fromOpts = _.cloneDeep(options);
      var toOpts = _.cloneDeep(options);
      fromOpts.productNameVersion = options.fromNameVersion;
      toOpts.productNameVersion = options.toNameVersion;

      return Promise.map([ fromOpts, toOpts ], getProduct, { concurrency: 1 })
      .then(function(result) {
        var fromProd = result[0];
        var toProd = result[1];

        // Use space option in replace API if available
        var space = toProd.spaceName || options.space;

        var fromProdName = fromProd.productName;
        var toProdName = toProd.productName;
        // Use product versions when available
        var fromProdVersion = fromProd.productVersion;
        var toProdVersion = toProd.productVersion;

        var reqOptions;
        if (space) {
          reqOptions = reqOpts(_.defaults({
            url: f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s:%s/supersede',
              options.organization, options.catalog, space, toProdName, toProdVersion),
            method: 'post',
          },
          options));
        } else {
          reqOptions = reqOpts(_.defaults({
            url: f('/v1/orgs/%s/environments/%s/products/%s:%s/supersede',
              options.organization, options.catalog, toProdName, toProdVersion),
            method: 'post',
          },
          options));
        }

        reqOptions.json = {};
        reqOptions.json.oldProduct = { name: fromProdName, version: fromProdVersion };
        reqOptions.json.planMappings = [];

        if (planMappings && (typeof planMappings === 'string')) {
          var planStrArray = planMappings.split(' ');
          planStrArray.forEach(function(plan) {
            var strArray = plan.split(':');
            if (strArray.length === 2) {
              newPlanMappings.push({ from: strArray[0], to: strArray[1] });
            } else {
              throw new Error(g.f(
                'The value of the {{--plans}} option is invalid; ' +
                'plan mappings must be a list of source plan and target plan pairs, ' +
                'i.e., {{--plans "bronze:freemium silver:premium gold:premium"}}'));
            }
          });
        }
        ;

        reqOptions.json.planMappings = newPlanMappings;

        return request(reqOptions).then(function(rsp) {
          var body = rsp.body;
          var subscriptions = typeof body === 'string' ? JSON.parse(body) : body;
          return {
            fromProd: result[0],
            toProd: result[1],
            subscriptions: subscriptions,
          };
        });
      });
    });
};

/**
 * Set migration target for a product
 *
 * @param {object} options
 * @param {object} options.productNameVersion identifies a product with the format `product:version`. Version optional.
 * @param {object} options.creds || options.server
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<object>.fromProd product being replaced
 * @return Promise.<object>.toProd product replacing
 * @return Promise.<object>.subscriptions response which is used to check pendingDeploymentState
 */
function setMigrationTarget(options) {
  return validator(options,
    [ 'organization', 'catalog', 'fromNameVersion', 'toNameVersion', 'planMappings' ])
    .then(function(options) {
      var newPlanMappings = [];
      var planMappings = options.planMappings;
      var fromOpts = _.cloneDeep(options);
      var toOpts = _.cloneDeep(options);
      fromOpts.productNameVersion = options.fromNameVersion;
      toOpts.productNameVersion = options.toNameVersion;

      return Promise.map([ fromOpts, toOpts ], getProduct, { concurrency: 1 })
      .then(function(result) {
        var fromProd = result[0];
        var toProd = result[1];

        // Use space option in replace API if available
        var space = toProd.spaceName || options.space;

        var fromProdName = fromProd.productName;
        var toProdName = toProd.productName;
        // Use product versions when available
        var fromProdVersion = fromProd.productVersion;
        var toProdVersion = toProd.productVersion;

        var reqOptions;
        if (space) {
          reqOptions = reqOpts(_.defaults({
            url: f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s:%s/set-migration',
              options.organization, options.catalog, space, fromProdName, fromProdVersion),
            method: 'put',
          },
          options));
        } else {
          reqOptions = reqOpts(_.defaults({
            url: f('/v1/orgs/%s/environments/%s/products/%s:%s/set-migration',
              options.organization, options.catalog, fromProdName, fromProdVersion),
            method: 'put',
          },
          options));
        }

        reqOptions.json = {};
        reqOptions.json.newProduct = { name: toProdName, version: toProdVersion };
        reqOptions.json.planMappings = [];

        if (planMappings && (typeof planMappings === 'string')) {
          var planStrArray = planMappings.split(' ');
          planStrArray.forEach(function(plan) {
            var strArray = plan.split(':');
            if (strArray.length === 2) {
              newPlanMappings.push({ from: strArray[0], to: strArray[1] });
            } else {
              throw new Error(g.f(
                'The value of the {{--plans}} option is invalid; ' +
                'plan mappings must be a list of source plan and target plan pairs, ' +
                'i.e., {{--plans "bronze:freemium silver:premium gold:premium"}}'));
            }
          });
        };

        reqOptions.json.planMappings = newPlanMappings;

        return request(reqOptions).then(function(rsp) {
          return {
            fromProd: result[0],
            toProd: result[1],
          };
        });
      });
    });
};

//
// Util functions
//
function getProduct(options) {
  var prod = options.productNameVersion.split(':');
  options = _.defaults({
    productName: prod[0],
    productVersion: prod.length >= 2 ? prod[1] : '',
  }, options);

  var reqOptions = reqOpts(_.defaults({
    url: productsSearchUrl(options),
    headers: {
      Accept: 'application/json',
    },
    json: true,
  }, options));

  return request(reqOptions).then(function(products) {
    products = _.filter(products || [], function(r) {
      // The search might return multiple apis and/or products
      return (r.type === PRODUCT_TYPE && r.name === options.productName);
    });
    //apis = fixAPIFields(apis);
    //return attachRelatedProductsToAPI(options, apis);
    return products;
  }).then(function(products) {
    return findProduct(options, products);
  }).then(function(product) {
    if (!product) {
      var error = new Error(g.f('The product %s was not found.', options.productNameVersion));
      return Promise.reject(error);
    } else {
      var reqOptions = reqOpts(_.defaults({
        url: productsUrlById(product.id, options),
        headers: {
          Accept: 'application/json',
        },
        json: true,
      }, options));

      return request(reqOptions).then(function(product) {
        product.orgName = options.organization;
        product.catalogName = options.catalog;
        product.spaceName = options.space;
        return product;
      });
    }
  });
};

/**
 * Search for a product, e.g. using just a name
 *
 * @param {string} productName
 * @param {string} productVersion
 * @param {Array.<Product>} products Array of products
 * *
 * @return Product */
function findProduct(options, products) {
  var foundProduct = null;
  var product;
  var productName = options.productName;
  var productVersion = options.productVersion;
  var count = 0;
  var i;
  if (productVersion) {
    for (i = 0; i < products.length; i++) {
      product = products[i];
      if (product.name === productName && product.version === productVersion) {
        foundProduct = product;
        count++;
      }
    }
  } else {
    for (i = 0; i < products.length; i++) {
      product = products[i];
      if (product.name === productName) {
        foundProduct = product;
        count++;
      }
    }
  }
  if (count > 1) {
    var error = new Error(g.f('The product must be qualified with version to be sufficiently disambiguated.'));
    throw error;
  }
  return foundProduct;
};

function pullProductById(options, product) {
  var reqOptions;
  if (product.spaceName) {
    reqOptions = reqOpts(_.defaults({
      url: f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s/all',
        product.orgName, product.catalogName, product.spaceName, product.id),
      method: 'get',
      json: true,
    },
    options));
  } else {
    reqOptions = reqOpts(_.defaults({
      url: f('/v1/orgs/%s/environments/%s/products/%s/all',
        product.orgName, product.catalogName, product.id),
      method: 'get',
      json: true,
    },
    options));
  }

  return request(reqOptions).then(function(result) {
    result.product.orgName = product.orgName;
    result.product.catalogName = product.catalogName;
    result.product.spaceName = product.spaceName;
    return result;
  });
};

/**
 * Download an API and write it to disk
 *
 * @param {object} api API document
 * @param {string} org Organization name
 * @param {object} options.creds || options.server
 *
 * @return Promise.<Product>
 */
function downloadAPIAndWSDL(api, org, options) {
  // Generate the api filename and write it to disk
  var apiFileName = generateApiFileName(api.document.info[ 'x-ibm-name'], api.document.info.version);

  // Generate the wsdl filename and write it to disk
  if (api.document && api.document[ 'x-ibm-configuration'] && api.document[ 'x-ibm-configuration'].type === 'wsdl') {
    var apiWsdlFileName = generateApiWsdlFileName(api.document.info[ 'x-ibm-name'], api.document.info.version);
    var id = api.document[ 'x-ibm-configuration'][ 'wsdl-definition'].wsdl;

    var reqOptions = reqOpts(_.defaults({
      url: f('/v1/orgs/%s/apis/wsdl/%s', org, id),
      method: 'get',
      encoding: null,
      headers: {
        accept: 'application/json',
      },
      returnHTTPResponse: true,
    },
    options));

    return request(reqOptions).then(function(res) {
      var body = res.body;
      if (res.headers[ 'content-disposition'].split('.').pop().replace(/['"]+/g, '') === 'zip') {
        apiWsdlFileName = generateApiWsdlZipFileName(api.document.info[ 'x-ibm-name'],
          api.document.info.version);
      }
      fs.writeFileSync(apiWsdlFileName, body);
      api.wsdlFileName = apiWsdlFileName;
      // Update the wsdl ref to the actual wsdl filename that was written to disk
      api = processApiForDownload(api, apiWsdlFileName);
      validateWriteFile(path.resolve(apiFileName), jsYaml.safeDump(api.document), true);
      api.apiFileName = apiFileName;
      return api;
    });
  } else {
    validateWriteFile(path.resolve(apiFileName), jsYaml.safeDump(api.document), true);
    api.apiFileName = apiFileName;
    return api;
  }
};

/**
 * Process product before downloading, replaces the api name:version to $ref
 *
 * @param {object} Product
 * @return Product
 */
function processProductForDownload(product) {
  _.keys(product.document.apis).forEach(function(apiName) {
    var api = product.document.apis[ apiName];
    api.$ref = generateApiFileName(getName(api.name), getVersion(api.name));
    delete api.name;
  });

  return product;
};

/**
 * Process the api for downloading
 * Replaces the api wsdl filename with the actual wsdl filename being written to the disk
 *
 * @param {object} api
 * @param {string} newWsdlFileName
 * @return Product
 */
function processApiForDownload(api, newWsdlFileName) {
  if (api.document && api.document[ 'x-ibm-configuration'] &&
    api.document[ 'x-ibm-configuration'].type === 'wsdl') {
    api.document[ 'x-ibm-configuration'][ 'wsdl-definition'][ 'wsdl'] = newWsdlFileName;
  }

  return api;
};

/**
 * Process product before uploading to apim server
 * Replaces the $ref from file:/// to name:version
 *
 * @param product {Product}
 */
function processProductForUpload(product) {
  var productDir = path.dirname(product.filePath);
  _.keys(product.data.apis).forEach(function(apiName) {
    var api = product.data.apis[apiName];
    var idx = _.findIndex(product.refs, function(apiInfo) {
      return apiInfo.filePath === path.resolve(productDir, api.$ref);
    });
    var apiInstance = product.refs[idx];
    api.name = apiInstance.name + ':' + apiInstance.version;
    delete api.$ref;
  });
};

// Stage a product by uploading APIs and deploying product
function processStaging(options, result) {
  result.body = {};
  result.body['product'] = result.product;
  result.body['apis'] = [];
  for (var prop in result.apis) {
    // if api is not wsdl type push to result
    if (result.apis[prop]['x-ibm-configuration'] === undefined ||
      result.apis[prop]['x-ibm-configuration'].type === undefined ||
      result.apis[prop]['x-ibm-configuration'].type !== 'wsdl') {
      result.body['apis'].push(result.apis[prop]);
    }
  }

  return wsdlUpload(options, result).then(function() {
    return deploy(options, result);
  });
};

// Upload a WSDL
function wsdlUpload(options, result) {
  var req = Promise.promisify(wsdlUploadReq);
  var apis = result.apis;
  var ids = {};

  return Promise.each(_.keys(apis), function(apiName) {
    var api = apis[apiName];

    if (api['x-ibm-configuration'] && api['x-ibm-configuration'].type === 'wsdl') {
      var file = api['x-ibm-configuration']['wsdl-definition'].wsdl;
      try {
        file = path.resolve(path.dirname(options.filename), file);
      } catch (e) {
        throw new Error(g.f('Unable to resolve path.', file), 404);
      }

      if (!fs.existsSync(file)) {
        throw new Error(g.f('The file name %s was not found.', file), 404);
      }

      return req(options, file).then(function(wsdl_data) {
        api['x-ibm-configuration']['wsdl-definition'].wsdl = wsdl_data.wsdlId;
        ids[api.info['x-ibm-name']] = {};
        ids[api.info['x-ibm-name']].api = api;
      });
    }
  }).then(function() {
    _.each(_.keys(ids), function(name) {
      var wsdl_api = ids[name];
      result.body['apis'].push(wsdl_api.api);
    });

    return result;
  });
};

// Request to Upload WSDL
function wsdlUploadReq(options, file, cb) {
  var request = require('request');

  var opts = reqOpts(_.defaults({
    url: f('/v1/orgs/%s/apis/wsdl', options.organization),
    method: 'post',
    json: true,
  }, options));

  var req = request.post(opts, function(err, resp, body) {
    if (err) {
      return cb(err);
    }
    if (resp.statusCode < 200 || resp.statusCode > 399) {
      err = new Error(resp.statusCode, body);
      return cb(err, null);
    }
    return cb(null, body);
  });
  var form = req.form();
  form.append('file', fs.createReadStream(file));
};

// Hopefull at some point the issue with the following code
// is going to be fixed so we can stop using request.js
/*
function wsdlUploadReq(options, file) {
  var reqOptions = reqOpts(_.defaults({
    url: f('/v1/orgs/%s/apis/wsdl', options.organization),
    method: 'post',
    json: true,
    returnHTTPResponse: true,
  }, options));

  reqOptions['Content-Type'] = 'multipart/form-data';
  reqOptions.formData = {
    Sofile: fs.createReadStream(file),
  };

  return request(reqOptions);
};
*/

// Request to stage a product
function deploy(options, result) {
  var space = options.space;
  var reqOptions;

  if (space) {
    reqOptions = reqOpts(_.defaults({
      url: f('/v1/orgs/%s/environments/%s/spaces/%s/products?resolveApiRef=false',
        options.organization, options.catalog, options.space),
      method: 'post',
      json: true,
    }, options));
  } else {
    reqOptions = reqOpts(_.defaults({
      url: f('/v1/orgs/%s/environments/%s/products?resolveApiRef=false',
        options.organization, options.catalog),
      method: 'post',
      json: true,
    }, options));
  }

  reqOptions.body = result.body;
  return request(reqOptions);
};

function productsSearchUrl(options) {
  var url;

  if (options.space) {
    url = f('/v1/orgs/%s/environments/%s/spaces/%s/search', options.organization, options.catalog, options.space);
  } else {
    url = f('/v1/orgs/%s/environments/%s/search', options.organization, options.catalog);
  }
  if (options.productVersion) {
    url += f('?name=%s&version=%s&type=productVersion', options.productName, options.productVersion);
  } else {
    url += f('?name=%s&type=productVersion', options.productName);
  }

  return url;
};

function productsUrlById(productId, options) {
  var space = options.space;
  if (space) {
    return f('/v1/orgs/%s/environments/%s/spaces/%s/products/%s',
      options.organization, options.catalog, options.space, productId);
  } else {
    return f('/v1/orgs/%s/environments/%s/products/%s',
      options.organization, options.catalog, productId);
  }
};

function getName(nameVersion) {
  var token = nameVersion.split(':');
  return token[0];
};

function getVersion(nameVersion) {
  var token = nameVersion.split(':');
  return token[1] || null;
}

function validateWriteFile(desPath, content, overWrite) {
  if (fs.existsSync(desPath) && !overWrite) {
    throw new Error(g.f('The file name %s already exists.', desPath));
  } else {
    fs.writeFileSync(desPath, content);
  }
};

function generateProductFileName(productName, productVersion) {
  return productName + '_product_' + productVersion + '.yaml';
};

function generateApiFileName(apiName, apiVersion) {
  return apiName + '_' + apiVersion + '.yaml';
};

function generateApiWsdlFileName(apiName, apiVersion) {
  return apiName + '_' + apiVersion + '.wsdl';
};

function generateApiWsdlZipFileName(apiName, apiVersion) {
  return apiName + '_' + apiVersion + '.zip';
};

module.exports = {
  list: list,
  get: get,
  set: set,
  delete: del,
  clear: clear,
  stage: stage,
  publish: publish,
  pull: pull,
  clone: clone,
  replace: replace,
  supersede: supersede,
  setMigrationTarget: setMigrationTarget,
};

