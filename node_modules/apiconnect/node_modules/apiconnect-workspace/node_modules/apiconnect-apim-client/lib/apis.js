/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var catalogAPI = require('./catalogs');
var config = require('apiconnect-config');
var f = require('util').format;
var fs = Promise.promisifyAll(require('fs'));
var logger = require('apiconnect-cli-logger');
var mkdirp = require('mkdirp');
var orgAPI = require('./orgs');
var os = require('os');
var path = require('path');
var reqOpts = require('./req-options');
var request = require('./request');
var validator = require('./opts-validator');
var yaml = require('js-yaml');

var API_TYPE = 'apiVersion';

/**
 * @typedef API
 * @param {string} createdBy
 * @param {string} updatedBy
 * @param {Date} updatedAt
 * @param {Date} createdAt
 * @param {string} apiName
 * @param {string} apiVersion
 * @param {string} apiTitle
 * @param {string} id GUID of api
 * @param {string} orgId GUID of organization
 * @param {string} envId GUID of catalog
 * @param {string} orgName Name of organization
 * @param {string} catalogName Name of catalog
 * @param {bool} spaceEnabled is true if the parent catalog has spaces enabled
 * @param {Array.<string>} spaceNames Names of spaces
 * @param {string} documentType Will be "apiVersion"
 * @param {deploymentState} will be one of running, stopped, suspended
 * @param {URL} url URL to download the API
 * @param {apiFile} path to file stored in os.tmpdir. Only populated when pulling the API.
 * @param {wsdlFile} path to file stored in os.tmpdir. Only populated when pulling the API that contains WSDL.
 *
 * Other fields (not tested):
 *  * vendorExtensions
 *  * planRegistrations
 *  * documentId
 *  * apiEndpoint
 *  * deploymentPackageId
 *  * apiId
 */

/**
 * @typedef APIs
 * @type Array.<API>
 */

/**
 * List all APIs in the catalog.
 *
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<APIs>
 */
function list(options) {
  options = options || {};

  return catalogAPI.listAll(options).then(function(catalogs) {
    if (catalogs.length === 0) {
      var err = new Error(f('No such catalog %s in organization %s', options.catalog, options.organization));
      err.code = 'CATALOG_NOT_FOUND';
      err.obj = { catalog: options.catalog, org: options.organization };
      throw err;
    }
    return Promise.map(catalogs, function(catalog) {
      if (!catalog.spaceEnabled) {
        var reqOptions = reqOpts(_.defaults({
          url: f('/v1/orgs/%s/environments/%s/apis', catalog.orgId, catalog.id),
          json: true,
        }, options));
        return request(reqOptions).map(function(api) {
          api.orgName = catalog.orgName;
          api.catalogName = catalog.shortName;
          return api;
        });
      } else {
        var spaces = catalog.spaces;
        if (options.space) {
          spaces = _.filter(spaces, function(s) {
            return s.name === options.space || s.id === options.space;
          });
        }

        return Promise.map(spaces, function(space) {
          reqOptions = reqOpts(_.defaults({
            url: f(
              '/v1/orgs/%s/environments/%s/spaces/%s/apis',
              catalog.orgId,
              catalog.id,
              space.id
            ),
            json: true,
          }, options));
          return request(reqOptions).map(function(api) {
            api.orgName = catalog.orgName;
            api.catalogName = catalog.shortName;
            api.spaceEnabled = catalog.spaceEnabled;
            api.spaceName = space.name;
            return api;
          });
        });
      }
    });
  }).then(function(apis) {
    apis = _.flattenDeep(apis);
    return _.values(_.reduce(apis, mapSpaces, {}));
  });

  function mapSpaces(accum, api) {
    var key = api.orgName + ':' + api.catalogName + ':' + api.apiName + api.apiVersion;
    if (accum[key] == null) {
      api.spaceNames = api.spaceName != null ? [ api.spaceName ] : [];
      accum[key] = api;
    } else if (api.spaceName != null) {
      accum[key].spaceNames.push(api.spaceName);
    }
    delete api.spaceName;
    return accum;
  }
}

/**
 * Fetch one or more apis in a catalog and its associated products
 *
 * @param {object} options
 * @param {string} options.organization
 * @param {string} options.catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 * @param {string} options.apiNameVersion API name or name:version
 *
 * @returns Promise.<APIs>
 */
function fetchAPIsAndProducts(options) {
  return validator(options, [ 'organization', 'catalog', 'apiNameVersion' ]).then(function(options) {
    return Promise.all([
      orgAPI.get(_.defaults({ name: options.organization }, options)),
      catalogAPI.get(options),
      fetchAPIs(options),
    ]).spread(function(org, cat, apis) {
      return updateOrgCatInfo(org, cat, apis, options);
    });
  });
}


/**
 * Fetch one or more apis in a catalog and its associated products
 *
 * @param {object} options
 * @param {string} options.organization
 * @param {string} options.catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 * @param {string} options.apiNameVersion API name or name:version
 *
 * @returns Promise.<APIs>
 */
function fetchAPIs(options) {
  var api = options.apiNameVersion.split(':');
  options = _.defaults({
    apiName: api[0],
    apiVersion: api.length >= 2 ? api[1] : '',
  }, options);

  var reqOptions = reqOpts(_.defaults({
    url: f(
      '/v1/orgs/%s/environments/%s/search?%s',
      options.organization,
      options.catalog,
      getAPIQueryParams(options)),
    json: true,
  }, options));

  if (options.space) {
    reqOptions = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/spaces/%s/search?%s',
        options.organization,
        options.catalog,
        options.space,
        getAPIQueryParams(options)),
      json: true,
    }, options));
  }

  return request(reqOptions).then(function(apis) {
    apis = _.filter(apis || [], function(r) {
      // The search might return multiple apis and/or products
      return (r.type === API_TYPE && r.name === options.apiName);
    });
    apis = fixAPIFields(apis);
    return attachRelatedProductsToAPI(options, apis);
  });

  function getAPIQueryParams(options) {
    if (options.apiVersion !== '') {
      return f('name=%s&version=%s', options.apiName, options.apiVersion);
    } else {
      return f('name=%s', options.apiName);
    }
  }
}

/**
 * Download specific API and associated WSDL from catalog/space.
 *
 * @param {object} options
 * @param {string} options.organization
 * @param {string} options.catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 * @param {string} options.apiNameVersion API name or name:version
 * @param {string} options.dirPath Optional location where to download WSDL and API files into
 *
 * @returns Promise.<APIs>
 */
function pullAPI(options) {
  return validator(options, [ 'organization', 'catalog', 'apiNameVersion' ]).then(function(options) {
    return Promise.all([
      orgAPI.get(_.defaults({ name: options.organization }, options)),
      catalogAPI.get(options),
      fetchAPIs(options),
    ]).spread(function(org, cat, apis) {
      return updateOrgCatInfo(org, cat, apis, options);
    }).then(function(apis) {
      return Promise.map(apis, function(api) {
        return downloadAPIAndWSDL(api, options);
      });
    });
  });
}

/**
 * Download all APIs and associated WSDL from catalog/space.
 *
 * @param {object} options
 * @param {string} options.organization
 * @param {string} options.catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 * @param {string} options.dirPath Optional location where to download WSDL and API files into
 *
 * @returns Promise.<APIs>
 */
function pullAllAPIs(options) {
  var concurrency = parseInt(config.loadConfig().getOne('concurrency'), 10) || config.DEFAULT_CONCURRENCY;
  logger.debug('Concurrency used: %d', concurrency);
  return list(options).then(function(apis) {
    return Promise.map(apis, function(api) {
      return downloadAPIAndWSDL(api, options);
    }, { concurrency: concurrency }).then(function(apis) {
      return attachRelatedProductsToAPI(options, apis);
    });
  });
}

/**
 * Set the state (started/stopped) of one or more apis in a catalog
 *
 * @param {object} options
 * @param {string} options.organization
 * @param {string} options.catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 * @param {string} options.apiNameVersion API name or name:version
 * @param {string} options.status `start` or `stop`
 *
 * @returns Promise.<APIs>
 */
function setAPIStatus(options) {
  return validator(options, [ 'organization', 'catalog', 'apiNameVersion', 'status' ]).then(function(options) {
    return Promise.all([
      orgAPI.get(_.defaults({ name: options.organization }, options)),
      catalogAPI.get(options),
      fetchAPIs(options).then(function(apis) {
        return Promise.map(apis, function(api) {
          var reqOptions = reqOpts(_.defaults({
            url: f(
              '/v1/orgs/%s/environments/%s/apis/%s/%s',
              options.organization,
              options.catalog,
              api.id,
              options.status),
            json: true,
            method: 'POST',
          }, options));

          if (options.space) {
            reqOptions = reqOpts(_.defaults({
              url: f(
                '/v1/orgs/%s/environments/%s/spaces/%s/apis/%s/%s',
                options.organization,
                options.catalog,
                options.space,
                api.id,
                options.status),
              json: true,
              method: 'POST',
            }, options));
          }

          return request(reqOptions).catch(function(err) {
            if (options.status === 'start' && _.filter(err.errors, 'deployer.api.not.suspended.in.env').length > 0) {
              return api;
            }
            if (options.status === 'stop' && _.filter(err.errors, 'deployer.api.not.running.in.env').length > 0) {
              return api;
            }
            throw err;
          });
        });
      }),
    ]).spread(function(org, cat, apis) {
      apis = fixAPIFields(apis);
      apis = updateOrgCatInfo(org, cat, apis, options);
      return attachRelatedProductsToAPI(options, apis);
    });
  });
}

/**
 * @private
 * Looks up the products associated with APIs
 */
function attachRelatedProductsToAPI(options, apis) {
  return Promise.map(apis, function(api) {
    var reqOptions = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/search?apiIdentifier=%s:%s&type=productVersion',
        options.organization,
        options.catalog,
        api.apiName,
        api.apiVersion
      ),
      json: true,
    }, options));

    if (options.space) {
      reqOptions = reqOpts(_.defaults({
        url: f(
          '/v1/orgs/%s/environments/%s/spaces/%s/search?apiIdentifier=%s:%s&type=productVersion',
          options.organization,
          options.catalog,
          options.space,
          api.apiName,
          api.apiVersion
        ),
        json: true,
      }, options));
    }

    return request(reqOptions).then(function(prods) {
      api.relatedProducts = prods;
      return api;
    });
  });
}

/**
 * @private
 * Download WSDL files and update api with file name (replacing WSDL ID)
 */
function downloadAPIAndWSDL(api, options) {
  var url = f(
    '/v1/orgs/%s/environments/%s/apis/%s',
    options.organization,
    options.catalog,
    api.id
  );

  if (options.space) {
    url = f(
      '/v1/orgs/%s/environments/%s/spaces/%s/apis/%s',
      options.organization,
      options.catalog,
      options.space,
      api.id
    );
  }

  var reqOptions = reqOpts(_.defaults({
    url: url,
    headers: {
      Accept: 'application/vnd.ibm-apim.swagger2+json',
    },
  }, options));
  var dirPath = options.dirPath || path.join(os.tmpdir(), (+Date.now()).toString());
  mkdirp.sync(dirPath);

  return request(reqOptions).then(function(apiData) {
    apiData = yaml.safeLoad(apiData);
    var hasWsdl = apiData && apiData['x-ibm-configuration'] && apiData['x-ibm-configuration'].type === 'wsdl';
    if (hasWsdl) {
      var wsdlDef = apiData['x-ibm-configuration']['wsdl-definition'];
      if (!wsdlDef || !wsdlDef.wsdl) {
        throw new Error('Unable to download WSDL assciated with swagger API');
      }

      var wsdlId = apiData['x-ibm-configuration']['wsdl-definition'].wsdl;
      var reqOptions = reqOpts(_.defaults({
        url: f('%s/wsdl/%s', url, wsdlId),
        encoding: null,
        returnHTTPResponse: true,
      }, options));
      return request(reqOptions).then(function(resp) {
        var wsdlFileName = apiData.info['x-ibm-name'] + '_' + apiData.info.version + '.wsdl';
        if (resp.headers && resp.headers['content-disposition'] &&
            resp.headers['content-disposition'].split('.').pop().replace(/['"]+/g, '') === 'zip') {
          wsdlFileName = apiData.info['x-ibm-name'] + '_' + apiData.info.version + '.zip';
        }
        api.wsdlFile = path.join(dirPath, wsdlFileName);
        return fs.writeFileAsync(api.wsdlFile, resp.body);
      }).return(apiData);
    }
    return apiData;
  }).then(function(apiData) {
    var apiFileName = apiData.info['x-ibm-name'] + '_' + apiData.info.version + '.yaml';
    api.apiFile = path.join(dirPath, apiFileName);
    return fs.writeFileAsync(api.apiFile, yaml.safeDump(apiData, { indent: 2, noRefs: true }));
  }).return(api);
}

/**
 * @private
 * Backend APIs return data with varying names. Make them consistent.
 */
function fixAPIFields(apis) {
  return _.map(apis, function(api) {
    if (!api.type && api.documentType) {
      api.type = api.documentType;
    }
    if (!api.apiName && api.name) {
      api.apiName = api.name;
    }
    if (!api.apiVersion && api.version) {
      api.apiVersion = api.version;
    }
    if (!api.deploymentState && api.state) {
      api.deploymentState = api.state;
    }
    return api;
  });
}

/**
 * @private
 * Used internally to attach org, cat and space name to apis
 */
function updateOrgCatInfo(org, cat, apis, options) {
  apis = _.map(apis, function(api) {
    api.orgName = org.name;
    api.catalogName = cat.shortName;
    api.spaceEnabled = cat.spaceEnabled;
    if (cat.spaceEnabled) {
      api.spaceNames = _.map(api.spaceIds, function(spaceId) {
        var space = _.find(cat.spaces, { id: spaceId });
        return space.name;
      });
    } else {
      api.spaceNames = [];
    }
    return api;
  });
  return apis;
}

module.exports = {
  list: list,
  get: fetchAPIsAndProducts,
  pull: pullAPI,
  pullAll: pullAllAPIs,
  set: setAPIStatus,
};

