/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-pm

'use strict';

var Promise = require('bluebird');
var g = require('strong-globalize')();
var path = require('path');

function demuxRemote(options) {
  if (options.remote) {
    // Since we're using loginOptional, ensure that we are logged in as this path requires login
    // If we're passed the a service name, it's actually an app name in this case. Override the app
    // option that is potentially set by the cli framework.
    if (options.service) {
      options.app = options.service;
    }
    if (options.creds && (options.creds.username || options.creds.token)) {
      var RemoteApps = require('apiconnect-cli-util').RemoteApps;
      return RemoteApps.resolve(options);
    }
    if (!options.creds.host) {
      return Promise.reject(new Error(g.f('The {{--server}} option is required.')));
    }
    return Promise.reject(new Error(g.f('Login to %s is required with {{\'apic login\'}}.', options.creds.host)));
  } else {
    return Promise.resolve(require('./local'));
  }
}

function getTopics() {
  return [
    {
      name: 'props',
      commands: [
        {
          command: 'clear',
          loginOptional: 'app',
          options: [
            '--remote',
            { name: 'service', rune: 'S', type: 'name' },
            { name: 'organization', rune: 'o', type: 'name', default: '$APIC_CONFIG$.app.data.orgs' },
            { name: 'server', rune: 's', type: 'url', default: '$APIC_CONFIG$.app.host' },
            { name: 'app', rune: 'a', type: 'name', default: '$APIC_CONFIG$.app.data.apps' },
          ],
          helpInfo: g.f('apic_props_clear_help.txt'),
          action: function(options) {
            var propsFmt = require('./util/props-fmt');
            options.logger = options.logger || require('apiconnect-cli-logger');
            return demuxRemote(options).then(function(impl) {
              return impl['propsClear'](options).then(function(a) {
                propsFmt.printDelete(
                  options.logger, a.props, options.service && !options.serviceFromConfig ? '' : a.app
                );
              });
            });
          },
        }, {
          command: 'delete <name> [name...]',
          loginOptional: 'app',
          options: [
            '--remote',
            { name: 'service', rune: 'S', type: 'name' },
            { name: 'organization', rune: 'o', type: 'name', default: '$APIC_CONFIG$.app.data.orgs' },
            { name: 'server', rune: 's', type: 'url', default: '$APIC_CONFIG$.app.host' },
            { name: 'app', rune: 'a', type: 'name', default: '$APIC_CONFIG$.app.data.apps' },
          ],
          helpInfo: g.f('apic_props_delete_help.txt'),
          action: function(name, names, options) {
            var propsFmt = require('./util/props-fmt');
            options.logger = options.logger || require('apiconnect-cli-logger');
            return demuxRemote(options).then(function(impl) {
              return impl['propsDelete'](name, names, options).then(function(a) {
                propsFmt.printDelete(
                  options.logger, a.props, options.service && !options.serviceFromConfig ? '' : a.app
                );
              });
            });
          },
        }, {
          command: 'get <NAME> [<name>...]',
          loginOptional: 'app',
          options: [
            '--remote',
            { name: 'service', rune: 'S', type: 'name' },
            { name: 'organization', rune: 'o', type: 'name', default: '$APIC_CONFIG$.app.data.orgs' },
            { name: 'server', rune: 's', type: 'url', default: '$APIC_CONFIG$.app.host' },
            { name: 'app', rune: 'a', type: 'name', default: '$APIC_CONFIG$.app.data.apps' },
          ],
          helpInfo: g.f('apic_props_get_help.txt'),
          action: function(name, names, options) {
            var propsFmt = require('./util/props-fmt');
            options.logger = options.logger || require('apiconnect-cli-logger');
            return demuxRemote(options).then(function(impl) {
              return impl['propsGet'](name, names, options).then(function(a) {
                propsFmt.print(options.logger, a.props, options.service && !options.serviceFromConfig ? '' : a.app);
              });
            });
          },
        }, {
          command: 'list',
          loginOptional: 'app',
          aliases: [ 'props' ],
          options: [
            '--remote',
            { name: 'service', rune: 'S', type: 'name' },
            { name: 'organization', rune: 'o', type: 'name', default: '$APIC_CONFIG$.app.data.orgs' },
            { name: 'server', rune: 's', type: 'url', default: '$APIC_CONFIG$.app.host' },
            { name: 'app', rune: 'a', type: 'name', default: '$APIC_CONFIG$.app.data.apps' },
          ],
          helpInfo: g.f('apic_props_list_help.txt'),
          action: function(options) {
            var propsFmt = require('./util/props-fmt');
            var _ = require('lodash');
            options.logger = options.logger || require('apiconnect-cli-logger');
            return demuxRemote(options).then(function(impl) {
              return impl['propsList'](options).then(function(apps) {
                _.each(apps, function(a) {
                  propsFmt.print(options.logger, a.props, options.service && !options.serviceFromConfig ? '' : a.app);
                });
              });
            });
          },
        }, {
          command: 'set <NAME=VALUE> [name=value...]',
          loginOptional: 'app',
          options: [
            '--remote',
            { name: 'service', rune: 'S', type: 'name' },
            { name: 'organization', rune: 'o', type: 'name', default: '$APIC_CONFIG$.app.data.orgs' },
            { name: 'server', rune: 's', type: 'url', default: '$APIC_CONFIG$.app.host' },
            { name: 'app', rune: 'a', type: 'name', default: '$APIC_CONFIG$.app.data.apps' },
          ],
          helpInfo: g.f('apic_props_set_help.txt'),
          action: function(nameValue, otherNameValues, options) {
            var propsFmt = require('./util/props-fmt');
            options.logger = options.logger || require('apiconnect-cli-logger');
            return demuxRemote(options).then(function(impl) {
              return impl['propsSet'](nameValue, otherNameValues, options).then(function(a) {
                propsFmt.print(options.logger, a.props, options.service && !options.serviceFromConfig ? '' : a.app);
              });
            });
          },
        },
      ],
    }, {
      name: 'services',
      commands: [
        {
          command: 'get',
          options: [
            { name: 'service', rune: 'S', type: 'name' },
          ],
          helpInfo: g.f('apic_services_get_help.txt'),
          action: function(options) {
            return require('./local').servicesGet(options);
          },
        }, {
          command: 'logs',
          aliases: [ 'logs' ],
          options: [
            { name: 'service', rune: 'S', type: 'name' },
            '-n, --no-tail',
          ],
          helpInfo: g.f('apic_services_logs_help.txt'),
          action: function(options) {
            return require('./local').servicesLogs(options);
          },
        }, {
          command: 'list',
          aliases: [ 'services' ],
          options: [],
          helpInfo: g.f('apic_services_list_help.txt'),
          action: function(options) {
            return require('./local').servicesList(options);
          },
        }, {
          command: 'start',
          aliases: [ 'start' ],
          options: [
            { name: 'service', rune: 'S', type: 'name' },
          ],
          helpInfo: g.f('apic_services_start_help.txt'),
          action: function(options) {
            return require('./local').servicesStart(options);
          },
          analytics: function(options) {
            return require('./local').startAnalytics(options);
          },
        }, {
          command: 'stop',
          aliases: [ 'stop' ],
          options: [
            '--all',
            { name: 'service', rune: 'S', type: 'name' },
          ],
          helpInfo: g.f('apic_services_stop_help.txt'),
          action: function(options) {
            return require('./local').servicesStop(options);
          },
        },
      ],
    }, {
      name: 'microgateway',
      description: 'Create and install a Micro Gateway application',
      commands: [ {
        command: 'app',
        aliases: [ 'microgateway' ],
        options: [
          { name: 'name', rune: 'n', type: 'name' },
          { name: 'server', rune: 's', type: 'url' },
        ],
        helpInfo: g.f('apic_microgateway_app_help.txt'),
        action: function(options) {
          return require('./microgateway/app')(options);
        },
      },
    ] },
  ];
}
exports.getTopics = getTopics;

function getVersion() {
  var pluginInfo = {};
  var pluginPath = path.resolve(__dirname, path.join('..'));
  var pkg = require(path.resolve(pluginPath, 'package.json'));
  var plugin = require(pluginPath);
  pluginInfo = {
    name: pkg.name,
    version: pkg.version,
    topics: plugin.getTopics ? plugin.getTopics() : null,
    components: plugin.getComponents ? plugin.getComponents() : null,
    path: pluginPath,
    isBuiltin: true,
    gitHead: pkg.gitHead,
    deps: [],
  };
  if (pkg.dependencies['apiconnect-mgmt-lite-datapower']) {
    var dpPath = path.join(require.resolve('apiconnect-mgmt-lite-datapower'), '..');
    var dpPkg = require(path.join(dpPath, 'package.json'));
    var dpInfo = {
      name: dpPkg.name,
      version: dpPkg.version,
      path: dpPath,
      gitHead: dpPkg.gitHead,
    };
    pluginInfo.deps.push(dpInfo);
  }
  // add dependencies microgateway and flow-engine
  if (pkg.dependencies['microgateway']) {
    var mgPath = path.join(require.resolve('microgateway'), '..');
    var mgPkg = require(path.join(mgPath, 'package.json'));
    var mgInfo = {
      name: mgPkg.name,
      version: mgPkg.version,
      path: mgPath,
      gitHead: mgPkg.gitHead,
    };
    if (mgPkg.dependencies['flow-engine']) {
      var fgPath = null;
      try {
        fgPath = path.join(require.resolve('flow-engine'), '..');
      } catch (e) {
        // ignore the error and to find the module
        fgPath = path.join(mgPath, 'node_modules', 'flow-engine');
      }
      if (fgPath) {
        var fgPkg = require(path.join(fgPath, 'package.json'));
        mgInfo.deps = [ {
          name: fgPkg.name,
          version: fgPkg.version,
          path: fgPath,
          gitHead: fgPkg.gitHead,
        } ];
      }
    }
    pluginInfo.deps.push(mgInfo);
  }
  return pluginInfo;
}

exports.getVersion = getVersion;

