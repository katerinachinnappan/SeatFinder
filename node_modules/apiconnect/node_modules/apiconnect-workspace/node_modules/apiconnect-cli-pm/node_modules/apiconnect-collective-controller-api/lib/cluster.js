// Copyright IBM Corp. 2016,2017. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var _ = require('lodash');
var async = require('async');
var cluster = require('apiconnect-collective-jmx').cluster;
var debug = require('./debug')('upload');
var fileService = require('./file-service');
var jmx = require('apiconnect-collective-jmx');
var mandatory = require('./util').mandatory;
var parseConfig = require('./parse-config');
var request = require('request');
var url = require('url');

var GROUP = 'apic';

/**
 * Operations for deploying a cluster of applications to a collective.
 * @class Cluster
 */
module.exports = Cluster;
function Cluster() {}

/**
 * List all clusters registered to controller.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 *
 * Returns array of members in the form `host,userdir,servername`
 */
Cluster.listClusterNames = function(options, cb) {
  options = parseConfig(options);

  // Override for testing.
  var _sendRequest = options.request || sendRequest;

  _sendRequest(options, null, cluster.listClusterNames, function(err, result) {
    if (err) {
      return cb(err);
    }
    return cb(null, result);
  });
};

/**
 * Lists all members of a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster.
 *
 * Returns a simple array of strings with members registed to cluster in the
 * form `host,userdir,servername`.
 * Example:
 *   ['hostname,userdir,servername','hostname,userdir,servername2'].
 */
Cluster.listMembers = function(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName, 'missing clusterName');

  // Override for testing.
  var _sendRequest = options.request || sendRequest;

  options.clusterName = [GROUP, options.clusterName].join('.');
  _sendRequest(options, null, cluster.listMembers, function(err, result) {
    if (err) {
      return cb(err);
    }
    return cb(null, result);
  });
};

/**
 * Restarts all members in a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster.
 *
 * Returns array of clusters in the form `["cluster1","cluster2"]`.
 */
Cluster.restartCluster = function(options, cb) {
  async.series(
    [
      Cluster.stopCluster.bind(null, options),
      Cluster.startCluster.bind(null, options),
    ],
    cb
  );
};

Cluster.stopCluster = function(options, cb) {
  async.waterfall(
    [
      Cluster.getScalingPolicy.bind(null, options),
      getUserDefinedInstances,
      _stop,
    ],
    cb
  );

  // TODO: Below `setTimeout()` is because Liberty's scalingController does
  // not pick up new scalingPolicy.xml changes immediately. We add a delay so
  // that when scalingController won't try to spawn a new member because it
  // thinks the old member died.
  function _stop(instances, cb) {
    options.instances = instances;
    options.scalingEnabled = 'false';
    async.waterfall(
      [
        fileService.uploadScalingPolicy.bind(null, options),
        function(cb) {
          setTimeout(function() {
            return cb(null);
          }, 15000);
        },
        _stopCluster.bind(null, options),
      ],
      cb
    );
  }
};

/**
 * Lower level stop function.
 * Stops all members registered to a cluster. This is a simple stop, if the
 * cluster is auto-scaled, to permanently stop a cluster, a new scalingPolicy
 * must be uploaded to the controller with an `enabled="false"` attribute.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster
 *
 * Returns object consisting of results from each known member in the cluster.
 * The signature being result:
 *  {
 *   "<host>,<userdir>,<servername>": {
 *     returnCode: {string} <number>
 *     stdout: {string} <text>
 *     stderr: {string} <text>
 *    }
 *  }
 * @private
 */
function _stopCluster(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName, 'missing clusterName');

  options.clusterName = [GROUP, options.clusterName].join('.');
  sendRequest(options, null, cluster.stopCluster, function(err, result) {
    if (err) {
      return cb(err);
    }
    return cb(null, result);
  });
}

Cluster.startCluster = function(options, cb) {
  async.waterfall(
    [
      Cluster.getScalingPolicy.bind(null, options),
      getUserDefinedInstances,
      _start,
    ],
    cb
  );

  function _start(instances, cb) {
    options.instances = instances;
    options.scalingEnabled = 'true';
    async.series(
      [
        _startCluster.bind(null, options),
        fileService.uploadScalingPolicy.bind(null, options),
      ],
      function(err, results) {
        if (err) {
          return cb(err);
        }
        if (!results[0]) {
          err = new Error('No servers returned from startCluster command');
          return cb(err);
        }
        return cb(null, results[0]);
      }
    );
  }
};

Cluster.getScalingPolicy = function(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName, 'missing clusterName');

  var appDir = '${wlp.user.dir}/servers/controller/configDropins/overrides';
  var fileName = [GROUP, options.clusterName, 'scalingPolicy.xml'].join('.');

  options.srcFile = [appDir, fileName].join('/');

  fileService.download(options, cb);
};

function getInstancesFromXml(data) {
  var parsedData = data.match(/min="([0-9]+)"/i);
  return parsedData && parsedData.length > 1 ? parsedData[1] : 0;
}

/**
 * Starts all members registered to a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster
 *
 * Returns object consisting of results from each known member in the cluster.
 * The signature being result:
 *  {
 *   "<host>,<userdir>,<servername>": {
 *     returnCode: {string} <number>
 *     stdout: {string} <text>
 *     stderr: {string} <text>
 *    }
 *  }
 * @private
 */
function _startCluster(options, cb) {
  options = parseConfig(options);
  mandatory(options.clusterName, 'missing clusterName');

  options.clusterName = [GROUP, options.clusterName].join('.');
  sendRequest(options, null, cluster.startCluster, function(err, result) {
    if (err) {
      return cb(err);
    }
    return cb(null, result);
  });
}

/**
 * Undeploys all members in a cluster.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster.
 *
 * Returns err and array of objects consisting of undeploy status, stderr,
 * stdout, and the serverName for the target member.
 * The signature of the returned result:
 *  cb(err OR null,
 *  [
 *   {"status":"FINISHED","serverName":"someName","stdout":"...", "stderr":""}
 *   {"status":"ERROR","serverName":"someName","stdout":"", "stderr":"..."}
 *  ])
 */
Cluster.undeployCluster = function(options, cb) {
  options = parseConfig(options);
  mandatory(options, 'missing options object!');
  mandatory(options.clusterName, 'missing clusterName!');

  // Below function overrides for unit tests
  var _disableScalingPolicy =
    options.disableScalingPolicy || Cluster.disableScalingPolicy;
  var _listMembers = options.listMembers || Cluster.listMembers;
  var _undeployMembers = options.undeployMembers || Cluster.undeployMembers;

  async.waterfall(
    [
      _disableScalingPolicy.bind(null, options),
      _listMembers.bind(null, options),
      Cluster.parseMembers,
      _undeployMembers.bind(null, options),
      monitorUndeploy,
    ],
    cb
  );

  function monitorUndeploy(deployIds, cb) {
    async.map(deployIds, checkDeployStatus, cb);
  }

  function checkDeployStatus(deploy, cb) {
    var _request = options.request || request;

    async.retry(
      {
        times: 30, // XXX(PHONG) - Change back to meaningful number
        interval: 5000, // XXX(PHONG) - change to 10s or meaningful amount
      },
      _checkDeployStatus,
      function(err, results) {
        if (err) {
          // Print error and skip because we needed to generate error for our
          // own purposes and so async.retry will keep trying, but we also need
          // to pass ALL results (even errors) back to APIC, which won't happen
          // if we invoke cb(err), because it will fail immediately;
          debug(err);
        }
        return cb(null, results);
      }
    );

    function _checkDeployStatus(cb, results) {
      var pathname = [
        '/ibm/api/collective/v1/deployment/',
        deploy.id,
        '/results',
      ].join('');

      var uri = url.format({
        hostname: options.host,
        port: options.port,
        protocol: 'https',
        pathname: pathname,
      });

      var reqOpts = {
        url: uri,
        method: 'GET',
        rejectUnauthorized: false,
        auth: {
          user: options.username,
          pass: options.password,
          sendImmediately: false,
        },
      };

      _request(reqOpts, function(err, res, body) {
        if (err) {
          return cb(err);
        }
        try {
          results = JSON.parse(body).results[0];
        } catch (err) {
          debug(err);
          return cb(err);
        }

        var status = results.status;
        var serverName = results.deployedArtifactName;

        var deployInfo = {
          status: status,
          serverName: serverName,
          stdout: results.stdout,
          stderr: results.stderr,
        };
        debug('Undeployment status for %s: %s', serverName, status);
        if (!status || status !== 'FINISHED') {
          return cb(
            new Error(serverName + ': deploy did not finish!'),
            deployInfo
          );
        }
        return cb(null, deployInfo);
      });
    }
  }
};

/**
 * Internal function, exposed for unit tests.
 *
 * Parses the results from `listMembers()` and returns an array of objects
 * formatted with the member properties needed to do an undeploy
 *
 * @param {string[]} data - array of strings from `listMembers()` needing to
 * be parsed.
 *
 * Returns array of objects consisting of undeploy memberHost, userDir, and
 * serverName for the target member.
 * The signature of the returned result:
 *  [
 *   {memberHost: "something.com", userDir: "/foo/path/bar", serverName: "..."}
 *  ]
 */
Cluster.parseMembers = function(data, cb) {
  var members = _.map(data, function(member) {
    var m = member.split(',');
    return {
      memberHost: m[0],
      userDir: m[1],
      serverName: m[2],
    };
  });
  return cb(null, members);
};

/**
 * Internal function, exposed for unit tests.
 *
 * Undeploys all members, defined in an array.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {object} members - Array of objects consisting
 * of memberHost, userDir, and serverName.
 * @property {string} memberHost - The member host name
 * @property {string} userDir - The WLPN_USER_DIR where the member code lives.
 * @property {string} serverName - The name of the server/application instance.
 *
 */
Cluster.undeployMembers = function(options, members, cb) {
  return async.map(
    members,
    Cluster.undeployMember.bind(null, options),
    function(err, results) {
      if (err) {
        return cb(err);
      }
      if (results.length < 1) {
        return cb(new Error('No IDs returned from undeploy!'));
      }
      return cb(null, results);
    }
  );
};

/**
 * Undeploys a member.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {Object.<string, string>} member - The member to undeploy, is an
 * object consisting of memberHost, userDir, and serverName.
 *
 */
Cluster.undeployMember = function(options, member, cb) {
  var _undeploy = options.undeploy || fileService.undeploy;
  mandatory(member, 'missing member data!');
  mandatory(member.memberHost, 'missing memberHost!');
  mandatory(member.userDir, 'missing userDir!');
  mandatory(member.serverName, 'missing serverName!');

  var undeployOpts = {
    host: mandatory(options.host, 'missing host!'),
    port: mandatory(options.port, 'missing port!'),
    username: mandatory(options.username, 'missing username!'),
    password: mandatory(options.password, 'missing password!'),
  };
  _.merge(undeployOpts, member);

  return _undeploy(undeployOpts, cb);
};

/**
 * Disables the scalingPolicy for a cluster. Used when undeploying so more
 * members do not get deployed when existing ones go down.
 *
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} clusterName - Name of cluster.
 *
 */
Cluster.disableScalingPolicy = function(options, cb) {
  // Optional functions for testing purposes
  var _getScalingPolicy = options.getScalingPolicy || Cluster.getScalingPolicy;
  var _getUserDefinedInstances =
    options.getUserDefinedInstances || getUserDefinedInstances;

  async.waterfall(
    [
      _getScalingPolicy.bind(null, options),
      _getUserDefinedInstances,
      _disableScalingPolicy,
    ],
    cb
  );

  function _disableScalingPolicy(instances, cb) {
    // `_uploadPolicy` for testing purposes
    var _uploadPolicy =
      options.uploadScalingPolicy || fileService.uploadScalingPolicy;
    options.instances = instances;
    options.scalingEnabled = 'false';
    _uploadPolicy(options, cb);
  }
};

function getUserDefinedInstances(data, cb) {
  var err = new Error('No data from XML');
  if (!data) return cb(err);

  var min = getInstancesFromXml(data);
  return cb(null, min);
}

function sendRequest(options, operation, jmxMethod, callback) {
  mandatory(options.host, 'host is missing');
  mandatory(options.port, 'port is missing');
  mandatory(options.username, 'user is missing');
  mandatory(options.password, 'password is missing');
  debug('Attempting request on controller host %s', options.host);
  var myJmx = options.jmx || jmx;
  var req = jmxMethod(options, operation);
  var endpoint = new myJmx.Endpoint(options.host, options.port, {
    acceptUnauthorized: options.autoAcceptCertificates,
    username: options.username,
    password: options.password,
  });
  debug('The request being sent is: %s', JSON.stringify(req));
  endpoint.request(req, null, function(err, rsp, body) {
    if (err) {
      debug('The request returned with an error response: %s', err);
      return callback(err);
    }
    return callback(null, rsp.body.value);
  });
}

/**
 * Sets the Scaling Policy and overrides the file in the controller.
 * @param {string} clusterName is required.
 * @param {string} host - Hostname of controller to the collective.
 * @param {string} instances - number of instances to set for cluster scaling.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * not provided, the other parameters must be passed into the function call
 * @param {string} username - Admin username for controller.
 * member.
 */
Cluster.setScale = function(options, cb) {
  var _fileService = options.fileService || fileService;
  mandatory(options.clusterName, 'Must provide a clusterName!');
  _fileService.uploadScalingPolicy(options, cb);
};

/**
 * Gets the Scaling Policy from controller configDropins/overrides folder.
 * @param {string} host - Hostname of controller to the collective.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * not provided, the other parameters must be passed into the function call
 * @param {string} username - Admin username for controller.
 * member.
 */
Cluster.getScale = function(options, cb) {
  var _getScalingPolicy = options.getScalingPolicy || Cluster.getScalingPolicy;
  var _getInstancesFromXml = options.getInstancesFromXml || getInstancesFromXml;
  _getScalingPolicy(options, function(err, stream) {
    if (err) {
      return cb(err);
    }
    return cb(null, _getInstancesFromXml(stream));
  });
};
