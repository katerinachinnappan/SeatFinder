/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';

/**
 * A wrapper around 'request' module
 */
var Promise = require('bluebird');
var _ = require('lodash');
var g = require('strong-globalize')();
var debug = require('debug')('apiconnect:apim-client:request');
var request = require('request-promise');

/**
 * Issue a request
 * @param options  {object}
 * @param options.ignoreErrors [array] array of message keys to ignore
 *
 * Reject if HTTP status code is (< 200 || > 399)
 */
module.exports = function req(options) {
  // request-promise opt
  options.resolveWithFullResponse = true;
  debug(options.method, options.url);

  return request(options).then(function(res) {
    // request header.encoding is set to null when we are not sure if the body coming back is
    // xml format or zip format instead of json obj (for scenario: downloading wsdl definition for SOAP API)
    // If request header.encoding is set to null, then convert it back to string if there is an error.
    // TODO -- rgc, this wasn't a 1to1 port. The old stuff didn't make sense?
    if (res.statusCode >= 200 || res.statusCode <= 399) {
      return options.returnHTTPResponse ? res : res.body;
    }
  }).catch(function(err) {
    // TODO -- could probably be smarter with the error handling here. APIM already put together
    // well thought out message. Use those rather than building our own.
    var error;
    if (err && err.response && err.response.headers && err.response.headers) {
      // If we get an error back from the server, log the x-apim header as if we're running in bluemix or
      // perhaps elsewhere this can help support.
      debug('x-apim backend address: ', err.response.headers['x-apim']);
    }
    if (err.statusCode === 401) {
      error = new Error(g.f('Status: %d: The credentials are invalid.', err.statusCode));
      error.statusCode = err.statusCode;
      return Promise.reject(error);
    } else if (err.statusCode) {
      return processErrors(err, options.ignoreErrors);
    } else {
      return Promise.reject(err);
    }

    function processErrors(err, ignoreErrorKeys) {
      var errMsg;
      var error;
      var errors;

      if (!ignoreErrorKeys) {
        ignoreErrorKeys = [];
      }
      if (err.error && (typeof err.error === 'string')) {
        try {
          err.error = JSON.parse(err.error);
        } catch (_) {
          return Promise.reject(err);
        }
      }
      if (err.error && Array.isArray(err.error.errors) && err.error.errors.length > 0) {
        errors = _.filter(err.error.errors, function(error) {
          if (Object.keys(error)[0] in ignoreErrorKeys) {
            return false;
          }
          return true;
        });

        if (errors.length > 0) {
          errMsg = errors[0][Object.keys(errors[0])[0]];
          error = new Error(errMsg);
          error.statusCode = err.statusCode;
          error.errors = errors;
          return Promise.reject(error);
        } else {
          return Promise.resolve(null);
        }
      } else {
        // This is for backward compatibility
        error = new Error(err.error);
        error.statusCode = err.statusCode;
        return Promise.reject(error);
      }
    }
  });
};

