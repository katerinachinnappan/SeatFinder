/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';

var _ = require('lodash');
var apiConfig = require('apiconnect-config');
var f = require('util').format;
var fs = require('fs');
var logger = require('apiconnect-cli-logger');
var os = require('os');
var path = require('path');
var url = require('url');

var version = require('../package.json').version;
var userAgent = f('APIC Toolkit/%s (%s; %s; %s)', version, os.type(), os.platform(), os.arch());
module.exports.sslOptions = sslOptions;
/**
 * Return the p12 file that can be used to connect to self-signed endpoints
 *
 * @return {object} example {pfxPath: <filepath>, passphrase: <password>}
 */
var cachedSslOptions = {
  loaded: false,
};

function sslOptions() {
  if (cachedSslOptions.loaded) {
    return cachedSslOptions;
  }

  var config = apiConfig.loadConfig();
  cachedSslOptions.rejectUnauthorized = false;
  if (config.getOne('trust-store')) {
    try {
      cachedSslOptions.ca = fs.readFileSync(config.getOne('trust-store'), 'utf8');
      cachedSslOptions.rejectUnauthorized = true;
    } catch (err) {
      logger.warn('Unable to load trust store file ' + config.getOne('trust-store'));
      logger.debug('Unable to load trust store: ' + err.message);
      logger.debug(err.stack);
    }
  }

  cachedSslOptions.pfx = fs.readFileSync(path.resolve(__dirname, 'ssl', 'certificate.p12'));
  cachedSslOptions.passphrase = 'onpremise';
  if (config.getOne('client-certificate')) {
    try {
      cachedSslOptions.pfx = fs.readFileSync(config.getOne('client-certificate'));
      cachedSslOptions.passphrase = config.getOne('client-certificate-password');
    } catch (err) {
      logger.warn('Unable to load client certificate file ' + config.getOne('client-certificate'));
      logger.debug('Unable to client certificate: ' + err.message);
      logger.debug(err.stack);
    }
  }

  logger.debug('Loaded ssl options: %j', cachedSslOptions);
  cachedSslOptions.loaded = true;
  return cachedSslOptions;
}

module.exports = function(opts) {
  var res = {
    headers: _.defaults({
      'user-agent': userAgent,
    }, (opts.headers || {})),
    agentOptions: sslOptions(),
    //Todo: This need to become more intelligent based on the url to decide
    //What to prepend it with, e.g. server, proxy (if e.g. ui has to hit the appliance)
    url: url.format(_.extend({}, url.parse(opts.url), {
      protocol: 'https:',
      host: opts.creds.host,
    })),
    json: opts.json,
    method: opts.method || 'GET',
    returnHTTPResponse: opts.returnHTTPResponse,
  };
  if (opts.creds.username && opts.creds.password) {
    res.auth = {
      user: opts.creds.username,
      pass: opts.creds.password,
    };
  } else if (opts.creds.token) {
    res.auth = {
      bearer: opts.creds.token,
    };
  } else {
    // TODO -- are there really any unauthenticated calls?
  }
  if (opts.body) {
    res.body = opts.body;
  }
  if (typeof opts.encoding !== 'undefined') {
    res.encoding = opts.encoding;
  }
  return res;
};
