/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';

var NodeRSA = require('node-rsa');
var Promise = require('bluebird');
var _ = require('lodash');
var cliConfig = require('apiconnect-config');
var debug = require('debug')('apiconnect:apim-client:apps');
var f = require('util').format;
var fs = require('fs');
var orgs = require('./orgs');
var path = require('path');
var reqOptions = require('./req-options');
var request = require('./request');
var toUri = cliConfig.loadConfig().toUri;
var validator = require('./opts-validator');


/**
 * Create or update a provider app
 *
 * @param {object} options
 * @param {string} options.organization APIm organization
 * @param {string} options.app application name
 * @param {string} options.runtime application runtime. `liberty` or `bluemix`.
 * @param {string} options.title application title. Defaults to clugified version of name.
 * @param {string} [options.libertyClusterName] collective name if application runs on liberty collective.
 *
 * @return Promise.<APPs>
 */
function create(options) {
  return createOrUpdate(options, true);
}

function update(options) {
  return createOrUpdate(options, false);
}

function createOrUpdate(options, create) {
  options = _.defaults({
    type: 'provider',
    json: true,
  }, options, {
    runtime: 'bluemix',
  });
  return validator(options, [ 'organization', 'app', 'runtime', 'title' ]).then(function(options) {
    var data = {
      title: options.title,
      name: options.app,
    };
    switch (options.runtime) {
      case 'bluemix':
        data.bluemix = Object.assign({}, options.runtimeOpts);
        break;
      case 'liberty':
        data.liberty = {
          collective: options.libertyClusterName,
        };
        break;
      default:
    }
    var uriPath;
    if (create === true) {
      uriPath = f('/v1/orgs/%s/provider-apps', options.organization);
    } else {
      uriPath = f('/v1/orgs/%s/provider-apps/%s', options.organization, options.app);
    }

    var reqOpts = reqOptions(_.defaults({
      url: uriPath,
      method: create ? 'POST' : 'PUT',
      body: data,
    }, options));
    return request(reqOpts).then(function(app) {
      return _parseResult(app, options);
    }).catch(handleError);
  });
}

/**
 * List provider apps contained in organizations the currently authenticated
 * user is a member of.
 *
 * @param {object} options
 * @param {string} options.organization name or GUID of provider organization
 * @param {boolean} [options.allOrganizations]
 *
 * @return Promise.<APPs>
 */
function list(options) {
  options = _.defaults({
    type: 'provider',
    json: true,
  }, options);
  return validator(options, [ 'organization' ]).then(function(options) {
    options.server = '';
    var reqOpts = reqOptions(_.defaults({
      url: f('/v1/orgs/%s/provider-apps', options.organization),
      method: 'get',
    }, options));
    return request(reqOpts).then(function(apps) {
      return _.map(apps, function(entry) {
        var app = _parseResult(entry, options.organization);
        var uriOpts = {
          protocol: 'apic-app',
          host: options.creds.host,
        };
        app.fullId = toUri(uriOpts) + '/orgs/' + options.organization + '/apps/' + app.name;
        return app;
      });
    }).catch(handleError);
  });
}

/**
 * List provider apps contained in organizations the currently authenticated
 * user is a member of.
 *
 * @param {object} options
 * @param {string} options.organization name or GUID of provider organization
 * @param {boolean} [options.allOrganizations]
 *
 * @return {Array.<ProviderApp>}
 */
function listAll(options) {
  options = _.defaults({
    type: 'provider',
    json: true,
  }, options);
  if (options.organization) {
    return list(options);
  }
  return orgs.list(options).then(function(organizations) {
    return Promise.map(organizations, function(org) {
      options.organization = org.name;
      return list(options);
    }).then(_.flatten);
  });
}

/**
 * Get information about an application.
 *
 * @param {object} options
 * @param {string} options.organization name or GUID of provider organization
 * @param {string} options.app name of the app
 * @param {boolean} [getEncrypted] get encrypted content
 *
 * @return Promise.<APPs>
 */
function get(options) {
  options = _.defaults({
    type: 'provider',
    json: true,
  }, options);
  return validator(options, [ 'organization', 'app' ]).then(function(options) {
    var uriPath = f('/v1/orgs/%s/provider-apps/%s', options.organization, options.app);
    var reqOpts = reqOptions(_.defaults({
      url: uriPath,
      method: 'get',
    }, options));
    if (options.getEncrypted) {
      return _loadKeys().then(function(key) {
        reqOpts.url = reqOpts.url + '/encrypt';
        reqOpts.method = 'post';
        reqOpts.body = { publicKey: key.exportKey('public') };
        return request(reqOpts).then(function(app) {
          return _parseResult(app, options, key);
        }).catch(handleError);
      });
    } else {
      return request(reqOpts).then(function(app) {
        return _parseResult(app, options);
      }).catch(handleError);
    }
  });
}

function _parseResult(data, options, key) {
  var app = {};
  app.name = data.name;
  app.title = data.title;
  app.id = data.id;
  app.orgName = options.organization;
  if (data.liberty && data.liberty.collective) {
    app.runtime = 'liberty';
    app.liberty = {
      collectiveName: data.liberty.collective.name,
      collectiveId: data.liberty.collective.id,
      applicationName: data.name,
      applicationId: data.id,
      hostHeader: data.name + '.' + app.orgName,
    };
    if (data.liberty.collective.controllers && data.liberty.collective.controllers.length >= 1) {
      app.liberty.username = data.liberty.collective.controllers[0].username;
      app.liberty.password = data.liberty.collective.controllers[0].password;
      app.liberty.controllerHosts = _.map(data.liberty.collective.controllers, function(c) {
        return _.pick(c, [ 'host', 'port' ]);
      });
      if (key) {
        app.liberty.password = key.decrypt(app.liberty.password, 'utf8');
      }
    }
  } else if (data.bluemix && data.bluemix.organization) {
    app.runtime = 'bluemix';
    app.bluemix = data.bluemix;
  }
  return app;
}

function _loadKeys() {
  var configDir = cliConfig.getUserConfigDir();
  var cliPrivateKeyPath = path.join(configDir, 'private.pem');
  var cliPublicKeyPath = path.join(configDir, 'public.pem');
  var key = new NodeRSA(null, null, { encryptionScheme: 'pkcs1' });
  return fs.statAsync(cliPrivateKeyPath).then(function loadKeys() {
    debug('loadKeys');
    return fs.readFileAsync(cliPrivateKeyPath, 'utf8').then(function(data) {
      debug('importing private key');
      key.importKey(data);
    }).then(function() {
      return fs.readFileAsync(cliPublicKeyPath, 'utf8');
    }).then(function(data) {
      debug('importing public key');
      key.importKey(data);
    }).then(function() {
      debug('return crypto');
      return key;
    });
  }).catch(function makeKeys() {
    debug('makeKeys');
    key.generateKeyPair();
    var privateKey = key.exportKey('private');
    var publicKey = key.exportKey('public');
    debug('writing private key');
    return fs.writeFileAsync(cliPrivateKeyPath, privateKey, 'utf8').then(function() {
      debug('writing public key');
      return fs.writeFileAsync(cliPublicKeyPath, publicKey, 'utf8');
    }).then(function() {
      debug('return crypto');
      return key;
    });
  });
}

function handleError(err) {
  var newErr;
  if (err.error && err.error.errors && err.error.errors.length > 0) {
    var errMsgs = _.values(err.error.errors[0]);
    newErr = new Error(_.first(errMsgs));
    newErr.errors = errMsgs;
    newErr.status = err.statusCode || 500;
    throw newErr;
  }
  if (err.message) {
    newErr = new Error(err.message);
    newErr.status = err.statusCode || 500;
    throw newErr;
  }
}

module.exports = {
  list: list,
  listAll: listAll,
  get: get,
  create: create,
  update: update,
};

