// Copyright IBM Corp. 2016,2017. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var async = require('async');
var cluster = require('apiconnect-collective-jmx').cluster;
var debug = require('./debug')('server-command');
var mandatory = require('apiconnect-collective-jmx').util.mandatory;
var jmx = require('apiconnect-collective-jmx');
var request = require('request');
var url = require('url');

/**
 * Provides commands to directly control server/application instances
 * via a collective controller.
 * @class ServerCommand
 */
module.exports = ServerCommand;
function ServerCommand() {}

// Exported for testing purposes.
exports.sendRequest = ServerCommand.sendRequest;

/**
 * Implements the server start commands.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The host on which the server is running.
 * @param {string} options.wlpnUserDir - The user directory in which the server
 * is set up.
 * @param {string} options.serverName - The server name identifying a server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.start = function(options, callback) {
  try {
    mandatory(options, 'options is missing');
    mandatory(options.hostName, 'hostName is missing');
    mandatory(options.wlpnUserDir, 'wlpnUserDir is missing');
    mandatory(options.serverName, 'serverName is missing');

    var serverCommand = jmx.serverCommand;

    ServerCommand.sendRequest(
      options,
      serverCommand.SERVER_COMMAND_OPERATIONS.startServer,
      serverCommand.getServerOperation,
      callback
    );
  } catch (err) {
    return callback(err);
  }
};

/**
 * Implements the server stop commands.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The host on which the server is running.
 * @param {string} options.wlpnUserDir - The user directory in which the server
 * is set up.
 * @param {string} options.serverName - The server name identifying a server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.stop = function(options, callback) {
  try {
    mandatory(options, 'options is missing');
    mandatory(options.hostName, 'hostName is missing');
    mandatory(options.wlpnUserDir, 'wlpnUserDir is missing');
    mandatory(options.serverName, 'serverName is missing');
    var serverCommand = jmx.serverCommand;

    ServerCommand.sendRequest(
      options,
      serverCommand.SERVER_COMMAND_OPERATIONS.stopServer,
      serverCommand.getServerOperation,
      callback
    );
  } catch (err) {
    return callback(err);
  }
};

/**
 * Implements the server status commands.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The host on which the server is running.
 * @param {string} options.wlpnUserDir - The user directory in which the server
 * is set up.
 * @param {string} options.serverName - The server name identifying a server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.status = function(options, callback) {
  try {
    mandatory(options, 'options is missing');
    mandatory(options.hostName, 'hostName is missing');
    mandatory(options.wlpnUserDir, 'wlpnUserDir is missing');
    mandatory(options.serverName, 'serverName is missing');
    var serverCommand = jmx.serverCommand;

    ServerCommand.sendRequest(
      options,
      serverCommand.SERVER_COMMAND_OPERATIONS.getServerStatus,
      serverCommand.getServerOperation,
      callback
    );
  } catch (err) {
    return callback(err);
  }
};

/**
 * Implements the server list commands.
 * @param {object} options - The options object.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.list = function(options, callback) {
  options.absolutePath = false;
  var serverCommand = jmx.serverCommand;
  var serverListResult = {};

  ServerCommand.sendRequest(
    options,
    null,
    serverCommand.getDescendantData,
    function(err, resultList) {
      if (err) {
        callback(err);
      }
      for (var key in resultList) {
        var parsedHost = key.split('/');
        if (parsedHost.length === 9) {
          var host = serverListResult[parsedHost[4]];
          if (host === undefined) {
            host = serverListResult[parsedHost[4]] = {};
            host.name = parsedHost[4];
            host.userDirs = {};
          }
          var userDir = host.userDirs[parsedHost[6]];
          if (userDir === undefined) {
            userDir = host.userDirs[parsedHost[6]] = {};
            userDir.name = parsedHost[6];
            userDir.servers = {};
          }
          var server = userDir.servers[parsedHost[8]];
          if (server === undefined) {
            server = userDir.servers[parsedHost[8]] = {};
            server.name = parsedHost[8];
          }
        }
      }
      callback(null, serverListResult);
    }
  );
};

/**
 * Retrieve a key-value pair from the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.getData = function(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  var serverCommand = jmx.serverCommand;
  ServerCommand.sendRequest(
    options,
    'getData',
    serverCommand.getSetDataInRegistry,
    callback
  );
};

/**
 * Delete a node in Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.deleteNode = function(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  var serverCommand = jmx.serverCommand;
  ServerCommand.sendRequest(
    options,
    'delete',
    serverCommand.getSetDataInRegistry,
    callback
  );
};

/**
 * Sets the data (a key-value pair) in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to set the data.
 * @param {string} options.data - The data to be stored in the path specified
 * above. The data could be an environmental variable formatted as 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.setData = function(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  mandatory(options.data, 'data is missing');
  var serverCommand = jmx.serverCommand;
  ServerCommand.sendRequest(
    options,
    'setData',
    serverCommand.getSetDataInRegistry,
    callback
  );
};

/**
 * Creates a node in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to set the data.
 * @param {string} options.data - The data to be stored in the path specified
 * above. The data could be an environmental variable formatted as 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
ServerCommand.createNode = function(options, callback) {
  // This path can be a fixed constant in this module.
  mandatory(options.path, 'path is missing');
  mandatory(options.data, 'data is missing');
  var serverCommand = jmx.serverCommand;
  ServerCommand.sendRequest(
    options,
    'create',
    serverCommand.getSetDataInRegistry,
    callback
  );
};

/**
 * Retrieve a key-value pair from the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.path - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
// FIXME rename to listClusterEnv
ServerCommand.listClusterData = function(options, callback) {
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = cluster.getClusterPath(options);
  ServerCommand.sendRequest(
    options,
    null,
    cluster.listClusterData,
    removePrefix
  );

  // Existing keys are returned with a prefix, we need to clean up.
  function removePrefix(err, results) {
    if (err) {
      debug(err);
      return callback(err);
    }
    results = cluster.removeClusterPrefix(options, results);
    return callback(null, results);
  }
};

/**
 * Retrieve a key-value pair from the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to get from.
 * @param {string} options.key - The registry path to get the data stored in
 * a particular path. The data could be an environmental variable formatted as
 * 'key=value'.
 * FIXME not 'could be', *is*
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 * @param {string} options.autoAcceptCertificates - An option to accept the
 * certificate of the controller.
 */
// FIXME rename to getClusterEnv
ServerCommand.getClusterData = function(options, callback) {
  mandatory(options.key, 'key is required');
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = [cluster.getClusterPath(options), options.key].join('/');
  ServerCommand.getData(options, callback);
};

/**
 * Sets the data (a key-value pair) in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to store data.
 * @param {string} options.key - The name of the variable to set the data.
 * @param {string} options.data - The data to be stored in the variable
 */
// FIXME rename to setClusterEnv
ServerCommand.setClusterData = function(options, callback) {
  mandatory(options.key, 'key is required');
  mandatory(options.data, 'data is required');
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = [cluster.getClusterPath(options), options.key].join('/');
  var serverCommand = jmx.serverCommand;
  ServerCommand.sendRequest(
    options,
    null,
    serverCommand.createDataInRegistry,
    function(err, result) {
      if (err) {
        return callback(err);
      }
      ServerCommand.setData(options, callback);
    }
  );
};

// FIXME(sam) this is NOT safe to call for anything other than than IHS, since
// it isn't atomic (delete, create), it needs to be rewritten to be
//   if create() fails: update;
ServerCommand.setDataInPath = function(args, callback) {
  async.series([deleteN, createN], function(err, message) {
    if (err) {
      return callback(err);
    }
    return callback(err, 'The data is successfully set in the path.');
  });

  function deleteN(callback) {
    ServerCommand.deleteNode(args, callback);
  }

  function createN(callback) {
    ServerCommand.createNode(args, callback);
  }
};

/**
 * Deletes the data (a key-value pair) in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to remove data
 * from.
 * @param {string} options.key - The name of the variable to delete.
 * @callback
 * @param callback
 */
ServerCommand.deleteClusterData = function(options, callback) {
  mandatory(options.key, 'key is required');
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = [cluster.getClusterPath(options), options.key].join('/');
  ServerCommand.deleteNode(options, callback);
};

/**
 * Deletes all of data (the key-value pairs) for a cluster in the Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to clear data
 * from.
 * @callback
 * @param callback
 */
ServerCommand.clearClusterData = function(options, callback) {
  mandatory(options.clusterName, 'clusterName is required');
  options.clusterName = addStackGroupName(options.clusterName);
  options.path = cluster.getClusterPath(options);
  ServerCommand.deleteNode(options, callback);
};

ServerCommand.sendRequest = function(options, operation, jmxMethod, callback) {
  mandatory(options.host, 'host is missing');
  mandatory(options.port, 'port is missing');
  mandatory(options.user, 'user is missing');
  mandatory(options.password, 'password is missing');
  debug('Attempting request on controller host %s', options.host);
  var myJmx = options.jmx || jmx;
  var req = jmxMethod(options, operation);
  var endpoint = new myJmx.Endpoint(options.host, options.port, {
    acceptUnauthorized: options.autoAcceptCertificates,
    username: options.user,
    password: options.password,
  });
  debug('The request being sent is: %s', JSON.stringify(req));
  endpoint.request(req, null, function(err, rsp, body) {
    if (err) {
      debug('The request returned with an error response: %s', err);
      return callback(err);
    }
    return callback(null, rsp.body.value);
  });
};

var IHS_PATH = '/sys.wlpn.internal/ihs';

/**
 * Sets a IHS IP/name to a port.
 * @param {string} options.ihsIp - The IP of the IHS server.
 * @param {string} options.ihsPort - The port of the IHS server.
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 */
ServerCommand.setIhsInfo = function(options, callback) {
  // write me a test later.
  mandatory(options.ihsIp, 'ihsIp is required');
  mandatory(options.ihsPort, 'ihsPort is required');
  options.path = [IHS_PATH, options.ihsIp].join('/');
  options.data = options.ihsPort;
  ServerCommand.setDataInPath(options, callback);
};

/**
 * Gets the IHS IP/name to port mappings
 *
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's password.
 *
 * Return looks like
 *   {
 *      '1.2.3.4': '8080',
 *      ...
 *   }
 */
ServerCommand.listIhsInfo = function(options, callback) {
  options.path = IHS_PATH;
  options.absolutePath = false;
  var list = {};
  var serverCommand = jmx.serverCommand;
  ServerCommand.sendRequest(
    options,
    null,
    serverCommand.getSubTree,
    removeTailItems
  );

  function removeTailItems(err, resultList) {
    if (err) {
      return callback(err);
    }
    for (var key in resultList) {
      var ip = key.replace(options.path, '');
      if (ip.length > 0) list[ip.replace('/', '')] = resultList[key];
    }
    callback(null, list);
  }
};

// FIXME delIhsInfo() needed?

function addStackGroupName(clusterName) {
  var group = 'apic';
  return [group, clusterName].join('.');
}

/**
 * Gets a list of hosts registered to the controller.
 *
 * @param {string} options.host - The host on which controller is running.
 * @param {string} options.port - The https port assigned to the controller.
 * @param {string} options.user - The controller's admin user name.
 * @param {string} options.password - The controller's admin password.
 *
 * Returned data looks like:
 * { allServersRunning: 1,
 * allServersStopped: 0,
 * allServersUnknown: 0,
 * someServersRunning: 0,
 * noServers: 0,
 * type: 'hosts',
 * ids: [ 'hostname1', 'hostname2' ] }
 */
ServerCommand.getHosts = function(options, callback) {
  mandatory(options, 'missing options');
  mandatory(options.host, 'missing host!');
  mandatory(options.port, 'missing port!');
  mandatory(options.user, 'missing user!');
  mandatory(options.password, 'missing password!');

  var _request = options.request || request;

  var uri = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: '/ibm/api/collective/v1/hosts',
  });

  var reqOpts = {
    url: uri,
    method: 'GET',
    rejectUnauthorized: false,
    auth: {
      user: options.user,
      pass: options.password,
      sendImmediately: false,
    },
  };

  _request(reqOpts, function(err, res, body) {
    if (err) return callback(err);
    var results = JSON.parse(body);

    return callback(null, results);
  });
};
