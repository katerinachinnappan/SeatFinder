// Copyright IBM Corp. 2016,2017. All Rights Reserved.
// Node module: apiconnect-collective-controller-api
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var async = require('async');
var debug = require('./debug')('upload');
var fs = require('fs');
var mandatory = require('./util').mandatory;
var parseConfig = require('./parse-config');
var path = require('path');
var pump = require('pump');
var request = require('request');
var streamifier = require('streamifier');
var url = require('url');

/**
 * Module for handling file uploads and member server deployment with uploaded
 * packages.
 * @class FileService
 */
module.exports = FileService;
function FileService() {}

var GROUP = 'apic';

/**
 * Upload to controller.
 * @param {string} [appDir] - Application directory on controller to place file.
 * @param {string} host - Hostname of controller.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} srcFile - local file you are uploading.
 * @param {string} username - Admin username for controller.
 */
FileService.upload = function(options, cb) {
  options = parseConfig(options);
  options.appDir = options.appDir || '${wlp.user.dir}/file-upload';
  mandatory(options.host, 'need a host!');
  mandatory(options.password, 'need a password!');
  mandatory(options.port, 'need a port!');
  mandatory(options.srcFile, 'need a file to upload!');
  mandatory(options.username, 'need a username!');

  var _request = options.request || request;

  var filePath;
  var fileBase;
  var fileStream;
  if (typeof options.srcFile === 'string') {
    filePath = path.resolve(options.srcFile);
    fileBase = mandatory(path.basename(options.srcFile), 'missing srcFile');
    fileStream = fs.createReadStream(filePath);
  } else if (typeof options.srcFile === 'object') {
    fileBase = options.srcFile.fileName;
    fileStream = streamifier.createReadStream(options.srcFile.data);
  }


  var targetFile = [options.appDir, fileBase].join('/');
  var pathname = '/IBMJMXConnectorREST/file/' + encodeURIComponent(
    targetFile);

  options.url = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: pathname,
    query: {
      expandOnCompletion: false,
    },
  });

  fileStream.pipe(_request.post({
    url: options.url,
    auth: {
      user: options.username,
      pass: options.password,
    },
    cache: false,
    data: '',
    dataType: 'json',
    headers: FileService.buildHeaders(options),
    processData: false,
    rejectUnauthorized: false,
    type: 'POST',
  }, function(err, httpResponse, body) {
    // Liberty doesn't seem to return err, returns stacktrace in body instead
    // err should be used as a networking error, not if upload went through
    // but failed for another reason. Should expose external body parsing
    // utility function from:
    // apiconnect-collective-jmx/blob/master/lib/endpoint.js#L104-L136
    if (err || body.length > 0) {
      err = err || parseJsonError(body);
      debug(err);
      console.error('Upload failed!');
      return cb(err);
    }
    console.log('Upload successful: %s', fileBase);
    return cb(null);
  }));
};

FileService.buildHeaders = function() {
  var headers = {
    'Content-Type': 'application/octet',
    'com.ibm.websphere.jmx.connector.rest.asyncExecution': true,
  };
  return headers;
};

function parseJsonError(data) {
  var _err;
  if (data.match('stackTrace')) {
    try {
      _err = new Error(JSON.parse(data).stackTrace);
    } catch (err) {
      _err = new Error(data);
    }
  }
  return _err;
}

/**
 * Deploy to member (creates new member), must have package already uploaded.
 * @param {string} appDir - Application directory on controller to place file.
 * @param {string} appPackage - The name of the package being deployed. Should
 * already be on the server in the specified appDir.
 * @param {string} [clusterName] - The name of the deployed cluster to affect,
 * also used for file naming for file being uploaded. If no clusterName is
 * specified, will take the filename from package srcFile (if specified) or
 * appPackage, if that is used instead.
 * @param {string} host - Hostname of controller.
 * @param {string} [instances] - number of instances to set for cluster scaling
 * (both min and max). If not specified, will default to 1.
 * @param {string} keystorePassword - Keystore Password for joining new member
 * to the collective.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} serverName - Name of new member.
 * @param {string} [srcFile] - local file to upload before deploy. If this is
 * not provided, the appPackage must be passed into the function call.
 * @param {string} username - Admin username for controller.
 */
FileService.deploy = function(options, cb) {
  options = parseConfig(options);
  mandatory(options.srcFile || options.appPackage,
    'need an appPackage or srcFile!');
  mandatory(options.host, 'need a host!');
  mandatory(options.keystorePassword, 'need keystorePassword!');
  mandatory(options.password, 'need a password!');
  mandatory(options.port, 'need a port!');
  mandatory(options.serverName, 'need a serverName!');
  mandatory(options.username, 'need a username!');
  options.instances = parseInt(options.instances, 10) || 1;

  // TODO(Phong): Below `setTimeout()` is because Liberty's scalingController
  // does not pick up new scalingPolicy.xml changes immediately. We add a delay
  // so that scalingController evaluates changes after deploy.xml is evaluated.
  // This will be fixed by Liberty so need to follow up in Q2
  async.waterfall([
    FileService.uploadPackage.bind(null, options),
    FileService.uploadDeployRules.bind(null, options),
    function(cb) { setTimeout(function() { return cb(null); }, 15000); },
    FileService.uploadScalingPolicy.bind(null, options),
  ], _deployResults);

  function _deployResults(err, results) {
    if (err) {
      debug(err);
      return cb(err);
    }
    return cb(null, results);
  }
};

/**
 * Undeploy to member (stops and removes).
 * @param {string} host - Hostname of controller.
 * @param {string} port - Port to get to controller.
 * @param {string} username - Admin username for controller.
 * @param {string} password - Admin password for controller.
 * @param {string} memberHost - hostname of member host where member was
 * deployed.
 * @param {string} userDir - userDir that member was deployed on member host.
 * @param {string} serverName - Name of member to undeploy.
 */
FileService.undeploy = function(options, cb) {
  options = parseConfig(options);
  mandatory(options.host, 'need a host!');
  mandatory(options.port, 'need a port!');
  mandatory(options.username, 'need a username!');
  mandatory(options.password, 'need a password!');
  mandatory(options.memberHost, 'need a memberHost!');
  mandatory(options.userDir, 'need a userDir!');
  mandatory(options.serverName, 'need a serverName!');

  var _request = options.request || request;

  var pathname = '/ibm/api/collective/v1/deployment/undeploy';

  var uri = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: pathname,
  });

  var reqOpts = {
    url: uri,
    method: 'POST',
    rejectUnauthorized: false,
    auth: {
      user: options.username,
      pass: options.password,
      sendImmediately: false,
    },
    json: {
      host: options.memberHost,
      userDir: options.userDir,
      serverName: options.serverName,
    },
  };

  _request(reqOpts, function(err, res, body) {
    if (err) {
      return cb(err);
    }
    if (!body.id) {
      return cb(new Error('Undeploy Failed: ' + body));
    }
    return cb(null, body);
  });
};

/**
 * Upload Package to controller stackGroup location.
 * @param {string} host - Hostname of controller.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} srcFile - local file to upload before deploy. If this is
 * not provided, the other parameters must be passed into the function call
 * @param {string} username - Admin username for controller.
 * member.
 */
FileService.uploadPackage = function(options, cb) {
  options = parseConfig(options);
  if (options.srcFile) {
    mandatory(options.host, 'need a host!');
    mandatory(options.port, 'need a port!');
    mandatory(options.username, 'need a username!');
    mandatory(options.password, 'need a password!');
    mandatory(options.srcFile, 'need a password!');

    options.appDir = '${wlp.user.dir}/shared/stackGroups/' +
      GROUP + '/packages';
    options.appPackage = mandatory(path.basename(options.srcFile),
      'missing srcFile');
    return FileService.upload(options, cb);
  }
  cb(null);
};

/**
 * Upload deploy.xml to controller to stackGroup location. This file is used to
 * feed data into the controller's deployRule.xml.
 * @param {string} appPackage - The name of the package being deployed. Should
 * already be on the server in the specified appDir. If an appPackage is not
 * specified, will use clusterName if specified. If clusterName is specified,
 * will overwrite appPackage for file naming. One or the other is required.
 * @param {string} [clusterName] - The name of the deployed cluster to affect,
 * also used for file naming for file being uploaded.
 * scaling policy for. If this is not specified, it will use
 * @param {string} host - Hostname of controller.
 * @param {string} [instances] - number of instances to set for cluster scaling
 * (both min and max). If not specified, will default to 1.
 * @param {string} keystorePassword - Keystore Password for joining new member
 * to the collective.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * @param {string} serverName - Name of new member.
 * @param {string} username - Admin username for controller.
 * member.
 */
FileService.uploadDeployRules = function(options, cb) {
  options = parseConfig(options);
  var packageName = options.clusterName || removeExt(options.appPackage);
  mandatory(packageName, 'Must provide a clusterName or appPackage!');
  mandatory(options.appPackage, 'need an appPackage!');
  mandatory(options.host, 'need a host!');
  mandatory(options.port, 'need a port!');
  mandatory(options.username, 'need a username!');
  mandatory(options.password, 'need a password!');
  mandatory(options.keystorePassword, 'need keystorePassword!');
  mandatory(options.serverName, 'need a serverName!');
  options.appDir = '${wlp.user.dir}/shared/stackGroups/' +
    GROUP + '/packages';

  var data = [
    '<deploy>',
    '<useRule id="APIC Server Rule" />',
    '<variable name="applicationPackage" value="',
    options.appPackage, '"/>',
    '<variable name="serverName" value="', options.serverName, '"/>',
    '<variable name="keystorePassword" value="',
    options.keystorePassword, '"/>',
    '<variable name="applicationDir" value="',
    encodeURIComponent(options.appDir), '"/>',
    '<variable name="clusterName" value="', GROUP, '.', packageName,
    '"/>', '</deploy>',
  ].join('');

  options.srcFile = {
    fileName: packageName + '.deploy.xml',
    data: data,
  };

  return FileService.upload(options, cb);
};

/**
 * Upload Scaling Policy to controller configDropins/overrides folder.
 * @param {string} appPackage - The name of the package being deployed. Should
 * already be on the server in the specified appDir. If an appPackage is not
 * specified, will use clusterName if specified. One or the other is required.
 * @param {string} [clusterName] - The name of the deployed cluster to affect,
 * also used for file naming for file being uploaded.
 * @param {string} host - Hostname of controller.
 * to the collective.
 * @param {string} instances - number of instances to set for cluster scaling.
 * @param {string} password - Admin password for controller.
 * @param {string} port - Port to get to controller.
 * not provided, the other parameters must be passed into the function call
 * @param {string} username - Admin username for controller.
 * member.
 */
FileService.uploadScalingPolicy = function(options, cb) {
  options = parseConfig(options);

  var packageName = options.clusterName || removeExt(options.appPackage);
  mandatory(packageName, 'Must provide a clusterName or appPackage!');
  mandatory(options.instances, 'Must provide number of instances!');
  mandatory(options.host, 'need a host!');
  mandatory(options.port, 'need a port!');
  mandatory(options.username, 'need a username!');
  mandatory(options.password, 'need a password!');

  var data = [
    '<?xml version="1.0" encoding="UTF-8" ?>',
    '<server>',
    '<scalingDefinitions>',
    '<scalingPolicy id="', GROUP, '.', packageName,
    '" min="', options.instances,
    '" max="', options.instances,
    '" enabled="', options.scalingEnabled || 'true',
    '"><bind clusters="', GROUP, '.', packageName,
    '"/>',
    '</scalingPolicy>',
    '</scalingDefinitions>',
    '</server>',
  ].join('');

  options.srcFile = {
    fileName: [
      GROUP,
      packageName,
      'scalingPolicy.xml',
    ].join('.'),
    data: data,
  };

  options.appDir = '${wlp.user.dir}/servers/controller/' +
    'configDropins/overrides';

  return FileService.upload(options, cb);
};

FileService.download = function(options, cb) {
  options = parseConfig(options);

  mandatory(options.host, 'missing host!');
  mandatory(options.port, 'missing port!');
  mandatory(options.username, 'missing username!');
  mandatory(options.password, 'missing password!');
  mandatory(options.srcFile, 'missing srcFile!');

  options.srcFile = /%2F/gi.test(options.srcFile) ? options.srcFile :
    encodeURIComponent(options.srcFile);
  var _request = options.request || request;

  var pathname = '/IBMJMXConnectorREST/file/' + options.srcFile;

  var _url = url.format({
    hostname: options.host,
    port: options.port,
    protocol: 'https',
    pathname: pathname,
  });

  var reqOpts = {
    url: _url,
    method: 'GET',
    rejectUnauthorized: false,
    auth: {
      user: options.username,
      pass: options.password,
      sendImmediately: false,
    },
  };

  // download() used differently by getPackage and getScalingPolicy, the latter
  // of which does not save the file, but parses contents for values.
  if (options.outputFile) {
    var targetFile = path.resolve(process.cwd(), options.outputFile);
    var file = fs.createWriteStream(targetFile);

    pump(_request(reqOpts), file, cb);
    return;
  } else {
    _request(reqOpts, function(err, res, body) {
      if (err) return cb(err);
      return cb(null, body);
    });
  }
};

function removeExt(file) {
  return path.basename(file, path.extname(file));
}
