/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
(function () {

    var jsonRefs = require('json-refs');
    var Promise = require('bluebird');
    var jsYaml = require('js-yaml');
    var jsonPointer = require('jsonpointer');
    var _ = require('lodash');

    var refs = {};

    var loader = function (res, callback) {
        callback(undefined, jsYaml.safeLoad(res.text));
    };

    /**
     * Calculate a hash of deferenced objects representing
     * the $refs found in the source document
     * @param document
     */
    refs.findReferences = function(document, options) {
        if (!options) options = {};
        if (!options.loaderOptions) options.loaderOptions = {};
        if (!options.loaderOptions.processContent) options.loaderOptions.processContent = loader;
        return new Promise(function (resolve, reject) {
            jsonRefs.clearCache();
            jsonRefs.resolveRefs(document, options).then(
                function(jsonRefsFound) {
                    var refs = {};
                    Object.keys(jsonRefsFound.refs).forEach(function(ref) {
                        var thisRef = jsonRefsFound.refs[ref];
                        if (thisRef.def && thisRef.def.$ref) {
                            refs[thisRef.def.$ref] = thisRef.value;
                        }
                    });
                    resolve(refs);
                }, function(error) {
                    reject(error);
                }
            );
        });
    };

    /**
     * Calculate a hash of deferenced objects representing
     * the local $refs found in the source document
     * @param document
     */
    refs.findLocalReferences = function(document, options) {
        if (!options) options = {};
        if (!options.loaderOptions) options.loaderOptions = {};
        if (!options.loaderOptions.processContent) options.loaderOptions.processContent = loader;
        return new Promise(function (resolve, reject) {
            refs.findReferences(document, options).then(function(references) {
                var localReferences = {};
                Object.keys(references).forEach(function(key) {
                    if (references.hasOwnProperty(key) && key.indexOf("#") === 0) {
                        localReferences[key] = references[key];
                    }
                });
                resolve(localReferences);
            }, function(error) {
                reject(error);
            });
        });
    };

    refs.replaceReference = function(sourceDocument, oldRef, newRef) {
        if (_.isArray(sourceDocument)) {
            sourceDocument.forEach(function(obj, index) {
                sourceDocument[index] = refs.replaceReference(obj, oldRef, newRef);
            });
        } else if (_.isObject(sourceDocument)) {
            Object.keys(sourceDocument).forEach(function(key) {
                if (!sourceDocument.hasOwnProperty(key)) {
                    return;
                }
                if (key === '$ref' && sourceDocument['$ref'] === oldRef) {
                    sourceDocument['$ref'] = newRef;
                } else {
                    sourceDocument[key] = refs.replaceReference(sourceDocument[key], oldRef, newRef);
                }
            });
        }
        return sourceDocument;
    };

    /**
     * Calculate a hash of deferenced objects representing
     * the $refs found in the source document
     * @param document
     */
    refs.resolveReferences = function(document) {
        return jsonRefs.resolveRefs(document);
    };

    function moveReferenceHelper(sourceReference, targetReferencePrefix, targetReference, sourceDocument, targetDocument, remove) {
        // default to replacing with ref, optionally remove completely
        remove = !!remove;
        var sourcePathSections = sourceReference.split("#");
        var sourcePath = (sourcePathSections.length > 0) ? sourcePathSections[1] : sourcePathSections[0];
        var targetPathSections = targetReference.split("#");
        var targetPath = (targetPathSections.length > 0) ? targetPathSections[1] : targetPathSections[0];
        var objToMove = jsonPointer.get(sourceDocument, sourcePath);
        if (!objToMove) {
            return null;
        }
        jsonPointer.set(targetDocument, targetPath, objToMove);

        // update all references in the source document
        if (!remove) {
            jsonPointer.set(sourceDocument, sourcePath, {
                $ref: targetReferencePrefix + targetReference
            });
            refs.replaceReference(sourceDocument, sourceReference, targetReferencePrefix + targetReference);
        } else {
            jsonPointer.set(sourceDocument, sourcePath, undefined);
            refs.replaceReference(sourceDocument, sourceReference, targetReferencePrefix + targetReference);
        }
        return objToMove;
    };

    /**
     * Moves the given reference from the source document,
     * to the target document, taking sub-references with it
     * @param reference
     * @param sourceDocument
     * @param targetDocument
     */
    refs.moveReference = function(sourceReference, targetReferencePrefix, targetReference, sourceDocument, targetDocument, remove) {
        return new Promise(function (resolve, reject) {
                var objToMove = moveReferenceHelper(sourceReference, targetReferencePrefix, targetReference, sourceDocument, targetDocument, remove);
                if (!objToMove) {
                    reject("Invalid source reference: " + sourceReference);
                    return;
                }

                // now, what if the objToMove had references of it's own?
                refs.findLocalReferences(objToMove).then(function(references) {
                    Object.keys(references).forEach(function(key) {
                        moveReferenceHelper(key, targetReferencePrefix, key, sourceDocument, targetDocument, key.indexOf("#/definitions") === 0);
                    });
                    resolve({
                        "reference": targetReference,
                        "source": sourceDocument,
                        "target": targetDocument
                    });
                }, function(error) {
                    reject(error);
                });
            // }, function(error) {
            //     reject(error);
            // });
        });
    };

    // CommonJS module
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = refs;
        }
        exports.apiconnectRefs = refs;
    }

    // Register as an anonymous AMD module
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return refs;
        });
    }

    // If there is a window object, that at least has a document property,
    // instantiate and define refs on the window
    if (typeof window === "object" && typeof window.document === "object") {
        window.apiconnectRefs = refs;
    }

    return refs;
})();

