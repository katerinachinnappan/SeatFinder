/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';
var g = require('strong-globalize')();

var Catalogs = require('./catalogs');
var Promise = require('bluebird');
var _ = require('lodash');
var admZip = require('adm-zip');
var f = require('util').format;
var fs = require('fs');
var logger = require('apiconnect-cli-logger');
var mkdirp = require('mkdirp');
var os = require('os');
var path = require('path');
var reqOpts = require('./req-options');
var request = require('./request');
var util = require('./util');
var validator = require('./opts-validator');

/**
 * Retrieve policies
 *
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function clone(options) {
  return this.list(options).then(function(data) {
    var policies = [];
    for (var i = 0; i < data.length; i++) {
      policies.push(pull(data[i].name, data[i].version, options));
    }
    return Promise.all(policies).then(function() {
      return data;
    });
  });
};

/**
 * Publish a policy
 *
 * @param {string} policyFolder The folder where the policy is located
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function publish(policyFolder, options) {

  var tempPath;
  var policyFilename;

  return validator(options, [ 'organization', 'catalog' ])
  .then(function() {

    tempPath = path.join(os.tmpdir(), Math.random() + '-' + (+new Date()));
    policyFilename = path.join(tempPath, 'customPolicy.zip');

    if (!policyFolder) {
      policyFolder = path.resolve('.');
    } else {
      policyFolder = path.resolve(policyFolder);
    }
    mkdirp.sync(tempPath);
    return util.zipFolder(policyFolder, policyFilename);
  })
  .then(function() {

    options = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/policies?force=true',
        options.organization,
        options.catalog
      ),
      method: 'POST',
      returnHTTPResponse: true,
    }, options));

    options['Content-Type'] = 'multipart/form-data';
    options.formData = {
      file: fs.createReadStream(path.resolve(policyFilename)),
    };

    return request(options);
  }).then(function(data) {

    var body = data.body;
    var policyMetaData = body && typeof body === 'string' ? JSON.parse(body) : body;
    var result = {
      policyMetaData: policyMetaData,
      policyFilename: policyFolder,
    };

    return Promise.resolve(result);

  });
};

/**
 * Retrieve/download a policy
 *
 * @param {string} policyName name of policy
 * @param {string} policyVersion version of policy
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function pull(policyName, policyVersion, options) {
  return validator(options, [ 'organization', 'catalog' ])
  .then(function() {
    return Catalogs.get(options);
  })
  .then(function(data) {
    var requestOptions = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/policies/%s/v%s/zip',
        options.organization,
        data.id,
        policyName,
        policyVersion
      ),
      returnHTTPResponse: true,
      method: 'get',
      encoding: null,
    }, options));
    return request(requestOptions)
      .catch(function(err) {
        // overwritting the backend error (since at this point they are not consistent)
        // and logging it, incase we need the actual error for debugging
        // Here is an example:
        // Error: {"id":"58c6dd9ee4b06c03445e2ed9","errors":[{"policy.types.notFound":
        // "The banking policy, version: 2.0.0 was not found."}]}
        logger.debug(err.message);
        return Promise.reject(new Error(g.f('Policy %s:%s could not be found', policyName,
          policyVersion)));
      });
  })
  .then(function(data) {
    var tmpPath = path.join(os.tmpdir(), Math.random() + '-' + (+new Date()));
    mkdirp.sync(tmpPath);

    var policyFilename = path.join(tmpPath, 'customPolicy.zip');
    util.validateWriteFile(policyFilename, data.body, true);

    var policyFoldername = policyName + '_policy_' + policyVersion;
    unzip(policyFilename, policyFoldername);

    var result = {
      policyName: policyName,
      policyVersion: policyVersion,
      policyFilename: policyFoldername,
    };

    return Promise.resolve(result);
  });
};

/**
 * Remove a policy
 *
 * @param {string} policyName name of policy
 * @param {string} policyVersion version of policy
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function remove(policyName, policyVersion, options) {

  return validator(options, [ 'organization', 'catalog' ])
  .then(function() {
    return Catalogs.get(options);
  })
  .then(function(data) {
    var requestOptions = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/policies/%s/v%s',
        options.organization,
        data.id,
        policyName,
        policyVersion
      ),
      method: 'delete',
      json: true,
    }, options));
    return request(requestOptions);
  });
};

/**
 * List all policies
 *
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<APIs>
 */
function listAll(options) {

  return Catalogs.listAll(options).then(function(catalogs) {
    return Promise.map(catalogs, function(catalog) {
      var listOpts = _.cloneDeep(options);
      listOpts.catalog = catalog.shortName;
      listOpts.organization = catalog.orgName;
      return list(listOpts);
    })
    .then(function(data) {
      return [].concat.apply([], data);
    });
  });
};

/**
 * List policies
 *
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function list(options) {
  return validator(options, [ 'organization', 'catalog' ])
  .then(function() {
    return Catalogs.get(options);
  })
  .then(function(data) {
    var requestOptions = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/policies',
        options.organization,
        data.id
      ),
      json: true,
    }, options));
    return request(requestOptions);
  })
  .then(function(data) {
    _.forEach(data, function(o) {
      o.catalog = options.catalog;
      o.organization = options.organization;
    });
    return data;
  });
};

/**
 * Get policy
 *
 * @param {string} policyName name of policy
 * @param {string} policyVersion version of policy
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function get(policyName, policyVersion, options) {

  return validator(options, [ 'organization', 'catalog' ])
  .then(function() {
    return Catalogs.get(options);
  })
  .then(function(data) {
    var requestOptions = reqOpts(_.defaults({
      url: f(
        '/v1/orgs/%s/environments/%s/policies/%s/v%s',
        options.organization,
        data.id,
        policyName,
        policyVersion
      ),
      json: true,
    }, options));
    return request(requestOptions);
  });
};

function unzip(src, dst) {
  var zip = admZip(src);
  zip.extractAllTo(dst, true);
};

module.exports = {
  clone: clone,
  get: get,
  list: list,
  listAll: listAll,
  publish: publish,
  pull: pull,
  remove: remove,
};

