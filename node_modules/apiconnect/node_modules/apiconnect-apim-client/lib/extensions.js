/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-apim-client

'use strict';
var g = require('strong-globalize')();

var Catalogs = require('./catalogs');
var Promise = require('bluebird');
var _ = require('lodash');
var f = require('util').format;
var fs = require('fs');
var logger = require('apiconnect-cli-logger');
var path = require('path');
var reqOpts = require('./req-options');
var request = require('./request');
var util = require('./util');
var validator = require('./opts-validator');

/**
 * List all extensions
 *
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 * @param {object} options.space name or GUID of space (only needed for catalogs with spaces enabled)
 *
 * @return Promise.<APIs>
 */
function listAll(options) {
  return Catalogs.listAll(options).then(function(catalogs) {
    return Promise.map(catalogs, function(catalog) {
      var listOpts = _.cloneDeep(options);
      listOpts.catalog = catalog.shortName;
      listOpts.organization = catalog.orgName;
      return list(listOpts);
    })
      .then(function(data) {
        return [].concat.apply([], data);
      });
  });
};

/**
 * List vendor extensions
 *
 * @param {object} options
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function list(options) {
  return validator(options, [ 'organization', 'catalog' ])
    .then(function() {
      return Catalogs.get(options);
    })
    .then(function(data) {
      var requestOptions = reqOpts(_.defaults({
        url: f(
          '/v1/orgs/%s/environments/%s/extensions',
          options.organization,
          data.id
        ),
        json: true,
      }, options));
      return request(requestOptions);
    })
    .then(function(data) {
      _.forEach(data, function(o) {
        o.catalog = options.catalog;
        o.organization = options.organization;
      });
      return data;
    });
};

/**
 * Get vendor extension
 *
 * @param {object} options
 * @param {string} options.extensionName name of the vendor extension
 * @param {string} options.extensionVersion version of the vendor extension
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function get(options) {
  return validator(options, [ 'organization', 'catalog', 'extensionName', 'extensionVersion' ])
    .then(function() {
      return Catalogs.get(options);
    })
    .then(function(data) {
      var requestOptions = reqOpts(_.defaults({
        url: f(
          '/v1/orgs/%s/environments/%s/extensions/%s:%s',
          options.organization,
          data.id,
          options.extensionName,
          options.extensionVersion
        ),
        json: true,
      }, options));
      return request(requestOptions);
    });
};

/**
 * Retrieve/download a vendor extension
 *
 * @param {object} options
 * @param {string} options.extensionName name of the vendor extension
 * @param {string} options.extensionVersion version of the vendor extension
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function pull(options) {
  return validator(options, [ 'organization', 'catalog', 'extensionName', 'extensionVersion' ])
    .then(function() {
      return Catalogs.get(options);
    })
    .then(function(data) {
      var requestOptions = reqOpts(_.defaults({
        url: f(
          '/v1/orgs/%s/environments/%s/extensions/%s:%s',
          options.organization,
          data.id,
          options.extensionName,
          options.extensionVersion
        ),
        headers: {
          Accept: 'application/vnd.ibm-apim.swagger2+yaml',
        },
        returnHTTPResponse: true,
        method: 'get',
        encoding: null,
      }, options));
      return request(requestOptions)
        .catch(function(err) {
          // overwritting the backend error (since at this point they are not consistent)
          // and logging it, incase we need the actual error for debugging
          // Here is an example:
          // Error: {"id":"58c6dd6ce4b06c03445e2ed8","errors":[{"vendorExtension.notFound":
          // "A vendor extension identified by 'banking:2.0.0' could not be found."}]}
          logger.debug(err.message);
          return Promise.reject(new Error(g.f('Vendor extension %s:%s could not be found', options.extensionName,
            options.extensionVersion)));
        });
    })
    .then(function(data) {
      var fileName = options.extensionName + '_extension_' + options.extensionVersion + '.yaml';
      fileName = path.resolve(fileName);
      util.writeFile(fileName, data.body, true);

      var result = {
        extensionName: options.extensionName,
        extensionVersion: options.extensionVersion,
        extensionFilename: fileName,
      };

      return Promise.resolve(result);
    });
};

/**
 * Remove a vendor extension
 *
 * @param {object} options
 * @param {string} options.extensionName name of the vendor extension
 * @param {string} options.extensionVersion version of the vendor extension
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function remove(options) {
  return validator(options, [ 'organization', 'catalog', 'extensionName', 'extensionVersion' ])
    .then(function() {
      return Catalogs.get(options);
    })
    .then(function(data) {
      var requestOptions = reqOpts(_.defaults({
        url: f(
          '/v1/orgs/%s/environments/%s/extensions/%s:%s',
          options.organization,
          data.id,
          options.extensionName,
          options.extensionVersion
        ),
        method: 'delete',
        json: true,
      }, options));
      return request(requestOptions);
    });
};

/**
 * Publish a vendor extension
 *
 * @param {object} options
 * @param {string} options.fileName name/path to the file containing the vendor extension
 * @param {object} options.organization name or GUID of provider organization
 * @param {object} options.catalog shortName or GUID of catalog
 *
 * @return Promise.<APIs>
 */
function publish(options) {
  return validator(options, [ 'organization', 'catalog', 'fileName' ]).then(function(options) {
    var reqOptions = reqOpts(_.defaults({
      url: f('/v1/orgs/%s/environments/%s/extensions', options.organization, options.catalog),
      json: true,
      method: 'post',
    }, options));

    reqOptions['Content-Type'] = 'multipart/form-data';
    reqOptions.formData = {
      file: fs.createReadStream(path.resolve(options.fileName)),
    };

    return request(reqOptions);
  });
};

module.exports = {
  listAll: listAll,
  list: list,
  get: get,
  pull: pull,
  publish: publish,
  remove: remove,
};

