#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-catalogs


'use strict';

var Promise = require('bluebird');
var Chance = require('chance');
var archiver = require('archiver');
var f = require('util').format;
var fs = Promise.promisifyAll(require('fs'));
var g = require('strong-globalize')();

var PREFIX = 'apic-';

function generateSlugFromText(text) {
  if (!text) {
    return generateRandomSlug(PREFIX);
  }

  // Remove the intial and ending spaces
  text = text.trim();

  //transform spaces to dash
  text = text.replace(/\s+/g, '-');

  //remove any characters that are not a-zA-Z_-0-9
  text = text.replace(/[^A-Za-z_\-0-9]/g, '');

  //make all text lowercase
  text = text.toLowerCase();

  if (text === '' || text === '-') {
    return generateRandomSlug(PREFIX);
  }

  return text;
}

function generateRandomSlug(prefix) {
  var randomWord = new Chance();
  var uniqueText = randomWord.word({ length: 5 });
  return prefix + uniqueText;
}

function validateWriteFileSync(desPath, content, overWrite) {
  if (fs.existsSync(desPath) && !overWrite) {
    throw new Error(g.f('The file name %s already exists.', desPath));
  } else {
    fs.writeFileSync(desPath, content);
  }
}


function generateApiFileName(apiName, apiVersion) {
  return f('%s_%s.yaml', apiName, apiVersion);
};

function generateApiWsdlFileName(apiName, apiVersion) {
  return f('%s_%s.wsdl', apiName, apiVersion);
};

function generateApiWsdlZipFileName(apiName, apiVersion) {
  return f('%s_%s.zip', apiName, apiVersion);
};

function generateProductFileName(productName, productVersion) {
  return f('%s_product_%s.yaml', productName, productVersion);
};

function writeFile(dest, content, overwrite) {
  var chain = Promise.resolve();
  if (overwrite === false) {
    chain = fs.statAsync(dest);
    chain.catch(function(_) {
      return Promise.reject(new Error(f('The file name %s already exists.', dest)));
    });
  }
  return chain.then(function() {
    return fs.writeFileAsync(dest, content);
  });
};

function zipFolder(srcFolder, zipFilePath) {
  return new Promise(function(resolve, reject) {
    var output = fs.createWriteStream(zipFilePath);
    var zipArchiver = archiver('zip');

    output.on('close', function() {
      resolve(output);
    });

    zipArchiver.on('error', function(error) {
      var err = new Error();
      err.msg = error;
      reject(err);
    });

    zipArchiver.pipe(output);
    zipArchiver.directory(srcFolder, false);
    zipArchiver.finalize();
  });
};

module.exports = {
  generateApiFileName: generateApiFileName,
  generateApiWsdlFileName: generateApiWsdlFileName,
  generateApiWsdlZipFileName: generateApiWsdlZipFileName,
  generateProductFileName: generateProductFileName,
  generateSlugFromText: generateSlugFromText,
  validateWriteFile: validateWriteFileSync,
  validateWriteFileSync: validateWriteFileSync,
  writeFile: writeFile,
  zipFolder: zipFolder,
};

