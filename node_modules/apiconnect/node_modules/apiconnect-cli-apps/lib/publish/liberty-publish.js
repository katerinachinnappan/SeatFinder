/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-apps

var Promise = require('bluebird');
var apimClient = require('apiconnect-apim-client');
var _ = require('lodash');
var collectiveApi = require('apiconnect-collective-controller-api');
var crypto = require('crypto');
var logger = require('apiconnect-cli-logger');
var os = require('os');
var path = require('path');
var rimraf = Promise.promisify(require('rimraf'));
var f = require('util').format;
var fs = Promise.promisifyAll(require('fs'));
var fsExtra = Promise.promisifyAll(require('fs-extra'));
var g = require('strong-globalize')();
var mkdirp = Promise.promisify(require('mkdirp'));

var build = require('../build/build');

var deploy = Promise.promisify(collectiveApi.fileService.deploy);
var listIhsInfo = Promise.promisify(collectiveApi.listIhsInfo);
var getHosts = Promise.promisify(collectiveApi.server.getHosts);

function libertyPublish(providerOrg, providerApp, options) {
  var msg = 'The {{APIC Collective Controllers}} are deprecated with {{API Connect v5.0.7.0}}. '
    + 'Please see {{https://ibm.biz/BdstnB}} for more information.';
  logger.warn(g.f(msg));

  var projectDir = path.resolve(options.projectDir);
  var ts = +new Date();
  var tmpPath = path.join(os.tmpdir(), Math.random() + '-' + ts);
  var clusterName = f('%s-%s-%d', providerApp.name, providerApp.id, ts);
  var vHostHeader = f('%s.%s', clusterName, providerOrg.name);

  var tarFilePath = path.join(tmpPath, clusterName + '-package.tgz');
  var tmpProjectDir = path.join(tmpPath, 'project');

  var keystorePassword = new Buffer(crypto.randomBytes(20));
  keystorePassword = keystorePassword.toString('base64');

  return mkdirp(tmpProjectDir).then(function() {
    logger.writeln(g.f('...preparing project'));
    return fsExtra.copyAsync(projectDir, tmpProjectDir);
  }).then(function() {
    var pkgJson = require(path.resolve(projectDir, 'package.json'));
    var isGateway = pkgJson.APIConnectGateway;
    if (isGateway) {
      return;
    }
    return prepareProject(tmpProjectDir, vHostHeader);
  }).then(function() {
    logger.writeln(g.f('...building package for deploy'));
    return build(tmpProjectDir, { zip: false, outputFilePath: tarFilePath });
  }).then(function() {
    return lookupLibertyDetails(providerOrg, providerApp, options);
  }).then(function(creds) {
    var l = creds.liberty;
    l.vHostHeader = vHostHeader;
    return getValidController(l).then(getIhsInfo);
  }).then(function(creds) {
    var scale = options.scale || creds.liberty.registeredHosts.ids.length;
    logger.writeln(g.f(
      '...uploading packages to %s:%s, scale: %d',
      creds.host, creds.port, scale
    ));

    var deployOptions = {
      srcFile: tarFilePath,
      host: creds.host,
      port: creds.port,
      username: creds.liberty.username,
      password: creds.liberty.password,
      serverName: clusterName,
      clusterName: clusterName,
      keystorePassword: keystorePassword,
      instances: scale,
    };
    return deploy(deployOptions).then(function() {
      return rimraf(tmpPath, { glob: false }).catch(function(err) {
        logger.debug('Unable to remove tmpdir %s: %s', tmpPath, err.message);
      });
    }).then(function() {
      return creds;
    });
  });
}
module.exports = libertyPublish;

function prepareProject(projectDir, vHostHeader) {
  return fs.writeFileAsync(
    path.join(projectDir, 'server.json'),
    JSON.stringify({
      vHost: vHostHeader,
    }),
    'utf8'
  );
}

function lookupLibertyDetails(providerOrg, providerApp, options) {
  var opts = {
    server: options.server,
    organization: providerOrg.name,
    app: providerApp.name,
    creds: options.creds,
    getEncrypted: true,
  };
  return apimClient.apps.get(opts);
}

/**
 * Try to get a valid controller.  If no valid controller was found, return the first controller.
 * @param libCreds
 * @returns controller info
 */
function getValidController(libCreds) {
  var controllers = [];
  var host, port;
  for (var i = 0; i < libCreds.controllerHosts.length; i++) {
    host = libCreds.controllerHosts[i].host;
    port = libCreds.controllerHosts[i].port;
    controllers.push(validateController(libCreds, host, port));
  };
  return Promise.all(controllers).then(function(controllers) {
    var retController;
    var foundController = false;
    _.forEach(controllers, function(controller) {
      if (!foundController && controller.validHost) {
        retController = controller;
        foundController = true;
      }
    });

    if (foundController) {
      return retController;
    }
    // No valid controller was found, return the 1st one which would contain the error
    return controllers[0];
  });
}

/**
 * Check to see if a given controller is valid and get a list of all liberty hosts
 * @param libCreds
 * @param host
 * @param port
 * @returns {*}
 */
function validateController(libCreds, host, port) {
  return getHosts({
    host: host,
    port: port,
    user: libCreds.username,
    password: libCreds.password,
    autoAcceptCertificates: true,
  }).then(function(hosts) {
    libCreds.registeredHosts = hosts;
    return {
      validHost: true,
      host: host,
      port: port,
      liberty: libCreds,
    };
  }).catch(function(err) {
    logger.debug('Error getting hosts from the controller.');
    logger.debug(err);
    return {
      validHost: false,
      host: host,
      port: port,
      liberty: libCreds,
    };
  });
}

/**
 * Get the IHS Info for the given controller
 * @param libCreds
 * @param host
 * @param port
 * @returns {*}
 */
function getIhsInfo(controllerInfo) {
  var libCreds = controllerInfo.liberty;
  return listIhsInfo({
    host: controllerInfo.host,
    port: controllerInfo.port,
    user: libCreds.username,
    password: libCreds.password,
    autoAcceptCertificates: true,
  }).then(function(ihsInfo) {
    controllerInfo.ihsInfo = ihsInfo.length === 0 ? [ 'IHS endpoint information is not available' ] :
      _.map(ihsInfo, function(p, h) { return h + ':' + p; });
    return controllerInfo;
  }).catch(function(err) {
    logger.debug('Unable to retrieve IHS info.');
    logger.debug(err);
    controllerInfo.ihsInfo = [ 'IHS endpoint information is not available' ];
    return controllerInfo;
  });
}

