/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-apps

'use strict';

var Promise = require('bluebird');
var _ = require('lodash');
var project = require('apiconnect-project');
var debug = require('debug')('apiconnect-cli-apps:lib:build:build');
var exec = require('child_process').exec;
var fmt = require('util').format;
var g = require('strong-globalize')();
var mkdirp = Promise.promisify(require('mkdirp'));
var pack = Promise.promisify(require('./pack'));
var path = require('path');

// liberty & local run
var defaults = { zip: false, install: true, scripts: true, outputFilePath: null, embedPackageDir: true };

module.exports = function(dir, opts) {
  opts = _.defaults(opts, defaults);
  debug(opts);

  if (!opts.install && opts.scripts) {
    return Promise.reject(new Error(g.f('The {{--scripts}} option can be used when {{`npm install`}} is enabled.')));
  }
  try {
    var projectInfo = project.inspectPath(dir, { incNodeProjects: true });
    if (projectInfo.type !== 'project') {
      return Promise.reject(new Error(g.f('The path %s is not an {{API Connect}} project.', dir)));
    }
    if (!projectInfo.name || projectInfo.name === '') {
      return Promise.reject(new Error(g.f('App Name should not be empty. Check package.json or config.json.')));
    }
  } catch (err) {
    debug(err);
    return Promise.reject(err);
  }
  var packageJson = {};
  //swiftserver has no package.json so set values from projectInfo for runPack()
  if (projectInfo.projectType === 'swiftserver') {
    packageJson.name = projectInfo.name;
    packageJson.version = '1.0.0';
    opts.embedPackageDir = false;
  } else {
    packageJson = require(path.resolve(dir, 'package.json'));
  }

  return Promise.reduce(buildCommands(), function(result, fn) {
    result = fn();
    return result;
  }, {}).then(function(result) {
    debug('done building', result);
    return result;
  });

  function buildCommands() {
    var cmds = [];

    if (projectInfo.projectType === 'swiftserver') {
      //ignore scripts options - doesn't apply to swiftserver
      cmds.push(checkSwift('swift --version')); //check for correct version of swift
      cmds.push(cmdWrapper('swift build --clean=dist')); //do clean first due to failure with swift build
      cmds.push(cmdWrapper('swift build')); //do build first to make sure all is well
      cmds.push(cmdWrapper('swift build --clean=dist')); //clean out Packages directory before deploying
    } else {
      if (opts.install) {
        var installCmd = 'npm install --production';
        if (!opts.scripts) {
          installCmd += ' --ignore-scripts';
        }
        cmds.push(cmdWrapper(installCmd));
        if (opts.scripts && packageJson.scripts && packageJson.scripts.build) {
          cmds.push(cmdWrapper('npm run build'));
        }
      }
      cmds.push(cmdWrapper('npm prune --production'));
    }

    cmds.push(runPack(opts.zip));

    return cmds;
  }

  function cmdWrapper(cmdStr) {
    debug('schedule %s', cmdStr);
    return function() {
      debug('executing %s > %s', dir, cmdStr);
      return new Promise(function(resolve, reject) {
        try {
          exec(cmdStr, { cwd: dir, maxBuffer: 1024 * 500 }, function(err, stdout, stderr) {
            debug(stdout);
            debug(stderr);
            if (err) {
              return reject(err);
            }
            return resolve(stdout);
          });
        } catch (err) {
          return reject(err);
        }
      });
    };
  }

  function runPack(zip) {
    debug('schedule runPack');
    return function() {
      var fileName = fmt('%s-%s.%s', packageJson.name, packageJson.version, zip ? 'zip' : 'tgz');
      var dst = opts.outputFilePath || path.join(dir, '..', fileName);
      debug('packing into', dst);
      return mkdirp(path.dirname(dst)).then(function() {
        debug('mkdirp done');
        return pack(dir, dst, zip ? 'zip' : 'tgz', opts.embedPackageDir).then(function() {
          debug('packing completed', dst);
          return dst;
        });
      });
    };
  }

  function checkSwift(cmdStr) {
    debug('schedule %s', cmdStr);
    return function() {
      debug('executing %s > %s', dir, cmdStr);
      return new Promise(function(resolve, reject) {
        try {
          exec(cmdStr, { cwd: dir }, function(err, stdout, stderr) {
            debug(stdout);
            debug(stderr);
            if (err) {
              return reject(err);
            }

            //check that swift version is 3
            var swiftVersion = stdout.match(/Swift version\s+(\d+)\./);
            if (!swiftVersion || (swiftVersion[1] !== '3')) {
              return reject(new Error(g.f('Swift 3 is required')));
            }

            return resolve(stdout);
          });
        } catch (err) {
          return reject(err);
        }
      });
    };
  }
};

