#!/usr/bin/env node
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-products


var ProductsAPI = require('apiconnect-apim-client').products;
var fmt = require('./formatter');
var g = require('strong-globalize')();
var Promise = require('bluebird');
var inquirer = require('inquirer');

module.exports = {
  productsClone: productsClone,
  productsDelete: productsDelete,
  productsGet: productsGet,
  productsList: productsList,
  productsPull: productsPull,
  productsSet: productsSet,
  productsReplace: productsReplace,
  productsSupersede: productsSupersede,
  productsSetMigrationTarget: productsSetMigrationTarget,
  productsStage: productsStage,
  productsPublish: productsPublish,
  productsClear: productsClear,
};

/**
 * Clone Products
 *
 * @param options            flag options
 */
function productsClone(options) {
  if (options.allCatalogs) {
    options.catalog = null;
  }
  if (options.allOrganizations) {
    options.organization = null;
  }
  return ProductsAPI.clone(options)
  .then(fmt.cloneFormat);
}

/**
 * Delete a product
 *
 * @param productNameVersion name and version of the product
 * @param options            flag options
 */
function productsDelete(productNameVersion, options) {
  options.productNameVersion = productNameVersion;
  return ProductsAPI.delete(options)
    .then(function(result) {
      return fmt.deleteFormat(result, options);
    });
}

/**
 * Get a product
 *
 * @param productNameVersion name and version of the product
 * @param options            flag options
 */
function productsGet(productNameVersion, options) {
  options.productNameVersion = productNameVersion;
  return ProductsAPI.get(options)
    .then(fmt.getFormat);
}

/**
 * List all products
 *
 * @param options            flag options
 */
function productsList(options) {
  if (options.allCatalogs) {
    options.catalog = null;
  }
  if (options.allOrganizations) {
    options.organization = null;
  }
  return ProductsAPI.list(options)
    .then(fmt.listFormat);
};

/**
 * Pull a product and its APIs
 *
 * @param productNameVersion name and version of the product
 * @param options            flag options
 */
function productsPull(productNameVersion, options) {
  options.productNameVersion = productNameVersion;
  return ProductsAPI.pull(options)
    .then(fmt.pullFormat);
}

/**
 * Update Product
 *
 * @param productNameVersion name and version of the product
 * @param options            flag options
 */
function productsSet(productNameVersion, options) {
  options.productNameVersion = productNameVersion;
  var statusToAction = {
    staged: 'stage',
    published: 'publish',
    retired: 'retire',
    archived: 'archive',
    deprecated: 'deprecate',
  };

  if (options.status && !statusToAction[options.status]) {
    throw new Error(g.f('The {{--status}} and {{--visiblity/--subscribability}} options are mutually exclusive.'));
  }
  if (options.status && (options.visibility || options.subscribability)) {
    throw new Error(g.f('The {{--status}} and {{--visiblity/--subscribability}} options are mutually exclusive.'));
  }
  if (options.visibility && !options.subscribability) {
    throw new Error(g.f('The {{-—subscribability}} option must be provided with the {{—-visibility}} option.'));
  }
  if (options.subscribability && !options.visibility) {
    throw new Error(g.f('The {{-—visibility}} option must be provided with the {{-—subscribability}} option.'));
  }

  options.operation = statusToAction[options.status];
  return ProductsAPI.set(options)
    .then(function(result) {
      return fmt.setFormat(result, options);
    });
}

/**
 * Replace a product
 *
 * @param fromNameVersion    name and version of the product being replaced
 * @param toNameVersion      name and version of the new product
 * @param options            flag options
 */
function productsReplace(fromNameVersion, toNameVersion, options) {
  options.fromNameVersion = fromNameVersion;
  options.toNameVersion = toNameVersion;
  options.planMappings = options.plans;
  if (!options.planMappings) {
    throw new Error(g.f('The {{--plans}} option is required.'));
  }
  return getInputs(options)
    .then(ProductsAPI.replace)
    .then(fmt.replaceFormat);
}


/**
 * Supersede a product
 *
 * @param fromNameVersion    name and version of the product being superseded
 * @param toNameVersion      name and version of the new product
 */
function productsSupersede(fromNameVersion, toNameVersion, options) {
  options.fromNameVersion = fromNameVersion;
  options.toNameVersion = toNameVersion;
  options.planMappings = options.plans;
  if (!options.planMappings) {
    throw new Error(g.f('The {{--plans}} option is required.'));
  }
  return getInputs(options)
    .then(ProductsAPI.supersede)
    .then(fmt.supersedeFormat);
}

/**
 * Set migration target on a product
 *
 * @param fromNameVersion    name and version of the product being migrated
 * @param toNameVersion      name and version of the new product
 * @param options            flag options
 */
function productsSetMigrationTarget(fromNameVersion, toNameVersion, options) {
  options.fromNameVersion = fromNameVersion;
  options.toNameVersion = toNameVersion;
  options.planMappings = options.plans;
  if (!options.planMappings) {
    throw new Error(g.f('The {{--plans}} option is required.'));
  }
  return getInputs(options)
    .then(ProductsAPI.setMigrationTarget)
    .then(fmt.setMirgationFormat);
}

/**
 * Stage a product
 *
 * @param filename           filename of product being staged
 * @param options            flag options
 */
function productsStage(filename, options) {
  options.filename = filename;
  return ProductsAPI.stage(options).then(function(result) {
    return fmt.stageFormat(result, options);
  });
}

/**
 * Publish a product
 *
 * @param filename           filename of product being staged
 * @param options            flag options
 */
function productsPublish(filename, options) {
  if (options.stage) {
    return productsStage(filename, options);
  }
  options.filename = filename;
  return ProductsAPI.publish(options).then(function(result) {
    fmt.stageFormat(result.stage, options);
    fmt.publishFormat(result.publish, options);
    return;
  }).catch(function(err) {
    if (err.code === 'REF_API_ERR' && err.obj.api.errors) {
      throw err.obj.api.errors;
    };
    throw err;
  });
}

/**
 * Clear products
 *
 * @param options            flag options
 */
function productsClear(options) {
  if (!options.confirm) {
    throw new Error(g.f('You must specify the {{--confirm CATALOG_NAME}} option to confirm ' +
      'clearing all the products in the catalog.'));
  }
  if (options.confirm !== options.catalog) {
    throw new Error(g.f('The value of the {{--confirm}} option must match the catalog being cleared.'));
  }
  return ProductsAPI.clear(options)
    .then(function(result) {
      return fmt.clearFormat(options, result);
    });
}

/**
 * Get inputs for replace, supersede and set-migration-target
 */
function getInputs(program) {
  return new Promise(function(resolve) {
    var inputs = [];
    if (!program.fromNameVersion) {
      inputs.push(
        {
          type: 'input',
          message: g.f('Product name and version {{(NAME:VERSION)}}'),
          name: 'fromNameVersion',
        }
      );
    }
    if (!program.toNameVersion) {
      inputs.push(
        {
          type: 'input',
          message: g.f('Product name and version {{(NAME:VERSION)}}'),
          name: 'toNameVersion',
        }
      );
    }
    if (inputs.length > 0) {
      inquirer.prompt(inputs, function(answers) {
        program.fromNameVersion = answers.fromNameVersion || program.fromNameVersion;
        program.toNameVersion = answers.toNameVersion || program.toNameVersion;
        resolve(program);
      });
    } else {
      resolve(program);
    }
  });
}

